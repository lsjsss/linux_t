

@[TOC]( TCP/IP configuration | Cloud computing )

---

# 1. TCP/IP地址配置

## 1.1 问题

> 为主机配置以下网络参数：
> 1）IP地址 192.168.1.10
> 2）子网掩码 255.255.255.0
> 3）网关 192.168.1.254
> 4）DNS 202.106.0.20
> 5）查看配置参数

## 1.2 方案

使用1台Windows 2008虚拟机，给其配置ip地址确保其可以正常的通信。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为Windows 2008服务器配置IP地址，通过控制面板设置网卡的IP地址。**

1）通过 `开始`-->`控制面板`-->`网络和Internet`-->`网络和共享中心`-->`更改适配器设置`可查看网络连接列表，双击`本地连接`-->`属性`-->`Internet协议版本4（TCP/IPv4）`，可打开属性设置窗口。将IP地址设置为192.168.1.10，子网掩码255.255.255.0、网关设置为192.168.1.254、DNS设置为202.106.0.20，如图-8所示，单击“确定”保存，如图-1所示
![图-1](https://img-blog.csdnimg.cn/4313299de42d4b559b1dbde84630439e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


2）通过本地连接属性中的“详细信息”可确认设置结果，如图-2所示

3)通过命令行查看网卡的IP地址

单击“开始”-->“运行”，输入“cmd”并确定，如图-3所示

将会打开cmd命令控制台窗口，如图-4所示

/

图-4

执行命令“ipconfig /all”可查看当前IP地址的详细配置：

```shell
C:\Users\Administrator> ipconfig /all
Windows IP 配置
   主机名  . . . . . . . . . . . . . : WIN-BHVD7FRDKUU
   主 DNS 后缀 . . . . . . . . . . . :
   节点类型  . . . . . . . . . . . . : 混合
   IP 路由已启用 . . . . . . . . . . : 否
   WINS 代理已启用 . . . . . . . . . : 否
以太网适配器 本地连接:
   连接特定的 DNS 后缀 . . . . . . . :
   描述. . . . . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection
   物理地址. . . . . . . . . . . . . : 00-0C-29-68-96-8E
   DHCP 已启用 . . . . . . . . . . . : 否
   自动配置已启用. . . . . . . . . . : 是
   本地链接 IPv6 地址. . . . . . . . : fe80::6996:7ae3:7c3b:4841%11(首选)
   IPv4 地址 . . . . . . . . . . . . : 192.168.1.10(首选)
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . : 192.168.1.254
   DHCPv6 IAID . . . . . . . . . . . : 234884137
   DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-1A-0B-72-75-00-0C-29-68-96-8E
   DNS 服务器  . . . . . . . . . . . : 202.106.0.20
   
   TCPIP 上的 NetBIOS  . . . . . . . : 已启用
.. ..
C:\Users\Administrator> 
```

# 2. 网络连通性测试

## 2.1 问题

> 为主机设置以下网络参数并测试连通性：
> 1)主机1配置IP地址 192.168.1.10，子网掩码 255.255.255.0
> 2)主机2配置IP地址 192.168.1.20，子网掩码 255.255.255.0
> 3)两台主机连接到同一网络
> 4)用ping命令测试网络连通性

## 2.2 方案

使用2台Windows 2008虚拟机，如图-5所示。将两个2008虚拟机网卡的IP地址设置为同一个网段，即可相互通信

/

图-5

实现此案例需要按照如下步骤进行。

## 2.3 步骤

**步骤一：修改两台Windows 2008虚拟机的网络类及IP地址**

1)为Windows 2008（server1）配置IP地址，通过控制面板设置网卡的IP地址

通过“开始”-->“控制面板”-->“网络和Internet”-->“网络和共享中心”-->“更改适配器设置”可查看网络连接列表，双击“本地连接”-->“属性”-->“Internet协议版本4（TCP/IPv4）”，可打开属性设置窗口。将IP地址设置为192.168.1.10，子网掩码255.255.255.0、网关设置为192.168.1.254、DNS设置为202.106.0.20，如图-6所示，单击“确定”保存。

/

图-6

2)为Windows 2008（server2）配置IP地址，通过控制面板设置网卡的IP地址。

通过“开始”-->“控制面板”-->“网络和Internet”-->“网络和共享中心”-->“更改适配器设置”可查看网络连接列表，双击“本地连接”-->“属性”-->“Internet协议版本4（TCP/IPv4）”，可打开属性设置窗口。将IP地址设置为192.168.1.20，子网掩码255.255.255.0、网关设置为192.168.1.254、DNS设置为202.106.0.20，如图-7所示，单击“确定”保存。

/

图-7

步骤二：关闭两台Windows 2008系统的防火墙

1)通过`控制面板`-->`检查防火墙状态`，可以查看防火墙服务的运行状态（默认为绿色的标识，标识已启用），如图-8所示

/

图-8

2)单击左侧的`打开或关闭Windows防火墙`，可自定义是否启用防火墙，对于普通内网服务器建议可将防火墙关闭，如图-9所示，单击确定。

/

图-9

3)再次检查防火墙状态，发现已经变成醒目的红色，表示Windows防火墙已停止，如图-10所示。

/

图-10

步骤三：使用ping命令测试网络连通性

1)使用命令行查看两台设备间是否可以通信

在Windows 2008（server1）中单击`开始`-->`运行`，输入`cmd`并确定，如图-11所示

/

图-11

将会打开cmd命令控制台窗口，如图-12所示

/

图-12

确认可ping通本网段内的其他主机IP地址（192.168.1.20）

若成功获得“来自192.168.1.20的回复”，说明本机可访问本网段内其他主机：

```shell
C:\Users\Administrator> ping 192.168.1.20
正在 Ping 192.168.1.20 具有 32 字节的数据:
来自 192.168.1.20 的回复: 字节=32 时间<1ms TTL=128
来自 192.168.1.20 的回复: 字节=32 时间<1ms TTL=128
来自 192.168.1.20 的回复: 字节=32 时间<1ms TTL=128
来自 192.168.1.20 的回复: 字节=32 时间<1ms TTL=128
192.168.1.20 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 0ms，最长 = 0ms，平均 = 0ms
```

# Exercise

## 1 请描述TCP/IP协议中主机与主机之间通信的三要素

IP地址（IP address）

子网掩码（subnet mask）

IP路由（IP router）

## 2 请描述IP地址的分类及每一类的范围

A类1-127

B类128-191

C类192-223

D类224-239组播(多播)

E类240-254科研

## 3 请描述A、B、C三类IP地址的默认子网掩码

A类255.0.0.0

B类255.255.0.0

C类255.255.255.0

## 4 在windows server 2008R2系统中如何通过命令查看主机IP地址

实现此案例需要按照如下步骤进行。

> 步骤一：打开命令提示符

点击开始菜单运行—输入CMD后回车或点击`开始菜单`—`所有程序`—`附件`—`命令提示符`

> 步骤二：用命令查看windows主机的IP地址 `shell ipconfig`或`ipconfig/all`



> 如有侵权，请联系作者删除



﻿@[TOC]( Ansible ad-hoc & Ansible module | Cloud computing )

---

# 1. Ansible ad-hoc应用一

## 1.1 问题

沿用练习一，练习Ansible ad-hoc具体应用，要求如下：

- 测试主机列表中的主机是否可以ping通
- 查看被管理主机的服务器信息（如时间、版本、内存等）
- 学习ansible-doc命令的用法
- 测试command与shell模块的区别
- 使用script模块在远程主机执行脚本（装软件包、启服务）

##  1.2 方案

Ansible ad-hoc是一种通过命令行批量管理的方式，命令基本格式如下：

格式：ansible 主机集合 -m 模块名 -a "参数"

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：测试环境**

1）查看主机列表

```shell
[root@control ~]# cd  ~/ansible                            #非常重要
[root@control ansible]# ansible  all  --list-hosts           #查看所有主机列表
# --list-hosts是ansible这个命令的固定选项，如同ls -a一样（-a是ls命令的固定选项）
#英语词汇：list（列表，清单）、host（主机、主办、主人）
```

2) 测试远程主机是否能ping通。

当需要远程多个主机或者多个组时，中间使用逗号分隔！！！

```shell
[root@control ansible]# ansible  node1  -m  ping              #调用ping模块
[root@control ansible]# ansible  node1,webserver  -m  ping
常见报错（有问题可以参考，没问题可以忽略）：
```

```shell
node1 | UNREACHABLE! => {
"changed": false, 
"msg": "Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).", 
"unreachable": true
}
问题分析：
英语词汇：Failed（失败），connect（连接），to（到），host（主机），via（通过）
permission（权限），denied（被拒绝）
Failed to connect to host via ssh（通过ssh远程连接到主机失败）
Permission denied（因为无法连接，所以报错说权限被拒绝）
解决办法：手动ssh其他主机（如node1），看看是否可以实现免密码登录。
          Ansible的原理是基于ssh远程管理，如果无法实现免密码登录，后面的实验无法成功！
        如何实现免密码登录，可以参考案例上面的命令，或者第一阶段知识。
```

提示：该模块虽然叫ping，但是它不会发送任何ICMP协议的ping数据包，控制端主机仅仅是ssh远程被管理端主机，检查其是否有python环境，能顺利远程并且有Python环境就会返回正确的提示信息，否则报错。拓扑如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/94153c63ce1f46739bb0ef7803889eb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

3）快速入门。

模块就是脚本（多数为Python脚本），多数脚本都支持参数，默认模块为command。

```shell
[root@control ansible]# ansible  node1  -m  command  -a   "uptime"     #查看CPU负载
[root@control ansible]# ansible  node1  -m command -a  "uname -r"      #查看内核版本
[root@control ansible]# ansible  node1   -a   "ip a s"                  #查看网卡信息
[root@control ansible]# ansible  all   -a   "date"                      #查看时间
```

拓扑如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/895b7fab1a9846c7922ed4db15dada9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

通过ansible-doc获取帮助。

```shell
[root@control ansible]# ansible-doc  -l                      #列出所有模块
[root@control ansible]# ansible-doc -l | grep yum            #在所有模块中过滤关键词
[root@control ansible]# ansible-doc yum                         #查看模块帮助
```

4）Shell模块。

command和shell模块的区别，command不支持bash的特性（bash有哪些特性可以参考Shell课程第一天的PPT），如管道和重定向等功能，但是shell模块可以支持。

不可以使用shell模块执行交互命令，如vim、top等。

```shell
[root@control ansible]# ansible test -m command -a "ps | wc -l"         #报错
[root@control ansible]# ansible test -m command -a  "ls &"               #报错
[root@control ansible]# ansible test -m shell -a  "ps aux | wc -l"       #进程数量
[root@control ansible]# ansible test -m shell -a  "who"                   #登陆信息
[root@control ansible]# ansible test -m shell -a  "touch /tmp/txt.txt"  
#使用shell模块创建文件会有Warning警告提示，正常！！！
```

5）script模块

script模块会把-a后面的脚本拷贝到被管理端主机，然后执行这个脚本。

```shell
[root@control ansible]# vim  ~/ansible/test.sh  
#!/bin/bash
dnf -y install httpd
systemctl start httpd
[root@control ansible]# ansible  test  -m script  -a  "./test.sh"    
#test是主机组的名称，-m调用script模块，-a后面的./test.sh是上面创建脚本的相对路径和文件名
#./是当前目录的意思，在当前目录下有个脚本叫test.sh
拓扑如图-3所示。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/916599887f83476faf11c892a02ef994.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

如何验证？

因为ansible远程的是node1，所以打开node1这台电脑，查看下是否安装了httpd软件、是否启动了服务。

```shell
[root@node1 ~]# rpm -q  httpd
[root@node1 ~]# systemctl  status  httpd
```

# 2. Ansible ad-hoc应用二

## 2.1 问题

沿用练习一，继续练习Ansible ad-hoc应用案例，具体要求如下：

- 远程目标主机新建文件和目录、修改文件或目录的权限
- 在远程目标主机创建链接文件
- 删除远程目标主机上的文件或目录
- 将控制端本地的文件拷贝到被管理端
- 从被管理端下载文件到本地
- 修改远程目标主机上的文件内容

## 2.2 方案

很多ansible模块都具有幂等性的特征。

幂等性：任意次执行所产生的影响均与一次执行的影响相同。

**步骤一：file模块**

file模块可以创建文件、目录、链接；修改权限与属性等（ansible-doc file）

```shell
[root@control ansible]# ansible  test  -m  file  -a  "path=/tmp/file.txt state=touch"         #远程test组中所有主机，新建文件，path后面指定要创建的文件或目录的名称
#state=touch是创建文件，state=directory是创建目录
## 验证： 到node1主机，使用ls /tmp/file.txt看看文件是否被创建成功   ##
```

拓扑如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b6d8885956fb4614ad260146f4a25e58.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

常见报错（有问题可以参考，没问题可以忽略）：

```shell
node1 | FAILED! => {
   … …
    "changed": false,
    "msg": "value of state must be one of: absent, directory, file, hard, link, touch, got: touc"
}
英语词汇：value（值），must（必须），be（是），of（…的），one（一个）
value of state must be one of:【state的值必须是后面给出的其中一个值】
解决办法：检查state的值是否有字母错误,上面报错例子中输入的是touc，不是touch。
```

常见错误（有问题可以参考，没问题可以忽略）：

```shell
node1 | FAILED! => {
   … …
   "msg": "Unsupported parameters for (file) module: nmae Supported parameters include: _diff_peek, _original_basename, access_time, 
access_time_format, attributes, backup, content, delimiter, directory_mode,
 follow, force, group, mode, modification_time, modification_time_format, owner,
 path, recurse, regexp, remote_src, selevel, serole, setype, seuser, src, state,
 unsafe_writes"
}
英语词汇：unsupported（不支持的），parameters（参数），supported（支持的）include(包括)
问题分析：file模块不支持nmae这个参数，它支持的参数包括哪些，后面有提示.
解决办法：检查模块的参数是否有字母错误，上面错误案例将name错写为nmae。
```

更多file模块的案例：

```shell
[root@control ansible]# ansible  test  -m  file  \
-a  "path=/tmp/mydir state=directory"       
#远程test组中所有主机，创建目录，path后面指定要创建的文件或目录的名称
## 验证：到node1主机，使用ls /tmp/看看tmp目录下是否有mydir子目录
[root@control ansible]# ansible  test  -m  file \
-a  "path=/tmp/file.txt owner=sshd group=adm mode=0777"  
#修改文件或目录权限，path后面指定要修改的文件名或目录名称，owner后面指定用户，group后面指定组，mode后面指定要修改的权限（0777中第一个0代表的是无特殊权限，如SUID、SGID等）
## 验证：到node1主机，使用ls -l /tmp/file.txt查看文件的详细信息是否正确
[root@control ansible]# ansible test -m file -a "path=/tmp/mydir state=absent"
#state=absent代表删除（删除目录）
[root@control ansible]# ansible test -m file -a "path=/tmp/file.txt state=absent"
# state=absent代表删除（删除文件）
[root@control ansible]# ansible test -m file \
-a "src=/etc/hosts  path=/tmp/host.txt state=link"  
#给/etc/hosts文件创建一个链接文件/tmp/host.txt（src指定源文件，path是软链接文件名）
#相当于执行命令 ln -s  /etc/hosts  /tmp/host.txt
## 验证：到node1主机使用ls -l  /tmp/hosts查看文件是否为软链接
```

**步骤二：copy模块**

copy模块可以将文件拷贝到远程主机 (ansible-doc copy)。

```shell
[root@control ansible]# echo AAA > ~/a3.txt                   #新建测试文件
[root@control ansible]# ansible test -m copy -a "src=~/a3.txt dest=/root/"
#把管理端本机的a3.txt文件，拷贝到test组中所有主机的/root/目录
#src代表源文件，dest代表目标文件
## 验证：到node1主机使用ls /root/a3.txt查看是否有该文件
```

拓扑如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3cbd73a49cdf4fc29b18a19598035b4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

**步骤三：fetch模块**

fetch模块与copy类似，但是作用相反,可以将其他主机的文件拷贝到本地(ansible-doc fetch)。

```shell
[root@control ansible]# ansible test -m fetch -a "src=/etc/hostname   dest=~/"
#将远程test组中所有主机的hostname文件下载到本地家目录
#src代表源文件，dest代表目标文件
[root@control ansible]# ls  ~/          #使用ls查看下是否下载成功
#不能下载目录，如果需要下载目录，可以先打包后再下载
```

拓扑如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f11cdee8fcdc4ac78e044c22d26cbfbf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

**步骤四：lineinfile|replace模块**

在修改单个文件的单行内容时可以使用lineinfile模块(ansible-doc lineinfile)。

```shell
[root@control ansible]# ansible test -m lineinfile  \
-a "path=/etc/issue line='hello world'"
#在/etc/issue文件中添加一行内容hello world，默认添加到最后，line后面跟的是需要添加的文件内容
## 验证：到node1主机执行命令cat /etc/issue查看文件内容是否正确
[root@control ansible]# ansible test -m lineinfile \
-a "path=/etc/issue line='hello world'"
#基于幂等原则，重复执行，不会创建多行内容
## 验证：到node1主机执行命令cat /etc/issue查看文件内容是否正确
```

lineinfile会替换一整行，replace可以替换关键词(ansible-doc replace)。

```shell
[root@control ansible]# ansible test -m replace \
-a "path=/etc/issue.net regexp=Kernel replace=Ocean"
#将node1主机中/etc/issue.net文件全文所有的Kernel替换为Ocean
#regexp后面是需要替换的旧内容；replace后面是需要替换的新内容
## 验证：到node1主机执行命令cat /etc/issue.net查看文件内容是否正确
```

# 3. Ansible ad-hoc应用三

## 3.1 问题

沿用练习三，继续练习Ansible ad-hoc应用案例，具体要求如下：

- 远程目标主机创建、删除系统账户；设置系统账户属性、修改账户密码
- 为目标主机创建、删除yum源配置文件；远程目标主机安装、卸载软件包
- 使用service模块管理远程主机的服务
- 创建、删除逻辑卷

**步骤一：user模块**

user模块可以实现Linux系统账户管理(ansible-doc user)。

```shell
[root@control ansible]# ansible test -m user -a "name=tuser1"
#远程test组中的所有主机并创建系统账户tuser1，默认state的值为present，代表创建用户
## 验证：到node1主机执行命令id  tuser1查看是否有该用户
```

拓扑如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb68ae9b4f6e4e95a5f6747491899a27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-7

```shell
[root@control ansible]# ansible test -m user -a \
"name=tuser2 uid=1010 group=adm groups=daemon,root home=/home/tuser2"
#创建账户并设置对应的账户属性，uid指定用户ID号，group指定用户属于哪个基本组
#groups指定用户属于哪些附加组，home指定用户的家目录
## 验证： 到node1主机执行命令id tuser2查看是否有该用户
```

拓扑如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/59910f92440e43c5827ed36e7bc360c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

```shell
[root@control ansible]# ansible test -m user \
-a "name=tuser1 password={{'abc'| password_hash('sha512')}}"
#修改账户密码，用户名是tuser1，密码是abc，密码经过sha512加密
[root@control ansible]# ansible test -m user \
-a "name=tuser1 state=absent"
#删除账户tuser1，state=absent代表删除账户的意思，name指定要删除的用户名是什么
#账户的家目录不会被删除，相当于执行userdel tuser1
[root@control ansible]# ansible test -m user \
-a "name=tuser2 state=absent remove=true"
#删除tuser2账户同时删除家目录、邮箱，相当于执行userdel  -r  tuser2
```

**步骤二：yum_repository模块**

使用yum_repository可以创建或修改yum源配置文件（ansible-doc yum_repository）。

```shell
[root@control ansible]# ansible test -m yum_repository \
-a "name=myyum description=hello baseurl=ftp://192.168.4.254/centos gpgcheck=no"
#新建一个yum源配置文件/etc/yum.repos.d/myyum.repo
#yum源文件名为myyum，该文件的内容如下：
[myyum]
baseurl = ftp://192.168.4.254/centos
gpgcheck = 0
name = hello
## 验证：到node1主机ls /etc/yum.repos.d/查看该目录下是否有新的yum文件
[root@control ansible]# ansible test -m yum_repository \
-a "name=myyum description=test baseurl=ftp://192.168.4.254/centos gpgcheck=yes gpgkey=…"
#修改yum源文件内容
[root@control ansible]# ansible test -m yum_repository -a "name=myyum state=absent"
#删除yum源文件myyum
```

**步骤三：yum模块**

使用yum模块可以安装、卸载、升级软件包（ansible-doc yum），

state: present(安装)|absent(卸载)|latest(升级)。

```shell
[root@control ansible]# ansible test -m yum -a "name=unzip state=present"
#安装unzip软件包，state默认为present，也可以不写
## 验证：到node1主机执行命令rpm -q unzip查看是否有该软件
[root@control ansible]# ansible test -m yum -a "name=unzip state=latest"
#升级unzip软件包，软件名称可以是*，代表升级所有软件包
[root@control ansible]# ansible test -m yum -a "name=unzip state=absent"
#调用yum模块，卸载unzip软件包，state=absent代表卸载软件
## 验证：到node1主机执行命令rpm -q unzip查看该软件是否已经被卸载
```

**步骤四：service模块（ansible-doc service）**

service为服务管理模块（启动、关闭、重启服务等），
state:started|stopped|restarted，
enabled:yes设置开机启动。

```shell
[root@control ansible]# ansible test -m yum -a "name=httpd"
#调用yum模块，安装httpd软件包
## 验证：到node1主机执行命令rpm -q httpd查看该软件是否被安装
[root@control ansible]# ansible test -m service -a "name=httpd state=started"
#调用service模块，启动httpd服务
## 验证：到node1主机执行命令systemctl  status  httpd查看服务状态
[root@control ansible]# ansible test -m service -a "name=httpd state=stopped"
#调用service模块，关闭httpd服务
## 验证：到node1主机执行命令systemctl  status  httpd查看服务状态
[root@control ansible]# ansible test -m service -a "name=httpd state=restarted"
#调用service模块，重启httpd服务
[root@control ansible]# ansible test -m service -a "name=httpd enabled=yes"
#调用service模块，设置httpd服务开机自启
```

**步骤五：逻辑卷相关模块（ansible-doc lvg、ansible-doc lvol）**

提示：做实验之前需要给对应的虚拟机添加额外磁盘，并创建磁盘2个分区

提示：可以使用前面学习过的parted或fdisk命令给磁盘创建分区

提示：这里的磁盘名称仅供参考，不要照抄！！！

lvg模块:创建、删除卷组(VG)，修改卷组大小，

state:present(创建)|absent(删除)。

```shell
 [root@control ansible]# ansible test -m yum -a "name=lvm2"
#安装lvm2软件包，安装了lvm2软件后，才有pvcreate、vgcreate、lvcreate等命令
[root@control ansible]# ansible test -m lvg -a "vg=myvg pvs=/dev/vdb1"
#创建名称为myvg的卷组，该卷组由/dev/vdb1组成
#注意：这里的磁盘名称要根据实际情况填写
## 验证：到node1主机执行命令pvs和vgs查看是否有对应的PV和VG
[root@control ansible]# ansible test -m lvg -a "vg=myvg pvs=/dev/vdb1,/dev/vdb2"
#修改卷组大小，往卷组中添加一个设备/dev/vdb2
```

lvol模块:创建、删除逻辑卷(LV)，修改逻辑卷大小，

state:present(创建)|absent(删除)。

```shell
[root@control ansible]# ansible test -m lvol -a "lv=mylv vg=myvg size=2G"
#使用myvg这个卷组创建一个名称为mylv的逻辑卷，大小为2G
## 验证：到node1主机执行命令lvs查看是否有对应的LV逻辑卷
[root@control ansible]# ansible test -m lvol -a "lv=mylv vg=myvg size=4G"
#修改LV逻辑卷大小
[root@control ansible]# ansible test -m lvol -a "lv=mylv vg=myvg state=absent force=yes"
#删除逻辑卷，force=yes是强制删除
[root@control ansible]# ansible test -m lvg -a "vg=myvg state=absent"
#删除卷组myvg
```

附加思维导图，如图-9所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/8953a24004b347a8947ffa298e093634.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-9

附加思考题（假设在没有创建ssh密钥的情况下）：

在没有创建ssh密钥的情况下，如果node1需要ssh远程node2是否需要输入密码？

如果node1需要ssh远程node2，应该输入谁的用户名和密码？

node1使用自己系统的账户和密码能否ssh远程node2，node2可以被随便登录还安全吗？

路人甲能否使用自己家的钥匙，去路人乙家（开路人乙家的门）？

node1执行命令ssh root@192.168.4.12，这里的root是谁的账户名？输入谁的密码？

如果使用真机windows的Xshell去ssh远程node2虚拟机，需要在windows也有一个root用户吗？


# Exercise

## 1 Ansible是基于什么语言开发的软件？

Python。

## 2 Ansible哪个模块可以将其他主机的文件拷贝到本地？

fetch模块

## 3 Ansible哪个模块可以自动配置YUM源？

yum_repository模块

## 4 哪些功能是command模块所不支持的？

- 管道
- 重定向
- &后台进程

> 如有侵权，请联系作者删除



﻿@[TOC]( Ansible advanced & Ansible Role | Cloud computing )

---

# 1. ansible应用案例

## 1.1 问题

本案例要求掌握Ansible更多高级语法知识，具体要求如下：

- 熟悉firewalld和template模块的使用
- 熟悉error处理机制
- 熟悉handlers任务
- 熟悉when条件判断
- 熟悉block任务块
- 熟悉loop循环的使用方法

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：firewalld模块**

使用firewalld模块可以配置防火墙策略。

```shell
[root@control ~]#  vim ~/ansible/firewall.yml
---
- hosts: test                           #hosts定义需要远程的主机
  tasks:                                 #tasks定义需要执行哪些任务
    - name: install firewalld.         #name为第一个任务定义描述信息
      yum:                               #第一个任务调用yum模块安装软件
        name: firewalld                 #需要安装的软件名称为firewalld
        state: present                  #state等于present代表安装软件
    - name: run firewalld.             #定义第二个任务的描述信息
      service:                          #第二个任务调用service模块启动服务
        name: firewalld                #启动的服务名称为firewalld
        state: started                 #state等于started代表启动服务
        enabled: yes                    #enabled等于yes是设置服务为开机自启动
    - name: set firewalld rule.       #第三个任务的描述信息
      firewalld:                        #第三个任务调用firewalld模块设置防火墙规则
        port: 80/tcp                    #在防火墙规则中添加一个放行tcp，80端口的规则
        permanent: yes                  #permaenent 是设置永久规则
        immediate: yes                  #immediate 是让规则立刻生效
        state: enabled                  #state等于enabled是添加防火墙规则
#最终：在默认zone中添加一条放行80端口的规则
```

**步骤二：template模块**

copy模块可以将一个文件拷贝给远程主机，但是如果希望每个拷贝的文件内容都不一样呢？如何给所有web主机拷贝index.html内容是各自的IP地址？

Ansible可以利用Jinja2模板引擎读取变量，之前在playbook中调用变量，也是Jinja2的功能，Jinja2模块的表达式包含在分隔符"{{ }}"内。

这里，我们给webserver主机拷贝首页，要求每个主机内容不同。

```shell
[root@control ansible]# vim ~/ansible/index.html
Welcome to {{ansible_hostname}} on {{ ansible_eth0.ipv4.address }}. 
#注意网卡名称根据实际情况填写，不可以完全照抄，不知道网卡名可以通过ip a s查询！
#{{ansible_hostname}}和{{ ansible_eth0.ipv4.address }}是ansible自动的facts变量。         
```

2）编写Playbook将网页模板文件拷贝到远程主机。

```shell
[root@control ansible]# vim ~/ansible/template.yml
---
- hosts: webserver
  tasks:
    - name: use template copy index.html to webserver.
      template:
        src: ~/ansible/index.html
        dest: /tmp/index.html
#hosts定义需要远程的目标主机是谁；tasks定义需要执行的任务是什么
#- name定义任务的描述信息；任务需要调用的模块是template模块
#template模块需要两个参数，src指定需要拷贝的源文件，dest指定需要拷贝的目标位置
#src: ~/ansible/template/index.html是上面创建的文件,文件中包含变量
#dest: /tmp/index.html拷贝到目标主机放在/tmp目录下
```

**步骤三：Ansible高级语法应用**

1）error错误处理

默认ansible在遇到error会立刻停止playbook，使用ignore_errors可以忽略错误，继续后续的任务。

如果一个剧本里面有20个任务，执行到第3个时失败，则不再往下执行。

下面这个这个Playbook在执行时会意外中断。

```shell
[root@control ansible]# vim ~/ansible/error.yml
---
- hosts: test
  tasks:
    - name: start a service that does not exist.
      service:
        name: hehe         #注意：没有这个服务（启动一个不存在的服务）                                       
        state: started
    - name: touch a file.
      file:
        path: /tmp/service.txt
        state: touch
```

下面这个Playbook在执行时因为忽略了错误（针对某一个任务），不会被中断。

```shell
[root@control ansible]# vim ~/ansible/error.yml
---
- hosts: test
  tasks:
    - name: start a service that does not exist.
      service:
        name: hehe
        state: started
      ignore_errors: true       #针对某一个任务忽略错误(ignore_errors是关键词)                          
    - name: touch a file.
      file:
        path: /tmp/service.txt
        state: touch
```

下面这个Playbook在执行时因为忽略了错误，不会被中断。

```shell
[root@control ansible]# cat ~/ansible/error.yml
---
- hosts: test
  ignore_errors: true      #针对playbook全局忽略错误                             
  tasks:
    - name: start a service that does not exist.
      service:
        name: hehe
        state: started
    - name: touch a file.
      file:
        path: /tmp/service.txt
        state: touch
```

2）handlers

在剧本中tasks用来定义任务（一定会执行），handlers也可以定义任务（不一定执行），handlers任务要想执行必须要被别人触发才能执行。

```shell
实例草稿：
---
- hosts: test
  tasks:
    - 任务1
       notify:任务5
    - 任务2
  handlers:
    - 任务5
    - 任务6
```

可以通过handlers定义一组任务，仅当某个任务触发(notify)handlers时才执行相应的任务，如果有多个notify触发执行handlers任务，也仅执行一次。

仅当任务的执行状态为changed时handlers任务才执行，handlers任务在所有其他任务都执行后才执行。

下面编写一个通过notify触发执行handlers任务的案例。

```shell
[root@control ansible]# vim ~/ansible/handlers.yml
---
- hosts: test
  tasks:
    - name: create directory.           #多次执行playbook该任务状态不再是changed
      file:                               #调用file模块创建目录
        path: /tmp/parents/subdir/      #需要创建的具体目录名称
        state: directory                #state等于directory代表创建目录
      notify: touch file                #notify后面名称必须和handlers中的任务名称一致           
  handlers:                              #通过handlers再定义一组任务
    - name: touch file                  #给任务写描述信息（任务的名字，名字可以任意）
      file:                              #调用file模块创建文件
        path: /tmp/parents/subdir/new.txt    #需要创建的文件名
        state: touch                           #state等于touch代表创建文件
#备注：仅当file模块执行成功，
#并且状态为changed时才会通过notify触发执行handlers下面的任务，
#所以多次执行该剧本时，handlers任务不会被重复执行,
#notity后面的名称必须和handlers下面name定义的任务名称一致（名称可以任意）。
```

3）when条件判断

when可以定义判断条件，条件为真时才执行某个任务。

常见条件操作符有：==、!=、>、>=、<、<=。

多个条件可以使用and(并且)或or（或者）分割，when表达式中调用变量不要使用{{ }}。

下面编写Playbook，远程主机剩余内存不足700M则关闭NetworkManager服务

```shell
[root@control ansible]# vim ~/ansible/when_1.yml
---
- hosts: test
  tasks:
    - name: check memory size.
      service:
        name: NetworkManager
        state: stopped
      when: ansible_memfree_mb < 700
#被管理端主机剩余内存不足700M则关闭NetworkManager服务(也可以关闭别的不需要的服务)
#ansible_memfree_mb这个是ansible自带的facts变量,代表剩余内存的容量。
```

下面再编写一个Playbook，判断操作系统是RedHat8则创建测试文件。YAML的语法格式中>支持多行输入，但不保留换行符。

```shell
[root@control ansible]# vim ~/ansible/when_2.yml
---
- hosts: test
  tasks:
    - name: touch a file
      file:
        path: /tmp/when.txt
        state: touch
      when:  >
        ansible_distribution == "RedHat"
        and
        ansible_distribution_major_version == "8"
#判断操作系统是RedHat8则创建测试文件
#YAML的语法格式中>支持多行输入，但不保留换行符（计算机会认为实际是一行内容）
#ansible_distribution和ansible_distribution_major_version都是自带的facts变量
#可以使用setup模块查看这些变量
```

4）block任务块

如果我们需要当条件满足时执行N个任务,我们可以给N个任务后面都加when判断(但是很麻烦),此时可以使用block定义一个任务块,当条件满足时执行整个任务块.

任务块就是把一组任务合并为一个任务组，使用block语句可以将多个任务合并为一个任务组。

```shell
[root@control ansible]# vim ~/ansible/block_1.yml
---
- hosts: test
  tasks:
    - name: define a group of tasks.
      block:                                          #block是关键词，定义任务组
        - name: install httpd                       #任务组中的第一个任务
          yum:                                        #调用yum模块安装httpd软件包
            name: httpd
            state: present
        - name: start httpd                          #任务组中的第二个任务
          service:                                    #调用service模块启动httpd服务
            name: httpd
            state: started
      when: ansible_distribution == "RedHat"       #仅当条件满足再执行任务组
#注意:when和block是对齐的,他们在一个级别,当条件满足时要执行的是任务组（不是某一个任务）
#判断条件是看远程的目标主机使用的Linux发行版本是否是RedHat.
```

对于block任务块，我们可以使用rescue语句定义在block任务执行失败时要执行的其他任务，还可以使用always语句定义无论block任务是否成功，都要执行的任务。

下面编写一个包含rescue和always的示例。

```shell
[root@control ansible]# vim ~/ansible/block_2.yml
---
- hosts: test
  tasks:
    - block:
        - name: touch a file test1.txt
          file:
            name: /tmp/test1.txt      #如果修改为/tmp/xyz/test1.txt就无法创建成功                        
            state: touch
      rescue:
        - name: touch a file test2.txt
          file:
            name: /tmp/test2.txt
            state: touch
      always:
        - name: touch a file test3.txt
          file:
            name: /tmp/test3.txt
            state: touch
#默认在/tmp/目录下创建test1.txt会成功，所以不执行rescue(创建test2.txt)
#如果我们把block中的任务改为创建/tmp/xyz/test1.txt（因为没有xyz目录所以会失败)
#当block默认任务失败时就执行rescue任务(创建test2.txt)
#但是不管block任务是否成功都会执行always任务(创建test3.txt)
```

5）loop循环

相同模块需要反复被执行怎么处理？使用loop循环可以避免重复。

编写Playbook，循环创建目录。

```shell
[root@control ansible]# vim ~/ansible/simple_loop.yml
---
- hosts: test
  tasks:
    - name: mkdir multi directory.
      file:
        path=/tmp/{{item}}       #注意，item是关键字，调用loop循环的值                                
        state=directory
      loop:                       #loop是关键词,定义循环的值,下面是具体的值
        - School
        - Legend
        - Life
#最终在/tmp目录下创建三个子目录.file模块被反复执行了三次。
#mkdir  /tmp/School;  mkdir  /tmp/Legend;   mkdir  /tmp/Life。
```

编写Playbook，循环创建用户并设置密码。

```shell
[root@control ansible]# vim ~/ansible/complex_loop.yml
---
- hosts: test
  tasks:
    - name: create multi user.
      user:
        name: "{{item.iname}}"
        password: "{{item.ipass | password_hash('sha512')}}"
      loop:
        - { iname: 'term', ipass: '123456' }
        - { iname: 'amy' , ipass: '654321' }
#loop循环第一次调用user模块创建用户,user模块创建用户会读取loop里面的第一个值.
#loop第一个值里面有两个子值,iname和ipass
#创建用户item.iname就是loop第一个值里面的iname=term
#修改密码item.ipass就是loop第一个值里面的ipass=123456
#loop循环第二次调用user模块创建用户,user模块创建用户会读取loop里面的第二个值.
#loop第二个值里面有两个子值,iname和ipass
#创建用户item.iname就是loop第二个值里面的iname=amy
#修改密码item.ipass就是loop第二个值里面的ipass=654321
```

# 2. Ansible Roles

## 2.1 问题

学习Ansible Roles基本概念，掌握Roles应用案例，具体要求如下：

- 自定义Ansible Role
- 编写playbook调用role
- 使用ansible-galaxy管理Roles

## 2.2 方案

在实际生产环境中，为了实现不同的功能，我们会编写大量的playbook文件。而且，每个playbook还可能会调用其他文件（如变量文件），对于海量的、无规律的文件，管理起来非常痛苦！

Ansible从1.2版本开始支持Role（角色），Role（角色）是管理ansible文件的一种规范（目录结构），Role（角色）会按照标准的规范，自动到特定的目录和文件中读取数据。

如果我们创建了一个名称为user.example的Role（角色），则其标准的目录结构如下图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/75f8bdd4719d4368aee96ece87fe5a80.png)
图-1

Roles目录结构中主要文件的作用是什么呢？

- defualts/main.yml：定义变量的缺省值，优先级较低
- files目录：存储静态文件的目录，如tar包、音乐、视频等
- handlers/main.yml:定义handlers
- meta/main.yml:写作者、版本等描述信息
- README.md:整个角色(role)的描述信息
- tasks/main.yml:定义任务的地方
- templates目录：存放动态数据文件的地方（文件中包含了变量的模板文件）
- vars/main.yml:定义变量，优先级高

**步骤一：Role应用案例**

1）创建Roles

下面这个案例目的：编写一个包含变量的模板文件，编写任务调用template模块，将模板文件拷贝给被管理端主机。

ansible-galaxy命令可以创建、管理自己的roles。

```shell
[root@control ansible]# mkdir ~/ansible/roles
[root@control ansible]# ansible-galaxy init  ~/ansible/roles/issue
#创建一个Role，该Role的目的是拷贝自己新建的一个模板文件到远程主机的/etc/issue
[root@control ansible]# tree  ~/ansible/roles/issue/
#查看目录结构，如果没有tree命令则需要使用yum安装该软件
```

2）修改Role文件

定义名称为myfile.txt的模板文件（该文件包含变量,因此必须放置templates目录）

```shell
[root@control ansible]# vim ~/ansible/roles/issue/templates/myfile.txt
This is the system {{ansible_hostname}}
Today's date is:{{ansible_date_time.date}}
Contact to {{ admin }}
```

自定义变量文件（前面调用了admin这个变量，这里需要定义admin变量并赋值）

```shell
[root@control ansible]# vim ~/ansible/roles/issue/vars/main.yml
---
# vars file for /root/ansible/roles/issue
admin: yoyo@tedu.cn
#变量名为admin，变量的值为yoyo@tedu.cn
```

文件准备好了，计算机不会自动将文件拷贝给被管理端主机！需要编写任务调用模块实现拷贝的功能。

修改任务文件，任务文件中不需要tasks关键词，Role的各个文件之间相互调用不需要写文件的路径。

```shell
[root@control ansible]# vim ~/ansible/roles/issue/tasks/main.yml
---
# tasks file for /root/ansible/roles/issue
-  name: delever issue file
   template:
     src: myfile.txt
     dest: /etc/issue
#调用template模块将myfile.txt文件拷贝给被管理端主机.
```

3）在Playbook中调用Role

Role创建好了，role不会自己运行，需要编写一个剧本调用上面的role。

编写playbook剧本文件,通过roles关键词调用role。

```shell
[root@control ansible]# vim  ~/ansible/issue.yml
---
- hosts: test
  roles:
    - issue
#- role2              #支持加载多个role
```

修改ansible.cfg配置文件，定义roles目录。

```shell
[root@control ansible]# vim  ~/ansible/ansible.cfg 
[defaults]
inventory = ./inventory
roles_path = ./roles                    #指定到哪个目录下找role
```

**步骤二：ansible-galaxy命令**

公共Roles仓库(https://galaxy.ansible.com)管理。

```shell
[root@control ansible]# ansible-galaxy  search 'httpd' 
#联网搜索roles
[root@control ansible]# ansible-galaxy info acandid.httpd 
#查看roles基本信息
[root@control ansible]# ansible-galaxy install acandid.httpd -p ~/ansible/roles/
#下载roles到特定的目录，-p可以指定下载到哪个目录
```

使用ansible-galaxy install可以直接下载Role，也可以编写requirements.yml文件下载Role。

```shell
[root@control ansible]# vim ~/ansible/roles/requirements.yml
#格式一：可以直接从Ansible Galaxy官网下载
- src: acandid.httpd
#格式二：可以从某个git服务器下载
- src: http://gitlab.com/xxx/xxx.git
  scm: git
  version: 56e00a54
  name: nginx-acme
#格式三：可以指定位置下载tar包，支持http、https、file
- src:  http://example.com/myrole.tar
  name:  myrole
[root@control ansible]# ansible-galaxy install \
-r ~/ansible/roles/requirements.yml \
-p roles
# -r后面跟文件名,该文件中包含了需要下载哪些role以及他们的链接位置
# -p 指定将下载的role保存到哪个目录
```

附加思维导图，如图-2所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3d4bc0e55c354f9aad26d370aaaad72d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2



# Exercise

## 1 Ansible使用什么语句实现循环功能？

loop语句

## 2 Ansible使用什么关键词可以定义任务块？

block

## 3 Ansible剧本中使用when进行条件判断时，变量是否使用{{}}引用？

否（不适用{{}}）

## 4 哪些是ansible role的标准目录？

- tasks
- defaults
- vars
- files
- handlers

> 如有侵权，请联系作者删除



﻿@[TOC]( Ansible Vault & Common users use Ansible | Cloud computing )

---

# 1. 综合练习（自动化部署Web集群）

## 1.1 问题

晚自习课外综合练习题，创建一个名为cluster的role，完成一个综合项目，具体要求如下：

- 创建Role，通过Role完成项目
- 部署Nginx调度器
- 部署2台http服务器

## 1.2 方案

综合练习题实验所需主机清单如表-1所示。

表-1 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/18c7c5c3a4e64cdda96328e5ef8ff0e5.png)


**步骤一：部署两台后端http服务器**

1）创建role角色

```shell
[root@control ansible]# ansible-galaxy  init  ~/ansible/roles/http
```

2）修改role配置文件，准备2台http网站的素材

安装httpd，拷贝一个网页文件。

```shell
[root@control ansible]# vim roles/http/tasks/main.yml
---
- name: install httpd
  yum:
    name: httpd
    state: present
- name: create index.html
  copy:
    content: "{{ansible_hostname}}"
    dest: /var/www/html/index.html
- name: set firewalld
  firewalld:
    service: http
    state: enabled
    permanent: yes
    immediate: yes
- name: start httpd
  service:
    name: httpd
    state: started
    enabled: yes
#文件中包含多个任务，每个任务可以设置一个name名字（也可以没有name）
#第一个任务调用yum模块安装httpd软件包
#第二个任务调用copy模块创建一个新的网页文件(index.html)
#调用copy模块时可以在没有源文件的情况下，直接使用content指定文件的内容
#将该内容直接拷贝到被管理主机的某个文件中(/var/www/html/index.html)
#第三个任务调用firewalld模块，设置防火墙规则，允许访问http服务
#第四个任务调用service模块将httpd服务启动，并设置开机自启。
```

3）编写Playbook调用role，并执行Playbook。

```shell
[root@control ansible]# vim web.yml
---
- hosts: webserver
  roles:
    - http
[root@control ansible]# ansible-playbook web.yml
```

**步骤二：部署nginx代理服务器**

1）创建role角色

```shell
[root@control ansible]# ansible-galaxy  init  ~/ansible/roles/proxy
```

2）准备代理服务器需要的素材

拷贝Nginx源码包，编写一个源码编译安装nginx的shell脚本。

```shell
[root@control ansible]# cp  lnmp_soft/nginx-1.17.6.tar.gz  \
~/ansible/roles/proxy/files/
[root@control ansible]# vim ~/ansible/roles/proxy/files/nginx_install.sh
#!/bin/bash
yum -y install gcc pcre-devel openssl-devel make tar
cd /tmp
tar -xf /tmp/nginx-1.17.6.tar.gz
cd nginx-1.17.6
./configure --with-http_ssl_module
make
make install
```

新建一个Nginx代理服务器的配置文件模板。

```shell
[root@control ansible]# vim ~/ansible/roles/proxy/files/nginx.conf
worker_processes  2;
#error_log  logs/error.log;
events {
    worker_connections  65535;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    tcp_nopush     on;
    keepalive_timeout  65;
    #gzip  on;
upstream webs {
   server 192.168.4.13;
   server 192.168.4.14;
}
    server {
        listen       80;
        server_name  localhost;
        location / {
            proxy_pass http://webs;
            root   html;
            index  index.html index.htm;
        }
        error_page  404              /404.html;
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

3）修改role配置文件。

```shell
[root@control ansible]# vim roles/proxy/tasks/main.yml
---
- name: copy nginx-1.17.6.tar.gz to proxy.
  copy:
    src: nginx-1.17.6.tar.gz
    dest: /tmp/
#拷贝源码包软件
- name: install nginx through shell script.
  script: nginx_install.sh
  args:
    creates: /usr/local/nginx/sbin/nginx
#执行源码编译安装脚本，如果已经安装nginx，则不再执行安装脚本.
#args是关键词，设置script模块的参数，通过creates参数做判断，creates也是关键词
#creates后面跟文件名，如果creates判断文件存在的话就不再执行script模块对应的命令。
- name: copy nginx.conf to destination host.
  copy:
    src: nginx.conf
    dest: /usr/local/nginx/conf/nginx.conf
- name: run nginx service.
  shell: /usr/local/nginx/sbin/nginx
  args:
    creates: /usr/local/nginx/logs/nginx.pid
#nginx.pid存在，说明nginx已经启动。如果该文件存在，则不再启动nginx。
- name: set firewalld
  firewalld:
    service: http
    state: enabled
    permanent: yes
    immediate: yes
```

4）编写Playbook调用role,并执行Playbook。

```shell
[root@control ansible]# vim proxy.yml
---
- hosts: proxy
  roles:
    - proxy
[root@control ansible]# ansible-playbook proxy.yml
```

# 2. 加密敏感数据

## 2.1 问题

本案例要求，使用ansible-vault对敏感数据进行加密处理，具体要求如下：

- 使用ansible-vault管理敏感数据

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用ansible-vault处理敏感数据**

1）加密敏感数据。

encrypt（加密）、decrypt（解密）、view（查看），rekey（重置密码）。

```shell
[root@control ansible]# echo 123456 > data.txt               #新建测试文件
[root@control ansible]# ansible-vault encrypt data.txt      #加密文件
[root@control ansible]# cat data.txt
[root@control ansible]# ansible-vault view data.txt         #查看加密文件
```

2）修改密码（rekey）

```shell
[root@control ansible]# ansible-vault rekey data.txt             #修改密码
Vault password: <旧密码>
New Vault password: <新密码>
Confirm New Vault password:<确认新密码>
```

3）解密文件

```shell
[root@control ansible]# ansible-vault decrypt data.txt      #解密文件
[root@control ansible]# cat data.txt
```

4）使用密码文件

加密、解密每次都输入密码很麻烦，可以将密码写入文件。

```shell
[root@control ansible]# echo "I'm secret data" > data.txt       #需要加密的敏感数据
[root@control ansible]# echo 123456 > pass.txt                   #加密的密码
[root@control ansible]# ansible-vault  encrypt --vault-id=pass.txt  data.txt 
[root@control ansible]# cat data.txt
[root@control ansible]# ansible-vault decrypt --vault-id=pass.txt data.txt
[root@control ansible]# cat data.txt
```

# 3. 配置sudo权限

## 3.1 问题

本案例要求使用sudo提升普通用户的权限，要求如下：

- 给所有被管理主机创建系统账户
- 账户名称为alice，密码为123456
- 修改sudo配置，让alice可以执行任何管理命令

## 3.2 方案

sudo（superuser or another do）让普通用户可以以超级管理员或其他人的身份执行命令。

sudo基本流程如下：

1. 管理员需要先授权（修改/etc/sudoers文件）
2. 普通用户以sudo的形式执行命令

修改/etc/sudoers的方法如下：

1. visudo（带语法检查，默认没有颜色提示）
2. vim /etc/sudoers（不带语法检查，默认有颜色提示）

授权格式如下：
用户或组 主机列表=(提权身份) [NOPASSWD]:命令列表

注意事项：命令需要写绝对路径，对组授权需要在组名称前面加%。

```shell
[root@control ~]# cat  /etc/sudoers         #不要改，下面仅仅是语法格式的示例（例子）
… …
root           ALL=(ALL)       ALL
tom            ALL=(root)      /usr/bin/systemctl
%wheel         ALL=(ALL)       ALL
```

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置sudo提权**

1）远程所有被管理主机批量创建系统账户，账户名称为alice，密码为123456。

```shell
[root@control ansible]# ansible all -m user -a "name=alice \
password={{'123456' | password_hash('sha512')}}"
```

2）配置alice账户可以提权执行所有命令（control批量授权，node1主机验证）。

使用lineinfile模块修改远程被管理端主机的/etc/sudoers文件，line=后面的内容是需要添加到文件最后的具体内容。

等于是在/etc/sudoers文件末尾添加一行:alice ALL=(ALL) NOPASSWD:ALL

```shell
[root@control ansible]# ansible all -m lineinfile \
-a "path=/etc/sudoers line='alice  ALL=(ALL) NOPASSWD:ALL'"
```

如何验证？可以在node1电脑上面使用alice用户执行sudo重启服务的命令看看是否成功。

```shell
[root@control ~]# ssh alice@node1
[alice@node1 ansible]$ sudo systemctl restart sshd       #不需要输入密码
[alice@node1 ansible]$ exit
```

# 4. 修改Ansible配置

## 4.1 问题

沿用练习一，修改ansible配置实现使用普通用户远程被控制端主机，具体要求如下：

- 修改主配置文件
- 设置ansible远程被管理端主机账户为alice
- 设置ansible远程管理提权的方式为sudo
- 修改主机清单文件
- 修改主机清单配置文件，添加SSH参数

## 4.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：配置普通用户远程管理其他主机

1）修改主配置文件，配置文件文件的内容可以参考/etc/ansible/ansible.cfg。

```shell
[root@control ansible]# vim ~/ansible/ansible.cfg
[defaults]
inventory = ~/ansible/inventory
remote_user = alice                #以什么用户远程被管理主机（被管理端主机的用户名）
[privilege_escalation]
become = true                    #alice没有特权，是否需要切换用户提升权限
become_method = sudo                #如何切换用户（比如用su就可以切换用户，这里是sudo）
become_user = root                #切换成什么用户（把alice提权为root账户）
become_ask_pass = no                #执行sudo命令提权时是否需要输入密码
```

思考：

如果A主机ssh远程访问B主机，应该输入哪个主机的用户名和对应的密码？

如果张三要去李四家，应该使用谁家的钥匙，打开谁家的门？

2)远程被管理端主机的alice用户，需要提前配置SSH密钥。

```shell
[root@control ansible]# for i in node1  node2  node3  node4  node5
do
  ssh-copy-id    alice@$i
done
```

验证效果：

```shell
[root@control ansible]# ssh alice@node1            #依次远程所有主机看看是否需要密码
#注意：是远程登录node1，应该输入的是node1电脑上面alice账户的密码，control没有alice用户
[root@node1 ~]# exit                                #退出远程连接
[root@control ansible]# ansible all -m command -a  "who"              #测试效果
[root@control ansible]# ansible all -m command -a  "touch /test"     #测试效果
```

常见报错（有问题可以参考，没问题可以忽略）：

```shell
node1 | UNREACHABLE! => {
    "changed": false,
    "msg": "Failed to connect to the host via ssh: alice@node1: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).",
    "unreachable": true
}
问题分析：
英语词汇：Failed（失败），connect（连接），to（到），host（主机），via（通过）
permission（权限），denied（被拒绝）
Failed to connect to host via ssh alice@node1（通过ssh使用alice远程连接到主机失败）
Permission denied（因为无法连接，所以报错说权限被拒绝）
解决办法：手动ssh alice@主机名（如node1），看看是否可以实现免密码登录。
          Ansible的原理是基于ssh远程管理，如果无法实现alice免密码登录，则实验会失败！
        如何实现免密码登录，可以参考案例上面的命令，或者第一阶段相关知识。
```

3）修改inventory主机清单配置文件（参考即可，不需要操作）。

如果个别主机的账户不同，该如何处理呢？

如果有些主机需要使用密码远程呢？如果有些主机的SSH端口不是22呢？

```shell
[root@control ~]# cat  ~/ansible/inventory
[test]                    
node1           ansible_ssh_port=端口号                      #自定义远程SSH端口
[proxy]
node2           ansible_ssh_user=用户名                    #自定义远程连接的账户名
[webserver]
node[3:4]       ansible_ssh_pass=密码                     #自定义远程连接的密码
[database]
node5
[cluster:children]                
webserver
database
```

附加思维导图，如图-1所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/46157ce584f841b086a8b9d21c36669c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1


# Exercise

## 1 ansible-vault加密数据的命令是什么？

```shell
# ansible-vault  encrypt  <文件名>
```

## 2 ansible-vault解密数据的命令是什么？

```shell
# ansible-vault  decrypt  <文件名>
```

## 3 ansible-vault修改密码的命令是什么？

```shell
# ansible-vault  rekey  <文件名>
```

## 4 通过sudo给普通用户授权时使用什么关键词可以免密码执行sudo？

NOPASSWD

> 如有侵权，请联系作者删除



﻿@[TOC]( Archiving and compression & redirection and pipeline operations & find precise search & advanced use of VIM   | Cloud computing )

---

# 1. 创建一个备份包

## 1.1 问题

本例要求使用 tar 工具完成以下备份任务：

1. 创建一个名为 /root/backup.tar.bz2 的归档文件
2. 其中包含 /usr/local 目录中的内容
3. tar 归档必须使用 bzip2 进行压缩

## 1.2 方案

制作归档压缩包：

- tar -zcf 备份文件.tar.gz 文档....
- tar -jcf 备份文件.tar.bz2 文档....
- tar -Jcf 备份文件.tar.xz 文档....

查看归档压缩包：

- tar -tf 备份文件

释放归档压缩包：

- tar -xf 备份文件 [-C 目标目录]

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建备份文件**

使用tar命令制作归档备份，结合-j选项调用bzip2压缩工具，保留绝对路径：

```shell
[root@server0 ~]# tar  -jcf  /root/backup.tar.bz2  /usr/local/
```

**步骤二：确认结果**

```shell
[root@server0 ~]# ls  -lh  /root/backup.tar.bz2          //确认文件
-rw-r--r--. 1 root root 1.9K 12月 23 23:22 /root/backup.tar.bz2
[root@server0 ~]# tar  -tf  /root/backup.tar.bz2         //确认内容
usr/local/
usr/local/bin/
usr/local/bin/lab
usr/local/etc/
usr/local/games/
```

# 2. 重定向与管道操作

## 2.1 问题

1. 显示ifconfig命令的前两行内容
2. 显示/etc/passwd第九行内容
3. 将hostname命令的输出内容，覆盖写入到/opt/hn.txt
4. 利用echo命令,将“tmooc”内容追加写入到/opt/hn.txt

## 2.2 方案

重新定向命令的输出：将前面命令的输出，写入到后面文本文件中

- \>：覆盖重定向
- \>>:追加重定向

管道 :将前面命令的输出，传递到后面命令，作为后面命令的参数

## 2.3 步骤

实现此案例需要按照如下步骤进行。

> 1）显示ifconfig命令的前两行内容

```shell
[root@server0 ~]# ifconfig  |  head  -2
```

> 2）显示/etc/passwd第九行内容

```shell
[root@server0 ~]# head  -9  /etc/passwd  |  tail -1
```

> 3）将hostname命令的输出内容，覆盖写入到/opt/hn.txt

```shell
[root@server0 ~]# hostname  >  /opt/hn.txt
```

>  4）利用echo命令,将“tmooc”内容追加写入到/opt/hn.txt

```shell
[root@server0 ~]# echo  tmooc  >>  /opt/hn.txt
```

# 3. 查找并处理文件

## 3.1 问题

1. 利用find查找所有用户 student 拥有的必须是文件,把它们拷贝到 /root/findfiles/ 文件夹中
2. 利用find查找/boot目录下大于10M并且必须是文件，拷贝到/opt
3. 利用find查找/boot/ 目录下以 vm 开头且必须是文件，拷贝到/opt
4. 利用find查找/boot/ 目录下为快捷方式
5. 利用find查找/etc 目录下，以 tab 作为结尾的 必须是文件

## 3.2 方案

根据预设的条件递归查找对应的文件

格式：find [目录] [条件1]

常用条件表示：

- -type 类型（f文件、d目录、l快捷方式）
- -name "文档名称"
- -size +|-文件大小（k、M、G）
- -user 用户名
- -mtime 修改时间

高级使用（处理find查找的结果）

- -exec 额外操作的开始
- \; 表示额外操作的结束
- {} 前面find命令每一个查询的结果

## 3.3 步骤

实现此案例需要按照如下步骤进行。

> 1）利用find查找所有用student 拥有的必须是文件,把它们拷贝到 /root/findfiles/ 文件夹中（确保本机具有student用户）

```shell
[root@server0 ~]# id student
[root@server0 ~]# mkdir /root/findfiles
[root@server0 ~]# find /   -user   student   -type f
[root@server0 ~]# find /   -user   student   -type f  -exec  cp  {}  /root/findfiles \;
 [root@server0 ~]#  ls  /root/findfiles
```

> 2）利用find查找/boot目录下大于10M并且必须是文件，拷贝到/opt

```shell
[root@server0 ~]# find  /boot  -size +10M
[root@server0 ~]# find  /boot  -size +10M   -exec  cp  {}  /opt  \;
[root@server0 ~]# ls  /opt
```

> 3）利用find查找/boot/ 目录下以 vm 开头且必须是文件，拷贝到/opt

```shell
[root@server0 ~]# find  /boot  -name  “vm*”  
[root@server0 ~]# find  /boot  -name  “vm*”   -exec  cp  {}   /opt  \;
[root@server0 ~]# ls   /opt
```

> 4）利用find查找/boot/ 目录下为快捷方式

```shell
[root@server0 ~]# find  /boot  -type  l
```

> 5）利用find查找/etc 目录下，以 tab 作为结尾的 必须是文件

```shell
[root@server0 ~]# find  /etc   -name  “*tab”  -type f
```

# 4. vim效率操作

## 4.1 问题

本例要求掌握使用vim文本编辑器时能够提高操作效率的一些常用技巧和方法，完成下列任务：

1. 将文件 /etc/passwd 复制为 /opt/nsd.txt，然后打开 /opt/nsd.txt 文件，练习命令模式下的切换/复制/删除/查找操作
2. 将文件 /etc/man_db.conf 复制到 /opt 目录下，然后打开 /opt/man_db.conf 文件，将第50~100行内的“man”替换为“MAN”，在 vim 中设置显示行号查看效果

## 4.2 方案

命令模式常用操作：

- 1G 或 gg ，跳转到文件的首行
- G ，跳转到文件的末尾行
- yy、#yy ，复制光标处的一行、#行
- p、P ，粘贴到光标处之后、之前
- x 或 Delete键 ，删除光标处的单个字符
- dd、#dd ，删除光标处的一行、#行
- d^、d$ ，从光标处之前删除至行首/行尾
- /word 向后查找字符串“word”，再按n/N跳至后/前一个结果
- u ，撤销最近的一次操作
- U ，撤销对当前行的所有修改
- Ctrl + r 取消前一次撤销操作
- ZZ 保存修改并退出

末行模式常用操作：

- :s/old/new ，替换当前行第一个“old”
- :s/old/new/g ，替换当前行所有的“old”
- :n,m s/old/new/g ，替换第n-m行所有的“old”
- :% s/old/new/g ，替换文件内所有的“old”
- :w /root/newfile ，另存为其它文件
- :r /etc/filesystems ，读入其他文件内容
- :set nu|nonu ，显示/不显示行号
- :set ai|noai ，启用/关闭自动缩进

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：vim命令模式下的切换/复制/删除/查找**

> 1）建立练习文件

将文件 /etc/passwd 复制为 /opt/nsd.txt：

```shell
[root@svr7 ~]# cp  /etc/passwd  /opt/nsd.txt
```

> 2）使用vim打开练习文件，默认处于命令模式

```shell
[root@svr7 ~]# vim  /opt/nsd.txt
.. ..
```

> 3）在命令模式下完成下列操作

切换操作：G 最后一行，5G 第5行，gg 第一行。
复制操作：按2yy复制2行，7G移动到第7行，p 粘贴。
删除操作：25G 移动到第25行，200dd 从此行开始删除200行（不够就剩下全删）。
查找操作：gg 第一行，/adm 查找关键词adm，n 跳转到下一个结果。

> 4）保存并退出编辑器

ZZ 保存退出。

**步骤二：vim末行模式下的替换/设置操作**

> 1）建立练习文件

将文件 /etc/man_db.conf 复制到 /opt/ 目录下：

```shell
[root@svr7 ~]# cp  /etc/man_db.conf  /opt/
```

> 2）使用vim打开练习文件，输入:切换到末行模式

```shell
[root@svr7 ~]# vim  /opt/man_db.conf
.. ..
: 
```

> 3）在末行模式下完成下列操作

输入 :set nu ，确认后显示行号。

输入 :50,100 s/man/MAN/g ，确认将第50~100行内的“man”替换为“MAN”。

> 4）保存并退出编辑器

输入 :wq ，确认后保存并退出编辑器。



# Exercise

## 1 将目录/usr/local压缩备份为/root/ulocal.tar.xz文件

```shell
[root@server0 ~]# tar  -Jcf  /root/ulocal.tar.xz  /usr/local/
[root@server0 ~]# ls  -lh  /root/ulocal.tar.xz 
-rw-r--r--. 1 root root 8.0K Nov 26 00:02 /root/ulocal.tar.xz
```

## 2 重定向与管道的区别

重新定:将前面命令的输出，写入到后面文本文件中，能够连接命令与文件

管道:将前面命令的输出，传递到后面命令，作为后面命令的参数，能够连接命令与命令

## 3 利用find查找/etc 目录下，以dow作为结尾的并且必须是文件

```shell
[root@server0 ~]# find  /etc   -name   “*dow”    -type   f
```

## 4 vim编辑器的删除、复制、粘贴操作

使用vim编辑器时，在命令模式下按（ dd ）可删除当前光标行，按（ yy ）可复制当前行，按（ p ）将剪贴板中的文本粘贴到当前行之后。


> 如有侵权，请联系作者删除



﻿@[TOC]( Basic rights and ownership & additional rights & and ACL policy management | Cloud computing )

---

# 1. 设置基本权限

## 1.1 问题

1. 新建/nsddir1/目录，在该目录下新建文件readme.txt
2. 使用户zhangsan能够在/nsddir1/目录下创建/删除子目录
   使用户zhangsan能够修改/nsddir1/readme.txt文件，调整/nsddir1/目录的权限，使任何用户都不能进入该目录，测试用户zhangsan是否还能修/nsddir1/readme.txt文件的内容
3. 将/nsddir1/目录及其下所有内容的权限都设置为 rwxr-x---

## 1.2 方案

设置基本权限的命令主要是chmod，本实验要分清三个基本权限rwx的意义。用户在访问一个目录或文件时，由设置的访问权限+归属关系共同决定最终权限访问权限。

- r 读取：允许查看内容-read
- w 写入：允许修改内容-write
- x 可执行：允许运行和切换-excute

若对目录有r权限，表示可列出该目录内容。

若对目录有w权限，表示可在该目录下新建/删除/移动文件或子目录。

若对目录有x权限，表示允许cd到该目录下。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：新建/nsddir1/目录，在该目录下新建文件readme.txt**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir /nsddir1
[root@localhost ~]# ls -ld /nsddir1/             //查看是否创建成功
drwxr-xr-x. 2 root root 4096 2月  26 09:55 /nsddir1/
[root@localhost ~]# touch /nsddir1/readme.txt
[root@localhost ~]# ls -l /nsddir1/readme.txt   //查看是否创建成功
-rw-r--r--. 1 root root 0 2月  26 09:56 /nsddir1/readme.txt
[root@localhost ~]#
```

**步骤二：使用户zhangsan能够在/nsddir1/目录下创建/删除子目录（此题考查对目录w权限的理解）**

命令操作如下所示：

```shell
[root@localhost ~]# id zhangsan          //查看zhangsan用户是否存在
id: zhangsan：无此用户
[root@localhost ~]# useradd zhangsan    //创建zhangsan用户
[root@localhost ~]# ls -ld /nsddir1/    //查看nsddir1目录的权限
drwxr-xr-x. 2 root root 4096 2月  26 09:56 /nsddir1/
```

分析： 首先看zhangsan对于此目录具备有什么权限，zhangsan很明显属于其他人，权限对应为rx，要想让其能够创建、删除子目录，必须让其具备w权限

```shell
[root@localhost ~]# su – zhangsan                   //切换zhangsan用户测试
[zhangsan@localhost ~]$ mkdir /nsddir1/zhangdir    //测试是否有权限创建
mkdir: 无法创建目录"/nsddir1/zhangdir": 权限不够
[zhangsan@localhost ~]$exit
[root@localhost ~]# chmod o+w /nsddir1/             //为其他人添加W权限
[root@localhost ~]# ls -ld /nsddir1/                //查看是否添加成功
drwxr-xrwx. 2 root root 4096 2月  26 09:56 /nsddir1/
[root@localhost ~]# su – zhangsan                   //再次切换到zhangsan用户测试
[zhangsan@localhost ~]$ mkdir /nsddir1/zhangdir    //测试是否有权限创建
[zhangsan@localhost ~]$ ls /nsddir1/                //查看是否创建成功
readme.txt  zhangdir
[zhangsan@localhost ~]$
```

**步骤三：使用户zhangsan能够修改/nsddir1/readme.txt文件，调整/nsddir1/目录的权限，使任何用户都不能进入该目录，测试用户zhangsan是否还能修/nsddir1/readme.txt文件的内容。**

分析： 首先要解决zhangsan用户能够修改readme.txt内容

命令操作如下所示：

```shell
[root@localhost ~]# ls -ld /nsddir1/readme.txt      //查看readme.txt文件的权限
-rw-r--r--. 1 root root 0 2月  26 09:56 /nsddir1/readme.txt
```

分析： 首先看zhangsan对于此目录具备有什么权限，zhangsan很明显是其他人的权限是r权限，在想如何实现让zhangsan修改其内容，需加w权限

```shell
[root@localhost ~]# su – zhangsan                    //切换zhangsan用户测试
[zhangsan@localhost ~]$ echo 123 > /nsddir1/readme.txt   //测试是否有权限写入
-bash: /nsddir1/readme.txt: 权限不够
[zhangsan@localhost ~]$ exit
logout
[root@localhost ~]# chmod o+w /nsddir1/readme.txt        //添加w权限
[root@localhost ~]# ls -l /nsddir1/readme.txt            //查看是否添加成功
-rw-r--rw-. 1 root root 0 2月  26 09:56 /nsddir1/readme.txt
[root@localhost ~]# su – zhangsan                          //切换zhangsan用户测试
[zhangsan@localhost ~]$ echo 123 > /nsddir1/readme.txt   //测试是否有权限写入
[zhangsan@localhost ~]$ cat /nsddir1/readme.txt           //查看写入成功
123
```

分析： zhangsan能够修改readme.txt内容了。现在设置/nsddir1权限是任何人都不能进入该目录，只需将所有人的x执行权限去掉即可。

命令操作如下所示：

```shell
[root@localhost ~]# ls -ld /nsddir1/
drwxr-xr-x. 2 root root 4096 3月  31 11:38 /nsddir1/
[root@localhost ~]# chmod a-x /nsddir1/
[root@localhost ~]# ls -ld /nsddir1/
drw-r--r--. 2 root root 4096 3月  31 11:38 /nsddir1/
[root@localhost ~]# su - zhangsan
[zhangsan@localhost ~]$ cd /nsddir1/
-bash: cd: /nsddir1/: 权限不够
[zhangsan@localhost ~]$ echo 123 > /nsddir1/readme.txt   //zhangsan用户无权限修改
-bash: /nsddir1/readme.txt: 权限不够 
```

**步骤四：将/nsddir1/目录及其下所有内容的权限都设置为 rwxr-x---（本题主要考察选项-R，依然是利用chmod来完成）**

命令操作如下所示：

```shell
[root@localhost ~]# chmod -R 750 /nsddir1/           //-R为递归修改
[root@localhost ~]# ls -ld /nsddir1/                     //查看目录本身权限是否修改
drwxr-x---. 3 root root 4096 2月  26 16:00 /nsddir1/
[root@localhost ~]# ls -l /nsddir1/                 //查看子目录子文件权限是否修改
总用量 8
-rwxr-x---. 1 root     root        4 2月  26 16:14 readme.txt
drwxr-x---. 2 zhangsan zhangsan 4096 2月  26 16:00 zhangdir
```

# 2. 文件/目录的默认权限

## 2.1 问题

1）以用户root登入，测试umask掩码值

- 查看当前的umask值
- 新建目录udir1、文件ufile1，查看默认权限
- 将umask设为077，再新建目录udir2、文件ufile2，查看默认权限
- 请把umask值重新设置为022

2）以用户zhangsan登入，查看当前的umask值

3）请问为什么普通用户的家目录权限都是700

## 2.2 方案

本题的主要目的主要是让大家能够记住并理解umask值的作用，它决定着这个Shell环境创建文件以及目录的默认权限。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：以用户root登入，测试umask掩码值**

- 查看当前的umask值
- 新建目录udir1、文件ufile1，查看默认权限
- 将umask设为077，再新建目录udir2、文件ufile2，查看默认权限
- 请把umask值重新设置为022

命令操作如下所示：

```shell
[root@localhost ~]# whoami       //确保自己登录身份是root
root
[root@localhost ~]# umask        //查看当前umask值，需用最大权限777减去022
0022
[root@localhost ~]# umask –S     //另外一种查看方式，-S选项是直接显示默认权限
u=rwx,g=rx,o=rx
```

分析： 查看创建目录以及文件的默认权限，是否与umask一致，注意文件默认安全起见没有赋予x执行权限

```shell
[root@localhost ~]# mkdir /udir1        //创建测试目录
[root@localhost ~]# touch /ufile1       //创建测试文件
[root@localhost ~]# ls -ld /udir1/      //查看是否与umask值相符合
drwxr-xr-x. 2 root root 4096 2月  26 16:37 /udir1/
[root@localhost ~]# ls -l /ufile1        //查看是否与umask值相符合
-rw-r--r--. 1 root root 0 2月  26 16:37 /ufile1
[root@localhost ~]# umask 077            //更改umask值
[root@localhost ~]# umask                //查看是否修改成功
0077
[root@localhost ~]# umask –S             
u=rwx,g=,o=
[root@localhost ~]# mkdir /udir2         //创建测试目录
[root@localhost ~]# touch /ufile2        //创建测试文件
[root@localhost ~]# ls -ld /udir2        //查看是否与umask值相符合
drwx------. 2 root root 4096 2月  26 16:43 /udir2
[root@localhost ~]# ls -l /ufile2        //查看是否与umask值相符合
-rw-------. 1 root root 0 2月  26 16:44 /ufile2
[root@localhost ~]# umask 022             //更改umask值为022
[root@localhost ~]# umask                 //查看是否修改成功
0022
```

**步骤二：以用户zhangsan登入，查看当前的umask值（本题的目的主要是为了让大家知道管理员与普通用户的默认umask是不同的）**

命令操作如下所示：

```shell
[root@localhost ~]# umask    //查看root的umask值
0022
[root@localhost ~]# su – zhangsan   //切换zhangsan用户身份
[zhangsan@localhost ~]$ umask       //查看zhangsan的umask值
0002
```

**步骤三：请问为什么普通用户的家目录权限都是700**

分析： 本题主要考察，useradd这条命令在执行的时候，与那些默认配置文件相关，有两个配置文件分别为/etc/default/useradd、/etc/login.defs。

命令操作如下所示：

```shell
[root@localhost ~]# grep -v "^#" /etc/login.defs | grep -v "^$" | grep -i umask
UMASK           077       //此配置文件规定创建用户家目录时，需遵循的umask值
```

# 3. 设置归属关系

## 3.1 问题

1. 新建/tarena1目录
2. 将属主设为gelin01，属组设为tarena组
3. 使用户gelin01对此目录具有rwx权限，其他人对此目录无任何权限
4. 使用户gelin02能进入、查看/tarena1文件夹
5. 请将gelin01加入tarena组，并将tarena1目录权限设置为450，测试gelin01用户能否进入该目录

## 3.2 方案

大家要记得更改归属关系是利用chown命令来完成的，其中要特别注意的是此命令既可以更改所有者，也可以更改所属组。要分清所有者与所属组的位置，并以冒号或者点隔开。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：新建/tarena1目录**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir /tarena1
```

**步骤二：将属主设为gelin01，属组设为tarena组**

命令操作如下所示：

```shell
[root@localhost ~]# ls -ld /tarena1/                 //想查看归属关系
drwxr-xr-x. 2 root root 4096 2月  26 17:10 /tarena1/
[root@localhost ~]# id gelin01                        //检查是否有gelin01用户
id: gelin01：无此用户 
[root@localhost ~]# grep tarena /etc/group           //检查是否有tarena组
[root@localhost ~]#
[root@localhost ~]# useradd gelin01                   //创建用户gelin01
[root@localhost ~]# groupadd tarena                   //创建组tarena
[root@localhost ~]# id gelin01                         //检查是否创建成功
uid=501(gelin01) gid=501(gelin01) 组=501(gelin01)
[root@localhost ~]# grep tarena /etc/group            //检查是否创建成功
tarena:x:502:
[root@localhost ~]# chown gelin01:tarena /tarena1/   //更改其归属关系
[root@localhost ~]# ls -ld /tarena1/                  //查看是否更改成功
drwxr-xr-x. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
[root@localhost ~]#
```

**步骤三：使用户gelin01对此目录具有rwx权限，其他人对此目录无任何权限（更改时需注意对象要弄清，不要弄混）**

命令操作如下所示：

```shell
[root@localhost ~]# ls -ld /tarena1/        //查看其权限划分情况
drwxr-xr-x. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
```

分析：想要gelin01用户权限为rwx，那么首先看gelin01是属于哪一种归属关系。可以看出是所有者身份。

```shell
[root@localhost ~]# chmod u=rwx /tarena1/   //更改所有者权限为rwx
[root@localhost ~]# ls -ld /tarena1/         //查看是否更改成功
drwxr-xr-x. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
```

分析： 其他人无任何权限，利用命令chmod o= /tarena1/

```shell
[root@localhost ~]# ls -ld /tarena1/       //查看其权限划分情况
drwxr-xr-x. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
[root@localhost ~]# chmod o= /tarena1/     //更改权限o没有任何权限
[root@localhost ~]# ls -ld /tarena1/       //查看其权限划分情况
drwxr-x---. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
[root@localhost ~]#
```

**步骤四：使用户gelin02能进入、查看/tarena1文件夹**

命令操作如下所示：

```shell
[root@localhost ~]# ls -ld /tarena1/     //查看其权限划分情况
drwxr-x---. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
```

分析： 首先gelin02这个用户对于tarena1目录的归属关系，因属于其他人，如果想让其能够查看必须要有r权限，想要进入必须要有x权限。可能有同学会想到利用chmod o=rx /tarena1 命令来完成此题，但这样做与上题相违背，所以不可。我们可以换一种方式，我们可以看到此目录的所属组具备rx权限，所以我们可以把gelin02加入到tarena组里，才是此题的正解。

```shell
[root@localhost ~]# id gelin02                    //查看是否有gelin02用户
id: gelin02：无此用户
[root@localhost ~]# useradd gelin02               //创建gelin02用户
[root@localhost ~]# gpasswd -a gelin02 tarena    //将gelin02用户加入组tarena
Adding user gelin02 to group tarena
[root@localhost ~]# grep tarena /etc/group       //查看是否加入成功
tarena:x:502:gelin02
[root@localhost ~]# su - gelin02                  //切换身份测试
[gelin02@localhost ~]$ ls -l /tarena1/           //查看是否具备r权限
总用量 0
[gelin02@localhost ~]$ cd /tarena1/              //查看是否具备x权限
[gelin02@localhost tarena1]$ pwd
/tarena1
```

**步骤五：请将gelin01加入tarena组，并将tarena1目录权限设置为450，测试gelin01用户能否进入该目录**

命令操作如下所示：

```shell
[root@localhost ~]# grep tarena /etc/group       //查看该组成员列表
tarena:x:502:gelin02
[root@localhost ~]# gpasswd -a gelin01 tarena    //将gelin01用户加入tarena组
Adding user gelin01 to group tarena
[root@localhost ~]# grep tarena /etc/group       //查看该组成员列表是否加入成功
tarena:x:502:gelin02,gelin01
[root@localhost ~]# ls -ld /tarena1/              //查看其权限划分情况
drwxr-x---. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
[root@localhost ~]# chmod 450 /tarena1/           //更改权限
[root@localhost ~]# ls -ld /tarena1/              //查看其权限划分情况
dr--r-x---. 2 gelin01 tarena 4096 2月  26 17:10 /tarena1/
```

分析： 此时注意首先归属关系要清楚，gelin01是所有者而gelin01又属于tarena组，那接下来在看所有者权限是只读权限只有一个r权限，而所属组成员所具备的的是rx权限，这个时候我们要想一想了，现在权限发生不一致的情况，那么gelin01具备什么权限呢？是r还是rx。我们可以测试一下。

```shell
[root@localhost ~]# su - gelin01        //切换用户身份测试
[gelin01@localhost ~]$ ls /tarena1/     //查看是否具备r权限
[gelin01@localhost ~]$                   //可以看到具备r权限
[gelin01@localhost ~]$ cd /tarena1/     //能够切换成功说明是rx，否则是只读r权限
-bash: cd: /tarena1/: 权限不够
```

分析： 很明显不能够切换成功，是只读权限。这里告诉大家Linux对于权限判别的一个优先顺序，是所有者>所属组>其他人，也就是说首先Linux系统判别的是你属于本目录的归属关系的哪一种，首先看你是不是所有者，再看你是不是所属组，最后看你是不是其他人。就拿本题来举例，首先看gelin01是不是所有者，可以看出gelin01是所有者那么权限直接就按照所有者的权限执行，也不会再看后面。也不会所有者权限与所属组权限取交或并，本题目的是让大家记住和体会Linux对于权限判别的一个优先顺序。

# 4. SUID权限测试

## 4.1 问题

1. 将mkdir命令复制为/bin/mymd1，添加SUID
2. 以用户zhangsan登入，做下列测试：在其家目录下分别使用mkdir、mymd1命令尝试创建snew01、snew02
3. 查看snew01、snew02权限及归属关系

## 4.2 方案

SUID是Linux特殊权限的一种，能够用来传递可执行程序所有者的身份及具备所有者的权限。

注意事项：只针对可执行程序文件、可执行程序所有者必须具备可执行权限、显示占用的是所有者的x位置。

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：将mkdir命令复制为/bin/mymd1，添加SUID**

分析： 要想复制mkdir命令程序并改名，首先得找到该命令的绝对路径。可以利用which命令搜索。

```shell
[root@localhost ~]# which mkdir       //利用which找到mkdir命令的绝对路径
/bin/mkdir
[root@localhost ~]# cp /bin/mkdir /bin/mymd1    //复制并改名
[root@localhost ~]# ls -l /bin/mymd1             //查看是否生成mymd1
-rwxr-xr-x. 1 root root 49384 2月  27 10:34 /bin/mymd1
[root@localhost ~]# chmod u+s /bin/mymd1         //添加SUID权限
[root@localhost ~]# ls -l /bin/mymd1             //查看是否添加成功
-rwsr-xr-x. 1 root root 49384 2月  27 10:34 /bin/mymd1
```

**步骤二：以用户zhangsan登入，做下列测试：在其家目录下分别使用mkdir、mymd1命令尝试创建snew01、snew02**

```shell
[root@localhost ~]# id zhangsan             //查看zhangsan用户是否存在
uid=500(zhangsan) gid=500(zhangsan) 组=500(zhangsan)
[root@localhost ~]# su – zhangsan           //切换用户身份测试
[zhangsan@localhost ~]$ ls -l /bin/mkdir   //查看mkdir命令程序权限的划分
-rwxr-xr-x. 1 root root 49384 10月 17 2013 /bin/mkdir    //可以看到没有SUID
[zhangsan@localhost ~]$ mkdir snew01       //创建测试目录snew01
[zhangsan@localhost ~]$ ls -ld snew01/     //查看snew01权限及归属关系
drwxrwxr-x. 2 zhangsan zhangsan 4096 2月  27 10:40 snew01/  //属主与属组均是zhangsan
[zhangsan@localhost ~]$ ls -l /bin/mymd1   //查看mymd1命令程序权限的划分
-rwsr-xr-x. 1 root root 49384 2月  27 10:34 /bin/mymd1   //可以看到具备SUID
[zhangsan@localhost ~]$ mymd1 snew02        //创建测试目录snew02
[zhangsan@localhost ~]$ ls -ld snew02       //查看snew02权限及归属关系
drwxrwxr-x. 2 root zhangsan 4096 2月  27 10:47 snew02
```

分析： 可以看到归属关系中所有者发生变化，继承了mymd1命令程序的所有者root。

# 5. SGID权限测试

## 5.1 问题

1. 创建/nsdpublic目录，将属组改为tarena。
2. 新建子目录nsd01、子文件test01.txt，查看两者的权限及归属。
3. 为此目录添加SGID权限，再新建子目录nsd02、子文件test02.txt。
4. 查看上述子目录及文件的权限及归属。

## 5.2 方案

SGID是Linux特殊权限的一种，其作用主要体现如下：

1） 在一个具有SGID权限的目录下，新建的文档会自动继承此目录的属组身份。

注意事项：对可执行的程序/目录有效、可执行程序所属组必须具备可执行权限、显示占用的是所属组的x位置。

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建/nsdpublic目录，将属组改为tarena**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir /nsdpublic           //创建测试目录
[root@localhost ~]# ls -ld /nsdpublic/         //查看权限及归属关系
drwxr-xr-x. 2 root root 4096 2月  27 11:27 /nsdpublic/
[root@localhost ~]# grep tarena /etc/group    //查看tarena组是否存在
tarena:x:502:gelin02,gelin01
[root@localhost ~]# chown :tarena /nsdpublic/ //更改目录所属组为tarena组
[root@localhost ~]# ls -ld /nsdpublic/         //查看是否修改成功
drwxr-xr-x. 2 root tarena 4096 2月  27 11:27 /nsdpublic/
```

**步骤二：新建子目录nsd01、子文件test01.txt，查看两者的权限及归属**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir /nsdpublic/nsd01       //在nsdpublic目录下创建nsd01目录
[root@localhost ~]# touch /nsdpublic/test01.txt //在nsdpublic目录下创建测试文件
[root@localhost ~]# ls -l /nsdpublic/            //查看归属关系其属组均为root组
总用量 4
drwxr-xr-x. 2 root root 4096 2月  27 11:49 nsd01
-rw-r--r--. 1 root root    0 2月  27 11:50 test01.txt
```

**步骤三：为此目录添加SGID权限，再新建子目录nsd02、子文件test02.txt**

命令操作如下所示：

```shell
[root@localhost ~]# chmod g+s /nsdpublic/     //为nsdpublic添加SGID权限
[root@localhost ~]# ls -ld /nsdpublic/        //查看设置成功
drwxr-sr-x. 3 root tarena 4096 2月  27 11:50 /nsdpublic/
[root@localhost ~]# mkdir /nsdpublic/nsd02
[root@localhost ~]# touch /nsdpublic/test02.txt
[root@localhost ~]# ls -l /nsdpublic/          
总用量 8
drwxr-xr-x. 2 root root   4096 2月  27 11:49 nsd01
drwxr-sr-x. 2 root tarena 4096 2月  27 11:57 nsd02
-rw-r--r--. 1 root root      0 2月  27 11:50 test01.txt
-rw-r--r--. 1 root tarena    0 2月  27 11:57 test02.txt
```

分析： 可以看到当nsdpublic目录具备SGID权限时，之前创建的nsd01与test01.txt其所属组均为发生变化，但新创建的nsd02与test02.txt两者都继承的所属组身份及权限，其中还需注意的一点是我们也可以看到nsd02子目录也同样继承了SGID权限。

# 6. Sticky权限测试

## 6.1 问题

1. 为/tarena/public/目录设权限777，并添加粘滞位t权限
2. 以用户zhangsan登入，在/tarena/public/目录下创建文件zhsfile2
3. 以用户lisi登入，在/tarena/public/目录下创建文件lsfile2
4. 查看文件zhsfile2、lsfile2的权限和归属
5. 尝试删除zhsfile2、lsfile2文件

## 6.2 方案

Sticky权限是Linux特殊权限的一种，主要用来对公共目录的w权限进行限制。

注意事项：适用于目录，用来限制用户滥用写入权、其他人必须具备可执行权限、显示占用的是其他人的x位置。

## 6.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为/tarena/public/目录设权限777，并添加粘滞位**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir -p /tarena/public   //创建多级目录
[root@localhost ~]# ls -R /tarena              //递归查看目录结构
/tarena:
public
/tarena/public:
[root@localhost ~]# ls -ld /tarena/public      //查看权限的划分情况
drwxr-xr-x. 2 root root 4096 2月  27 14:47 /tarena/public/
[root@localhost ~]# chmod 777 /tarena/public  //设置权限为777
[root@localhost ~]# ls -ld /tarena/public      //查看设置结果
drwxrwxrwx. 2 root root 4096 2月  27 14:47 /tarena/public/
[root@localhost ~]# chmod o+t /tarena/public   //设置特殊权限t权限
[root@localhost ~]# ls -ld /tarena/public      //查看设置结果
drwxrwxrwt. 2 root root 4096 2月  27 14:47 /tarena/public/
[root@localhost ~]#
```

**步骤二：以用户zhangsan登入，在/tarena/public/目录下创建文件zhsfile2**

命令操作如下所示：

```shell
[root@localhost ~]# id zhangsan                //查看zhangsan用户是否存在
uid=500(zhangsan) gid=500(zhangsan) 组=500(zhangsan)
[root@localhost ~]# su – zhangsan              //切换用户身份测试
[zhangsan@localhost ~]$ touch /tarena/public/zhsfile2
[zhangsan@localhost ~]$ ls -l /tarena/public  //测试是否创建成功
总用量 0
-rw-rw-r--. 1 zhangsan zhangsan 0 2月  27 14:57 zhsfile2
[zhangsan@localhost ~]$
```

**步骤三：以用户lisi登入，在/tarena/public/目录下创建文件lsfile2**

命令操作如下所示：

```shell
[root@localhost ~]# id lisi                 //查看lisi用户是否存在
uid=503(lisi) gid=504(lisi) 组=504(lisi)
[root@localhost ~]# su – lisi               //切换用户身份
[lisi@localhost ~]$ touch /tarena/public/lsfile2   
[lisi@localhost ~]$ ls -l /tarena/public   //测试是否创建成功
总用量 0
-rw-rw-r--. 1 lisi     lisi     0 2月  27 15:03 lsfile2
-rw-rw-r--. 1 zhangsan zhangsan 0 2月  27 14:57 zhsfile2
[lisi@localhost ~]$
```

**步骤四：查看文件zhsfile2、lsfile2的权限和归属**

命令操作如下所示：

```shell
[lisi@localhost ~]$ ls -l /tarena/public/ 
总用量 0
-rw-rw-r--. 1 lisi     lisi     0 2月  27 15:03 lsfile2
-rw-rw-r--. 1 zhangsan zhangsan 0 2月  27 14:57 zhsfile2
[lisi@localhost ~]$
```

**步骤五：尝试删除zhsfile2、lsfile2文件（以lisi身份）**

命令操作如下所示：

```shell
[lisi@localhost ~]$ whoami                    //查看当前用户身份
Lisi
[lisi@localhost ~]$ ls -ld /tarena/public    //查看目录权限
drwxrwxrwt. 2 root root 4096 2月  27 15:07 /tarena/public/
[lisi@localhost ~]$ ls -l /tarena/public
总用量 0
-rw-rw-r--. 1 lisi     lisi     0 2月  27 15:03 lsfile2
-rw-rw-r--. 1 zhangsan zhangsan 0 2月  27 14:57 zhsfile2
[lisi@localhost ~]$ rm -rf /tarena/public/lsfile2    //删除lisi自己文件
[lisi@localhost ~]$ rm -rf /tarena/public/zhsfile2   //删除其他用户的文件
rm: 无法删除"/tarena/public/zhsfile2": 不允许的操作
```

# 7. 定义ACL控制策略

## 7.1 问题

1. 创建账户：mike、john、kaka
2. 创建文件：/data/file1.txt
3. mike对文件有读写权限，john只有读权限。其他用户没有任何权限
4. kaka具有与john相同权限
5. 创建lily用户，lily对file1.txt具有读执行权限，其他用户没有任何权限

## 7.2 方案

并不是所有的分区都支持ACL策略设置，后续会学习怎样让一个分区支持ACL。在安装系统时划分的分区默认是支持ACL策略的，而如果该分区是在安装系统之后创建的默认是不支持的。

ACL策略应用的情况是，当所有者、所属组、其他人三个归属关系，三种身份的权限都不能满足某个用户或组的权限设置。这个时候ACL可以为这个用户或组单独设置权限，使Linux权限划分设置更加灵活。

## 7.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建账户：mike、john、kaka**

命令操作如下所示：

```shell
[root@localhost ~]# useradd mike
[root@localhost ~]# useradd john
[root@localhost ~]# useradd kaka
```

**步骤二：创建文件：/data/file1.txt**

命令操作如下所示：

```shell
[root@localhost ~]# touch /data/file1.txt
[root@localhost ~]# ls -l /data/file1.txt
-rw-r--r--. 1 root root 0 2月  27 15:38 /data/file1.txt
```

**步骤三：mike对文件有读写权限，john只有读权限。其他用户没有任何权限**

分析： 此题涉及到三种不同的权限，我们可以这样来做，让mike来做所有者，让john属于此文件所属组成员，当然其他人就好说了直接设置即可。

命令操作如下所示：

```shell
 [root@localhost ~]# ls -l /data/file1.txt              //查看权限及归属关系
-rw-r--r--. 1 root root 0 2月  27 15:38 /data/file1.txt
[root@localhost ~]# chown mike:john /data/file1.txt    //更改所有者与所属组
[root@localhost ~]# ls -l /data/file1.txt               //查看更改结果
-rw-r--r--. 1 mike john 0 2月  27 15:38 /data/file1.txt
[root@localhost ~]# chmod o= /data/file1.txt            //设置权限，其他人无权限
[root@localhost ~]# ls -l /data/file1.txt               //查看呢设置结果
-rw-r-----. 1 mike john 0 2月  27 15:38 /data/file1.txt
[root@localhost ~]#
```

**步骤四：kaka具有与john相同权限**

分析： 我们可以把kaka加入到john组里面

命令操作如下所示：

```shell
[root@localhost ~]# id kaka                //查询kaka用户信息
uid=506(kaka) gid=507(kaka) 组=507(kaka)
[root@localhost ~]# gpasswd -a kaka john  //将kaka用户加入到john组
Adding user kaka to group john
[root@localhost ~]# id kaka                //查询kaka用户信息
uid=506(kaka) gid=507(kaka) 组=507(kaka),506(john)
[root@localhost ~]#
```

**步骤五：创建lily，lily对file1.txt具有读执行权限，其他用户没有任何权限**

分析： 这个时候就出现基本权限及归属关系不能解决，首先所有者已确定是mike，所属组权限rw所以也不行，最后其他人上面题有要求无任何权限。所以ACL策略就派上用场了。

命令操作如下所示：

```shell
[root@localhost ~]# echo 123456 > /data/file1.txt  //写入测试文字
[root@localhost ~]# cat /data/file1.txt             //管理员测试
123456
[root@localhost ~]# id lily                          //查询是否存在lily用户
id: lily：无此用户
[root@localhost ~]# useradd lily                     //创建lily用户
[root@localhost ~]# su – lily                        //切换用户身份
[lily@localhost ~]$ cat /data/file1.txt       //测试在没有设置ACL前lily能否查看
cat: /data/file1.txt: 权限不够
[lily@localhost ~]$ exit                              //退到root用户身份
logout
[root@localhost ~]# getfacl /data/file1.txt         //查看文件ACL策略
getfacl: Removing leading '/' from absolute path names
# file: data/file1.txt
# owner: mike
# group: john
user::rw-
group::r--
other::---
[root@localhost ~]# setfacl -m u:lily:r /data/file1.txt   //设置ACL策略
[root@localhost ~]# getfacl /data/file1.txt                //查看ACL策略
getfacl: Removing leading '/' from absolute path names
# file: data/file1.txt
# owner: mike
# group: john
user::rw-
user:lily:r--
group::r--
mask::r--
other::---
[root@localhost ~]# su – lily             //切换用户
[lily@localhost ~]$ cat /data/file1.txt  //测试是否具有r权限
123456
```

# Exercise

## 1 如何禁止用户harry对/opt/private目录有任何权限，但不影响其他用户对此目录的访问

```shell
[root@server0 ~]# mkdir  /opt/private
[root@server0 ~]# setfacl  -m  u:harry:-  /opt/private/
[root@server0 ~]# getfacl /opt/private/
getfacl: Removing leading '/' from absolute path names
# file: opt/private/
# owner: root
# group: root
user::rwx
user:harry:---                                     //确认结果
group::r-x
mask::r-x
other::r-x
```

## 2 新建目录/var/public，允许任何人写入，但禁止更改其他用户的文件

```shell
[root@server0 ~]# mkdir  /var/public
[root@server0 ~]# chmod  ugo=rwx  /var/public
[root@server0 ~]# chmod  o+t  /var/public
[root@server0 ~]# ls -ld /var/public/
drwxrwxrwt. 2 root root 6 Nov 26 00:11 /var/public/
```

## 3 新建目录新建/tarena目录使用户gelin01对此目录具有rwx权限，其他人对此目录无任何权限

```shell
[root@svr7 ~]# mkdir /tarena
[root@svr7 ~]# useradd gelin01
[root@svr7 ~]# ls -ld /tarena/
drwxr-xr-x. 2 root root 6 3月   3 14:39 /tarena/
[root@svr7 ~]# chown gelin01 /tarena/
[root@svr7 ~]# chmod o=--- /tarena/
[root@svr7 ~]# ls -ld /tarena/
drwxr-x---. 2 gelin01 root 6 3月   3 14:39 /tarena/
[root@svr7 ~]#
```

## 4 为lisi创建ACL访问权限，使得lisi可以查看/etc/shadow文件

```shell
[root@svr7 ~]# useradd lisi
[root@svr7 ~]# setfacl -m u:lisi:r /etc/shadow
[root@svr7 ~]# getfacl /etc/shadow
getfacl: Removing leading '/' from absolute path names
# file: etc/shadow
# owner: root
# group: root
user::---
user:lisi:r--
group::---
mask::r--
other::---

[root@svr7 ~]# su - lisi
[lisi@svr7 ~]$ cat /etc/shadow
root:$6$SEs4pO9FblvOFnNk$ZIMUYUpSjS9UQHPsscuNe/xYGYjMqxV/uFqRJVAi.nNJawAC05Ah8fwV.HVEF58yuhVRYKt4wOBEoqKsr1/ZX/::0:99999:7:::
bin:*:17632:0:99999:7:::
daemon:*:17632:0:99999:7:::
adm:*:17632:0:99999:7:::
lp:*:17632:0:99999:7:::
……
```


> 如有侵权，请联系作者删除



﻿@[TOC]( Basic USAGE of AWK & AWK application cases & comprehensive scripts | Cloud computing )

---

# 1 案例1：使用awk提取文本

## 1.1 问题

本案例要求使用awk工具完成下列过滤任务：

- 练习awk工具的基本用法
- 提取本机的网卡流量、根分区剩余容量、获取SSH远程失败的IP地址
- 格式化输出/etc/passwd文件中的用户名、UID、宿主目录信息

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：awk文本过滤的基本用法**

1）基本操作方法

格式：awk [选项] '[条件]{指令}' 文件

其中，print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。

Awk过滤数据时支持仅打印某一列，如第2列、第5列等。

处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。

直接过滤文件内容：

```shell
[root@svr5 ~]# cat test.txt 
hello the world
welcome to beijing
[root@svr5 ~]# awk '{print $1,$3}' test.txt        //打印文档第1列和第3列
hello world
welcome beijing
```

结合管道过滤命令输出：

```shell
[root@svr5 ~]# df -h | awk '{print $4}'        //打印磁盘的剩余空间
```

2）选项 -F 可指定分隔符

输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：

```shell
[root@svr5 ~]# awk -F: '{print $1,$7}' /etc/passwd
root /bin/bash
bin /sbin/nologin
daemon /sbin/nologin
adm /sbin/nologin
lp /sbin/nologin
… …
```

awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：

```shell
[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd
root bash
bin nologin
daemon nologin
adm sbin
… …
```

awk常用内置变量：
$0 文本当前行的全部内容
$1 文本的第1列
$2 文件的第2列
$3 文件的第3列，依此类推
NR 文件当前行的行号
NF 文件当前行的列数（有几列）

输出每次处理行的行号，以及当前行以“:”分隔的字段个数（有几列）：

```shell
[root@svr5 ~]# awk -F: '{print NR,NF}' passwd.txt
1 7
2 7
3 7
.. ..
```

2）awk的print指令不仅可以打印变量，还可以打印常量

```shell
[root@svr5 ~]# awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
root 的解释器: /bin/bash
bin 的解释器: /sbin/nologin
… …
```

**步骤二：利用awk提取本机的网络流量、根分区剩余容量、获取远程失败的IP地址**

1）提取IP地址

分步实现的思路及操作参考如下——

通过ifconfig eth0查看网卡信息，其中包括网卡流量：

```shell
[root@svr5 ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.21  netmask 255.255.255.0  broadcast 192.168.4.255
        inet6 fe80::fa64:c143:ad6a:5159  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:b3:11:11  txqueuelen 1000  (Ethernet)
        RX packets 313982  bytes 319665556 (304.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 51809  bytes 40788621 (38.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

RX为接收的数据量，TX为发送的数据量。packets以数据包的数量为单位，bytes以字节为单位：

```shell
[root@svr5 ~]# ifconfig eth0 | awk '/RX p/{print $5}'    //过滤接收数据的流量
319663094
[root@svr5 ~]# ifconfig eth0 | awk '/TX p/{print $5}'     //过滤发送数据的流量
40791683
```

2）提取根分区剩余容量

分步实现的思路及操作参考如下——

通过df命令查看根分区的使用情况，其中包括剩余容量：

```shell
[root@svr5 ~]# df -h /
文件系统             容量     已用     可用     已用%     挂载点
/dev/sda2         19G         7.2G     11G         40%         /
```

输出上述结果中最后一行的第4列：

```shell
[root@svr5 ~]# df -h / | tail -1 | awk '{print $4}'
11G
```

或者直接在awk中使用正则：

```shell
[root@svr5 ~]# df -h | awk '/\/$/{print $4}'
11G
```

3）根据/var/log/secure日志文件，过滤远程连接密码失败的IP地址

```shell
[root@svr5 ~]# awk '/Failed/{print $11}' /var/log/secure
192.168.2.254
192.168.2.100
... ...
```

**步骤三：格式化输出/etc/passwd文件**

1）awk处理的时机

awk会逐行处理文本，支持在处理第一行之前做一些准备工作，以及在处理完最后一行之后做一些总结性质的工作。在命令格式上分别体现如下：

```shell
awk  [选项]  '[条件]{指令}'  文件
awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
```

- BEGIN{ } 行前处理，读取文件内容前执行，指令执行1次
- { } 逐行处理，读取文件过程中执行，指令执行n次
- END{ } 行后处理，读取文件结束后执行，指令执行1次
  只做预处理的时候，可以没有操作文件，比如：

```shell
[root@svr5 ~]# awk 'BEGIN{A=24;print A*2}'
[root@svr5 ~]# awk 'BEGIN{print x+1}'           #x可以不定义，直接用，默认值位0
[root@svr5 ~]# awk 'BEGIN{print 3.2+3.5}'
```

举个例子（统计系统中使用bash作为登录Shell的用户总个数）：

a.预处理时赋值变量x=0
b.然后逐行读入/etc/passwd文件，如果发现登录Shell是/bin/bash则x加1
c.全部处理完毕后，输出x的值即可。相关操作及结果如下：

```shell
[root@svr5 ~]# awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd
29
```

2）格式化输出/etc/passwd文件

要求: 格式化输出passwd文件内容时，要求第一行为列表标题，中间打印用户的名称、UID、家目录信息，最后一行提示一共已处理文本的总行数，如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/31ec411a20184419a379693b0e166dcf.png)
图-1

3）根据实现思路编写、验证awk过滤语句

输出信息时，可以使用“\t”显示Tab制表位：

```shell
[root@svr5 ~]# awk -F: 'BEGIN{print "User\tUID\tHome"} \
                                {print $1 "\t"  $3  "\t"  $6}     \
                             END{print "Total",NR,"lines."}' /etc/passwd
User    UID     Home
root    0       /root
bin     1       /bin
daemon  2       /sbin
adm     3       /var/adm
lp      4       /var/spool/lpd
sync    5       /sbin
.. ..
Total 67 lines.
```

# 2. awk处理条件

## 2.1 问题

本案例要求使用awk工具完成下列过滤任务，注意awk处理条件的设置：

- 列出UID间于1~1000的用户详细信息
- 输出/etc/hosts文件内以127或192开头的记录
- 列出100以内整数中7的倍数或是含7的数

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：认识awk处理条件的设置**

1）使用正则设置条件

输出其中以bash结尾的完整记录：

```shell
[root@svr5 ~]# awk -F: '/bash$/{print}' /etc/passwd
root:x:0:0:root:/root:/bin/bash
```

输出包含root的行数据：

```shell
[root@svr5 ~]# awk -F: '/root/' /etc/passwd
```

输出root或adm账户的用户名和UID信息：

```shell
[root@svr5 ~]# awk -F: '/^(root|adm)/{print $1,$3}' /etc/passwd
root 0
adm 3
```

输出账户名称包含root的基本信息（第1列包含root）：

```shell
[root@svr5 ~]# awk -F: '$1~/root/' /etc/passwd
```

输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：

```shell
[root@svr5 ~]# awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
root /bin/bash
sync /bin/sync
shutdown /sbin/shutdown
```

2）使用数值/字符串比较设置条件

比较符号：==(等于) !=（不等于） >（大于）
\>=（大于等于） <（小于） <=（小于等于）

输出第3行（行号NR等于3）的用户记录：

```shell
[root@svr5 ~]# awk -F: 'NR==3{print}' /etc/passwd
```

输出账户UID大于等于1000的账户名称和UID信息：

```shell
[root@svr5 ~]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd
tom 1000
jerry 1001
```

输出账户UID小于10的账户名称和UID信息：

```shell
[root@svr5 ~]# awk -F: '$3<10{print $1,$3}' /etc/passwd
root 0
bin 1
daemon 2
adm 3
lp 4
sync 5
shutdown 6
halt 7
mail 8
```

输出用户名为“root”的行：

```shell
[root@svr5 ~]# awk -F: '$1=="root"' /etc/passwd
root:x:0:0:root:/root:/bin/bash
```

3）逻辑测试条件

输出账户UID大于10并且小于20的账户信息：

```shell
[root@svr5 ~]# awk -F: '$3>10 && $3<20' /etc/passwd
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
```

输出账户UID大于1000或者账户UID小于10的账户信息：

```shell
[root@svr5 ~]# awk -F: '$3>1000 || $3<10' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
varnish:x:1001:1001::/home/varnish:/sbin/nologin
nginx:x:1002:1002::/home/nginx:/sbin/nologin
```

4）数学运算

```shell
[root@svr5 ~]# awk 'BEGIN{x++;print x}'
1
[root@svr5 ~]# awk 'BEGIN{x=8;print x+=2}'
10
[root@svr5 ~]# awk 'BEGIN{x=8;x--;print x}'
7
[root@svr5 ~]# awk 'BEGIN{print 2+3}'
5
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{ print 23%8}'
7
[root@svr5 ~]# seq  200 | awk  '$1%3==0'       //找200以内3的倍数
… …
```

**步骤二：完成任务要求的awk过滤操作**

1）列出UID间于1~1000的用户详细信息：

```shell
[root@svr5 ~]# awk -F: '$3>=1 && $3<=1000' /etc/passwd
```

2）输出/etc/hosts映射文件内以127或者192开头的记录：

```shell
[root@svr5 ~]# awk  '/^(127|192)/' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
192.168.4.5  svr5.tarena.com svr5
```

3）列出100以内整数中7的倍数或是含7的数：

```shell
[root@svr5 ~]# seq 100 | awk '$1%7==0||$1~/7/'
7
14
17
21
27
28
35
37
42
47
.. ..
```

# 3. awk数组

## 3.1 问题

本案例要求了解awk数组的使用

**步骤一：awk数组**

1）数组的语法格式

数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。

```shell
[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
88 11
[root@svr5 ~]# awk 'BEGIN{a++;print a}'
1
[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
0 0
1 11
2 22
```

注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：

```shell
[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
11
```

# 4 案例4：awk扩展应用

## 4.1 问题

本案例要求使用awk工具完成下列两个任务：

分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名

## 4.2 方案

1）awk统计Web访问排名

在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。

通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最终就获得了这个IP地址出现的次数。

针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序升序排列，而-r表示反序，-k可以指定按第几个字段来排序。

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：统计Web访问量排名**

分步测试、验证效果如下所述。

1）提取IP地址及访问量

```shell
[root@svr5 ~]# awk '{ip[$1]++} \
>  END{for(i in ip) {print ip[i],i }}' /var/log/httpd/access_log
4  127.0.0.1
17 192.168.4.5
13 192.168.4.110
.. ..
```

2）对第1）步的结果根据访问量排名

```shell
[root@svr5 ~]# awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr
17 192.168.4.5
13 192.168.4.110
4 127.0.0.1
.. ..
```

# 5. 编写监控脚本

## 5.1 问题

本案例要求编写脚本，实现计算机各个性能数据监控的功能，具体监控项目要求如下：

> CPU负载
> 网卡流量
> 内存剩余容量
> 磁盘剩余容量
> 计算机账户数量
> 当前登录账户数量
> 计算机当前开启的进程数量
> 本机已安装的软件包数量

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备工作**

1）查看性能数据的命令

```shell
[root@svr5 ~]# uptime                            //查看CPU负载
[root@svr5 ~]# ifconfig eth0                    //查看网卡流量
[root@svr5 ~]# free                            //查看内存信息
[root@svr5 ~]# df                                //查看磁盘空间
[root@svr5 ~]# wc -l /etc/passwd                //查看计算机账户数量
[root@svr5 ~]# who |wc -l                        //查看登录账户数量
[root@svr5 ~]# rpm -qa |wc -l                    //查看已安装软件包数量
```

**步骤二：编写参考脚本**

1）脚本内容如下：

```shell
[root@svr5 ~]# vim test.sh
#!/bin/bash
ip=`ifconfig eth0 | awk '/inet /{print $2}'`
echo "本地IP地址是:"$ip
cpu=`uptime | awk '{print $NF}'`            
#awk中NF为当前行的列数，$NF是最后一列
echo "本机CPU最近15分钟的负载是:"$cpu
net_in=`ifconfig eth0 | awk '/RX p/{print $5}'`
echo "入站网卡流量为:"$net_in
net_out=`ifconfig eth0 | awk '/TX p/{print $5}'`
echo "出站网卡流量为:"$net_out
mem=`free | awk '/Mem/{print $4}'`
echo "内存剩余容量为:"$mem
disk=`df | awk '/\/$/{print $4}'`
echo "根分区剩余容量为:"$disk
user=`cat /etc/passwd |wc -l`
echo "本地账户数量为:"$user
login=`who | wc -l`
echo "当前登陆计算机的账户数量为:"$login
process=`ps aux | wc -l`
echo "当前计算机启动的进程数量为:"$process
soft=`rpm -qa | wc -l`
echo "当前计算机已安装的软件数量为:"$soft
```

# 6. 编写安全检测脚本

## 6.1 问题

本案例要求编写脚本，防止远程ssh暴力破解密码，具体监控项目要求如下：

检测ssh登录日志，如果远程登陆账号名错误3次，则屏蔽远程主机的IP

检测ssh登录日志，如果远程登陆密码错误3次，则屏蔽远程主机的IP

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备工作**

1）过滤帐户名失败的命令(登陆日志文件为/var/log/secure)

```shell
[root@svr5 ~]# awk '/Invalid user/{print $10}' /var/log/secure
```

2）过滤密码失败的命令

```shell
[root@svr5 ~]# awk '/Failed password/{print $11}' /var/log/secure
```

**步骤二：编写参考脚本**

1）脚本内容如下：

```shell
[root@svr5 ~]# vim test.sh
#!/bin/bash
awk '/Failed password/{print $11}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
awk '/Invalid user/{print $10}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
```


# Exercise

## 1 简述awk工具的基本语法格式。

- 格式1： awk [选项] ‘[条件]{处理动作}’ 文件列表
- 格式2： 命令 | awk [选项] ‘[条件]{处理动作}’

## 2 简述awk工具常用的内置变量、各自的作用。

- $n：即$1、$2、$3……，表示指定分隔的第几个字段
- $0：保存当前读入的整行文本内容
- NF：记录当前处理行的字段个数（列数）
- NR：记录当前已读入行的数量（行数）

## 3 awk处理文本时，读文件前、读取文件内容中、读文件后后这三个环节是如何表示的？

- BEGIN{ } 文件前处理：awk没有读入行之前 要执行的动作； 一般对数据作初始化操作，可以单独使用。
- { } 行处理：对awk读入的每一行进行处理，可以单独使用。
- END{ }文件后处理：awk 把所有的行都处理完后要执行的动作，一般输出数据处理的结果。可以单独使用。

## 4 提取当前eth0网卡的IPv4地址及掩码信息。

查看测试文本：

```shell
[root@svr5 ~]# ip add list eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:64:88:8e brd ff:ff:ff:ff:ff:ff
    inet 192.168.4.55/24 brd 192.168.4.255 scope global eth0
    inet 192.168.4.5/24 brd 192.168.4.255 scope global secondary eth0
    inet6 fe80::20c:29ff:fe64:888e/64 scope link 
       valid_lft forever preferred_lft forever
```

提取IPv4地址及掩码信息的操作及效果：

```shell
[root@svr5 ~]# ip add list eth0 | awk '/\<inet\>/{print $2}'
192.168.4.55/24
192.168.4.5/24
```

## 5 找出UID位于10~20之间的用户，输出用户名及对应的UID。

```shell
[root@svr5 ~]# awk -F: '$3>=10 && $3<=20{print $1":"$3}' /etc/passwd
uucp:10
operator:11
games:12
gopher:13
ftp:14 
```

## 6 利用awk工具统计使用bash作为解释器的用户数量。

使用NF内置变量找最后一列的内容，匹配bash即可让x+1：

```shell
[root@svr5 ~]# awk -F/ '$NF=="bash"{x++}END{print x}' /etc/passwd
```

## 7 在awk中是否可以使用数组，分别以什么构成？

可以使用数组，分别以 数组名、下标、值 三个部分构成

## 8 在linux中对文本的排序如何实现？

使用sort命令，比如abc.txt文本

另外还可以使用选项-n按数字升序排列 -k：针对指定的列进行排序 -r：反向排序

```shell
[root@svr5 ~]# sort –n abc.txt
```

> 如有侵权，请联系作者删除





﻿@[TOC]( Basic Web applications & BASIC NFS services & triggering mount | Cloud computing )

---

# 1 案例1：独立Web站点的快速部署

## 1.1 问题

本例要求为 http://server0.example.com 配置Web站点，要求如下：

1. 建立一个主页文件，将其重命名为 index.html
2. 将此文件拷贝到站点的 DocumentRoot 目录下
3. 使用 elinks 或firefox 浏览上述Web站点

## 1.2 方案

Web网站服务端：软件包httpd、系统服务httpd
Web网站浏览器：软件包elinks或fireox
传输协议及端口：TCP 80

Web网站服务端配置文件：

- /etc/httpd/conf/httpd.conf
- /etc/httpd/conf.d/*.conf

默认首页文件：index.html
httpd网站文档的默认根目录:/var/www/html

URL（Uniform Resource Locator，统一资源定位器）网址的基本组成：

```shell
http://服务器地址[:端口号]/目录/文件名
```

对于需要验证的FTP资源，还需要指定用户名密码信息：

```shell
ftp://用户名:密码@服务器地址[:端口号]/目录/文件名
```

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：构建及部署网站服务器**

1）安装软件包httpd

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@server0 ~]# yum  -y  install  httpd
.. ..
```

2）部署网页

```shell
[root@server0 ~]# cd  /var/www/html/                       //进入网页目录
[root@server0 html]#echo ‘Default Site.’ >  index.html                          
[root@server0 html]# cat  index.html                      //检查网页文件
Default Site.
```

3）启动系统服务httpd，并设置开机自启

```shell
[root@server0 html]# systemctl  restart  httpd
[root@server0 html]# systemctl  enable  httpd
ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.target.wants/httpd.service'
```

**步骤二：访问网站服务器**

1）使用elinks浏览器查看

Elinks浏览器可以在命令行模式显示出网页文本，经常用来测试网站的可用性。

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@desktop0 ~]# vim  /etc/hosts
.. ..
192.168.4.7 server0.example.com
[root@desktop0 ~]# yum  -y  install  elinks                      //安装elinks
.. ..
[root@desktop0 ~]# elinks  -dump  http://server0.example.com/     //访问指定网址
   Default Site.
```

2）使用firefox浏览器查看

Firefox浏览器支持更多网页特性，是访问复杂网页、网址的优秀工具。

在桌面终端直接运行“firefox http://server0.examle.com/”，或者通过菜单快捷方式打开Firefox浏览器再输入对应网址，都可以看到目标网页（如图-1所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5aeb9d64ce0b4ce0b904afbed49c3e5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

# 2. 虚拟Web主机的部署

## 2.1 问题

本例要求为虚拟机A扩展Web站点，新建虚拟主机 http://www0.example.com，具体要求如下：

1. 设置 DocumentRoot 为 /var/www/virtual
2. 建立主页文件，并重命名为 index.html
3. 将文件 index.html其放到此虚拟主机的 DocumentRoot 目录下
4. 确保站点 http://server0.example.com 仍然可用

## 2.2 方案

单一网站平台（比如172.25.0.11）：

- 多个域名 ---> 相同的网页内容
- 配置文件：/etc/httpd/conf/httpd.conf
- 网页目录定义：DocumentRoot /var/www/html

虚拟主机平台（比如172.25.0.11）：

- 在同一套httpd平台上跑很多个网站
- 多个域名 ---> 不同的网页内容
- 网页目录由<VirtualHost ...>区段配置定义

多个虚拟主机站点的典型设置（/etc/httpd/conf.d/*.conf）：

```shell
<VirtualHost *:80>
       ServerName  网站1的FQDN
       DocumentRoot  网站1的网页根目录
</VirtualHost>
<VirtualHost *:80>
       ServerName  网站2的FQDN
       DocumentRoot   网站2的网页根目录
</VirtualHost>
.. ..
```

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署网页文档**

1）建立网页目录

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@server0 ~]# mkdir  /var/www/virtual
```

2）部署网页文件

```shell
[root@server0 ~]# cd  /var/www/virtual/
[root@server0 virtual]# echo ‘Virtual Site.’  >  index.html
[root@server0 virtual]# cat  index.html                  //检查网页文件
Virtual Site.
```

**步骤二：配置虚拟主机 http://www0.example.com/**

1）为新站点创建独立的配置文件

```shell
[root@server0 virtual]# vim  /etc/httpd/conf.d/01-www0.conf
<VirtualHost  *:80>
        ServerName  www0.example.com
        DocumentRoot  /var/www/virtual
</VirtualHost>
[root@server0 virtual]# httpd  -t                              //确保语法检查OK
Syntax OK
```

2）重启系统服务httpd

```shell
[root@server0 virtual]# systemctl  restart  httpd
```

**步骤三：访问虚拟主机 http://www0.example.com/**

访问此虚拟站点，可以看到预期的网页内容：

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@desktop0 ~]# vim  /etc/hosts
.. ..
192.168.4.7 server0.example.com   www0.example.com
[root@desktop0 ~]# elinks  -dump  http://www0.example.com/
   Virtual Site.
```

**步骤四：完善原始站点 http://server0.example.com/**

需要注意的是，原始的独立站点可能出现异常，访问时并不是原始的网页：

```shell
[root@desktop0 ~]# elinks  -dump  http://server0.example.com/
   Virtual Site.
```

原因是一旦启用虚拟站点机制以后：

外部的 DocumentRoot、ServerName 会被忽略

- 第1个虚拟站点被视为默认站点，若客户机请求的URL不属于任何已知站点，则由第1个站点响应
- 若要解决此异常，需要将原始站点转换为第一个虚拟主机，启用顺序的设置可以通过文件名开头的数字来实现。

1）为原始站点建立虚拟主机配置

```shell
[root@server0 ~]# vim  /etc/httpd/conf.d/00-default.conf
<VirtualHost  *:80>
        ServerName  server0.example.com
        DocumentRoot  /var/www/html
</VirtualHost>
```

2）重启系统服务httpd

```shell
[root@server0 virtual]# systemctl  restart  httpd
```

3）访问两个虚拟站点，确保各自的网页内容正确

```shell
[root@desktop0 ~]# elinks  -dump  http://server0.example.com/
   Default Site.
[root@desktop0 ~]# elinks  -dump  http://www0.example.com/
   Virtual Site.
```

# 3. 普通NFS共享的实现

## 3.1 问题

本例要求在虚拟机A上配置NFS服务，完成以下任务：

1. 只读的方式共享目录 /public

然后在虚拟机 B上访问NFS共享目录

1. 将虚拟机A的 /public 挂到本地 /mnt/nfsmount
2. 这些文件系统在系统启动时自动挂载

## 3.2 方案

对于普通NFS共享来说：

- 服务端首先运行rpcbind服务，然后运行 nfs-server服务
- 客户端不需要运行特定的系统服务

配置NFS共享目录的记录格式：

```shell
文件夹绝对路径        客户地址1(ro或rw等控制参数)  客户地址2(ro或rw等控制参数) .. ..
```

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在虚拟机A上发布NFS共享目录**

1）准备需要共享的文件夹

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@server0 ~]# mkdir  /public
```

2）建立NFS共享配置

```shell
[root@server0 ~]# vim  /etc/exports
/public         *(ro)
```

3）启动系统服务nfs-server，并设置开机自启

```shell
[root@server0 ~]# systemctl  restart  rpcbind
[root@server0 ~]# systemctl  restart  nfs-server
[root@server0 ~]# systemctl  enable  nfs-server
ln -s '/usr/lib/systemd/system/nfs-server.service' '/etc/systemd/system/nfs.target.wants/nfs-server.service'
```

**步骤二：在虚拟机B上挂载NFS共享目录/public**

1）创建挂载点

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@desktop0 ~]# mkdir  /mnt/nfsmount
```

2）配置开机挂载虚拟机A的NFS共享目录/public

```shell
[root@desktop0 ~]# vim  /etc/fstab
.. ..
192.168.4.7:/public     /mnt/nfsmount   nfs     defaults,_netdev   0  0
```

3）测试挂载配置

```shell
[root@desktop0 ~]# mount  -a
[root@desktop0 ~]# df  -hT  /mnt/nfsmount/
Filesystem                  Type  Size  Used Avail Use% Mounted on
server0.example.com:/public nfs4   10G  3.2G  6.8G  32% /mnt/nfsmount
```

# 4. autofs触发挂载

## 4.1 问题

1. 在虚拟机A上配置NFS服务
2. 只读的方式共享目录 /tedu，只能被192.168.4.0/24的系统访问
3. 在虚拟机B上访问NFS共享目录
4. 将虚拟机A 的 /tedu 完成触发挂载到本地 /mnt/nfsauto

## 4.2 方案

autofs触发挂载是一个服务，要想使用这个服务，要确保系统安装了此服务和开启此服务。autofs之所以可以达到触发挂载，原因是它具有两个配置文件：

- 主配置文件 /etc/auto.master，记录“监控点目录、挂载配置文件的路径”
- 挂载配置文件，比如 /etc/auto.misc，记录“挂载点子目录 -挂载参数 :设备名”

更改配置文件后需重启autofs服务生效。

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：虚拟机A配置NFS服务**

命令操作如下所示：

1）准备需要共享的文件夹

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@server0 ~]# mkdir  /tedu
```

2）建立NFS共享配置

```shell
[root@server0 ~]# vim  /etc/exports
/public         *(ro)
/tedu          192.168.4.0/24(ro)
```

3）启动系统服务nfs-server，并设置开机自启

```shell
[root@server0 ~]# systemctl  restart  rpcbind
[root@server0 ~]# systemctl  restart  nfs-server
[root@server0 ~]# systemctl  enable  nfs-server
ln -s '/usr/lib/systemd/system/nfs-server.service' '/etc/systemd/system/nfs.target.wants/nfs-server.service'
```

**步骤二：虚拟机B配置一个触发挂载服务：**

在/etc/auto.master主配置文件

命令操作如下所示：

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@localhost /]# vim /etc/auto.master
/misc   /etc/auto.misc         //此句话原本已存在无需更改
/mnt    /etc/myauto
[root@localhost /]#
```

在/etc/myauto挂载配置文件中，定义挂载设备、参数、挂载点。挂载设备为/dev/sdb5

命令操作如下所示：

```shell
[root@localhost /]# vim /etc/myauto
[root@localhost /]# grep tools /etc/auto.misc 
nfsauto           -fstype=nfs    192.168.4.7:/tedu
[root@localhost /]# service autofs restart     //重启autofs服务
[root@localhost /]# ls /mnt/
[root@localhost /]# ls /mnt/nfsauto              //访问触发挂载点
lost+found
[root@localhost /]# mount | grep nfsauto          //查看结果
```

# Exercise

## 1 简述HTTP、HTML的含义及作用

HTTP指的是Hyper Text Transfer Protocol，超文本传输协议，主要为网站服务器程序与浏览器之间传输网页定义相关的标准。

HTML指的是Hyper Text Markup Language，超文本标记语言，是静态网页文件的标记规范。

## 2 已知Web站点server0的网页目录位于/var/www/html，那么对应与网址http://server0/private/的服务端文件是什么

URL网址的/对应Web服务端上DocumentRoot指定的网页目录，其后的URL路径也对应到服务端网页目录下的子目录；当未指定网页文件名时，默认首页为index.html。

因此，此题对应的服务端文件应该是/var/www/html/private/index.html。

## 3 简述实现基于域名的多个虚拟Web主机时基本的配置内容

```shell
[root@server0 ~]# /etc/httpd/conf.d/httpd.conf
.. ..
<VirtualHost  IP地址:端口>
       ServerName  站点1的DNS名称
       DocumentRoot  站点1的网页根目录
</VirtualHost>
<VirtualHost  IP地址:端口>
       ServerName  站点2的DNS名称
       DocumentRoot  站点2的网页根目录
</VirtualHost>
.. ..
```

## 4 在服务器server0上通过NFS共享/usr/src目录，允许任何人访问

```shell
[root@server0 ~]# vim  /etc/exports 
/usr/src        *(ro)
.. ..
[root@server0 ~]# systemctl  restart  nfs-server
```

## 5 在启用SELinux保护的情况下，如何允许httpd开启8909端口

```shell
[root@server0 ~]# semanage  port  -a  -t  http_port_t  -p tcp  8909
.. ..
[root@server0 ~]# semanage  port  -l  |  grep  http_port          //确认结果
http_port_t     tcp      8909,80, 81, 443, 488, 8008, 8009, 8443, 9000 
.. ..
```

> 如有侵权，请联系作者删除





﻿@[TOC]( Batch installation environment & PXE boot configuration & Kickstart auto answer & Cobbler installation platform | Cloud computing )

---

# 1 案例1：配置并验证DHCP服务

## 1.1 问题

本例要求为PXE客户机提供地址分配服务，在主机 svr7 上搭建支持PXE的DHCP服务器，提供的地址参数如下：

- IP地址范围 192.168.4.10~200/24
- PXE引导服务器位于 192.168.4.7、引导文件 pxelinux.0

然后在主机 pc207 上使用dhclient命令测试 DHCP地址分配服务。

## 1.2 方案

DHCP地址分配的四次会话：DISCOVERY --> OFFER --> REQUEST -->ACK 。

DHCP服务器基本概念：

- DHCP租期：允许客户机租用IP地址的时间期限，单位为秒
- DHCP作用域：分配给客户机的IP地址所在的网段
- DHCP地址池：用来动态分配的IP地址的范围

DHCP服务端：软件包dhcp、系统服务dhcpd
DHCP服务端配置文件：/etc/dhcp/dhcpd.conf

传输协议及端口：UDP 67（服务器）、UDP 68（客户端）

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置DHCP服务端**

1）安装dhcp软件包

```shell
[root@svr7 ~]# yum  -y  install  dhcp
.. ..
```

2）建立dhcpd.conf服务配置

```shell
[root@svr7 ~]# vim  /etc/dhcp/dhcpd.conf
subnet 192.168.4.0 netmask 255.255.255.0 {
     range  192.168.4.10 192.168.4.200;
     next-server  192.168.4.7;
     filename  "pxelinux.0";
}
```

3）启动系统服务dhcpd，并设置开机自启

```shell
[root@svr7 ~]# systemctl  restart  dhcpd
[root@svr7 ~]# systemctl  enable  dhcpd
Created symlink from /etc/systemd/system/multi-user.target.wants/dhcpd.service to /usr/lib/systemd/system/dhcpd.service.
```

4）确认dhcpd服务状态

```shell
[root@svr7 ~]# netstat  -anptu  |  grep  dhcpd
udp        0      0 0.0.0.0:67              0.0.0.0:*                           58693/dhcpd         
.. ..
```

**步骤二：在客户端测试DHCP服务**

1）使用dhclient命令测试，观察获取IP地址的过程

```shell
[root@pc207 ~]# dhclient  -d  eth0
Internet Systems Consortium DHCP Client 4.2.5
Copyright 2004-2013 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
.. ..
DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 7 (xid=0x6707682f)
DHCPREQUEST on eth0 to 255.255.255.255 port 67 (xid=0x6707682f)
DHCPOFFER from 192.168.4.7
DHCPACK from 192.168.4.7 (xid=0x6707682f)
bound to 192.168.4.10 -- renewal in 18008 seconds.
^C                                   //按Ctrl+c键退出测试
```

2）若因操作异常导致IP故障，可恢复客户机原有IP配置

```shell
[root@pc207 ~]# pkill  -9  dhclient                      //杀死dhclient进程
[root@pc207 ~]# nmcli  connection  up  eth0              //激活原配置
.. ..
```

# 2. PXE基础装机环境

## 2.1 问题

本例要求为后续的PXE服务器构建提供Linux软件仓库，完成下列任务：

1. 部署Web目录/var/www/html/dvd
2. 挂载Linux光盘镜像文件到该目录
3. 访问 http://192.168.4.7/dvd测试，确保可用

## 2.2 方案

PXE网络装机的整体思路 —— 装机条件准备：

- 准备CentOS7安装源（HTTP方式YUM库）
- 启用DHCP服务

PXE网络装机的整体思路 —— PXE引导配置：

- 启用TFTP服务，提供装机用的内核、初始化文件
- 提供PXE引导程序、配置启动菜单

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：通过 HTTP 方式发布CentOS7软件源**

1）快速构建httpd服务器（若已构建，此步可跳过）

```shell
[root@room9pc13 ~]# yum  -y  install  httpd          //装包
[root@room9pc13 ~]# systemctl  restart  httpd         //启动服务
[root@room9pc13 ~]# systemctl  enable  httpd          //设置开机自启
```

2）准备yum仓库，部署到Web子目录

```shell
[root@room9pc13 ~]# mkdir  /var/www/html/dvd      //建挂载点
[root@room9pc13 ~]# vim  /etc/fstab
.. ..
/dev/cdrom  /var/www/html/dvd  iso9660  defaults  0  0
[root@room9pc13 ~]# mount  -a                         
[root@room9pc13 ~]# ls  /var/www/html/dvd/         //确认部署位置
```

**步骤二：确保yum仓库HTTP资源可用**

从浏览器访问http://192.168.4.7/dvd/，可看到仓库资源。

# 3. 配置PXE引导

## 3.1 问题

本例要求为PXE装机提供引导服务，并提供必要的素材，完成下列任务：

1. 启用TFTP服务器，部署引导文件（内核vmlinuz、初始文件initrd.img、网卡启动程序pxelinux.0）
2. 创建pxelinux.cfg/配置目录，在此目录下建立默认引导文件default

## 3.2 方案

TFTP，Trivial File Transfer Protocol：简单文件传输协议，通过UDP 69端口提供小文件的传输服务，默认应将资源部署到/var/lib/tftpboot目录下，不支持认证和目录访问等复杂FTP操作。

网卡启动程序pxelinux.0由软件包syslinux提供。

PXE安装用的内核及初始化文件可从CentOS7的光盘目录/images/pxeboot/下提取。

PXE启动配置相关资料可参考CentOS7的光盘目录/isolinux/，其中包括图形支持模块vesamenu.c32、背景图片spash.png、菜单配置文件isolinux.cfg（使用时改名为default）。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：快速构建TFTP服务器**

1）安装tftp-server软件包

```shell
[root@svr7 ~]# yum -y install tftp-server 
.. ..
```

2）启动系统服务tftp，并设置开机自启

```shell
[root@svr7 ~]# systemctl  restart  tftp
```

**步骤二：部署启动文件**

1）拷贝pxelinux.0程序，部署到TFTP目录

在软件包syslinux提供的目录下找到pxelinux.0程序

```shell
[root@svr7 ~]# yum  -y  install  syslinux
[root@svr7 ~]# rpm  -ql  syslinux  |  grep pxelinux.0
/usr/share/syslinux/gpxelinux.0
/usr/share/syslinux/pxelinux.0
```

将其拷贝到/var/lib/tftpboot/目录下，确认部署结果：

```shell
[root@svr7 ~]# cp  /usr/share/syslinux/pxelinux.0  /var/lib/tftpboot/
[root@svr7 ~]# ls  /var/lib/tftpboot/
pxelinux.0
```

2）拷贝引导装机的内核、初始镜像，部署到TFTP目录

当文件较多时，可以在TFTP目录下创建子目录：

```shell
[root@svr7 ~]# mkdir  /var/lib/tftpboot/CentOS7
```

再通过CentOS7光盘目录找到PXE版内核vmlinuz、初始镜像initrd.img，将其拷贝到上述子目录：

```shell
[root@svr7 ~]# cd  /var/lib/tftpboot/CentOS7/
[root@svr7 CentOS7]# wget  http://192.168.4.7/dvd/isolinux/vmlinuz
[root@svr7 CentOS7]# wget  http://192.168.4.7/dvd/isolinux/initrd.img
                                              //下载内核、初始化文件
```

确认部署结果：

```shell
[root@svr7 pxeboot]# ls  -R  /var/lib/tftpboot/
/var/lib/tftpboot/:
pxelinux.0  CentOS7
/var/lib/tftpboot/CentOS7:
initrd.img  vmlinuz
```

**步骤三：配置启动菜单**

1）创建配置目录

```shell
[root@svr7 ~]# mkdir  /var/lib/tftpboot/pxelinux.cfg
```

2）以光盘中的isolinux目录为模板，拷贝必要的文件

```shell
[root@svr7 ~]# cd  /var/lib/tftpboot/
[root@svr7 tftpboot]# wget  http://192.168.4.7/dvd/isolinux/vesamenu.c32 
                                                      //提供图形支持
[root@svr7 tftpboot]# wget  http://192.168.4.7/dvd/isolinux/splash.png  
                                                            //准备背景图片
[root@svr7 tftpboot]# wget  -O  pxelinux.cfg/default  http://192.168.4.7/dvd/isolinux/isolinux.cfg 
                                                         //建立菜单配置
[root@svr7 isolinux]# ls  -R  /var/lib/tftpboot/          //确认部署结果
/var/lib/tftpboot/:
pxelinux.0  pxelinux.cfg  CentOS7  splash.png  vesamenu.c32
/var/lib/tftpboot/pxelinux.cfg:
default
/var/lib/tftpboot/CentOS7:
initrd.img  vmlinuz
```

3）调整启动参数

```shell
[root@svr7 ~]# vim  /var/lib/tftpboot/pxelinux.cfg/default
default vesamenu.c32                              //默认交给图形模块处理
timeout 600                                      //选择限时为60秒（单位1/10秒）
.. ..
menu title  PXE  Installation  Server             //启动菜单标题信息
.. ..
label  linux                                  //菜单项标签
    menu  label  ^Install CentOS7 Linux 7
    kernel  CentOS7/vmlinuz                      //内核的位置
    append  initrd=CentOS7/initrd.img  
                                                 //初始镜像、安装源位置
label local                                     //从硬盘启动
    menu  default                              //默认启动方式
    menu label Boot from ^local drive
    localboot 0xffff
menu  end
```

**步骤四：访问TFTP服务端确保可用**

1）在pc207上安装tftp命令工具

```shell
[root@pc207 ~]# yum  -y  install  tftp
.. ..
```

2）在pc207上访问svr7上的TFTP服务端，下载文件测试

```shell
[root@pc207 ~]# tftp  192.168.4.7  -c  get pxelinux.0
[root@pc207 ~]# ls  -lh  pxelinux.0                      //检查下载结果
-rw-r--r--. 1 root root 27K 1月  13 15:48 pxelinux.0
```

# 4. PXE+kickstart自动装机

## 4.1 问题

本例要求在PXE服务器上为CentOS7客户机准备ks应答文件，完成下列任务：

1. 实现全自动的安装及配置
2. 能够自动配好YUM仓库

然后在客户机上验证PXE+kickstart全自动装机过程：

1. 再次将测试客户机从PXE启动并安装
2. 完成后，重启客户机并验证结果

## 4.2 方案

使用图形配置工具system-config-kickstart来生成应答文件

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备应答文件**

找一台CentOS7系统的模板虚拟机，使用配置工具生成应答文件。

1）在模板机上安装system-config-kickstart软件包

```shell
[root@svr7 ~]# yum  -y  install  system-config-kickstart
.. ..
```

2）调整模板机的yum仓库设置

清理掉无关的yum源，只保留为客户机安装CentOS7系统所必要的yum源，并且将源的ID修改为development。

```shell
[root@svr7 ~]# vim  /etc/yum.repos.d/dvd.repo
[development]
name = CentOS Linux 7
baseurl = http://192.168.4.7/dvd
gpgcheck = 0
```

3）运行system-config-kickstart工具，创建应答文件

在支持图形程序的环境运行system-config-kickstart，即可打开该配置工具（如图-5所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d51f785b3587496c8b68c5804addc4f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

通过“文件”菜单打开/root/anaconda-ks.cfg文件，作为应答配置模板，这样可以节省很多时间（如图-6所示）。根据需要确认默认语言、时区，设置根口令、磁盘分区规划等基本信息。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c53101536b9840adafc2b656e8752a22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

在安装方法部分，选择“执行新安装”，并正确设置HTTP安装源的访问地址信息（如图-7所示）。

/

图-7

在分区信息部分，选择清除主引导记录、删除所有现存分区、初始化磁盘标签，并手动添加/boot 200MB、SWAP分区 2000MB、/分区 所有剩余空间（如图-8所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3c6fe26ac91c411193433b12b8158d97.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

在网络配置部分，确认已添加第一块网卡，设为DHCP自动获取（如图-9所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1ac7e9774942dea8b30965c4617007.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-9

在防火墙配置部分，禁用SELinux、禁用防火墙（如图-10所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5fe95055870b46998573e7782bc7f835.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-10

在软件包选择部分，根据客户机的实际需要定制。比如若要使用图形桌面环境，建议将GNOME相关的包勾选上（如图-11所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/698bf12a47774848aeb3c1f23ddaec47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-11

确认上述调整后，通过“文件”菜单将其保存为/root/ks.cfg。

4）应答文件微调整

删除掉随模板机配置残留的不可用仓库记录（比如以repo --name开头的Server-HighAvailability、Server-ResilientStorage、autopart等行）

```shell
[root@svr7 ~]# vim  /root/ks.cfg
install                                                  //安装基本信息设置
xconfig  --startxonboot
keyboard --vckeymap=cn --xlayouts='cn'
rootpw --iscrypted $1$.48kBNVL$e.Ym0L/RzkJonYwbg9Brq1
timezone Asia/Shanghai
url --url="http://192.168.4.254/dvd"                  //安装源设置
lang zh_CN
firewall --disabled
#repo --name="Server-HighAvailability" --baseurl=file:///run/install/repo/addons/HighAvailability
#repo --name="Server-ResilientStorage" --baseurl=file:///run/install/repo/addons/ResilientStorage
#autopart --type=lvm                                      //分区设置
zerombr
clearpart --all --initlabel
part /boot --fstype="xfs" --size=200
part swap --fstype="swap" --size=2000
part / --fstype="xfs" --grow --size=1
.. ..
%post --interpreter=/bin/bash                          //安装后脚本设置
%end
%packages                                              //软件包设置
@^graphical-server-environment
@base
@core
@desktop-debugging
@development
.. ..
initial-setup
initial-setup-gui
-NetworkManager
-NetworkManager-team
.. ..
%end
```

**步骤二：部署应答文件**

1）将应答文件部署在客户机可访问的位置

部署并确认文件：

```shell
[root@room9pc13 ~]# cp  /root/ks.cfg  /var/www/html/
[root@room9pc13 ~]# ls  -lh  /var/www/html/ks.cfg          //检查部署的文件
-rw-r--r--. 1 root root 4.5K 1月  13 20:20 /var/www/html/ks.cfg
```

在客户端下载应答文件，确保可访问：

```shell
[root@pc207 ~]# wget  http://192.168.4.7/ks.cfg
.. ..
2017-01-13 20:22:19 (183 MB/s) - “ks.cfg” 已保存 [4508] 
[root@pc207 ~]# ls  -lh  ks.cfg                 //检查下载的文件
-rw-r--r--. 1 root root 4.5K 1月  13 20:22 ks.cfg
```

2）在PXE服务器上修改default引导配置，调用应答文件

找到相应的label启动项，在append后添加ks=应答文件地址，去掉原有的inst.stage2参数设置：

```shell
[root@svr7 ~]# vim  /var/lib/tftpboot/pxelinux.cfg/default
.. ..
label linux
    menu label ^Install CentOS7 Linux 7
    kernel CentOS7/vmlinuz
    append initrd=CentOS7/initrd.img ks=http://192.168.4.7/ks.cfg 
.. ..
```

**步骤三：验证PXE+kickstart自动应答**

1）新建一台虚拟机裸机，确认支持PXE网卡启动

新建一台虚拟机裸机，注意以下事项：将内存设为2G、硬盘设为20G；网络类型要与pxesverver服务器的相同，比如选择vmnet1。

2）启动虚拟机裸机，验证PXE网络安装过程

正常PXE引导，选择第一个启动项回车确认即快速进入全自动安装，后续过程基本无需人工干预（如图-13所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c64feab1e5e246d7b9c919b3af90f058.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-13


# Exercise

## 1 简述DHCP租期、作用域、地址池的含义

租期：允许客户机租用IP地址的时间期限，单位为秒
作用域：分配给客户机的IP地址所在的网段
地址池：用来动态分配的IP地址的范围

## 2 为了指引客户机访问PXE服务器，对应的DHCP配置是什么

需要告知客户机TFTP引导服务器的地址、需要下载的启动文件名：

```shell
next-server  192.168.4.7;          //PXE引导服务器
filename  "pxelinux.0";             //引导文件名
```

## 3 PXE服务器提供vmlinuz和initrd.img文件的作用分别是什么

vmlinuz：为将要安装的客户机系统提供引导，并加载安装程序；

initrd.img：为在客户机上加载并运行vmlinuz内核提供临时的Linux环境。

## 4 简要说明PXE装机引导的基本过程

1. 客户端向DHCP服务器请求分配IP地址；
2. DHCP服务器为客户端分配IP地址，告知Boot server；
3. 客户端向Boot server请求下载启动文件；
4. Boot server向客户端提供启动文件；
5. 客户端向文件共享服务器请求应答文件；
6. 客户端根据应答文件信息，安装操作系统。

## 5 使用system-config-kickstart工具时需要注意什么

注意事项：

1）运行此工具的客户机最好与将要安装的客户机使用相同的操作系统。

2）仅配置对应的YUM源，源ID设为 development。

3）可以加载应答文件模板/root/anaconda-ks.cfg再修改，提高效率。

> 如有侵权，请联系作者删除





﻿@[TOC]( Big data and Hadoop & distributed file systems & distributed Hadoop clusters | Cloud computing )

---

# 1. 部署Hadoop

## 1.1 问题

本案例要求安装单机模式Hadoop：

- 热词分析：
- 最低配置：2cpu，2G内存，10G硬盘
- 虚拟机IP：192.168.1.50 hadoop1
- 安装部署 hadoop
- 数据分析，查找出现次数最多的单词

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备**

1）配置主机名为hadoop1，ip为192.168.1.50，配置yum源（系统源）

备注：由于在之前的案例中这些都已经做过，这里不再重复，不会的学员可以参考之前的案例

2）安装java环境

```shell
[root@hadoop1 ~]# yum -y install java-1.8.0-openjdk-devel
[root@hadoop1 ~]# java -version
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-b12)
OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)
[root@hadoop1 ~]# jps
1235 Jps
```

3）安装hadoop

```shell
[root@hadoop1 ~]# cd hadoop/
[root@hadoop1 hadoop]# ls
hadoop-2.7.7.tar.gz  kafka_2.12-2.1.0.tgz  zookeeper-3.4.13.tar.gz
[root@hadoop1 hadoop]# tar -xf hadoop-2.7.7.tar.gz 
[root@hadoop1 hadoop]# mv hadoop-2.7.7 /usr/local/hadoop
[root@hadoop1 hadoop]# cd /usr/local/hadoop
[root@hadoop1 hadoop]# ls
bin  include  libexec      NOTICE.txt  sbin
etc  lib      LICENSE.txt  README.txt  share
[root@hadoop1 hadoop]# ./bin/hadoop   //报错，JAVA_HOME没有找到
Error: JAVA_HOME is not set and could not be found.
[root@hadoop1 hadoop]#
```

4）解决报错问题

```shell
[root@hadoop1 hadoop]# rpm -ql java-1.8.0-openjdk
[root@hadoop1 hadoop]# cd ./etc/hadoop/
[root@hadoop1 hadoop]# vim hadoop-env.sh
25 export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64    /jre"
33 export HADOOP_CONF_DIR="/usr/local/hadoop/etc/hadoop"
[root@hadoop1 ~]# cd /usr/local/hadoop/
[root@hadoop1 hadoop]# ./bin/hadoop
Usage: hadoop [--config confdir] [COMMAND | CLASSNAME]
  CLASSNAME            run the class named CLASSNAME
 or
  where COMMAND is one of:
  fs                   run a generic filesystem user client
  version              print the version
  jar <jar>            run a jar file
                       note: please use "yarn jar" to launch
                             YARN applications, not this command.
  checknative [-a|-h]  check native hadoop and compression libraries availability
  distcp <srcurl> <desturl> copy file or directories recursively
  archive -archiveName NAME -p <parent path> <src>* <dest> create a hadoop archive
  classpath            prints the class path needed to get the
  credential           interact with credential providers
                       Hadoop jar and the required libraries
  daemonlog            get/set the log level for each daemon
  trace                view and modify Hadoop tracing settings
Most commands print help when invoked w/o parameters.
```

5)词频统计

```shell
[root@hadoop1 hadoop]# mkdir /usr/local/hadoop/input
[root@hadoop1 hadoop]# ls
bin  etc  include  lib  libexec  LICENSE.txt  NOTICE.txt  input  README.txt  sbin  share
[root@hadoop1 hadoop]# cp *.txt /usr/local/hadoop/input
[root@hadoop1 hadoop]# ./bin/hadoop jar  \
 share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar  wordcount input output        //wordcount为参数 统计input这个文件夹，存到output这个文件里面（这个文件不能存在，要是存在会报错，是为了防止数据覆盖）
[root@hadoop1 hadoop]#  cat   output/part-r-00000    //查看
```



# 2. 准备集群环境

## 2.1 问题

本案例要求：

- 准备集群环境
- 最低配置：2CPU，2G内存，10G硬盘
- 虚拟机IP：
- 192.168.1.50 hadoop1
- 192.168.1.51 node-0001
- 192.168.1.52 node-0002
- 192.168.1.53 node-0003
- 要求：禁用selinux、禁用firewalld (所有主机)
- 安装java-1.8.0-openjdk-devel，并配置 /etc/hosts(所有主机)
- 设置hadoop1 免密登录其他主机、并不用输入 yes
- 使所有节点能够ping通，配置SSH信任关系
- 节点验证

## 2.2 方案

准备四台虚拟机，由于之前已经准备过一台，所以只需再准备三台新的虚拟机即可，安装hadoop，使所有节点可以ping通，配置SSH信任关系，如图-1所示：





![img](https://img-blog.csdnimg.cn/img_convert/4050752bb38d1973ef7cfacac0aee037.png)

图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备**

1）三台机器配置主机名为node-0001、node-0002、node-0003，配置ip地址（ip如图-1所示），yum源（系统源）

2）编辑/etc/hosts（四台主机同样操作，以hadoop1为例）

```shell
[root@hadoop1 ~]# vim /etc/hosts
192.168.1.50  hadoop1
192.168.1.51  node-0001
192.168.1.52  node-0002
192.168.1.53  node-0003
```

3）安装java环境，在node-0001，node-0002，node-0003上面操作（以node-0001为例）

```shell
[root@node-0001 ~]# yum -y install java-1.8.0-openjdk-devel
```

4）布置SSH信任关系

```shell
[root@hadoop1 ~]# vim /etc/ssh/ssh_config    //第一次登陆不需要输入yes
Host *
        GSSAPIAuthentication yes
        StrictHostKeyChecking no
[root@hadoop1 .ssh]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:Ucl8OCezw92aArY5+zPtOrJ9ol1ojRE3EAZ1mgndYQM root@hadoop1
The key's randomart image is:
+---[RSA 2048]----+
|        o*E*=.   |
|         +XB+.   |
|        ..=Oo.   |
|        o.+o...  |
|       .S+.. o   |
|        + .=o    |
|         o+oo    |
|        o+=.o    |
|        o==O.    |
+----[SHA256]-----+
[root@hadoop1 .ssh]# for i in 61 62 63 64 ; do  ssh-copy-id  192.168.1.$i; done   
//部署公钥给hadoop1，node-0001，node-0002，node-0003
```

5）测试信任关系

```shell
[root@hadoop1 .ssh]# ssh node-0001
Last login: Fri Sep  7 16:52:00 2018 from 192.168.1.60
[root@node-0001 ~]# exit
logout
Connection to node-0001 closed.
[root@hadoop1 .ssh]# ssh node-0002
Last login: Fri Sep  7 16:52:05 2018 from 192.168.1.60
[root@node-0002 ~]# exit
logout
Connection to node-0002 closed.
[root@hadoop1 .ssh]# ssh node-0003
```

**步骤二：配置hadoop**

1）修改slaves文件

```shell
[root@hadoop1 ~]# cd  /usr/local/hadoop/etc/hadoop
[root@hadoop1 hadoop]# vim slaves
node-0001
node-0002
node-0003
```

2）hadoop的核心配置文件core-site

```shell
[root@hadoop1 hadoop]# vim core-site.xml
<configuration>
<property>
        <name>fs.defaultFS</name>
        <value>hdfs://hadoop1:9000</value>
    </property>
    <property>
        <name>hadoop.tmp.dir</name>
        <value>/var/hadoop</value>
    </property>
</configuration>
[root@hadoop1 hadoop]# mkdir /var/hadoop        //hadoop的数据根目录
```

3）配置hdfs-site文件

```shell
[root@hadoop1 hadoop]# vim hdfs-site.xml
<configuration>
 <property>
        <name>dfs.namenode.http-address</name>
        <value>hadoop1:50070</value>
    </property>
    <property>
        <name>dfs.namenode.secondary.http-address</name>
        <value>hadoop1:50090</value>
    </property>
    <property>
        <name>dfs.replication</name>
        <value>2</value>
    </property>
</configuration>
```



# 3. 配置Hadoop集群

## 3.1 问题

本案例要求完成hadoop的同步配置：

- 完成所有Hadoop集群的配置，并同步给所有主机
- 环境配置文件：hadoop-env.sh
- 核心配置文件：core-site.xml
- HDFS配置文件：hdfs-site.xml
- 节点配置文件：slaves

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：同步**

1）同步配置到node-0001，node-0002，node-0003

```shell
 [root@hadoop1 hadoop]# for i in 52 53 54 ; do rsync -aSH --delete /usr/local/hadoop/ 
\   192.168.1.$i:/usr/local/hadoop/  -e 'ssh' & done
[1] 23260
[2] 23261
[3] 23262
```

2）查看是否同步成功

```shell
[root@hadoop1 hadoop]# ssh node-0001 ls /usr/local/hadoop/
bin
etc
include
lib
libexec
LICENSE.txt
NOTICE.txt
output
README.txt
sbin
share
input
[root@hadoop1 hadoop]# ssh node-0002 ls /usr/local/hadoop/
bin
etc
include
lib
libexec
LICENSE.txt
NOTICE.txt
output
README.txt
sbin
share
input
[root@hadoop1 hadoop]# ssh node-0003 ls /usr/local/hadoop/
bin
etc
include
lib
libexec
LICENSE.txt
NOTICE.txt
output
README.txt
sbin
share
input
```



# 4. 初始化并验证集群

## 4.1 问题

本案例要求初始化并验证集群：

- hadoop1 部署 namenode，secondarynamenode
- node-000X 部署 datanode

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：格式化**

```shell
[root@hadoop1 hadoop]# cd /usr/local/hadoop/
[root@hadoop1 hadoop]# ./bin/hdfs namenode -format         //格式化 namenode
[root@hadoop1 hadoop]# ./sbin/start-dfs.sh        //启动
[root@hadoop1 hadoop]# jps        //验证角色
23408 NameNode
23700 Jps
23591 SecondaryNameNode
[root@hadoop1 hadoop]# ./bin/hdfs dfsadmin -report        //查看集群是否组建成功
Live datanodes (3):        //有三个角色成功
```

**步骤二：web 页面验证**

```shell
firefox http://hadoop1:50070 (namenode)
firefox http://hadoop1:50090 (secondarynamenode)
firefox http://node-0001:50075 (datanode)
```



# 5. mapreduce模板案例

## 5.1 问题

本案例要求在 hadoop1 上拷贝 mapreduce 模板案例：

- 配置使用 yarn 的资源管理类
- 把配置同步给所有主机

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署mapred-site**

1）配置mapred-site（hadoop1上面操作）

```shell
[root@hadoop1 ~]# cd /usr/local/hadoop/etc/hadoop/
[root@hadoop1 ~]# mv mapred-site.xml.template mapred-site.xml
[root@hadoop1 ~]# vim mapred-site.xml
<configuration>
<property>
        <name>mapreduce.framework.name</name>
        <value>yarn</value>
    </property>
</configuration>
```



# 6. 部署Yarn

## 6.1 问题

本案例要求：

- 在之前创建的 4 台虚拟机上部署 Yarn
- 在虚拟机上安装部署 Yarn
- hadoop1 部署 resourcemanager
- node(1,2,3) 部署 nodemanager

## 6.2 方案

在之前创建的 4 台虚拟机上部署 Yarn，如图-1所示：

![img](https://img-blog.csdnimg.cn/img_convert/18e6047eaef1a82c44ba2702b8ef7fd0.png)

图-2

## 6.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装与部署hadoop**

1）配置yarn-site（hadoop1上面操作）

```shell
[root@hadoop1 hadoop]# vim yarn-site.xml
<configuration>
<!-- Site specific YARN configuration properties -->
<property>
        <name>yarn.resourcemanager.hostname</name>
        <value>hadoop1</value>
    </property>
    <property>
        <name>yarn.nodemanager.aux-services</name>
        <value>mapreduce_shuffle</value>
    </property>
</configuration>
```

2）同步配置（hadoop1上面操作）

```shell
[root@hadoop1 hadoop]# for i in {52..54}; do rsync -aSH --delete /usr/local/hadoop/ 192.168.1.$i:/usr/local/hadoop/  -e 'ssh' & done
[1] 712
[2] 713
[3] 714
```

3）验证配置（hadoop1上面操作）

```shell
[root@hadoop1 hadoop]# cd /usr/local/hadoop
[root@hadoop1 hadoop]# ./sbin/start-dfs.sh
Starting namenodes on [hadoop1]
hadoop1: namenode running as process 23408. Stop it first.
node-0001: datanode running as process 22409. Stop it first.
node-0002: datanode running as process 22367. Stop it first.
node-0003: datanode running as process 22356. Stop it first.
Starting secondary namenodes [hadoop1]
hadoop1: secondarynamenode running as process 23591. Stop it first.
[root@hadoop1 hadoop]# ./sbin/start-yarn.sh
starting yarn daemons
starting resourcemanager, logging to /usr/local/hadoop/logs/yarn-root-resourcemanager-hadoop1.out
node-0002: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0002.out
node-0003: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0003.out
node-0001: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0001.out
[root@hadoop1 hadoop]# jps    //hadoop1查看有ResourceManager
23408 NameNode
1043 ResourceManager
1302 Jps
23591 SecondaryNameNode
[root@hadoop1 hadoop]# ssh node-0001 jps        //node-0001查看有NodeManager
25777 Jps
22409 DataNode
25673 NodeManager
[root@hadoop1 hadoop]# ssh node-0002 jps        //node-0001查看有NodeManager
25729 Jps
25625 NodeManager
22367 DataNode
[root@hadoop1 hadoop]# ssh node-0003 jps        //node-0001查看有NodeManager
22356 DataNode
25620 NodeManager
25724 Jps
```

4）web访问hadoop

```shell
firefox http://hadoop1:8088 (resourcemanager)
firefox http://node-0001:8042 (nodemanager)
```



# Exercise

## 1 大数据的由来

随着计算机技术的发展，互联网的普及，信息的积累已经到了一个非常庞大的地步，信息的增长也在不断的加快，随着互联网、物联网建设的加快，信息更是爆炸是增长，收集、检索、统计这些信息越发困难，必须使用新的技术来解决这些问题

## 2 什么是大数据

数据指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产

是指从各种各样类型的数据中，快速获得有价值的信息

## 3 简述大数据特性有哪些

Volume (大体量)：可从数百TB到数十数百PB、甚至EB的规模

Variety (多样性)：大数据包括各种格式和形态的数据

Velocity (时效性)：很多大数据需要在一定的时间限度下得到及时处理

Veracity (准确性)：处理的结果要保证一定的准确性

Value (大价值)：大数据包含很多深度的价值，大数据分析挖掘和利用将带来巨大的商业价值

## 4 Hadoop常用组件以及核心组件有哪些

HDFS：Hadoop分布式文件系统（核心组件）

MapReduce：分布式计算框架（核心组件）

Yarn：集群资源管理系统（核心组件）

Zookeeper：分布式协作服务

Hbase：分布式列存数据库

Hive：基于Hadoop的数据仓库

Sqoop：数据同步工具

Pig：基于Hadoop的数据流系统

Mahout：数据挖掘算法库

Flume：日志收集工具

## 5 Hadoop如何实现统计词频

```shell
[root@nn01 ~]# cd /usr/local/hadoop/
[root@nn01 hadoop]# mkdir /usr/local/hadoop/aa
[root@nn01 hadoop]# ls
bin  etc  include  lib  libexec  LICENSE.txt  NOTICE.txt  aa  README.txt  sbin  share
[root@nn01 hadoop]# cp *.txt /usr/local/hadoop/aa
[root@nn01 hadoop]# ./bin/hadoop jar  \
 share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.6.jar  wordcount aa bb        //wordcount为参数 统计aa这个文件夹，存到bb这个文件里面（这个文件不能存在，要是存在会报错，是为了防止数据覆盖）
[root@nn01 hadoop]#  cat   bb/part-r-00000    //查看
```



> 如有侵权，请联系作者删除





@[TOC]( Block storage application cases & distributed file system & and object storage | Cloud computing )

---

# 1. 块存储应用案例

## 1.1 问题

延续Day03的实验内容，演示块存储的应用案例，实现以下功能：

- 创建镜像快照
- 使用快照还原数据
- 使用快照克隆镜像
- 删除快照

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一、创建镜像快照**

1) 查看镜像快照（默认所有镜像都没有快照）。

```shell
 [root@node1 ~]# rbd snap ls jacob
#查看某个镜像有没有快照，jacob是镜像的名称，ls是list查看
```

2) 给镜像创建快照。

```shell
[root@node1 ~]# rbd snap create jacob --snap jacob-snap1
#为jacob镜像创建快照，--snap指定快照名称，快照名称为jacob-snap1，快照名称可以任意
[root@node1 ~]# rbd snap ls jacob
SNAPID NAME            SIZE 
     4 jacob-snap1 15360 MB
```

3) 删除客户端写入的测试文件

```shell
[root@client ~]# rm  -rf   /mnt/test.txt
[root@client ~]# umount  /mnt
```

4) 还原快照

```shell
[root@node1 ~]# rbd snap rollback jacob --snap jacob-snap1
# rollback是回滚的意思，使用jacob-snap1快照回滚数据，对jacob镜像进行回滚数据
[root@client ~]# mount /dev/rbd0 /mnt/        #客户端重新挂载分区
[root@client ~]# ls  /mnt                      #查看数据是否被恢复
```

**步骤二：创建快照克隆**

1）克隆快照

```shell
[root@node1 ~]#  rbd snap protect jacob --snap jacob-snap1    #保护快照
#jacob是镜像名称，jacob-snap1是前面创建的快照（被保护的快照，不可以被删除）
[root@node1 ~]#  rbd snap rm jacob --snap jacob-snap1    #删除被保护的快照，会失败
[root@node1 ~]#  rbd clone \
jacob --snap jacob-snap1 jacob-clone --image-feature layering
#使用jacob镜像的快照jacob-snap1克隆一个新的名称为jacob-clone的镜像
#新镜像名称可以任意
```

2）查看克隆镜像与父镜像快照的关系

```shell
[root@node1 ~]#  rbd info jacob-clone
rbd image 'jacob-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
    parent: rbd/jacob@jacob-snap1
#克隆镜像的很多数据都来自于快照链(相当于文件的软链接的概念)
#如果希望克隆镜像可以独立工作，就需要将父快照中的数据，全部拷贝一份，但比较耗时！！！
[root@node1 ~]#  rbd flatten jacob-clone        #让新克隆的镜像与快照脱离关系
[root@node1 ~]#  rbd info jacob-clone            #查看镜像信息
rbd image 'jadob-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
#注意，父快照信息没了！
```

3）删除快照

```shell
[root@node1 ~]#  rbd snap unprotect jacob --snap jacob-snap1     #取消快照保护
[root@node1 ~]#  rbd snap rm jacob --snap jacob-snap1            #可以删除快照
```

# 2. Ceph文件系统

## 2.1 问题

延续前面的实验，实现Ceph文件系统的功能。具体实现有以下功能：

- 部署MDSs节点
- 创建Ceph文件系统
- 客户端挂载文件系统

## 2.2 方案

前面的块共享，仅允许同时一个客户端访问，无法实现多人同时使用块设备。

而Ceph的文件系统共享则允许多人同时使用。

下面假设使用虚拟机node3，部署MDS节点。

主机的主机名及对应的IP地址如表-1所示。

表－1 主机名称及对应IP地址表
![在这里插入图片描述](https://img-blog.csdnimg.cn/bfffe35c26b9436ea123e4335bd5bfa3.png)


## 2.3 步骤

实现此案例需要按照如下步骤进行。

1）添加一台虚拟机node3，要求如下：
IP地址:192.168.4.13
主机名:node3

配置yum源（包括操作系统的源、ceph的源）
与Client主机同步时间
node1允许无密码远程node3
修改node1的/etc/hosts，并同步到所有node主机

2）部署元数据服务器
登陆node3，安装ceph-mds软件包（如果前面课程已经安装，此步骤可以忽略）

```shell
[root@node3 ~]# yum -y install ceph-mds 
```

登陆node1部署节点操作

```shell
[root@node1 ~]# cd  /root/ceph-cluster
#该目录，是最早部署ceph集群时，创建的目录
[root@node1 ceph-cluster]# ceph-deploy mds create node3
#远程nod3，拷贝集群配置文件，启动mds服务
```

3）创建存储池

备注：一个文件系统是由inode和block两部分组成，效果如图-1所示。

inode存储文件的描述信息（metadata元数据），block中存储真正的数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8e48e90f8dc942a7994f338875ac6ad3.png)
图-1

```shell
[root@node3 ~]# ceph osd pool create cephfs_data 64
#创建存储池，共享池的名称为cephfs_data，对应有64个PG
#共享池名称可以任意
[root@node3 ~]# ceph osd pool create cephfs_metadata 64
#创建存储池，共享池的名称为cephfs_metadata，对应有64个PG
```

PG拓扑如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/14e709991cff40879753afe184c3fc2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-2

PG是一个逻辑概念，没有对应的物质形态，是为了方便管理OSD而设计的概念。

为了方便理解，可以把PG想象成为是目录，可以创建32个目录来存放OSD，也可以创建64个目录来存放OSD。

4）创建Ceph文件系统

```shell
[root@node3 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
#myfs1是名称，名称可以任意，注意，先写metadata池，再写data池
#fs是filesystem的缩写，filesystem中文是文件系统
#默认，只能创建1个文件系统，多余的会报错
[root@node3 ~]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
```

5）客户端挂载（客户端需要安装ceph-common，前面的课程已经安装）

```shell
[root@client ~]# mount -t ceph 192.168.4.11:6789:/  /mnt  \
-o name=admin,secret=AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
#注意:-t（type）指定文件系统类型，文件系统类型为ceph
#-o（option）指定mount挂载命令的选项，选项包括name账户名和secret密码
#192.168.4.11为MON节点的IP（不是MDS节点），6789是MON服务的端口号
#admin是用户名,secret后面是密钥
#密钥可以在/etc/ceph/ceph.client.admin.keyring中找到
```

思考题：请问lsblk和df命令的区别？

如果做NFS的实验，客户端不安装nfs-utils是否可以mount成功？

##扩展知识：创建ceph用户，查看用户##

```shell
    [root@node1 ~]# ceph auth get-or-create client.nb \
    osd  'allow *' \
    mds  'allow *' \
    mon  'allow *'      > 文件名
# >是重定向导出，后面的文件名可以任意，没有文件会创建，有文件则会覆盖文件的内容
    [root@node1 ~]# ceph auth list              #查看所有用户列表
```

# 3. 创建对象存储服务器

## 3.1 问题

延续前面的实验，实现Ceph对象存储的功能。具体实现有以下功能：

- 安装部署Rados Gateway
- 启动RGW服务
- 设置RGW的前端服务与端口
- 客户端测试

## 3.2 步骤

**步骤一：部署对象存储服务器**

1）准备实验环境，要求如下：
IP地址:192.168.4.13
主机名:node3

配置yum源（包括操作系统的源、ceph的源）
与Client主机同步时间
node1允许无密码远程node3

修改node1的/etc/hosts，并同步到所有node主机

2）部署RGW软件包

```shell
[root@node3 ~]# yum -y install ceph-radosgw
```

3）新建网关实例

拷贝配置文件，启动一个rgw服务

```shell
[root@node1 ~]# cd /root/ceph-cluster
[root@node1 ~]# ceph-deploy rgw create node3        #远程mode3启动rgw服务
```

登陆node3验证服务是否启动

```shell
[root@node3 ~]# ps aux |grep radosgw
ceph      4109  0.2  1.4 2289196 14972 ?       Ssl  22:53   0:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.node3 --setuser ceph --setgroup ceph
[root@node3 ~]# systemctl  status ceph-radosgw@\*
```

4）修改服务端口

登陆node3，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用

```shell
[root@node3 ~]#  vim  /etc/ceph/ceph.conf
[client.rgw.node3]
host = node3
rgw_frontends = "civetweb port=8000"
#node3为主机名
#civetweb是RGW内置的一个web服务
[root@node3 ~]# systemctl  restart ceph-radosgw@\*
```

**步骤二：客户端测试（扩展选做实验）**

1）curl测试

```shell
[root@client ~]# curl  192.168.4.13:8000
```

2）使用第三方软件访问

登陆node3（RGW）创建账户

```shell
[root@node3 ~]#  radosgw-admin user create \
--uid="testuser" --display-name="First User"
… …
"keys": [
        {
            "user": "testuser",
            "access_key": "5E42OEGB1M95Y49IBG7B",
            "secret_key": "i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6"
        }
    ],
[root@node5 ~]# radosgw-admin user info --uid=testuser
//testuser为用户名，access_key和secret_key是账户密钥
```

3）客户端安装软件（软件需要自己上网搜索下载）

```shell
[root@client ~]#  yum install s3cmd-2.0.1-1.el7.noarch.rpm
```

修改软件配置（注意，除了下面设置的内容，其他提示都默认回车）

```shell
[root@client ~]#  s3cmd --configure
Access Key: 5E42OEGB1M95Y49IBG7BSecret Key: i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6
S3 Endpoint [s3.amazonaws.com]: 192.168.4.13:8000
[%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.13:8000
Use HTTPS protocol [Yes]: No
Test access with supplied credentials? [Y/n] n
Save settings? [y/N] y
#注意，其他提示都默认回车
```

4）创建存储数据的bucket（类似于存储数据的目录）

```shell
[root@client ~]# s3cmd ls
[root@client ~]# s3cmd mb s3://my_bucket
Bucket 's3://my_bucket/' created
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
[root@client ~]# s3cmd ls s3://my_bucket
DIR s3://my_bucket/log/
[root@client ~]# s3cmd ls s3://my_bucket/log/
2018-05-09 08:19 309034 s3://my_bucket/log/messages 
```

5）测试下载功能

```shell
[root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/
```

6）测试删除功能

```shell
[root@client ~]# s3cmd del s3://my_bucket/log/messages
```

附加知识总结：（Ceph操作思路）

一、准备工作：

IP，主机名，hosts解析，ssh密钥，时间同步，yum源，防火墙，selinux

二、部署ceph：

1.安装软件

```shell
  ceph-deploy(脚本)
  ceph-mon  ceph-osd  ceph-mds  ceph-radosgw(集群)
```

2.修改配置启动服务mon

```shell
  mkdir  目录；cd 目录
  ceph-deploy  new  node1   node2   node3  (生成配置文件)
  ceph-deploy  mon  create-initial  (启动服务)
```

3.启动osd共享硬盘

```shell
  ceph-deploy  disk  zap   主机名:磁盘名  ...  ...
  ceph-deploy  osd  create  主机名:磁盘   ...  ...
```

三、使用Ceph思路:

1.块共享

```shell
  服务器: rbd  create  创建一个共享镜像
  客户端: 安装cpeh-common;  cp 配置文件和密钥
          rbd  map  |  rbd  unmap
```

2.文件系统共享(文件系统由inode和block)

服务器: 创建两个共享池(名称任意)

使用两个共享池合并一个文件系统

安装ceph-mds软件，并启动服务(ceph-deploy mds create node3)

```shell
  客户端： mount  -t  MON的IP:6789:/   /挂载点   -o  name=用户名,secret=密码
```

3.对象存储

服务器启动一个radosgw即可(RGW)

```shell
   ceph-deploy  rgw  create  node3
```

四、ceph-deploy脚本用法：

```shell
   ceph-deploy  new   node1  node2  node3    #生成配置文件
   ceph-deploy  mon   create-initial         #远程所有主机启动mon服务
   ceph-deploy  disk zap  主机名:磁盘名       #初始化磁盘
   ceph-deploy  osd   create  主机名:磁盘名   #远程主机并启动osd服务
   ceph-deploy  mds   create   主机名        #远程主机并启动mds服务
   ceph-deploy  rgw  create  主机名          #远程主机并启动RGW服务
```

附加知识（如何删除某个OSD，下面的假设是删除osd.4）

```shell
ceph osd tree
ceph osd out osd.4
ceph osd tree
ceph -s
ceph osd crush remove osd.4
ceph auth del osd.4
ceph -s
ceph osd rm osd.4
最后要找到对应的主机，umount把osd.4对应的磁盘卸载
```

# Exercise

## 1 怎样才可以防止ceph镜像快照被删除？

- 通过protect保护快照

## 2 什么是CephFS？

分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连；

CephFS使用Ceph集群提供与POSIX兼容的文件系统；

允许Linux直接将Ceph存储mount到本地。

## 3 什么是存储设备的元数据？

任何文件系统中的数据分为数据和元数据；
数据是指普通文件中的实际数据；
而元数据指用来描述一个文件的特征的系统数据；
比如：访问权限、文件拥有者以及文件数据块的分布信息(inode...)等。

> 如有侵权，请联系作者删除



﻿@[TOC]( Case statement & function and interrupt control & string handling | Cloud computing )

---

# 1 案例1：基于case分支编写脚本

## 1.1 问题

本案例要求编写test.sh脚本，相关要求如下：

- 能使用redhat、fedora控制参数
- 控制参数通过位置变量$1传入
- 当用户输入redhat参数，脚本返回fedora
- 当用户输入fedora参数，脚本返回redhat
- 当用户输入其他参数，则提示错误信息

## 1.2 方案

case分支属于匹配执行的方式，它针对指定的变量预先设置一个可能的取值，判断该变量的实际取值是否与预设的某一个值相匹配，如果匹配上了，就执行相应的一组操作，如果没有任何值能够匹配，就执行预先设置的默认操作。

case分支的语法结构如下所示：

```shell
case  变量  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac
```

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本文件**

脚本编写参考如下：

```shell
[root@svr5 ~]# vim test.sh
#!/bin/bash
case $1 in
redhat)
        echo "fedora";;
fedora)
        echo "redhat";;
    *)                                              //默认输出脚本用法
    echo "用法: $0 {redhat|fedora}"
esac
[root@svr5 ~]# chmod +x test.sh
```

**步骤三：验证、测试脚本**

未提供参数，或提供的参数无法识别时，提示正确用法：

```shell
[root@svr5 ~]# ./test.sh
用法: ./test.sh {redhat|fedora}
确认脚本可以响应redhat控制参数：
```shell
[root@svr5 ~]# ./test.sh redhat
fedora
```

确认脚本可以响应fedora控制参数：

```shell
[root@svr5 ~]# ./test.sh fedora
redhat
```

# 2. 编写一键部署软件脚本

## 2.1 问题

本案例要求编写脚本实现一键部署Nginx软件（Web服务器）：

一键源码安装Nginx软件
脚本自动安装相关软件的依赖包

## 2.2 步骤

实现此案例需要按照如下步骤进行。

1）依赖包

源码安装Nginx需要提前安装依赖包软件gcc,openssl-devel,pcre-devel

**步骤一：编写脚本**

1）参考脚本内容如下：

```shell
[root@svr5 ~]# vim test.sh
#!/bin/bash
yum -y install gcc openssl-devel pcre-devel
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
```

2）确认安装效果

Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：

/usr/local/nginx/conf 配置文件目录
/usr/local/nginx/html 网站页面目录
/usr/local/nginx/logs Nginx日志目录
/usr/local/nginx/sbin 主程序目录

主程序命令参数：

```shell
[root@svr5 ~]# /usr/local/nginx/sbin/nginx                //启动服务
[root@svr5 ~]# /usr/local/nginx/sbin/nginx    -s stop        //关闭服务
[root@svr5 ~]# /usr/local/nginx/sbin/nginx    -V            //查看软件信息
```

# 3. 启动脚本

## 3.1 问题

本案例要求编写Ngin启动脚本，要求如下：

- 脚本支持start、stop、restart、status
- 脚本支持报错提示
- 脚本具有判断是否已经开启或关闭的功能

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

脚本通过位置变量$1读取用户的操作指令，判断是start、stop、restart还是status。

netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：

- -n以数字格式显示端口号
- -t显示TCP连接的端口
- -u显示UDP连接的端口
- -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
- -p显示监听端口的服务名称是什么（也就是程序名称）

1）参考脚本内容如下：

```shell
[root@svr5 ~]# vim test.sh
#!/bin/bash
case $1 in
start)
        /usr/local/nginx/sbin/nginx;;
stop)
        /usr/local/nginx/sbin/nginx -s stop;;
restart)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nignx/sbin/nginx;;
status)
        netstat -ntulp |grep -q nginx
        if [ $? -eq 0 ];then
echo 服务已启动
else
echo 服务未启动
fi;;
*)
        echo Error;;
esac
```

2）执行测试脚本：

```shell
[root@svr5 ~]# ./test.sh start
[root@svr5 ~]# ./test.sh stop
[root@svr5 ~]# ./test.sh status
[root@svr5 ~]# ./test.sh xyz
```

# 4. 使用Shell函数

## 4.1 问题

本案例要求编写脚本mycolor.sh，相关要求如下：

将颜色输出的功能定义为函数
调用函数，可以自定义输出内容和颜色

## 4.2 方案

在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，增强易读性，提高Shell脚本的执行效率

1）函数的定义方法

格式1：

```shell
function  函数名 {
    命令序列
    .. ..
}
```

格式2：

```shell
函数名() {
    命令序列
    .. ..
}
```

2）函数的调用

直接使用“函数名”的形式调用，如果该函数能够处理位置参数，则可以使用“函数名 参数1 参数2 .. ..”的形式调用。

**注意：函数的定义语句必须出现在调用之前，否则无法执行。**

3) 测试语法格式

```shell
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir /test
> cd /test
> }
[root@svr5 ~]# mycd                            //调用函数
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir $1
> cd $1
> }
[root@svr5 ~]# mycd  /abc                            //调用函数
[root@svr5 ~]# mycd  /360                            //调用函数
```

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写mycolor.sh脚本**

1）任务需求及思路分析

用户在执行时提供2个整数参数，这个可以通过位置变量$1、$2读入。

调用函数时，将用户提供的两个参数传递给函数处理。

颜色输出的命令:echo -e "\033[32mOK\033[0m"。

3X为字体颜色，4X为背景颜色。

2）根据实现思路编写脚本文件

```shell
[root@svr5 ~]# vim mycolor.sh
#!/bin/bash
cecho() {
    echo -e "\033[$1m$2\033[0m"
}
cecho 32 OK
cecho 33 OK
cecho 34 OK
cecho 35 OK
[root@svr5 ~]# chmod +x mycolor.sh
```

3）测试脚本执行效果

```shell
[root@svr5 ~]# ./mycolor.sh
```

使用函数，优化改进前面的脚本：

```shell
[root@svr5 ~]# vim myping.sh
#!/bin/bash
myping(){
    ping -c1 -W1  $1  &>/dev/null
    if [ $? -eq 0 ];then
        echo "$1 is up"
    else
        echo "$1 is down"
    fi
}
for  i  in  {1..254}
do
     myping  192.168.4.$i  &
done
wait
#wait命令的作用是等待所有后台进程都结束才结束脚本。
```

# 5. 中断及退出

## 5.1 问题

本案例要求编写两个Shell脚本，相关要求如下：

- 从键盘循环取整数（0结束）并求和，输出最终结果
- 找出1~20以内6的倍数，并输出她的平方值

## 5.2 方案

通过break、continue、exit在Shell脚本中实现中断与退出的功能。

break可以结束整个循环；continue结束本次循环，进入下一次循环；exit结束整个脚本，案例如下：

```shell
[root@svr5 ~]# vim  test.sh
#!/bin/bash
for  i   in   {1..5}
do
       [  $i  -eq  3 ]&& break //这里将break替换为continue，exit分别测试脚本执行效果       echo $i
done
echo "Game Over"
```

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写求和脚本sum.sh**

1）编写脚本文件

```shell
[root@svr5 ~]# vim sum.sh 
#!/bin/bash
SUM=0
while :
do 
read  -p  "请输入整数（0表示结束）："  x
    [ $x -eq 0 ]  &&  break
    SUM=$[SUM+x]
done
echo "总和是：$SUM"
[root@svr5 ~]# chmod +x sum.sh
[root@svr5 ~]# ./sum.sh
```

**步骤二：编写脚本文件，找出1-20内6的倍数，并打印她的平方值**

1）编写脚本文件

注意：要求打印所有6的倍数的平方值，也就是非6的倍数都跳过！！！

```shell
[root@svr5 ~]# vim test.sh 
#!/bin/bash
for i in {1..20}
do
    [ $[i%6] -ne 0 ]  &&  continue
    echo $[i*i]
done
[root@svr5 ~]# chmod +x test.sh
[root@svr5 ~]# ./test.sh
````

# 6. 字符串截取及切割

## 6.1 问题

使用Shell完成各种Linux运维任务时，一旦涉及到判断、条件测试等相关操作时，往往需要对相关的命令输出进行过滤，提取出符合要求的字符串。

本案例要求熟悉字符串的常见处理操作，完成以下任务练习：

- 参考PPT示范操作，完成子串截取、替换等操作
- 根据课上的批量改名脚本，编写改进版renfilex.sh：能够批量修改当前目录下所有文件的扩展名，修改前/后的扩展名通过位置参数$1、$2提供

## 6.2 方案

子串截取的用法：

- ${变量名:起始位置:长度}

子串替换的两种用法：

- 只替换第一个匹配结果：${变量名/old/new}
- 替换全部匹配结果：${变量名//old/new}

字符串掐头去尾：

- 从左向右，最短匹配删除：${变量名#*关键词}
- 从左向右，最长匹配删除：${变量名##*关键词}
- 从右向左，最短匹配删除：${变量名%关键词*}
- 从右向左，最长匹配删除：${变量名%%关键词*}

## 6.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：字符串的截取**

1）使用 ${}表达式

格式：${变量名:起始位置:长度}

**使用${}方式截取字符串时，起始位置是从0开始的。**

定义一个变量phone，并确认其字符串长度：

```shell
[root@svr5 ~]# phone="13788768897"
[root@svr5 ~]# echo ${#phone}
11                                         //包括11个字符
```

使用${}截取时，起始位置可以省略，省略时从第一个字符开始截。比如，以下操作都可以从左侧开始截取前6个字符：

```shell
[root@svr5 ~]# echo ${phone:0:6}
137887
```

或者

```shell
[root@svr5 ~]# echo ${phone::6}
137887
```

因此，如果从起始位置1开始截取6个字符，那就变成这个样子了：

```shell
[root@svr5 ~]# echo ${phone:1:6}
378876
```

4）一个随机密码的案例

版本1：

```shell
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
num=$[RANDOM%62]
pass=${x:num:1}
```

版本2：

```shell
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
pass=''
for i in {1..8}
do
num=$[RANDOM%62]
tmp=${x:num:1}
pass=${pass}$tmp
done
echo $pass
```

**步骤二：字符串的替换**

1）只替换第1个子串

格式：${变量名/old/new}

还以前面的phone变量为例，确认原始值：

```shell
[root@svr5 ~]# echo $phone
13788768897
```

将字符串中的第1个8替换为X:

```shell
[root@svr5 ~]# echo  ${phone/8/X}
137X8768897
```

2）替换全部子串

格式：${变量名//old/new}

将phone字符串中的所有8都替换为X:

```shell
[root@svr5 ~]# echo  ${phone//8/X}
137XX76XX97
```

**步骤三：字符串的匹配删除**

以处理系统默认的账户信息为例，定义变量A：

```shell
[root@svr5 ~]# A=`head -1 /etc/passwd`
[root@svr5 ~]# echo $A
root:x:0:0:root:/root:/bin/bash
```

1）从左向右，最短匹配删除

格式：${变量名#*关键词}

删除从左侧第1个字符到最近的关键词“：”的部分，* 作通配符理解：

```shell
[root@svr5 ~]# echo ${A#*:}
x:0:0:root:/root:/bin/bash
```

2）从左向右，最长匹配删除

格式：${变量名##*关键词}

删除从左侧第1个字符到最远的关键词“:”的部分：

```shell
[root@svr5 ~]# echo $A                      //确认变量A的值
root:x:0:0:root:/root:/bin/bash
[root@svr5 ~]# echo ${A##*:}
/bin/bash
```

3）从右向左，最短匹配删除

格式：${变量名%关键词*}

删除从右侧最后1个字符到往左最近的关键词“:”的部分，* 做通配符理解：

```shell
[root@svr5 ~]# echo ${A%:*}
root:x:0:0:root:/root
```

4）从右向左，最长匹配删除

格式：${变量名%%关键词*}

删除从右侧最后1个字符到往左最远的关键词“:”的部分：

```shell
[root@svr5 ~]# echo ${A%%:*}
root
```

**步骤四：编写renfilex.sh脚本**

创建一个测试用的测试文件

```shell
[root@svr5 ~]# mkdir rendir
[root@svr5 ~]# cd rendir
[root@svr5 rendir]# touch {a,b,c,d,e,f,g,h,i}.doc
[root@svr5 rendir]# ls
a.doc  b.doc  c.doc  d.doc  e.doc  f.doc  g.doc  h.doc  i.doc
```

1）批量修改文件扩展名的脚本

脚本用途为：批量修改当前目录下的文件扩展名，将.doc改为.txt。

脚本内容参考如下：

```shell
[root@svr5 rendir]# vim renfile.sh
#!/bin/bash
for i in `ls *.doc`            #注意这里有反引号
do
    mv $i  ${i%.*}.txt
done
[root@svr5 ~]# chmod +x renfile.sh
```

测试脚本：

```shell
[root@svr5 rendir]# ./renfile.sh
[root@svr5 rendir]# ls
a.txt  b.txt  c.txt  d.txt  e.txt  f.txt  g.txt  h.txt  i.txt
```

2）改进版脚本(批量修改扩展名)

通过位置变量 $1、$2提供更灵活的脚本，改进的脚本编写参考如下：

```shell
[root@svr5 rendir]# vim ./renfile.sh
#!/bin/bash
#version:2
for i in `ls *.$1`
do
    mv $i  ${i%.*}.$2
done
```

3）验证、测试改进后的脚本

将 *.doc文件的扩展名改为.txt：

```shell
[root@svr5 rendir]# ./renfile.sh txt doc
```

将 *.doc文件的扩展名改为.mp4：

```shell
[root@svr5 rendir]# ./renfile.sh doc mp4
```

# 7. 字符串初值的处理

## 7.1 问题

本案例要求编写一个脚本sumx.sh，求从1-x的和，相关要求如下：

从键盘读入x值
当用户未输入任何值时，默认按1计算

## 7.2 方案

通过${var:-word}判断变量是否存在，决定变量的初始值。

## 7.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：认识字符串初值的最常见处理方法**

1）只取值，${var:-word}

若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。

变量值已存在的情况：

```shell
[root@svr5 ~]# XX=11
[root@svr5 ~]# echo $XX              //查看原变量值
11
[root@svr5 ~]# echo ${XX:-123}      //因XX已存在，输出变量XX的值
11
```

变量值不存在的情况：

```shell
[root@svr5 ~]# echo ${YY:-123}      //因YY不存在，输出“123”
123
```

编写一个验证知识点的参考示例脚本如下：

```shell
[root@svr5 ~]# cat /root/test.sh
#!/bin/bash
read  -p   "请输入用户名:"   user
[ -z $user ] && exit                    //如果无用户名，则脚本退出
read  -p   "请输入密码:"   pass
pass=${pass:-123456}                    //如果用户没有输入密码，则默认密码为123456
useradd  $user
echo "$pass"  | passwd   --stdin   $user
```

**步骤二：编写sumx.sh脚本，处理read输入的初值**

用来从键盘读入一个正整数x，求从1到x的和；当用户未输入值（直接回车）时，为了避免执行出错，应为x赋初值1 。

1）脚本编写参考如下

```shell
[root@svr5 ~]# vim sumx.sh
#!/bin/bash
read -p "请输入一个正整数：" x
x=${x:-1}
i=1; SUM=0
while [ $i -le $x ]
do
    let SUM+=i
    let i++
done
echo "从1到$x的总和是：$SUM"
[root@svr5 ~]# chmod +x sumx.sh
```

2）验证、测试脚本执行效果：

```shell
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：25                          //输入25，正常读入并计算、输出结果
从1到25的总和是：325
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：70                         //输入70，正常读入并计算、输出结果
从1到70的总和是：2485
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：                          //直接回车，设x=1后计算、输出结果
从1到1的总和是：1
```

# Exercise

## 1 简述Linux服务脚本中的case分支结构。

Linux服务脚本通常利用$1位置变量来获取控制参数，并结合case分支来做出不同的响应，典型的结构如下：

```shell
case  "$1"  in                                              //检查第一个位置参数
  start)
        echo  "启动服务.. .." ;;                             //启动服务的语句块
  stop)
        echo  "停止服务.. .." ;;                               //停止服务的语句块
  restart)
        $0  stop                                                //停止服务
        $0  start                                           //启动服务
        ;;
  *)
        echo  $"用法: $0 {start|stop|restart}"             //提示正确用法
        exit 1 
esac
```

## 2 简述定义一个Shell函数的两种方法。

方法1：

```shell
function  函数名 {
    命令序列
    .. ..
}
```

方法2：

```shell
函数名() {
    命令序列
    .. ..
}
```

## 3 简述Shell环境常见的中断及退出控制指令。

- break：跳出当前所在的循环体，执行循环体后的语句。
- continue:跳过循环体内余下的语句，重新判断条件以便执行下一次循环。
- exit:退出脚本，默认返回值是 0。

> 如有侵权，请联系作者删除



﻿@[TOC]( Ceph Overview & Ceph cluster deployment & Ceph block storage | Cloud computing )

---

# 1. 实验环境

## 1.1 问题

准备四台虚拟机，其三台作为存储集群节点，一台安装为客户端，实现如下功能：

- 创建1台客户端虚拟机
- 创建3台存储集群虚拟机
- 配置主机名、IP地址、YUM源
- 修改所有主机的主机名
- 配置无密码SSH连接
- 配置NTP时间同步
- 创建虚拟机磁盘

## 1.2 方案

使用4台虚拟机，1台客户端、3台存储集群服务器，拓扑结构如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/37b988d7ce0f4208950fb0f0c74cfef4.png)
图-1

所有主机的主机名及对应的IP地址如表-1所示。

注意：所有主机基本系统光盘的YUM源必须提前配置好。

表－1 主机名称及对应IP地址表
![在这里插入图片描述](https://img-blog.csdnimg.cn/0b776d4523e54b3bb168058fcd1c3751.png)
Ceph组件架构如图-2所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b21de80a1f344eea9f1e1aaabe08d50f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-2

Ceph会对数据进行切割处理，如图-3所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5aa8035ee0af48c1be3a89f9f5c73c19.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-3

Ceph随机读写数据的思路，如图-4所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4de12f77daad4682822cb3353c884b9a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-4

Ceph集群结构如图-5所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6d853344d1b8441698fe2880cf05273c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-5

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装前准备**

1）为所有节点配置yum源服务器。

将真机第二阶段素材中的ceph10.iso挂载到/var/ftp/ceph目录，为所有虚拟机提供YUM源。

```shell
# mkdir  /var/ftp/ceph
# mount -t  iso9660   /.../ceph10.iso   /var/ftp/ceph           #不能照抄
```

2）为虚拟机添加磁盘：

除了client客户端，所有3台ceph服务器都添加2块20G磁盘。

```shell
[root@client ~]# lsblk                 #没有额外磁盘
[root@node1 ~]# lsblk                  #多了2块磁盘
[root@node2 ~]# lsblk                  #多了2块磁盘
[root@node3 ~]# lsblk                  #多了2块磁盘
```

3）所有主机设置防火墙和SELinux（如果已经关闭，则此步骤可以忽略）

```shell
[root@client ~]# firewall-cmd --set-default-zone=trusted
[root@client ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@client ~]# setenforce 0
[root@node1 ~]# firewall-cmd --set-default-zone=trusted
[root@node1 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node1 ~]# setenforce 0
[root@node2 ~]# firewall-cmd --set-default-zone=trusted
[root@node2 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node2 ~]# setenforce 0
[root@node3 ~]# firewall-cmd --set-default-zone=trusted
[root@node3 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node3 ~]# setenforce 0
```

4）配置无密码连接(包括自己远程自己也不需要密码)，在node1操作。

```shell
[root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''
#-f后面跟密钥的文件名称（希望创建密钥到哪个文件）
#-N ''代表不给密钥配置密钥（不能给密钥配置密码）
[root@node1 ~]# for i in 10  11  12  13
 do
     ssh-copy-id  192.168.4.$i
 done
#通过ssh-copy-id将密钥传递给192.168.4.10、192.168.4.11、192.168.4.12、192.168.4.13
```

5）修改/etc/hosts并同步到所有主机。

注意：/etc/hosts解析的域名要与本机主机名一致！！！！

```shell
 [root@node1 ~]# vim /etc/hosts     #修改文件，手动添加如下内容（不要删除文件原有内容）
... ...
192.168.4.10  client
192.168.4.11     node1
192.168.4.12     node2
192.168.4.13     node3
```

提示：/etc/hosts解析的域名必须与本机主机名一致！！！

将/etc/hosts文件拷贝给所有其他主机（client、node1、node2、node3）

```shell
[root@node1 ~]# for i in client node1  node2  node3
do
scp  /etc/hosts   $i:/etc/
done
```

6）修改所有节点都需要配置YUM源，并同步到所有主机。

```shell
[root@node1 ~]# vim /etc/yum.repos.d/ceph.repo    #新建YUM源配置文件，内容如下
[mon]
name=mon
baseurl=ftp://192.168.4.254/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.254/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.254/ceph/Tools
gpgcheck=0
[root@node1 ~]# yum clean all               #清空缓存
[root@node1 ~]# yum repolist                #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in  client  node1  node2  node3
do
scp  /etc/yum.repos.d/ceph.repo   $i:/etc/yum.repos.d/
done
```

7）给所有节点安装ceph相关软件包。

```shell
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
    ssh  $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
done 
```

8）Client主机配置NTP服务器。

```shell
[root@client ~]# yum -y install chrony
[root@client ~]# vim /etc/chrony.conf
    allow 192.168.4.0/24        #大约26行
    local stratum 10            #大约29行(去注释即可)
[root@client ~]# systemctl restart chronyd
```

9）node1，node2，node3修改NTP客户端配置。

```shell
[root@node1 ~]# yum -y install chrony
[root@node1 ~]# vim /etc/chrony.conf
server 192.168.4.10   iburst              #配置文件第二行，手动添加一行新内容
[root@node1 ~]# systemctl restart chronyd
[root@node1 ~]# chronyc sources -v        #查看同步结果，应该是^*
[root@node2 ~]# yum -y install chrony
[root@node2 ~]# vim /etc/chrony.conf
server 192.168.4.10   iburst              #配置文件第二行，手动添加一行新内容
[root@node2 ~]# systemctl restart chronyd
[root@node2 ~]# chronyc sources -v            #查看同步结果，应该是^*
[root@node3 ~]# yum -y install chrony
[root@node3 ~]# vim /etc/chrony.conf
server 192.168.4.10   iburst              #配置文件第二行，手动添加一行新内容
[root@node3 ~]# systemctl restart chronyd
[root@node3 ~]# chronyc sources -v       #查看同步结果，应该是^*
```

# 2. 部署ceph集群

## 2.1 问题

沿用练习一，部署Ceph集群服务器，实现以下目标：

- 安装部署工具ceph-deploy
- 创建ceph集群
- 准备日志磁盘分区
- 创建OSD存储空间
- 查看ceph状态，验证

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装部署软件ceph-deploy**

1）在node1安装部署工具，学习工具的语法格式。

```shell
[root@node1 ~]#  yum -y install ceph-deploy
[root@node1 ~]#  ceph-deploy  --help
[root@node1 ~]#  ceph-deploy mon --help
```

2）创建目录（目录名称可以任意，推荐与案例一致）

```shell
[root@node1 ~]#  mkdir ceph-cluster
[root@node1 ~]#  cd ceph-cluster/
```

**步骤二：部署Ceph集群**

1）创建Ceph集群配置,在ceph-cluster目录下生成Ceph配置文件（ceph.conf）。

在ceph.conf配置文件中定义monitor主机是谁。

```shell
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
[root@node1 ceph-cluster]# vim ceph.conf        #不要修改原始内容，在文件末尾添加一行
rbd_default_features = 1
#默认开启COW分层快照的功能
```

2）初始化所有节点的mon服务，也就是启动mon服务。

拷贝当前目录的配置文件到所有节点的/etc/ceph/目录并启动mon服务。

```shell
[root@node1 ceph-cluster]# ceph-deploy mon create-initial
#配置文件ceph.conf中有三个mon的IP，ceph-deploy脚本知道自己应该远程谁
```

3) 在每个node主机查看自己的服务(注意每台主机服务名称不同)

```shell
[root@node1 ceph-cluster]# systemctl status ceph-mon@node1
[root@node2 ~]# systemctl status ceph-mon@node2
[root@node3 ~]# systemctl status ceph-mon@node3
#备注:管理员可以自己启动（start）、重启（restart）、关闭（stop），查看状态（status）.
#提醒:这些服务在30分钟只能启动3次,超过就报错. 
#StartLimitInterval=30min
#StartLimitBurst=3
#在这个文件中有定义/usr/lib/systemd/system/ceph-mon@.service
#如果修改该文件，需要执行命令# systemctl  daemon-reload重新加载配置
```

4）查看ceph集群状态（现在状态应该是health HEALTH_ERR）

```shell
[root@node1 ceph-cluster]# ceph -s
```

【提示】：如果无法成功部署ceph集群，可以通过如下命令清理集群软件以及相关数据（注意，这些操作会删除node1-node3主机的所有ceph软件及配置文件等数据，非必要不要操作！！）。

```shell
[root@node1 ceph-cluster]# ceph-deploy  purge  node1  node2  node3
[root@node1 ceph-cluster]# ceph-deploy  purgedata  node1  node2  node3
```

**步骤三：创建OSD**

1) 初始化清空磁盘数据（仅node1操作即可）。

初始化磁盘，将所有磁盘分区格式设置为GPT格式（根据实际情况填写磁盘名称）。

```shell
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdb   node1:vdc   
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdb   node2:vdc
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdb   node3:vdc  
#相当于ssh 远程node1，在node1执行parted /dev/vdb  mktable  gpt
#其他主机都是一样的操作
#ceph-deploy是个脚本，这个脚本会自动ssh远程自动创建gpt分区
```

思考题？

```shell
# vim test.sh
#!/bin/bash
case $1 in
user)
     useradd -u 1000 $2;;
disk)
     parted  /dev/$2  mktable  gpt;;
esac
# chmod +x test.sh
# ./test.sh  user  jerry
# ./test.sh  disk  vdc
```

执行上面的脚本没有指定账户UID，为什么会自动创建一个UID为1000的用户？

执行上面的脚本没有指定磁盘分区表类型，为什么创建的分区表类型为gpt类型？

上面的脚本如果执行时不给位置变量的参数为怎么样？

2）创建OSD存储空间（仅node1操作即可）

重要：很多同学在这里会出错！将主机名、设备名称输入错误！！！

远程所有node主机，创建分区，格式化磁盘，挂载磁盘，启动osd服务共享磁盘。

```shell
[root@node1 ceph-cluster]# ceph-deploy osd create node1:vdb  node1:vdc
#每个磁盘都会被自动分成两个分区；一个固定5G大小；一个为剩余所有容量
#5G分区为Journal日志缓存；剩余所有空间为数据盘。
[root@node1 ceph-cluster]# ceph-deploy osd create node2:vdb  node2:vdc
[root@node1 ceph-cluster]# ceph-deploy osd create node3:vdb  node3:vdc
```

提醒：ceph-deploy是个脚本，脚本会自动创建分区、格式化、挂载！

怎么验证分区了？怎么验证格式化？怎么验证挂载了？

```shell
[root@node1 ~]# df -Th
[root@node2 ~]# df -Th
[root@node3 ~]# df -Th
```

思考题：请问lsblk和df命令的区别？

3）在三台不同的主机查看OSD服务状态，可以开启、关闭、重启服务。

注意：注意看清楚下面的主机名！！！

```shell
[root@node1 ~]# systemctl status ceph-osd@0
[root@node2 ~]# systemctl status ceph-osd@2
[root@node3 ~]# systemctl status ceph-osd@4
#备注:管理员可以自己启动（start）、重启（restart）、关闭（stop），查看状态（status）.
#提醒:这些服务在30分钟只能启动3次,超过就报错.
#StartLimitInterval=30min
#StartLimitBurst=3
#在这个文件中有定义/usr/lib/systemd/system/ceph-osd@.service
#如果修改该文件，需要执行命令# systemctl  daemon-reload重新加载配置
```

常见错误及解决方法（非必须操作）。

使用osd create创建OSD存储空间时，如提示下面的错误提示：
[ceph_deploy][ERROR ] RuntimeError: bootstrap-osd keyring not found; run 'gatherkeys'

可以使用如下命令修复文件，重新配置ceph的密钥文件：

```shell
[root@node1 ceph-cluster]#  ceph-deploy gatherkeys node1 node2 node3 
```

**步骤四：验证测试**

1) 查看集群状态。

```shell
[root@node1 ~]#  ceph  -s
[root@node1 ~]#  ceph   osd   tree
```

2）常见错误（非必须操作）。

如果查看状态包含如下信息：

```shell
health: HEALTH_WARN
        clock skew detected on  node2, node3…  
```

clock skew表示时间不同步，解决办法：请先将所有主机的时间都使用NTP时间同步！！！

Ceph要求所有主机时差不能超过0.05s，否则就会提示WARN。

如果状态还是失败，可以尝试执行如下命令，重启所有ceph服务：

```shell
[root@node1 ~]#  systemctl restart ceph.target
```

# 3. 创建Ceph块存储

## 3.1 问题

沿用练习一，使用Ceph集群的块存储功能，实现以下目标：

- 创建块存储镜像
- 客户端映射镜像
- 删除镜像

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建镜像**

1）查看存储池，默认存储池名称为rbd。

```shell
[root@node1 ~]# ceph osd lspools
0 rbd,
#查看结果显示，共享池的名称为rbd，这个共享池的编号为0，英语词汇：pool（池塘、水塘）
```

2）创建镜像、查看镜像

```shell
[root@node1 ~]# rbd create demo-image --size 10G
#创建demo-image镜像，这里的demo-image创建的镜像名称，名称可以为任意字符。
#size可以指定镜像大小
[root@node1 ~]# rbd create rbd/jacob  --size 10G
#在rbd池中创建名称为jacob的镜像（rbd/jacob），镜像名称可以任意
[root@node1 ~]# rbd list                    #列出所有镜像
[root@node1 ~]# rbd info demo-image        #查看demo-image这个镜像的详细信息
rbd image 'demo-image':
    size 10240 MB in 2560 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3aa2ae8944a
    format: 2
    features: layering
```

步骤二：动态调整

1）扩容容量

```shell
[root@node1 ~]# rbd resize --size 15G jacob             
#调整jacob镜像的大小，jacob是镜像的名称，size指定扩容到15G
[root@node1 ~]# rbd info jacob
```

2）缩小容量

```shell
[root@node1 ~]# rbd resize --size 7G jacob --allow-shrink
#英文词汇：allow（允许），shrink（缩小）
[root@node1 ~]# rbd info jacob
#查看jacob这个镜像的详细信息（jacob是前面创建的镜像）
```

**步骤三：通过KRBD访问**

Linux内核可用直接访问Ceph块存储，KVM可用借助于librbd访问Ceph块存储。

客户端访问结构如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b3940b5e20ce48bfb90537619685c268.png)
图-6

1）客户端通过KRBD访问

```shell
#客户端需要安装ceph-common软件包
#拷贝配置文件（否则不知道集群在哪）
#拷贝连接密钥（否则无连接权限）
[root@client ~]# yum -y  install ceph-common
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.conf  /etc/ceph/
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.client.admin.keyring \
/etc/ceph/
[root@client ~]# rbd map  jacob          #客户端访问映射服务器的jacob共享镜像
[root@client ~]#  lsblk                   #查看结果（会多一块磁盘）
[root@client ~]# rbd showmapped          #查看磁盘名和共享镜像名称的对应关系
id pool image snap device    
0  rbd  jacob -    /dev/rbd0
```

2) 客户端格式化、挂载分区

```shell
[root@client ~]# mkfs.xfs /dev/rbd0                     #格式化，格式为xfs
[root@client ~]# mount /dev/rbd0 /mnt/                  #挂载（可以挂载到任意目录）
[root@client ~]# echo "test" > /mnt/test.txt           #写入数据
```

**步骤四：删除镜像**

1） 客户端撤销磁盘映射

```shell
[root@client ~]# umount /mnt                      #卸载
[root@client ~]# rbd showmapped                  #查看磁盘名和共享镜像名称的对应关系
id pool image        snap device    
0  rbd  jacob        -    /dev/rbd0
[root@client ~]# rbd unmap /dev/rbd0            #撤销磁盘映射
```

附加信息：Ceph操作思路（知识总结）

一、准备工作：

IP，主机名，hosts解析，ssh密钥，时间同步，yum源，防火墙，selinux

二、部署ceph：

1.安装软件

```shell
  ceph-deploy(脚本)
  ceph-mon  ceph-osd  ceph-mds  ceph-radosgw(集群)
```

2.修改配置启动服务mon

```shell
  mkdir  目录；cd 目录
  ceph-deploy  new  node1   node2   node3  (生成配置文件)
  ceph-deploy  mon  create-initial  (拷贝配置文件并启动mon服务)
```

3.启动osd服务共享硬盘

```shell
  ceph-deploy  disk  zap   主机名:磁盘名  ...  ...
  ceph-deploy  osd  create  主机名:磁盘   ...  ...
```

三、使用Ceph的思路:

1.块共享

```shell
  服务器: rbd  create  创建一个共享镜像
  客户端: 安装cpeh-common;  cp 配置文件和密钥
          rbd  map  |  rbd  unmap
```

附加知识（如何删除某个OSD，下面的假设是删除osd.4）

```shell
ceph osd tree
ceph osd out osd.4
ceph osd tree
ceph -s
ceph osd crush remove osd.4
ceph auth del osd.4
ceph -s
ceph osd rm osd.4
最后要找到对应的主机，umount把osd.4对应的磁盘卸载
```


# Exercise

## 1 写出Ceph核心组件？

-  OSDs：存储设备
-  Monitors：集群监控组件
-  MDSs：存放文件系统的元数据（对象存储和块存储不需要该组件）
-  RadosGW：对象存储网关

## 2 使用什么工具可以快速部署Ceph集群存储？

ceph-deploy。

## 3 Linux客户端访问Ceph块存储设备的命令？

rbd map 镜像名称。

> 如有侵权，请联系作者删除



﻿@[TOC]( Command line foundation & directory and file management & text content operation | Cloud computing )

---

# 1. 命令行基础技巧

## 1.1 问题

本例要求掌握Linux命令行环境的基本操作，完成下列任务：

1. 利用Tab键快速找出下列文件：/etc/sysconfig/network-scripts/ifcfg-*、/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release
2. 练习以下快捷编辑操作：Ctrl + l、Ctrl + u、Ctrl + w；Ctrl + c、Esc + .

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：利用Tab键快速补全文档路径**

> 1）找出现有的网络连接配置文件

```shell
[root@server0 ~]# ls /etc/sysco<TAB>
[root@server0 ~]# ls /etc/sysconfig/netw<TAB>
[root@server0 ~]# ls /etc/sysconfig/network-s<TAB>
[root@server0 ~]# ls /etc/sysconfig/network-scripts/ifc<TAB>
[root@server0 ~]# ls /etc/sysconfig/network-scripts/ifcfg-<TAB><TAB>
ifcfg-br0          ifcfg-br1          ifcfg-lo
ifcfg-br0:253      ifcfg-eno16777736
```

> 2）找出Linux校验软件包的密钥文件

[root@server0 ~]# ls /etc/pki/rp<TAB>
[root@server0 ~]# ls /etc/pki/rpm-gpg/RP<TAB>
[root@server0 ~]# ls /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-r<TAB>
[root@server0 ~]# ls /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release
/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release

**步骤二：练习以下快捷编辑操作**

> 1）清理编辑的命令行

快速清屏：Ctrl + l

从当前光标处删除到行首：Ctrl + u

从当前光标处往前删除一个单词：Ctrl + w

> 2）放弃编辑的命令行

中止当前命令行：Ctrl + c

> 3）参数复用

在当前光标处粘贴上一条命令行的最后一个参数：Esc + .

# 2. 挂载并访问光盘设备

## 2.1 问题

本例要求学会mount挂载操作。主要完成下列任务：

1. 连接光盘CentOS7-1804.iso
2. 将光盘挂载到 /mnt 目录，检查 /mnt 目录内容
3. 卸载光盘设备，再次检查目录内容

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用ls命令列出指定的文件**

> 1）连接光盘 CentOS7-1804.iso

```shell
[root@server0 ~]# mount  /dev/cdrom  /mnt     //挂载设备
mount: /dev/sr0 写保护，将以只读方式挂载
```

> 2）将光盘挂载到 /mnt 目录，检查 /mnt 目录内容

```shell
[root@server0 ~]# ls  /mnt                 //访问设备内容
addons  images      Packages         RPM-GPG-KEY-redhat-release
EFI     isolinux    release-notes    TRANS.TBL
EULA    LiveOS      repodata
GPL     media.repo  RPM-GPG-KEY-redhat-beta
```

> 3）卸载光盘设备，再次检查目录内容

```shell
[root@server0 ~]# umount  /mnt/        //卸载设备
[root@server0 ~]# ls  /mnt/             //确认结果
```

# 3. ls列表及文档创建

## 3.1 问题

本例要求学会列表查看目录内容、新建文档相关技能，并熟悉通配符机制的应用。主要完成下列任务：

1. 使用ls命令列出指定的文件：/etc/目录下以re开头.conf结尾的文件、/dev/目录下编号是个位数的tty控制台设备
2. 一条命令创建文件夹 /protected/project/tts10

## 3.2 方案

对于通配符使用，需理解每个通配符的作用：

- *：任意多个任意字符
- ?：单个字符
- [a-z]：多个字符或连续范围中的一个，若无则忽略
- {a,min,xy}：多组不同的字符串，全匹配

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用ls命令列出指定的文件**

> 1）列出/etc/目录下以re开头.conf结尾的文件

使用通配符 * 代替未知的字符串。

```shell
[root@server0 ~]# ls /etc/re*.conf
/etc/request-key.conf  /etc/resolv.conf
```

> 2）列出/dev/目录下编号是个位数的tty控制台设备

使用通配符 ? 代替单个未知的字符。

```shell
[root@server0 ~]# ls /dev/tty?
/dev/tty0  /dev/tty2  /dev/tty4  /dev/tty6  /dev/tty8
/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty7  /dev/tty9
```

或者更严谨一些，使用 [0-9] 代替单个数字。

```shell
[root@server0 ~]# ls /dev/tty[0-9]
/dev/tty0  /dev/tty2  /dev/tty4  /dev/tty6  /dev/tty8
/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty7  /dev/tty9
```

**步骤二：新建文档**

> 1）使用mkdir新建文件夹

```shell
[root@server0 ~]# mkdir -p /protected/project/tts10
[root@server0 ~]# ls -ld /protected/project/tts10/
drwxr-xr-x. 2 root root 6 Aug 30 10:11 /protected/project/tts10/
```

# 4 案例4：复制、删除、移动

## 4.1 问题

本例要求学会对文档进行复制、删除、移动/改名相关操作，依次完成下列任务：

- 在当前目录下创建一个子目录 dir1
- 将文件夹 /boot/grub2/ 复制到目录dir1下
- 将目录 /root/ 下以 .cfg 结尾的文件复制到dir1下
- 将文件 /etc/redhat-release复制到 /root/ 下，同时改名为 version.txt
- 将文件 /root/version.txt 移动到dir1目录下
- 删除 dir1 目录下的 grub2 子目录

## 4.2 步骤

实现此案例需要按照如下步骤进行。

> 1）在当前目录下创建一个子目录 dir1

```shell
[root@server0 ~]# mkdir dir1
```

> 2）将文件夹 /boot/grub2/ 复制到目录dir1下

```shell
[root@server0 ~]# cp -r /boot/grub2/ dir1/
[root@server0 ~]# ls -ld dir1/*                                 //检查复制结果
drwxr-xr-x. 6 root root 104 Aug 30 10:27 dir1/grub2
```

> 3）将目录 /root/ 下以 .cfg 结尾的文件复制到dir1下

```shell
[root@server0 ~]# cp /root/*.cfg dir1/
[root@server0 ~]# ls -ld dir1/*                                 //检查复制结果
-rw-------. 1 root root 16793 Aug 30 10:29 dir1/anaconda-ks.cfg
drwxr-xr-x. 6 root root   104 Aug 30 10:27 dir1/grub2
```

> 4）将文件 /etc/redhat-release复制到 /root/ 下，同时改名为 version.txt

```shell
[root@server0 ~]# cp /etc/redhat-release /root/version.txt
[root@server0 ~]# ls -ld /root/version.txt                  //检查复制结果
-rw-r--r--. 1 root root 52 Aug 30 10:30 /root/version.txt
```

> 5）将文件 /root/version.txt 移动到dir1目录下

```shell
[root@server0 ~]# cp /root/version.txt dir1/
[root@server0 ~]# ls -ld dir1/*                             //检查移动/改名结果
-rw-------. 1 root root 16793 Aug 30 10:29 dir1/anaconda-ks.cfg
drwxr-xr-x. 6 root root   104 Aug 30 10:27 dir1/grub2
-rw-r--r--. 1 root root    52 Aug 30 10:31 dir1/version.txt
```

> 6）删除 dir1 目录下的grub2子目录

```shell
[root@server0 ~]# rm -rf dir1/grub2/
[root@server0 ~]# ls -ld dir1/*                             //检查删除结果
-rw-------. 1 root root 16793 Aug 30 10:29 dir1/anaconda-ks.cfg
-rw-r--r--. 1 root root    52 Aug 30 10:31 dir1/version.txt
```

# 5. 文本内容操作

## 5.1 问题

本例要求学会对文档进行复制、删除、移动/改名相关操作，依次完成下列任务：

- 在根目录下创建一个子目录 tedu
- 利用vim建立文件/tedu/stu.txt并写入内容“I Love Goddess”
- 利用grep过滤/etc/passwd中包含root的行
- 利用grep过滤/etc/passwd中以bash结尾的行

## 5.2 方案

 - vim是Linux系统上最常用的命令行交互式文本编辑器，主要工作在三种模式：命令模式、输入模式、末行模式。
- 通过vim打开一个文件时，默认处于命令模式；从命令模式按i键可以进入编辑状态，按Esc键返回命令模式；从命令模式输入冒号:可以进入末行模式，在末行模式下主要执行wq存盘与退出等基本操作。

## 5.3 步骤

实现此案例需要按照如下步骤进行。

> 1）在根目录下创建一个子目录 tedu

```shell
[root@server0 ~]# mkdir /tedu
```

> 2）利用vim建立文件/tedu/stu.txt并写入内容“I Love Goddess”

```shell
[root@server0 ~]# vim   /tedu/stu.txt
I Love Goddess 
```

> 3）利用grep过滤/etc/passwd中包含root的行

```shell
[root@server0 ~]# grep   root   /etc/passwd
```

> 4）利用grep过滤/etc/passwd中以bash结尾的行

```shell
[root@server0 ~]# grep   bash$   /etc/passwd
```

# Exercise

## 1 简述一条Linux命令行的一般组成格式

命令字 [选项]… [参数1] [参数2]…

## 2 简述绝对路径、相对路径的含义

绝对路径：以 / 开始的完整路径
相对路径：以当前工作目录为参照的路径

## 3 linux命令行常用的通配符有哪些，各自的作用是什么

针对不确定的文档名称，以特殊字符表示。

- *：任意多个任意字符
- ?：单个字符
- [a-z]：多个字符或连续范围中的一个，若无则忽略
- {a,min,xy}：多组不同的字符串，全匹配

## 4 删除文件/etc/resolv.conf，然后用vim重建此文件

> 1）确认文件原有的内容

```shell
[root@svr7 ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
search ilt.example.com example.com
nameserver 172.25.254.250
```

> 2）删除文件

```shell
[root@svr7 ~]# rm -rf /etc/resolv.conf 
[root@svr7 ~]# ls -l /etc/resolv.conf                         //检查删除结果
ls: cannot access /etc/resolv.conf: No such file or directory
```

> 3）用vim重建此文件

```shell
[root@svr7 ~]# vim /etc/resolv.conf                         //保留有效配置即可
search ilt.example.com example.com
nameserver 172.25.254.250
[root@svr7 ~]# cat /etc/resolv.conf                         //检查重建结果
search ilt.example.com example.com
nameserver 172.25.254.250
```


> 如有侵权，请联系作者删除



﻿@[TOC]( Comprehensive project & network upgrade | Cloud computing )

---

# 1 案例：综合网络搭建

## 1.1 问题

现有网络问题分析：

- 接入层交换机只与同一个三层交换机相连，存在单点故障而影响网络通信。
- 互联网连接单一服务商

现有网络需求：

- 随着企业发展，为了保证网络的高可用性，需要使用很多的冗余技术
- 保证局域网络不会因为线路故障而导致的网络故障
- 保证客户端机器不会因为使用单一网关而出现的单点失败
- 保证到互联网的高可用接入使用冗余互联网连接

## 1.2 方案

基于项目的需求，需要用到如下技术：

- OSPF路由协议：实现网络路径的自动学习
- VRRP：实现网关冗余

重新规划后的网络拓扑如图-1：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c24b30db9ac04b1db7791e8cefa89a16.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行，为了配置过程中不被弹出信息干扰，可以关闭信息提示

**步骤一：S3700交换机配置**

```shell
SW1配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet 0/0/1 to Ethernet 0/0/2
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Ethernet 0/0/5
[Huawei-Ethernet0/0/5] port link-type access
[Huawei-Ethernet0/0/5] port default vlan 10
SW2配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet 0/0/1 to Ethernet 0/0/2
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Ethernet 0/0/5
[Huawei-Ethernet0/0/5] port link-type access
[Huawei-Ethernet0/0/5] port default vlan 20
SW3配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet 0/0/1 to Ethernet 0/0/2
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Ethernet 0/0/5
[Huawei-Ethernet0/0/5] port link-type access
[Huawei-Ethernet0/0/5] port default vlan 30
SW4配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet 0/0/1 to Ethernet 0/0/2
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Ethernet 0/0/5
[Huawei-Ethernet0/0/5] port link-type access
[Huawei-Ethernet0/0/5] port default vlan 40
```

**步骤二：S5700交换机配置**

```shell
MS1配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40 50 60
[Huawei]port-group 1
[Huawei-port-group-1]group-member GigabitEthernet 0/0/1 to GigabitEthernet 0/0/5
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Vlanif 10
[Huawei-Vlanif10]ip address 192.168.10.252 24
[Huawei-Vlanif10]vrrp vrid 1 virtual-ip 192.168.10.254
[Huawei-Vlanif10]vrrp vrid 1 priority 110
[Huawei]interface Vlanif 20
[Huawei-Vlanif20]ip address 192.168.20.252 24
[Huawei-Vlanif20]vrrp vrid 2 virtual-ip 192.168.20.254
[Huawei-Vlanif20]vrrp vrid 2 priority 110
[Huawei]interface Vlanif 30
[Huawei-Vlanif30]ip address 192.168.30.252 24
[Huawei-Vlanif30]vrrp vrid 3 virtual-ip 192.168.30.254
[Huawei]interface Vlanif 40
[Huawei-Vlanif40]ip address 192.168.40.252 24
[Huawei-Vlanif40]vrrp vrid 4 virtual-ip 192.168.40.254
[Huawei]interface Vlanif 50
[Huawei-Vlanif50]ip address 192.168.50.2 24
[Huawei]interface GigabitEthernet 0/0/23
[Huawei-GigabitEthernet0/0/23]port link-type access
[Huawei-GigabitEthernet0/0/23]port default vlan 50
[Huawei]interface Vlanif 60
[Huawei-Vlanif60]ip address 192.168.60.2 24
[Huawei]interface GigabitEthernet 0/0/24
[Huawei-GigabitEthernet0/0/24]port link-type access
[Huawei-GigabitEthernet0/0/24]port default vlan 60
[Huawei]ospf    
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.10.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.30.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.40.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.50.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.60.0 0.0.0.255
MS2配置
<Huawei>system-view
[Huawei]vlan batch 10 20 30 40 70 80
[Huawei]port-group 1
[Huawei-port-group-1]group-member GigabitEthernet 0/0/1 to GigabitEthernet 0/0/5
[Huawei-port-group-1]port link-type  trunk
[Huawei-port-group-1]port trunk allow-pass vlan all
[Huawei-port-group-1]quit
[Huawei]interface Vlanif 10
[Huawei-Vlanif10]ip address 192.168.10.253 24
[Huawei-Vlanif10]vrrp vrid 1 virtual-ip 192.168.10.254
[Huawei]interface Vlanif 20
[Huawei-Vlanif20]ip address 192.168.20.253 24
[Huawei-Vlanif20]vrrp vrid 2 virtual-ip 192.168.20.254
[Huawei]interface Vlanif 30
[Huawei-Vlanif30]ip address 192.168.30.253 24
[Huawei-Vlanif30]vrrp vrid 3 virtual-ip 192.168.30.254
[Huawei-Vlanif20]vrrp vrid 3 priority 110
[Huawei]interface Vlanif 40
[Huawei-Vlanif40]ip address 192.168.40.253 24
[Huawei-Vlanif40]vrrp vrid 4 virtual-ip 192.168.40.254
[Huawei-Vlanif20]vrrp vrid 4 priority 110
[Huawei]interface Vlanif 70
[Huawei-Vlanif70]ip address 192.168.70.2 24
[Huawei]interface GigabitEthernet 0/0/23
[Huawei-GigabitEthernet0/0/23]port link-type access
[Huawei-GigabitEthernet0/0/23]port default vlan 70
[Huawei]interface Vlanif 80
[Huawei-Vlanif80]ip address 192.168.80.2 24
[Huawei]interface GigabitEthernet 0/0/24
[Huawei-GigabitEthernet0/0/24]port link-type access
[Huawei-GigabitEthernet0/0/24]port default vlan 80
[Huawei]ospf    
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.10.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.30.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.40.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.70.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.80.0 0.0.0.255
```

然后测试目前网络是否可以达成全网互通

**步骤三：路由器配置**

按图-2为路由器与三层交换机相连的接口配置ip

注:50.1表示ip需要配置为192.168.50.1

![在这里插入图片描述](https://img-blog.csdnimg.cn/72f24969742c4ab6a4141e79c23d3e05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-2

```shell
R1
<Huawei>system-view 
[Huawei]acl 2000    
[Huawei-acl-basic-2000]rule permit source any 
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 192.168.50.1 24
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.70.1 24
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]ip address 100.0.0.1 8
[Huawei-GigabitEthernet0/0/2]nat outbound 2000
[Huawei-GigabitEthernet0/0/2]quit
[Huawei]ip route-static 0.0.0.0 0 100.0.0.10
[Huawei]ospf
[Huawei-ospf-1]default-route-advertise      //对外通告默认路由
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.50.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.70.0 0.0.0.255
R2
<Huawei>system-view 
[Huawei]acl 2000    
[Huawei-acl-basic-2000]rule permit source any 
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 192.168.60.1 24
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.80.1 24
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]ip address 100.0.0.2 8
[Huawei-GigabitEthernet0/0/0]nat outbound 2000
[Huawei-GigabitEthernet0/0/2]quit
[Huawei]ip route-static 0.0.0.0 0 100.0.0.10
[Huawei]ospf
[Huawei-ospf-1]default-route-advertise 
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.60.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.80.0 0.0.0.255
```

三层交换机如果看不到从路由器学习来的默认路由就去检查路由器G0/2地址是否配置，之后验证从内网可以访问外网设备，ping通证明项目升级成功


# Exercise

> 如有侵权，请联系作者删除



﻿@[TOC]( Computer networks & network communication reference model & switch command line & switch command line configuration & data link layer resolution | Cloud computing )

---

# 1. eNSP软件与交换机命令行

## 1.1 问题

- 熟悉eNSP软件的使用
- 熟悉交换机的命令行视图
- 熟悉交换机视图间的转换

## 1.2 方案

在eNSP程序主窗口中，添加一台s3700交换机，进入交换机，输入相关命令进行配置和查看交换机

## 1.3 步骤

实现此案例需要按照如下步骤进行

**步骤一：改变命令行视图**

```shell
<Huawei>system-view             //进入系统视图
[Huawei]interface Ethernet0/0/1    //进入接口视图
[Huawei-Ethernet0/0/1]quit    //返回上一视图
[Huawei]
[Huawei]interface Ethernet0/0/1    //再次进入接口视图
[Huawei-Ethernet0/0/1]return     //返回用户视图
<Huawei>
```

# 2. 访问及配置交换机

## 2.1 问题

- 修改交换机主机名
- 查看交换机VRP版本
- 查看交换机配置
- 使用账户和密码登录终端
- 保存交换机的配置
- 恢复设备出厂默认值

## 2.2 方案

在eNSP程序主窗口中，添加一台s3700交换机，进入交换机，输入相关命令进行配置和查看交换机

## 2.3 步骤

实现此案例需要按照如下步骤进行

**步骤一：修改交换机主机名**

进入系统视图后，使用sysname指令可以为交换机设置主机名。例如，以下操作可以将主机名设置为SW1

```shell
<Huawei>system-view 
[Huawei]sysname SW1
[SW1]
```

**步骤二：显示VRP版本**

```shell
[Huawei]display version 
Huawei Versatile Routing Platform Software
VRP (R) software, Version 5.110 (S3700 V200R001C00)
Copyright (c) 2000-2011 HUAWEI TECH CO., LTD
Quidway S3700-26C-HI Routing Switch uptime is 0 week, 0 day, 0 hour, 17 minutes
```

**步骤三：查看交换机配置**

查看ios名称及版本信息

```shell
[Huawei]display current-configuration 
#
sysname Huawei
#
cluster enable
ntdp enable
ndp enable
#
drop illegal-mac alarm
#
diffserv domain default
#
drop-profile default
#
```

**步骤四：使用账户和密码登录终端**

```shell
<Huawei>system-view 
[Huawei]aaa
[Huawei-aaa]local-user admin01 password cipher 123    //创建账户叫admin01,密码123       
[Huawei-aaa]quit
[Huawei]user-interface console 0        
[Huawei-ui-console0]authentication-mode aaa        //激活配置
```

步骤五：保存交换机的配置

```shell
<Huawei>save        
The current configuration will be written to the device.
Are you sure to continue?[Y/N]y                    //这里按y确认
Info: Please input the file name ( *.cfg, *.zip ) [vrpcfg.zip]:
Mar 12 2019 19:12:18-08:00 Huawei %%01CFM/4/SAVE(l)[0]:The user chose Y when dec
iding whether to save the configuration to the device.
Now saving the current configuration to the slot 0.
Save the configuration successfully.
```

**步骤六：恢复设备出厂默认值**

```shell
<Huawei>reset saved-configuration     //重置配置文件
Warning: The action will delete the saved configuration in the device.
The configuration will be erased to reconfigure. Continue? [Y/N]:y    //是否擦除，回答y
Warning: Now clearing the configuration in the device.
Mar 12 2019 19:13:50-08:00 Huawei %%01CFM/4/RST_CFG(l)[1]:The user chose Y when 
deciding whether to reset the saved configuration.
Info: Succeeded in clearing the configuration in the device.
<Huawei>reboot        //重启设备
Info: The system is now comparing the configuration, please wait.
Warning: All the configuration will be saved to the configuration file for the n
ext startup:, Continue?[Y/N]:n            //提示是否再次保存，选择n
Info: If want to reboot with saving diagnostic information, input 'N' and then e
xecute 'reboot save diagnostic-information'.
System will reboot! Continue?[Y/N]:y    //是否重启，选择y
```

# 3. 验证交换机工作原理

## 3.1 问题

通过2台交换机以及4台pc设备分析交换机工作原理

## 3.2 方案

实现此目的需要先搭建拓扑，如图-1所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/7d3b2cf4498d490d9677b74e809550cd.png)
图-1

## 3.3 步骤

**步骤一：pc设备配置**

为不同pc设置ip地址与子网掩码，分别是192.168.0.1/24~192.168.0.4/24，配置完毕点击右下角应用，如图-2所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/3ece6a2fa3124bf694a05c44692cf181.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-2

**步骤二：通过pc设备的命令行界面使用ping命令对其他设备发起访问**

如图-3所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/b653e4cb175a48c1abf44c369ec7a484.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-3

**步骤三：在交换机中查看MAC地址表**

```shell
[Huawei]display mac-address
MAC address table of slot 0:
-------------------------------------------------------------------------------
MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  
               VSI/SI                                              MAC-Tunnel  
-------------------------------------------------------------------------------
5489-987d-68c4 1           -      -      Eth0/0/1        dynamic   0/-         
5489-9806-61a2 1           -      -      Eth0/0/2        dynamic   0/-         
5489-98d8-3d5d 1           -      -      Eth0/0/3        dynamic   0/-         
5489-98d3-6953 1           -      -      Eth0/0/3        dynamic   0/-         
-------------------------------------------------------------------------------
```

# Exercise

## 1 请描述计算机网络的功能

数据通信
资源共享
增加可靠性
提高系统处理能力

## 2 计算机网络发展过程中，70-80年代诞生了什么标志性技术

TCP/IP

## 3 常见网络拓扑结构有哪些？

星型
网状

## 4 OSI的七层与TCP/IP的五层参考模型分别是

物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

物理层，数据链路层，网络层，传输层，应用层

## 5 华为路由交换设备常见的命令行视图有哪些？

用户视图，系统视图，接口视图，协议视图

## 6 请描述交换机工作原理

学习，MAC地址表是交换机通过学习接收的数据帧的源MAC地址来形成的

广播，如果目标地址在MAC地址表中没有，交换机就向除接收到该数据帧的接口外的其他所有接口广播该数据帧

转发，交换机根据MAC地址表单播转发数据帧

更新，交换机MAC地址表的老化时间是300秒，交换机如果发现一个帧的入接口和MAC地址表中源MAC地址的所在接口不同，交换机将MAC 地址重新学习到新的接口


> 如有侵权，请联系作者删除



﻿@[TOC]( Conditional testing, if selection structure & loop structure | Cloud computing )

---

# 1. 条件测试操作

## 1.1 问题

本案例要求参考PPT上的示例，分别练习以下条件测试操作：

- 字符串匹配
- 比较整数值的大小
- 识别文件/目录的状态
- 多个条件/操作的逻辑组合

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：条件测试的基本用法**

1）语法格式

使用“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。

条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即 \$?），所以可以在测试后查看变量\$?的值来做出判断，或者结合\&\&、||等逻辑操作显示出结果（或作其他操作） 。

**步骤二：字符串测试**

1）== 比较两个字符串是否相同

检查当前用户是否为root。

当root用户执行时：

```shell
[root@svr5 ~]# [ $USER == "root" ]         //测试
[root@svr5 ~]# echo $?                    //查看结果0为对，非0为错
```

当普通用户执行时：

```shell
[zengye@svr5 ~]$ [ $USER == "root" ]
[zengye@svr5 ~]$ echo $?                    //查看结果0为对，非0为错
```

2）!= 比较两个字符串是否不相同

当普通用户执行时：

```shell
[zengye@svr5 ~]$ [ $USER != "root" ] 
```

当root用户执行时：

```shell
[root@svr5 ~]# [ $USER != "root" ]
```

3）一行执行多条命令的情况

```shell
# A && B                        //仅当A命令执行成功，才执行B命令
# A || B                        //仅当A命令执行失败，才执行B命令
# A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系
# A && B || C                   //思考？
```

4) -z 检查变量的值是否未设置（空值）

```shell
[root@svr5 ~]# var1="nb" ; var2=""
[root@svr5 ~]# [ -z "$var1" ] && echo "空值" || echo "非空值"
非空值
[root@svr5 ~]# [ -z $var2 ] && echo "空值" || echo "非空值"
空值                                      //变量var2已设置，但无任何值，视为空
[root@svr5 ~]# [ ! -z $var1 ]                //测试var1是否为非空
```

还有一个-n可以测试变量是否不为空（相当于! -z）。

**步骤三：整数值比较**

参与比较的必须是整数（可以调用变量），比较非整数值时会出错：

```shell
[root@svr5 ~]# A=20.4
[root@svr5 ~]# [ $A -gt 10 ]                  //不支持小数比较
-bash: [: 20.4: integer expression expected
```

1）-eq 比较两个数是否相等。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -eq 20 ] && echo "相等" || echo "不相等"
相等
[root@svr5 ~]# [ $X -eq 30 ] && echo "相等" || echo "不相等"
不相等
```

2）-ne 比较两个数是否不相等。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -ne 20 ] && echo "不等于" || echo "等于"
等于
[root@svr5 ~]# [ $X -ne 30 ] && echo "不等于" || echo "等于"
不等于
```

3）-gt 比较前面的整数是否大于后面的整数。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -gt 10 ] && echo "大于" || echo "否"
大于
[root@svr5 ~]# [ $X -gt 20 ] && echo "大于" || echo "否"
否
[root@svr5 ~]# [ $X -gt 30 ] && echo "大于" || echo "否"
否
```

4）-ge 比较前面的整数是否大于或等于后面的整数。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -ge 10 ] && echo "大于或等于" || echo "否"
大于或等于
[root@svr5 ~]# [ $X -ge 20 ] && echo "大于或等于" || echo "否"
大于或等于
[root@svr5 ~]# [ $X -ge 30 ] && echo "大于或等于" || echo "否"
否
```

5）-lt 比较前面的整数是否小于后面的整数。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -lt 10 ] && echo "小于" || echo "否"
否
[root@svr5 ~]# [ $X -lt 20 ] && echo "小于" || echo "否"
否
[root@svr5 ~]# [ $X -lt 30 ] && echo "小于" || echo "否"
小于
```

6）-le 比较前面的整数是否小于或等于后面的整数。

```shell
[root@svr5 ~]# X=20                          //定义一个测试变量
[root@svr5 ~]# [ $X -le 10 ] && echo "小于或等于" || echo "否"
否
[root@svr5 ~]# [ $X -le 20 ] && echo "小于或等于" || echo "否"
小于或等于
[root@svr5 ~]# [ $X -le 30 ] && echo "小于或等于" || echo "否"
小于或等于
```

7）提取当前登录的用户数，比较是否大于等于3。

```shell
[root@svr5 ~]# who | wc -l                                  //确认已登录的用户数
2
[root@svr5 ~]# N=$(who | wc -l)                              //赋值给变量N
[root@svr5 ~]# [ $N -ge 3 ] && echo "超过了" || echo "没超过"
没超过
```

上述赋值给变量N及与3比较的操作，可以简化为如下形式：

```shell
[root@svr5 ~]# [ $(who | wc -l) -ge 3 ] && echo "超过了" || echo "没超过"
没超过
```

**步骤四：识别文件/目录的状态**

1）-e 判断对象是否存在（不管是目录还是文件）

```shell
[root@svr5 ~]# [ -e "/usr/" ] && echo "存在" || echo "不存在"
存在
[root@svr5 ~]# [ -e "/etc/fstab" ] && echo "存在" || echo "不存在"
存在
[root@svr5 ~]# [ -e "/home/nooby" ] && echo "存在" || echo "不存在"
不存在
```

2）-d 判断对象是否为目录（存在且是目录）

```shell
[root@svr5 ~]# [ -d "/usr/" ] && echo "是目录" || echo "不是目录"
是目录
[root@svr5 ~]# [ -d "/etc/fstab" ] && echo "是目录" || echo "不是目录"
不是目录
[root@svr5 ~]# [ -d "/home/nooby" ] && echo "是目录" || echo "不是目录"
不是目录
```

3）-f 判断对象是否为文件（存在且是文件）

```shell
[root@svr5 ~]# [ -f "/usr/" ] && echo "是文件" || echo "不是文件"
不是文件
[root@svr5 ~]# [ -f "/etc/fstab" ] && echo "是文件" || echo "不是文件"
是文件
[root@svr5 ~]# [ -f "/home/nooby" ] && echo "是文件" || echo "不是文件"
不是文件
```

4）-r 判断对象是否可读

此测试对root用户无效，无论文件是否设置r权限，root都可读：

```shell
[root@svr5 ~]# cp /etc/hosts /tmp/test.txt          //复制一个文件做测试
[root@svr5 ~]# chmod -r /tmp/test.txt              //去掉所有的r权限
[root@svr5 ~]# [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
可读                                              //root测试结果仍然可读
切换为普通用户，再执行相同的测试，结果变为“不可读”：

[zengye@svr5 ~]$ [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
不可读
```

5）-w 判断对象是否可写

此测试同样对root用户无效，无论文件是否设置w权限，root都可写：

```shell
[root@svr5 ~]# chmod -w /tmp/test.txt             //去掉所有的w权限
[root@svr5 ~]# ls -l /tmp/test.txt              //确认设置结果
---------- 1 root root 33139 12-11 10:43 /tmp/test.txt
[root@svr5 ~]# [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
可写
```

切换为普通用户，可以正常使用-w测试：

```shell
[zengye@svr5 ~]$ ls -l /tmp/test.txt
---------- 1 root root 33139 12-11 10:52 /tmp/test.txt
[zengye@svr5 ~]$ [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
不可写
```

6）-x 判断对象是否具有可执行权限

这个取决于文件本身、文件系统级的控制，root或普通用户都适用：

```shell
[root@svr5 ~]# chmod 644 /tmp/test.txt          //重设权限，无x
[root@svr5 ~]# ls -l /tmp/test.txt              //确认设置结果
-rw-r--r-- 1 root root 33139 12-11 10:52 /tmp/test.txt
[root@svr5 ~]# [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
不可执行
[root@svr5 ~]# chmod +x /tmp/test.txt          //添加x权限
[root@svr5 ~]# [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
可执行
```

**步骤五：多个条件/操作的逻辑组合**

1）&&，逻辑与

给定条件必须都成立，整个测试结果才为真。

检查变量X的值是否大于10，且小于30：

```shell
[root@svr5 ~]# X=20                      //设置X变量的值为20
[root@svr5 ~]# [ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
YES
```

2）||，逻辑或

只要其中一个条件成立，则整个测试结果为真。

只要/tmp/、/var/spool/目录中有一个可写，则条件成立：

```shell
[root@svr5 ~]# [ -w "/tmp/" ] || [ -w "/var/spool/" ] && echo "OK"
OK
```

# 2. 使用if选择结构

## 2.1 问题

本案例要求编写3个Shell脚本，分别实现以下目标：

- 检测/media/cdrom目录，若不存在则创建
- 检测并判断指定的主机是否可ping通
- 从键盘读取一个论坛积分，判断论坛用户等级，等级分类如下:

大于等于90 神功绝世
大于等于80，小于90 登峰造极
大于等于70，小于80 炉火纯青
大于等于60，小于70 略有小成
小于60 初学乍练

## 2.2 方案

if单分支的语法组成：

```shell
if  条件测试
then  
命令序列
fi
```

if双分支的语法组成：

```shell
if  条件测试
then
命令序列1
else  
命令序列2
fi
```

if多分支的语法组成：

```shell
if    条件测试1 ;then  
命令序列1
elif  条件测试2 ;then  
命令序列2
else
命令序列n
fi
```

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：检测/media/cdrom目录，若不存在则创建**

1）编写脚本如下：

```shell
[root@svr5 ~]# vim mountdir.sh 
#!/bin/bash
dir="/media/cdrom/"
if [ ! -d $dir ]
then
    mkdir -p $dir
fi 
[root@svr5 ~]# chmod +x mountdir.sh                  //添加可执行权限
```

2）测试、验证脚本功能

```shell
[root@svr5 ~]# ls -ld /media/cdrom                  //本来没有/media/cdrom目录
ls: /media/cdrom: 没有那个文件或目录
[root@svr5 ~]# ./mountdir.sh                          //执行脚本
[root@svr5 ~]# ls -ld /media/cdrom                  //再检查已经有了
drwxr-xr-x 2 root root 4096 12-11 15:16 /media/cdrom
```

有了/media/cdrom文件夹以后，再次执行上述脚本，实际上不做任何有效操作：

```shell
[root@svr5 ~]# ./mountdir.sh
```

**步骤二：检测并判断指定的主机是否可ping通**

1）分析任务需求

使用ping命令检测目标主机时，人工可直接判断反馈结果，而脚本却不方便。但是当ping测试成功时，执行状态$?的值为0；而ping测试失败时，\$?的值不为0。因此在Shell脚本中可以利用这一点来判断ping目标主机的成败。

为了节省ping测试时间，可以只发送3个测试包（-c 3）、缩短发送测试包的间隔秒数（-i 0.2）、等待反馈的超时秒数（-W 1）。比如，检查可ping通的主机：

```shell
[root@svr5 ~]# ping -c 3 -i 0.2 -W 1 192.168.4.5
PING 192.168.4.5 (192.168.4.5) 56(84) bytes of data.
64 bytes from 192.168.4.5: icmp_seq=1 ttl=64 time=0.131 ms
64 bytes from 192.168.4.5: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.4.5: icmp_seq=3 ttl=64 time=0.073 ms
--- 192.168.4.5 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 402ms
rtt min/avg/max/mdev = 0.073/0.093/0.131/0.027 ms
[root@svr5 ~]# echo $?                                  //执行状态表示成功
0
```

2）脚本编写参考如下：

```shell
[root@svr5 ~]# vim pinghost.sh 
#!/bin/bash
ping -c 3 -i 0.2 -W 1 $1 &> /dev/null
if [ $? -eq 0 ] ; then
    echo "Host $1 is up."
else
    echo "Host $1 is down."
fi
[root@svr5 ~]# chmod +x pinghost.sh 
```

3）测试、验证脚本功能

```shell
[root@svr5 ~]# ./pinghost.sh 192.168.4.5
Host 192.168.4.5 is up.
[root@svr5 ~]# ./pinghost.sh 192.168.4.50
Host 192.168.4.50 is down.
```

**步骤三：从键盘读取一个论坛积分，判断论坛用户等级**

1）脚本编写参考如下：

大于等于90 神功绝世
大于等于80，小于90 登峰造极
大于等于70，小于80 炉火纯青
大于等于60，小于70 略有小成
小于60 初学乍练

```shell
[root@svr5 ~]# vim grade.sh 
#!/bin/bash
read -p "请输入积分（0-100）：" JF
if [ $JF -ge 90 ] ; then
    echo "$JF 分，神功绝世"
elif [ $JF -ge 80 ] ; then
    echo "$JF 分，登峰造极"
elif [ $JF -ge 70 ] ; then
    echo "$JF 分，炉火纯青"
elif [ $JF -ge 60 ] ; then
    echo "$JF 分，略有小成"
else
    echo "$JF 分，初学乍练"
fi
[root@svr5 ~]# chmod +x grade.sh
```

3）测试、验证脚本

```shell
[root@svr5 ~]# ./grade.sh 
请输入积分（0-100）：74
74 分，炉火纯青
[root@svr5 ~]# ./grade.sh 
请输入分数（0-100）：68
68 分，略有小成
[root@svr5 ~]# ./grade.sh 
请输入分数（0-100）：87
87 分，登峰造极
```

# 3. 使用for循环结构

## 3.1 问题

本案例要求编写一个Shell脚本chkhosts.sh，利用for循环来检测多个主机的存活状态，相关要求及说明如下：

- 对192.168.4.0/24网段执行ping检测
- 脚本能遍历ping各主机，并反馈存活状态
  执行检测脚本以后，反馈结果如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd4a645e95e94d6bb2597d1bd6d8dc59.png)
图-1

## 3.2 方案

在Shell脚本应用中，常见的for循环采用遍历式、列表式的执行流程，通过指定变量从值列表中循环赋值，每次复制后执行固定的一组操作。

for循环的语法结构如下所示：

```shell
for  变量名  in  值列表
do
    命令序列
done
for  变量名  in  {1..5}
do
    命令序列
done
for  变量名  in  `seq 5`
do
    命令序列
done
for  变量名  in  `ls /etc/*.conf`
do
    命令序列
done
```

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习for循环基本用法**

脚本1，通过循环批量显示5个hello world：

```shell
[root@svr5 ~]# vim for01.sh
#!/bin/bash
for i in 1 2 3 4 5
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x for01.sh
[root@svr5 ~]# ./for01.sh
```

脚本2，通过循环批量显示10个hello world：

```shell
[root@svr5 ~]# vim for02.sh
#!/bin/bash
for i in {1..10}
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x for02.sh
[root@svr5 ~]# ./for02.sh
```

脚本3，通过循环批量显示10个数字：

```shell
[root@svr5 ~]# vim for03.sh
#!/bin/bash
for i in {1..10}
do
        echo "$i"
done
[root@svr5 ~]# chmod +x for03.sh
[root@svr5 ~]# ./for03.sh
```

**步骤二：批量检测多个主机的存活状态**

1）编写脚本如下：

命令备注：ping命令可以测试某台主机的连通性，
使用-c选项可以设置ping的次数，
使用-i选项可以设置多次ping之间的间隔时间（单位秒），
使用-W选项可以设置ping不通时的超时时间（单位秒）。

```shell
[root@svr5 ~]# vim chkhosts.sh
#!/bin/bash
for i in {1..254}
do
    ping -c 3 -i 0.2 -W 1 192.168.4.$i &> /dev/null
    if [ $? -eq 0 ] ; then
        echo "Host 192.168.4.$i is up."
    else
        echo "Host 192.168.4.$i is down."
    fi
done
[root@svr5 ~]# chmod +x chkhosts.sh
```

4）测试、验证脚本

```shell
… …
[root@svr5 ~]# ./chkhosts.sh
Host 192.168.4.5 is up.
Host 192.168.4.6 is down
… …
```

**步骤三：创建账户的案例**

创建users.txt，写入无规律的账户名称，最后使用for循环读取该文件，批量创建账户并设置密码。

```shell
[root@svr5 ~]# vim addfor.sh
#!/bin/bash
for i in `cat /root/user.txt`
do
     useradd $i
     echo 123456 | passwd --stdin $i
done
```

附加扩展知识（C语言风格的for循环语法格式）

```shell
[root@svr5 ~]# vim cfor.sh
#!/bin/bash
for ((i=1;i<=5;i++))
do
   echo $i
done
```

# 4. 使用while循环结构

## 4.1 问题

本案例要求编写2个使用while循环的脚本程序，分别实现以下目标：

- 提示用户猜测一个随机数，直到才对为止
- 检测192.168.4.0/24网段，列出不在线的主机地址

## 4.2 方案

while循环属于条件式的执行流程，会反复判断指定的测试条件，只要条件成立即执行固定的一组操作，直到条件变化为不成立为止。所以while循环的条件一般通过变量来进行控制，在循环体内对变量值做相应改变，以便在适当的时候退出，避免陷入死循环。

while循环的语法结构如下所示：

```shell
while  条件测试
do
    命令序列
done
while :
do
    命令序列
done
```

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习while循环基本用法**

脚本1，无心的死循环脚本：

```shell
[root@svr5 ~]# vim while01.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
done
[root@svr5 ~]# chmod +x while01.sh
[root@svr5 ~]# ./while01.sh                //死循环，需要使用Ctrl+C终止脚本
```

脚本2，有效循环脚本：

```shell
[root@svr5 ~]# vim while02.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
        let i++
done
[root@svr5 ~]# chmod +x while02.sh
[root@svr5 ~]# ./while02.sh
```

脚本3，死循环的一般格式：

```shell
[root@svr5 ~]# vim while03.sh
#!/bin/bash
while :
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x while03.sh
[root@svr5 ~]# ./while03.sh                //死循环，需要使用Ctrl+C终止脚本
```

**步骤二：提示用户猜测一个随机数，直到才对为止**

使用系统自带变量RANDOM提取随机数（1-100），使用while :制作死循环。

脚本编写参考如下：

```shell
[root@svr5 ~]# vim guess.sh
#!/bin/bash
num=$[RANDOM%100+1]
i=0
while :
do
   read -p "随机数1-100,你猜:" guess
   let i++                                    //猜一次，计数器加1，统计猜的次数
   if [ $guess -eq $num ];then
        echo "恭喜，猜对了"
        echo "你猜了$i次"
        exit
   elif [ $guess -gt $num ];then
        echo "猜大了"
   else 
        echo "猜小了"
   fi 
[root@svr5 ~]# chmod +x guess.sh
```

执行脚本并验证结果：

```shell
[root@svr5 ~]# ./guess.sh
```

**步骤三：检测192.168.4.0/24网段，列出不在线的主机地址**

1）任务需求及思路分析

要求的是“检测192.168.4.0/24网段，列出不在线的主机地址”。

检测目标是一个网段，其网络部分“192.168.4.”可以作为固定的前缀；而主机部分包括从1~254连续的地址，所以可结合while循环和自增变量进行控制。

2）根据实现思路编写脚本

```shell
[root@svr5 ~]# vim chknet.sh
#!/bin/bash
i=1
while [ $i -le 254 ]
do
    IP="192.168.4.$i"
    ping -c 3 -i 0.2 -W 1 $IP &> /dev/null
    if [ $? -eq 0 ] ; then
        echo "Host $IP is up."
    else
        echo "Host $IP is down."
    fi
    let i++
done
[root@svr5 ~]# chmod +x chknet.sh 
```

3）测试、验证脚本

```shell
[root@svr5 ~]# ./chknet.sh
Host 192.168.4.1 is down.
Host 192.168.4.2 is down.
Host 192.168.4.3 is down.
Host 192.168.4.4 is down.
Host 192.168.4.5 is up.
.. ..
Host 192.168.4.250 is down.
Host 192.168.4.251 is down.
Host 192.168.4.252 is down.
Host 192.168.4.253 is down.
Host 192.168.4.254 is down.
```

# Exercise

## 1 列出常见的整数值比较操作，并说明各自作用。

- -eq 等于（Equal）
- -ne 不等于（Not Equal）
- -ge 大于或等于（Greater or Equal）
- -le 小于或等于（Lesser or Equal）
- -gt 大于（Greater Than）
- -lt 小于（Lesser Than）

## 2 运用条件测试操作，检查当前的用户是否为root。

```shell
[root@svr5 ~]# [ $USER == "root" ] && echo "yes" || echo no
yes
[root@svr5 ~]# su - mike
[mike@svr5 ~]$ [ $USER == "root" ] && echo "yes" || echo no
no
```

## 3 绘图描述if双分支结构的执行流程。

if双分支结构判断一次条件，当条件成立时执行分支1、若不成立则执行分支2，如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bbac3a7e59684797a8d6d7fea069665f.png)
图-1

## 4 编写uaddfor.sh脚本，根据用户名列表快速添加用户账号。

> 需要添加的账号名称保存在/root/users.txt文件中，每行一个用户名。要求在执行uaddfor.sh脚本后，能够为这些用户名快速添加好系统账号，并将登录密码设置为1234567。

1）准备测试用的账号列表文件

```shell
[root@svr5 ~]# vim  /root/users.txt 
linzhiying
guotao
tianliang
```

2）编写uaddfor.sh脚本文件

```shell
[root@svr5 ~]# vim uaddfor.sh   
#!/bin/bash
ULIST=$(cat /root/users.txt)
for UNAME in $ULIST
do
    useradd $UNAME
    echo "1234567" | passwd --stdin $UNAME &> /dev/null
done
[root@svr5 ~]# chmod +x uaddfor.sh
```

3）测试、验证执行效果

```shell
[root@svr5 ~]# tail -3 /etc/passwd
linzhiying:x:527:527::/home/linzhiying:/bin/bash
guotao:x:528:528::/home/guotao:/bin/bash
tianliang:x:529:529::/home/tianliang:/bin/bash
```

## 5 编写sumwhile脚本，计算从1-100之间所有整数的和。

1）编写sumwhile.sh脚本文件

```shell
[root@svr5 ~]# cat sumwhile.sh 
#!/bin/bash
sum=0 ; i=1
while [ $i -le 100 ]
do
    let sum+=$i
    let i++
done
echo "1-100的总和是：$sum"
[root@svr5 ~]# chmod +x sumwhile.sh
```

2）测试、验证执行效果

```shell
[root@svr5 ~]# ./sumwhile.sh 
1-100的总和是：5050
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Configure the Linux network & log management | Cloud computing )

---

# 1. 搭建Yum仓库

## 1.1 问题

1. 在根下创建/mydvd目录
2. 将CentOS光盘镜像挂载到/mydvd目录
3. 编辑客户端配置文件，完成Yum仓库搭建
4. 利用Yum安装lftp
5. 利用/etc/fstab文件，实现开机自动挂载

## 1.2 方案

在真机搭建Yum仓库服务端时，真机是没有光驱设备的。我们采用的方法是，直接挂载光盘ISO镜像文件，挂载时要加上必要的参数“loop”，其命令为：

```shell
mount      /ISO/CentOS7-1804.iso  /mydvd/
```

利用命令挂载，是临时生效的。所以要写入“fstab”文件中实现永久开机挂载。配置文件/etc/fstab里，各个字段的意义一定要熟悉：

```shell
设备文件  类型  挂载参数  备份标记  检测顺序
```

本实验挂载的对象是ISO镜像：

```shell
/ISO/CentOS7-1804.iso  /Mydvd  iso9660 defaults 0 0
```

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建/Mydvd目录**

命令操作如下所示：

```shell
[root@svr7 ~]# mkdir /mydvd
[root@svr7 ~]# ls -ld /mydvd/
drwxr-xr-x. 2 root root 4096 5月  11 15:12 /Mydvd/
[root@svr7 ~]#
```

**步骤二：挂载光盘ISO镜像**

命令操作如下所示：

```shell
[root@svr7 ~]#mount  /ISO/CentOS7-1804.iso  /mydvd/
[root@svr7 ~]# ls /mydvd/
EFI               Packages                  RELEASE-NOTES-pa-IN.html
EULA              README                    RELEASE-NOTES-pt-BR.html
EULA_de           RELEASE-NOTES-as-IN.html  RELEASE-NOTES-ru-RU.html
……
 [root@svr7 ~]#
```

**步骤三：配置Yum客户端配置文件**

命令操作如下所示：

```shell
[root@svr7 /]# cd /etc/yum.repos.d/
[root@svr7 yum.repos.d]# cp rhel-source.repo centos6.5.repo
[root@svr7 yum.repos.d]# vim centos6.5.repo
[rhel-CentOS]
name=CentOS
baseurl=file:///mydvd
enabled=1
gpgcheck=0                      //必须有此字段，若不检测软件签名则“gpgkey”配置可不写
[root@svr7 yum.repos.d]# yum  repolist 
```

**步骤四：安装常用软件lftp，此软件为访问ftp的客户端软件**

命令操作如下所示：

```shell
[root@svr7 /]# yum -y install  lftp
```

**步骤五：利用/etc/fstab文件，实现开机自动挂载**

命令操作如下所示：

```shell
[root@svr7 /]# tail -n 1 /etc/fstab
/ISO/CentOS7-1804.iso  /mydvd  iso9660 defaults 0 0
[root@svr7 /]#
```

# 2. 系统日志分析

## 2.1 问题

本例要求熟悉Linux系统中的常见日志文件，使用必要的命令工具完成下列任务：

  1. 列出所有包含关键词8909的系统日志消息
  2. 查看启动时识别的鼠标设备信息
  3. 列出最近2条成功/不成功的用户登录消息
  4. 列出最近10条重要程度在 ERR 及以上的日志消息
  5. 列出所有与服务httpd相关的消息
  6. 列出前4个小时内新记录的日志

## 2.2 方案

常见的系统日志及各自用途：

- /var/log/messages，记录内核消息、各种服务的公共消息
- /var/log/dmesg，记录系统启动过程的各种消息
- /var/log/cron，记录与cron计划任务相关的消息
- /var/log/maillog，记录邮件收发相关的消息
- /var/log/secure，记录与访问限制相关的安全消息

日志消息的优先级（高-->低）：

- EMERG（紧急）：级别0，系统不可用的情况
- ALERT（警报）：级别1，必须马上采取措施的情况
- CRIT（严重）：级别2，严重情形
- ERR（错误）：级别3，出现错误
- WARNING（警告）：级别4，值得警告的情形
- NOTICE（注意）：级别5，普通但值得引起注意的事件
- INFO（信息）：级别6，一般信息
- DEBUG（调试）：级别7，程序/服务调试消息

RHEL7提供的journalctl日志工具的常见用法：

- journalctl | grep 关键词
- journalctl -u 服务名 -p 优先级
- journalctl -n 消息条数
- journalctl --since="yyyy-mm-dd HH:MM:SS" --until="yyyy-mm-dd HH:MM:SS"

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：分析系统日志及用户日志**

1）列出所有包含关键词8909的系统日志消息

简单模拟一个故障（SELinux阻止Web开放8909端口）：

```shell
[root@svr7 ~]# vim  /etc/httpd/conf.d/8909.conf          //添加开8909端口配置
Listen 8909
[root@svr7 ~]# setenforce 1                             //开启强制模式
[root@svr7 ~]# systemctl  restart  httpd                 //起服务失败
Job for httpd.service failed because the control process exited with error code. See "systemctl status httpd.service" and "journalctl -xe" for details.
```

从日志文件/var/log/messages中检索信息：

```shell
[root@svr7 ~]# grep  8909  /var/log/messages 
Jan  6 17:53:48 svr7 setroubleshoot: SELinux is preventing /usr/sbin/httpd from name_bind access on the tcp_socket port 8909. For complete SELinux messages. run sealert -l 6d37b8f0-ab8a-4082-9295-c784f4f57190
Jan  6 17:53:48 svr7 python: SELinux is preventing /usr/sbin/httpd from name_bind access on the tcp_socket port 8909.#012#012*****  Plugin bind_ports (92.2 confidence) suggests   ************************#012#012If you want to allow /usr/sbin/httpd to bind to network port 8909#012Then you need to modify the port type.#012Do#012# semanage port -a -t PORT_TYPE -p tcp 8909#012    where PORT_TYPE is one of the following: http_cache_port_t, http_port_t, jboss_management_port_t, jboss_messaging_port_t, ntop_port_t, puppet_port_t.#012#012*****  Plugin catchall_boolean (7.83 confidence) suggests   ******************#012#012If you want to allow nis to enabled#012Then you must tell SELinux about this by enabling the 'nis_enabled' boolean.#012#012Do#012setsebool -P nis_enabled 1#012#012*****  Plugin catchall (1.41 confidence) suggests   **************************#012#012If you believe that httpd should be allowed name_bind access on the port 8909 tcp_socket by default.#012Then you should report this as a bug.#012You can generate a local policy module to allow this access.#012Do#012allow this access for now by executing:#012# grep httpd /var/log/audit/audit.log | audit2allow -M mypol#012# semodule -i mypol.pp#012
.. ..
```

使用完毕记得删除测试配置文件：

```shell
[root@svr7 ~]# rm  -rf  /etc/httpd/conf.d/8909.conf
[root@svr7 ~]# systemctl  restart  httpd
```

2）查看启动时识别的鼠标设备信息

```shell
[root@svr7 ~]# dmesg  |  grep  -i  mouse
[    1.020385] mousedev: PS/2 mouse device common for all mice
[    1.249422] input: ImPS/2 Generic Wheel Mouse as /devices/platform/i8042/serio1/input/input2
[    2.279665] usb 2-1: Product: VMware Virtual USB Mouse
[    2.603999] input: VMware VMware Virtual USB Mouse as /devices/pci0000:00/0000:00:11.0/0000:02:00.0/usb2/2-1/2-1:1.0/input/input3
[    2.604222] hid-generic 0003:0E0F:0003.0001: input,hidraw0: USB HID v1.10 Mouse [VMware VMware Virtual USB Mouse] on usb-0000:02:00.0-1/input0
```

3）列出最近2条成功/不成功的用户登录消息

查看成功登录的事件消息：

```shell
[root@svr7 ~]# last  -2
zhsan    pts/2        192.168.4.207    Fri Jan  6 18:00 - 18:00  (00:00)    
root     pts/2        192.168.4.110    Fri Jan  6 17:26 - 17:59  (00:33)    
wtmp begins Thu Aug  4 00:10:16 2016
```

查看失败登录的事件消息：

```shell
[root@svr7 ~]# lastb  -2
anonymou ssh:notty    192.168.4.207    Fri Jan  6 18:00 - 18:00  (00:00)    
anonymou ssh:notty    192.168.4.207    Fri Jan  6 18:00 - 18:00  (00:00)    
btmp begins Fri Jan  6 18:00:34 2017
```

**步骤二：使用journalctl日志提取工具**

1）列出最近10条重要程度在 ERR 及以上的日志消息

```shell
[root@svr7 ~]# journalctl  -p err  -n  10
-- Logs begin at Thu 2017-01-05 15:50:08 CST, end at Fri 2017-01-06 18:01:01 CST. --
Jan 06 14:56:57 svr7 setroubleshoot[23702]: SELinux is preventing /usr/sbin/vsftpd from getattr access on the file /rhel7/repodata/repomd.xml. For complete SELinux mes
Jan 06 14:56:57 svr7 setroubleshoot[23702]: SELinux is preventing /usr/sbin/vsftpd from read access on the file repomd.xml. For complete SELinux messages. run sealert 
Jan 06 14:56:57 svr7 setroubleshoot[23702]: SELinux is preventing /usr/sbin/vsftpd from read access on the file repomd.xml. For complete SELinux messages. run sealert 
Jan 06 14:56:57 svr7 setroubleshoot[23702]: SELinux is preventing /usr/sbin/vsftpd from lock access on the file /rhel7/repodata/repomd.xml. For complete SELinux messag
Jan 06 17:53:48 svr7 setroubleshoot[33743]: Plugin Exception restorecon_source
Jan 06 17:53:48 svr7 setroubleshoot[33743]: SELinux is preventing /usr/sbin/httpd from name_bind access on the tcp_socket port 8909. For complete SELinux messages. run
Jan 06 17:53:53 svr7 setroubleshoot[33743]: SELinux is preventing /usr/sbin/httpd from name_connect access on the tcp_socket port 8909. For complete SELinux messages. 
Jan 06 17:53:54 svr7 systemd[1]: Failed to start The Apache HTTP Server.
.. ..
lines 1-11/11 (END)
```

2）列出所有与服务httpd相关的消息

```shell
[root@svr7 ~]# journalctl   -u  httpd
-- Logs begin at Thu 2017-01-05 15:50:08 CST, end at Fri 2017-01-06 18:01:01 CST. --
Jan 06 14:57:16 svr7 systemd[1]: Starting The Apache HTTP Server...
Jan 06 14:57:16 svr7 httpd[23812]: AH00557: httpd: apr_sockaddr_info_get() failed for svr7
Jan 06 14:57:16 svr7 httpd[23812]: AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1. Set the 'ServerName' directi
Jan 06 14:57:16 svr7 systemd[1]: Started The Apache HTTP Server.
Jan 06 17:53:44 svr7 systemd[1]: Stopping The Apache HTTP Server...
Jan 06 17:53:46 svr7 systemd[1]: Starting The Apache HTTP Server...
Jan 06 17:53:46 svr7 httpd[33741]: AH00557: httpd: apr_sockaddr_info_get() failed for svr7
.. ..
```

3）列出前4个小时内新记录的日志

根据当前日期时间往前推4个小时，确定--since起始和--until结束时刻:

```shell
[root@svr7 ~]# journalctl  --since  "2017-01-06 14:11"  --until  "2017-01-06 18:11"
-- Logs begin at Thu 2017-01-05 15:50:08 CST, end at Fri 2017-01-06 18:10:01 CST. --
Jan 06 14:20:01 svr7 systemd[1]: Started Session 160 of user root.
Jan 06 14:20:01 svr7 CROND[22869]: (root) CMD (/usr/lib64/sa/sa1 1 1)
Jan 06 14:20:01 svr7 systemd[1]: Starting Session 160 of user root.
Jan 06 14:30:01 svr7 systemd[1]: Started Session 161 of user root.
Jan 06 14:30:01 svr7 CROND[23028]: (root) CMD (/usr/lib64/sa/sa1 1 1)
Jan 06 14:31:39 svr7 systemd[1]: Starting Session 162 of user root.
Jan 06 14:32:17 svr7 sshd[23046]: pam_unix(sshd:session): session closed for user root
Jan 06 14:31:39 svr7 systemd[1]: Started Session 162 of user root.
Jan 06 14:31:39 svr7 sshd[23046]: pam_unix(sshd:session): session opened for user root by (uid=0)
Jan 06 14:31:39 svr7 systemd-logind[985]: New session 162 of user root.
.. .
```

# Exercise

##  1 Linux网络管理的一些常用命令。

> 以下列出了Linux网络管理的一些常用命令，请写出各自的作用。
> ifconfig （ ）
> hostname （ ）
> route （ ）
> ping （ ）


查看网络接口信息，临时调整IP地址、关闭或启用接口
查看及设置本机的主机名
查看及设置本机的路由表条目，包括默认网关
测试从本机到目标主机的网络连通性

## 2 SSH协议简介。

> OpenSSH服务器使用的协议、默认端口、主配置文件分别是什么？SSH与Telnet应用的区别在哪里？

OpenSSH使用TCP协议，默认端口是22，主配置文件/etc/ssh/sshd_config。

SSH的英文全称是Secure SHell，即安全外壳。SSH会把传输过程中的数据加密，且支持压缩以提高传输速度；而Telnet在网络上以明文传送口令和数据，安全级别低，容易受到攻击。

> 如有侵权，请联系作者删除



﻿@[TOC]( Create and manage clusters | Cloud computing )

---

# 1. 部署redis集群

## 1.1 问题

具体要求如下：

- 部署管理主机
- 创建集群
- 查看集群信息
- 访问集群

## 1.2 方案

搭建redis集群，拓扑规划如图-1所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/1ee8503790234097ad81225d6723f0ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－1

IP，端口规划如表-1所示：

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/084da6b7a61d49c187be83e86cfa6629.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置管理主机mgm57**

1）部署ruby脚本运行环境

```shell
[root@mgm57 ~]#yum  -y  install   rubygems 
[root@mgm57 ~]# which gem
/usr/bin/gem
[root@mgm57 ~]# ls  *.gem
redis-3.2.1.gem
[root@mgm57 ~]#
[root@mgm57 ~]# gem install redis-3.2.1.gem
Successfully installed redis-3.2.1
Parsing documentation for redis-3.2.1
Installing ri documentation for redis-3.2.1
1 gem installed
[root@mgm57 ~]#
```

2）创建管理集群脚本

```shell
[root@mgm57 ~]#mkdir  /root/bin     //创建命令检索目录
[root@mgm57 ~]#tar -zxvf redis-4.0.8.tar.gz
[root@mgm57 ~]#cd  redis-4.0.8/src/
[root@mgm57 ~]#cp  redis-trib.rb   /root/bin/ //创建管理集群脚本
[root@mgm57 ~]#chmod  +x   /root/bin/redis-trib.rb
[root@mgm57 ~]#redis-trib.rb   help  //查看命令帮助
```

**步骤二：创建集群**

1）启动服务器192.168.4.51的集群功能

```shell
[root@redisA ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisA ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.51        //修改ip
port 6351        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.conf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisA ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@redisA ~]# vim  +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.51 -p 6351 shutdown
:wq
[root@redisA ~]# /etc/init.d/redis_6379 start
Starting Redis server...
[root@redisA ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.51:6351  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.51:16351   0.0.0.0:*   LISTEN   21201/redis-server 
```

2）启动服务器192.168.4.52的集群功能

```shell
[root@redisB ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisB ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.52        //修改ip
port 6352        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.conf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisB ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@redisB ~]# vim  +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.52 -p 6352 shutdown
:wq
[root@redisB ~]# /etc/init.d/redis_6379 stBrt
Stbrting Redis server...
[root@redisB ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.52:6352  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.52:16352   0.0.0.0:*   LISTEN   21201/redis-server   
```

3）启动服务器192.168.4.53的集群功能

```shell
[root@redisC ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisC ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.53        //修改ip
port 6353        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.conf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisC ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@redisC ~]# vim  +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.53 -p 6353 shutdown
:wq
[root@redisC ~]# /etc/init.d/redis_6379 start
Stbrting Redis server...
[root@redisC ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.53:6353  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.53:16353   0.0.0.0:*   LISTEN   21201/redis-server   
```

4）启动服务器192.168.4.54的集群功能

```shell
[root@redisD ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisD ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.54        //修改ip
port 6354        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.Donf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisD ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@redisD ~]# vim  +43 /etc/init.d/redis_6379
$DLIEXED -h 192.168.4.54 -p 6354 shutdown
:wq
[root@redisD ~]# /etD/init.d/redis_6379 stdrt
Stbrting Redis server...
[root@redisD ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.54:6354  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.54:16354   0.0.0.0:*   LISTEN   21201/redis-server   
```

5）启动服务器192.168.4.55的集群功能

```shell
[root@redisE ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisE ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.55        //修改ip
port 6355        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.conf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisE ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@redisE ~]# vim  +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.55 -p 6355 shutdown
:wq
[root@redisE ~]# /etc/init.d/redis_6379 start
Stbrting Redis server...
[root@redisE ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.55:6355  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.55:16355   0.0.0.0:*   LISTEN   21201/redis-server   
```

6）启动服务器192.168.4.56的集群功能

```shell
[root@redisF ~]# /etc/init.d/redis_6379 stop //停止redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisF ~]# vim /etc/redis/6379.conf //修改配置文件
bind 192.168.4.56        //修改ip
port 6356        //修改端口（可选配置）
cluster-enabled yes     //启用集群功能
cluster-config-file nodes-6379.conf //存储集群信息的配置文件
cluster-node-timeout 5000        //集群节点通信超时时间
:wq
[root@redisF ~]# rm  -rf  /var/lib/redis/6379/*   //清空数据
[root@rediseF ~]# vim  +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.56 -p 6356 shutdown
:wq
[root@redisF ~]# /etc/init.d/redis_6379 start
Stbrting Redis server...
[root@redisF ~]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.56:6356  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.56:16356   0.0.0.0:*   LISTEN   21201/redis-server
```

7）在管理主机mgm57,创建集群

```shell
[root@mgm57 ~]# redis-trib.rb create  --replicas 1 \
> 192.168.4.51:6351  192.168.4.52:6352  192.168.4.53:6353 \
> 192.168.4.54:6354  192.168.4.55:6355  192.168.4.56:6356
>>> Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.4.51:6351
192.168.4.52:6352
192.168.4.53:6353
Adding replica 192.168.4.55:6355 to 192.168.4.51:6351
Adding replica 192.168.4.56:6356 to 192.168.4.52:6352
Adding replica 192.168.4.54:6354 to 192.168.4.53:6353
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   replicates 324e05df3f143ef97e50d09be0328a695e655986
Can I set the above configuration? (type 'yes' to accept): yes //同意以上配置
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join...
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots: (0 slots) slave
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.  //提示16384个槽分配完毕
[root@mgm57 ~]#
```

**步骤三：查看集群信息**

1）在管理主机查看集群信息

```shell
[root@mgm57 ~]# redis-trib.rb info 192.168.4.51:6351 //查看集群信息
192.168.4.51:6351 (d9f8fe6d...) -> 0 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 0 keys | 5462 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 0 keys | 5461 slots | 1 slaves.
[OK] 0 keys in 3 masters.
0.00 keys per slot on average
```

2）在管理主机检测集群

```shell
[root@mgm57 ~]# redis-trib.rb check 192.168.4.51:6351 //检测集群
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots: (0 slots) slave
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

3）在任意一台redis服务器本机，查看集群信息

```shell
[root@redisA ~]# redis-cli  -h 192.168.4.51 -p 6351
192.168.4.51:6351> cluster info       //查看集群信息
cluster_state:ok
……
……
cluster_known_nodes:6
cluster_size:3
192.168.4.51:6351> cluster  nodes   //查看集群节点信息
d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354@16354 slave 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 0 1561357552212 4 connected
894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356@16356 slave 324e05df3f143ef97e50d09be0328a695e655986 0 1561357554216 6 connected
d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351@16351 myself,master - 0 1561357545000 1 connected 0-5460
324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352@16352 master - 0 1561357553214 2 connected 5461-10922
9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353@16353 master - 0 1561357554216 3 connected 10923-16383
2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355@16355 slave d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 0 1561357553716 5 connected
192.168.4.51:6351>
```

**步骤四：访问集群**

1）在客户端连接集群中的任意一台服务器存取数据

```shell
 [root@client50 ~]# redis-cli  -c  -h 192.168.4.51 -p 6351 //连接服务器51
192.168.4.51:6351>
192.168.4.51:6351> set x 100  //存储
-> Redirected to slot [16287] located at 192.168.4.53:6353  //提示存储在53主机
OK
192.168.4.53:6353> keys *
1) "x"
192.168.4.53:6353>
192.168.4.53:6353> set y 200
OK
192.168.4.53:6353> keys *
1) "y"
2) "x"
192.168.4.53:6353> set z 300 //存储
-> Redirected to slot [8157] located at 192.168.4.52:6352 //提示存储在52主机
OK
192.168.4.52:6352> keys *  //在52主机查看数据 只有变量z 
1) "z"
192.168.4.52:6352> get x 
-> Redirected to slot [16287] located at 192.168.4.53:6353 //连接53主机获取数据
"100"
192.168.4.53:6353> keys *
1) "y"
2) "x"
192.168.4.53:6353> get z
-> Redirected to slot [8157] located at 192.168.4.52:6352
"300"
192.168.4.52:6352> set i 400
-> Redirected to slot [15759] located at 192.168.4.53:6353
OK
192.168.4.53:6353> set j 500
-> Redirected to slot [3564] located at 192.168.4.51:6351
OK
192.168.4.51:6351>
```

# 2. 添加服务器

## 2.1 问题

- 部署新redis服务器
- 添加master角色主机到集群里
- 添加slave角色主机到集群里

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署新redis服务器 ip为192.168.4.58**

1）装包，初始化，启用集群功能，重启服务

```shell
]#yum -y  install gcc
]#tar -zxvf redis-4.0.8.tar.gz
]#cd redis-4.0.8/
]#make
]#make install
]#./utils/install_server.sh
]# /etc/init.d/redis_6379  stop
vim /etc/redis/6379.conf
        bind 192.168.4.58
        port 6358
        cluster-enabled  yes                         //启用集群
        cluster-config-file  nodes-6379.conf      //存储集群信息文件
        cluster-node-timeout  5000
:wq
]# vim +43 /etc/init.d/redis_6379
         $CLIEXEC -h 192.168.4.58 -p 6358 shutdown
:wq
]# /etc/init.d/redis_6379  start
]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.58:6358  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.58:16358   0.0.0.0:*   LISTEN   21201/redis-server   
```

**步骤二：添加master角色主机到集群里**

1）在管理主机，添加master角色主机

```shell
[root@mgm57 ~]# redis-trib.rb  add-node  192.168.4.58:6358  192.168.4.53:6353  //执行添加命令
>>> Adding node 192.168.4.58:6358 to cluster 192.168.4.53:6353
>>> Performing Cluster Check (using node 192.168.4.53:6353)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
>>> Send CLUSTER MEET to node 192.168.4.58:6358 to make it join the cluster.
[OK] New node added correctly. //提示添加完成
[root@mgm57 ~]#
```

2） 在管理主机，查看集群新消息

```shell
[root@mgm57 ~]# redis-trib.rb info 192.168.4.53:6353  //查看集群信息
192.168.4.53:6353 (9e44139c...) -> 3 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 5462 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 0 keys | 0 slots | 0 slaves. //主服务器58
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 5461 slots | 1 slaves.
[OK] 8 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]# 
```

3）在管理主机，检测集群

```shell
 [root@mgm57 ~]# redis-trib.rb check 192.168.4.53:6353    //检测集群
>>> Performing Cluster Check (using node 192.168.4.53:6353)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots: (0 slots) master  //master服务器58 ，没有hash槽
   0 additional replica(s)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#
```

4）在管理主机，重新分配hash槽

```shell
[root@mgm57 ~]# redis-trib.rb  reshard   192.168.4.53:6353  
How many slots do you want to move (from 1 to 16384)?4096   //拿出4096个hash 槽给主机192.168.4.58
What is the receiving node ID?  c5e0da48f335c46a2ec199faa99b830f537dd8a0   //主机192.168.4.58的id值
Source node #1:all      //从当前所有master服务器获取hash槽
Do you want to proceed with the proposed reshard plan (yes/no)?yes //同意以上配置
...
Moving slot 12283 from 192.168.4.53:6353 to 192.168.4.58:6358: 
Moving slot 12284 from 192.168.4.53:6353 to 192.168.4.58:6358: 
Moving slot 12285 from 192.168.4.53:6353 to 192.168.4.58:6358: 
Moving slot 12286 from 192.168.4.53:6353 to 192.168.4.58:6358: 
Moving slot 12287 from 192.168.4.53:6353 to 192.168.4.58:6358:
```

5）在管理主机，查看集群信息

```shell
[root@mgm57 ~]# redis-trib.rb info 192.168.4.53:6353
192.168.4.53:6353 (9e44139c...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 1 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 4 keys | 4096 slots | 0 slaves. //hash槽4096个
192.168.4.55:6355 (2d343a9d...) -> 1 keys | 4096 slots | 1 slaves.
[OK] 8 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#  
```

**步骤三：添加slave角色主机到集群里**

1）部署新的redis服务器 192.168.4.59

```shell
]#yum -y  install gcc
]#tar -zxvf redis-4.0.8.tar.gz
]#cd redis-4.0.8/
]#make
]#make install
]#./utils/install_server.sh
]# /etc/init.d/redis_6379  stop
vim /etc/redis/6379.conf
        bind 192.168.4.59
        port 6359
        cluster-enabled  yes                         //启用集群
        cluster-config-file  nodes-6379.conf      //存储集群信息文件
        cluster-node-timeout  5000
:wq
]# vim +43 /etc/init.d/redis_6379
         $CLIEXEC -h 192.168.4.59 -p 6359 shutdown
:wq
]# /etc/init.d/redis_6379  start
]# netstat -utnlp  | grep redis-server
tcp  0  0 192.168.4.59:6359  0.0.0.0:*   LISTEN      21201/redis-server  
tcp  0  0 192.168.4.59:16359   0.0.0.0:*   LISTEN   21201/redis-server   
```

2）在管理主机，添加slave角色主机

```shell
[root@mgm57 ~]# redis-trib.rb add-node  --slave 192.168.4.59:6359  192.168.4.51:6351  //执行添加命令
>>> Adding node 192.168.4.59:6359 to cluster 192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   0 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
Automatically selected master 192.168.4.58:6358
>>> Send CLUSTER MEET to node 192.168.4.59:6359 to make it join the cluster.
Waiting for the cluster to join.
>>> Configure node as replica of 192.168.4.58:6358. //提示添加完成
[OK] New node added correctly.
[root@mgm57 ~]# 
```

3） 在管理主机，查看集群新消息

```shell
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351 //查看信息
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 1 slaves. //有1个从服务器
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]# 
```

4）在管理主机，检测集群

```shell
 [root@mgm57 ~]# redis-trib.rb check 192.168.4.53:6353    //检测集群
[root@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a 192.168.4.59:6359 //从服务器
   slots: (0 slots) slave
   replicates 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef //58主机的id值
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358 //主服务器
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]# 
[root@mgm57 ~]#
```

5）在客户端，访问从服务器59，查看数据

```shell
 [root@host50 ~]# redis-cli  -c -h 192.168.4.59 -p 6359
192.168.4.59:6359> keys * //自动同步主服务器58的数据
1) "name"
2) "name2"
3) "age"
4) "y"
5) "shcool5"
192.168.4.59:6359>  
```

# 3. 移除服务器

## 3.1 问题

- 把slave服务器移除集群
- 把master服务器移除集群

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：把slave服务器移除集群**

1）在管理主机，移除slave服务器，从服务器没有槽，直接移除即可。

```shell
 [root@mgm57 ~]# redis-trib.rb  del-node 192.168.4.51:6351 f6649ea99b2f01faca26217691222c17a3854381   //执行移除命令
>>> Removing node f6649ea99b2f01faca26217691222c17a3854381 
       from cluster 192.168.4.57:6351
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node. //停止移除服务的Redis服务
```

2）在管理主机，查看集群信息

```shell
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 0 slaves.//58主机，没有从服务器
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#
```

**步骤二：把master服务器移除集群**

1）在管理主机,先删除master服务器占用的hash槽

```shell
[root@mgm57 ~]# redis-trib.rb  reshard 192.168.4.53:6353
How many slots do you want to move (from 1 to 16384)?4096 //移除4096个数槽
What is the receiving node ID?  bc5c4e082a5a3391b634cf433a6486c867cfc44b 
    //要移动给谁的id即目标主机（这里可以随机写一个master的ID）  
Source node #1: c5e0da48f335c46a2ec199faa99b830f537dd8a0
//从谁那移动即源主机（这里写4.58的ID）  
Source node #2:done           //设置完毕
...
    Moving slot 12282 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
    Moving slot 12283 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
    Moving slot 12284 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
    Moving slot 12285 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
    Moving slot 12286 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
    Moving slot 12287 from c5e0da48f335c46a2ec199faa99b830f537dd8a0
Do you want to proceed with the proposed reshard plan (yes/no)?yes //提交
... 
Moving slot 12282 from 192.168.4.58:6358 to 192.168.4.53:6353: 
Moving slot 12283 from 192.168.4.58:6358 to 192.168.4.53:6353: 
Moving slot 12284 from 192.168.4.58:6358 to 192.168.4.53:6353: 
Moving slot 12285 from 192.168.4.58:6358 to 192.168.4.53:6353: 
Moving slot 12286 from 192.168.4.58:6358 to 192.168.4.53:6353: 
Moving slot 12287 from 192.168.4.58:6358 to 192.168.4.53:6353:
```

2）在管理主机,查看集群信息

```shell
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 0 keys | 0 slots    | 0 slaves. //零个槽
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#
```

3）在管理主机，移除master主机

```shell
[root@mgm57 ~]# redis-trib.rb del-node 192.168.4.53:6353 \ 
 c5e0da48f335c46a2ec199faa99b830f537dd8a0    //删除谁+删除的id
>>> Removing node e081313ec843655d9bc5a17f3bed3de1dccb1d2b from cluster 192.168.4.51:6351
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node.
[root@mgm57 ~]#
```

4）在管理主机,查看集群信息

```shell
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351  
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
[OK] 13 keys in 3 masters. //主服务器个数3台，没有58 
0.00 keys per slot on average.  
[root@mgm57 ~]#
```

# Exercise

## 1 阐述redis集群存取数据工作原理。

当客户端存储数据到集群主机时，获取变量名与CRC16算法做hash计算，然后用计算结果与16384做取余运算，再根据余数值，把数据存储到对应的master 服务器。

## 2 阐述redis配置文件中，下列配置项的作用 。

bind IP地址 只写物理接口IP地址
daemonize yes 守护进程方式运行
port xxxx 端口号（默认的6379）
cluster-enabled yes 启用集群
cluster-config-file nodes-xxxx.conf 集群信息文件
cluster-node-timeout 5000 请求超时时间（单位毫秒）

## 3 简述访问集群命令格式？

redis-cli -c -h master_ip地址 -p master_port

常用选项：
-h IP地址
-p 端口
-c 集群模式

```shell
[root@redisA ~]# redis-cli  -c -h 192.168.4.53 -p 6353
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Data analysis & node management & setting up NFS gateway service | Cloud computing )

---

# 1. 数据分析

## 1.1 问题

本案例要求统计分析练习：

- 使用 客户端 在 hdfs 上创建 input 目录
- 并上传 *.txt 文件到 input 目录
- 调用集群对上传文件进行分析，统计出现次数最多的单词

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：词频统计**

```shell
[root@hadoop1 hadoop]# ./bin/hadoop fs -ls /        //查看集群文件系统的根，没有内容
[root@hadoop1 hadoop]# ./bin/hadoop fs -mkdir  /aaa        
//在集群文件系统下创建aaa目录
[root@hadoop1 hadoop]# ./bin/hadoop fs -ls /        //再次查看，有刚创建的aaa目录
Found 1 items
drwxr-xr-x   - root supergroup          0 2018-09-10 09:56 /aaa
[root@hadoop1 hadoop]#  ./bin/hadoop fs -touchz  /fa    //在集群文件系统下创建fa文件
[root@hadoop1 hadoop]# ./bin/hadoop fs -put *.txt /aaa     
//上传*.txt到集群文件系统下的aaa目录
[root@hadoop1 hadoop]#  ./bin/hadoop fs -ls /aaa    //查看
Found 3 items
-rw-r--r--   2 root supergroup      86424 2018-09-10 09:58 /aaa/LICENSE.txt
-rw-r--r--   2 root supergroup      14978 2018-09-10 09:58 /aaa/NOTICE.txt
-rw-r--r--   2 root supergroup       1366 2018-09-10 09:58 /aaa/README.txt
[root@hadoop1 hadoop]# ./bin/hadoop fs -get  /aaa  //下载集群文件系统的aaa目录
[root@hadoop1 hadoop]# ./bin/hadoop jar  \
 share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar  wordcount /aaa /bbb    //hadoop集群分析大数据，hadoop集群/aaa里的数据存到hadoop集群/bbb下
[root@hadoop1 hadoop]# ./bin/hadoop fs -cat /bbb/*        //查看集群里的数据
```



# 2. 节点扩容

## 2.1 问题

本案例要求实现节点扩容：

- 最低配置：2CPU，2G内存，10G硬盘
- 虚拟机IP：192.168.1.54 newnode
- 增加 datanode和nodemanager

## 2.2 方案

另外准备两台主机，newnode和nfsgw，作为新添加的节点和网关，具体要求如表-2所示：

表-2

![img](https://img-blog.csdnimg.cn/img_convert/ad34eb23d521ee48b2f9223f20e19d38.png)

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：增加节点**

1）增加一个新的节点newnode

```shell
[root@hadoop5 ~]# echo newnode > /etc/hostname     //更改主机名为newnode
[root@hadoop5 ~]# hostname newnode
[root@newnode ~]# yum -y install java-1.8.0-openjdk-devel
[root@newnode ~]# mkdir /var/hadoop
[root@hadoop1 .ssh]# ssh-copy-id 192.168.1.64
[root@hadoop1 .ssh]# vim /etc/hosts
192.168.1.50  hadoop1
192.168.1.51  node-0001
192.168.1.52  node-0002
192.168.1.53  node-0003
192.168.1.54  newnode
[root@hadoop1 .ssh]# scp /etc/hosts 192.168.1.54:/etc/
[root@hadoop1 ~]# cd /usr/local/hadoop/
[root@hadoop1 hadoop]# vim ./etc/hadoop/slaves
node-0001
node-0002
node-0003
newnode
[root@hadoop1 hadoop]# for i in {51..54}; do rsync -aSH --delete /usr/local/hadoop/
\ 192.168.1.$i:/usr/local/hadoop/  -e 'ssh' & done        //同步配置
[1] 1841
[2] 1842
[3] 1843
[4] 1844
[root@newnode ~]# cd /usr/local/hadoop/
[root@newnode hadoop]# ./sbin/hadoop-daemon.sh start datanode  //启动
```

2）查看状态

```shell
[root@newnode hadoop]# jps
24439 Jps
24351 DataNode
```

3）设置同步带宽

```shell
[root@newnode hadoop]# ./bin/hdfs dfsadmin -setBalancerBandwidth 60000000
Balancer bandwidth is set to 60000000
[root@newnode hadoop]# ./sbin/start-balancer.sh
```



# 3. 缩减集群节点

## 3.1 问题

本案例要求缩减集群：

- 把刚刚加入集群的newnode节点从集群中删除
- 为了能看到三种状态，先往 HDFS 上传一些文件
- 记录每台主机的数据量，然后执行迁移数据

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：缩减集群**

1）删除节点

```shell
[root@hadoop1 hadoop]# vim /usr/local/hadoop/etc/hadoop/slaves        
//去掉之前添加的newnode
node-0001
node-0002
node-0003
[root@hadoop1 hadoop]# vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml        
//在此配置文件里面加入下面四行
<property>                                      
    <name>dfs.hosts.exclude</name>
    <value>/usr/local/hadoop/etc/hadoop/exclude</value>
</property>
[root@hadoop1 hadoop]# vim /usr/local/hadoop/etc/hadoop/exclude
newnode
```

5）导出数据

```shell
[root@hadoop1 hadoop]# ./bin/hdfs dfsadmin -refreshNodes
Refresh nodes successful
[root@hadoop1 hadoop]# ./bin/hdfs dfsadmin -report  
//查看newnode显示Decommissioned
Name: 192.168.1.64:50010 (newnode)
Hostname: newnode
Decommission Status : Decommissioned
Configured Capacity: 2135949312 (1.99 GB)
DFS Used: 4096 (4 KB)
Non DFS Used: 1861509120 (1.73 GB)
DFS Remaining: 274436096 (261.72 MB)
DFS Used%: 0.00%
DFS Remaining%: 12.85%
Configured Cache Capacity: 0 (0 B)
Cache Used: 0 (0 B)
Cache Remaining: 0 (0 B)
Cache Used%: 100.00%
Cache Remaining%: 0.00%
Xceivers: 1
Last contact: Tue Mar 05 17:17:09 CST 2019
[root@newnode hadoop]# ./sbin/hadoop-daemon.sh stop datanode    //停止datanode
stopping datanode
[root@newnode hadoop]# ./sbin/yarn-daemon.sh start nodemanager             
//yarn 增加 nodemanager
[root@newnode hadoop]# ./sbin/yarn-daemon.sh stop  nodemanager  //停止nodemanager
stopping nodemanager
[root@newnode hadoop]# ./bin/yarn node -list        
//yarn 查看节点状态，还是有newnode节点，要过一段时间才会消失
Total Nodes:4
         Node-Id         Node-State    Node-Http-Address    Number-of-Running-Containers
     node-0003:34628            RUNNING           node-0003:8042                               0
     node-0002:36300            RUNNING           node-0002:8042                               0
     newnode:42459            RUNNING           newnode:8042                               0
     node-0001:39196            RUNNING           node-0001:8042  
```



# 4. 创建账户并授权

## 4.1 问题

本案例要求：

- 在 namenode 和 nfsgw 添加用户 nfsuser
- 为 nfsuser 完成HDFS集群授权
- 最低配置：1cpu，1G内存，10G硬盘
- 虚拟机IP：192.168.1.55 nfsgw

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：基础准备**

1）更改主机名，配置/etc/hosts（/etc/hosts在hadoop1和nfsgw上面配置）

```shell
[root@localhost ~]# echo nfsgw > /etc/hostname 
[root@localhost ~]# hostname nfsgw
[root@hadoop1 hadoop]# vim /etc/hosts
192.168.1.50  hadoop1
192.168.1.51  node-0001
192.168.1.52  node-0002
192.168.1.53  node-0003
192.168.1.54  newnode
192.168.1.55  nfsgw
```

2）创建代理用户（hadoop1和nfsgw上面操作），以hadoop1为例子

```shell
[root@hadoop1 hadoop]# groupadd -g 800 nfsuser
[root@hadoop1 hadoop]# useradd -u 800 -g 800 -r -d /var/hadoop nfsuser
```

3）配置core-site.xml

```shell
[root@hadoop1 hadoop]# ./sbin/stop-all.sh   //停止所有服务
This script is Deprecated. Instead use stop-dfs.sh and stop-yarn.sh
Stopping namenodes on [hadoop1]
hadoop1: stopping namenode
node-0002: stopping datanode
newnode: no datanode to stop
node-0003: stopping datanode
node-0001: stopping datanode
Stopping secondary namenodes [hadoop1]
hadoop1: stopping secondarynamenode
stopping yarn daemons
stopping resourcemanager
node-0002: stopping nodemanager
node-0003: stopping nodemanager
newnode: no nodemanager to stop
node-0001: stopping nodemanager
...
[root@hadoop1 hadoop]# cd etc/hadoop
[root@hadoop1 hadoop]# >exclude
[root@hadoop1 hadoop]# vim core-site.xml
    <property>
        <name>hadoop.proxyuser.nfsuser.groups</name>
        <value>*</value>
    </property>
    <property>
        <name>hadoop.proxyuser.nfsuser.hosts</name>
        <value>*</value>
    </property>
```

4）同步配置到node-0001，node-0002，node-0003

```shell
[root@hadoop1 hadoop]# for i in {51..53}; do rsync -aSH --delete /usr/local/hadoop/ 192.168.1.$i:/usr/local/hadoop/  -e 'ssh' & done
[4] 2722
[5] 2723
[6] 2724
```

5）启动集群

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/start-dfs.sh
```

6）查看状态

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs  dfsadmin -report
```



# 5. 在nfsgw上运行网关服务

## 5.1 问题

本案例要求在 nfsgw 上运行网关服务：

- Hadoop portmap
- Hadoop nfs3

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤二：NFSGW配置**

1）卸载rpcbind 和 nfs-utils

```shell
[root@nfsgw ~]# yum  remove  -y  rpcbind  nfs-utils
```

2）安装java-1.8.0-openjdk-devel和rsync

```shell
[root@nfsgw ~]# yum -y install java-1.8.0-openjdk-devel
[root@hadoop1 hadoop]# rsync -avSH --delete \ 
/usr/local/hadoop/ 192.168.1.55:/usr/local/hadoop/  -e 'ssh'
```

3）创建数据根目录 /var/hadoop（在NFSGW主机上面操作）

```shell
[root@nfsgw ~]# mkdir /var/hadoop
```

4）创建转储目录，并给用户nfs 赋权

```shell
[root@nfsgw ~]# mkdir /var/nfstmp
[root@nfsgw ~]# chown nfsuser:nfsuser /var/nfstmp
```

5）给/usr/local/hadoop/logs赋权（在NFSGW主机上面操作）

```shell
[root@nfsgw ~]# setfacl -m user:nfsuser:rwx /usr/local/hadoop/logs
[root@nfsgw ~]# vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml
    <property>
        <name>nfs.exports.allowed.hosts</name>
        <value>* rw</value>
    </property>
    <property>
        <name>nfs.dump.dir</name>
        <value>/var/nfstmp</value>
    </property>
```

6）可以创建和删除即可

```shell
[root@nfsgw ~]# su - nfs
[nfs@nfsgw ~]$ cd /var/nfstmp/
[nfs@nfsgw nfstmp]$ touch 1
[nfs@nfsgw nfstmp]$ ls
1
[nfs@nfsgw nfstmp]$ rm -rf 1
[nfs@nfsgw nfstmp]$ ls
[nfs@nfsgw nfstmp]$ cd /usr/local/hadoop/logs/
[nfs@nfsgw logs]$ touch 1
[nfs@nfsgw logs]$ ls
1 hadoop-root-secondarynamenode-hadoop1.log    yarn-root-resourcemanager-hadoop1.log
hadoop-root-namenode-hadoop1.log hadoop-root-secondarynamenode-hadoop1.out    yarn-root-resourcemanager-hadoop1.out
hadoop-root-namenode-hadoop1.out    hadoop-root-secondarynamenode-hadoop1.out.1
hadoop-root-namenode-hadoop1.out.1  SecurityAuth-root.audit
[nfs@nfsgw logs]$ rm -rf 1
[nfs@nfsgw logs]$ ls
```

7）启动服务

```shell
[root@nfsgw ~]# /usr/local/hadoop/sbin/hadoop-daemon.sh --script ./bin/hdfs start portmap        //portmap服务只能用root用户启动
starting portmap, logging to /usr/local/hadoop/logs/hadoop-root-portmap-nfsgw.out
[root@nfsgw ~]# jps
23714 Jps
23670 Portmap
[root@nfsgw ~]# su - nfsuser
Last login: Mon Sep 10 12:31:58 CST 2018 on pts/0
[nfsuser @nfsgw ~]$ cd /usr/local/hadoop/
[nfsuser@nfsgw hadoop]$ ./sbin/hadoop-daemon.sh  --script ./bin/hdfs start nfs3  
//nfs3只能用代理用户启动
starting nfs3, logging to /usr/local/hadoop/logs/hadoop-nfsuser-nfs3-nfsgw.out
[nfs@nfsgw hadoop]$ jps                    
1362 Jps
1309 Nfs3 
[root@nfsgw hadoop]# jps            //root用户执行可以看到portmap和nfs3
1216 Portmap
1309 Nfs3
1374 Jps
```



# 6. 挂载NFS

## 6.1 问题

本案例要求：

- 在newnode挂载 NFS 并实现开机自启
- 想一想如何实现 NFS 的高可用？

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤二：NFSGW测试**

1）实现客户端挂载（客户端可以用newnode这台主机）

```shell
[root@newnode ~]# rm -rf /usr/local/hadoop
[root@newnode ~]# yum -y install nfs-utils
[root@newnode ~]# mount -t nfs -o \
vers=3,proto=tcp,nolock,noatime,sync,noacl 192.168.1.55:/  /mnt/  //挂载
[root@newnode ~]# cd /mnt/
[root@newnode mnt]# ls
aaa  bbb  fa  system  tmp
[root@newnode mnt]# touch a
[root@newnode mnt]# ls
a  aaa  bbb  fa  system  tmp
[root@newnode mnt]# rm -rf a
[root@newnode mnt]# ls
aaa  bbb  fa  system  tmp
```

8）实现开机自动挂载

```shell
[root@newnode ~]# vim /etc/fstab
192.168.1.55:/  /mnt/ nfs  vers=3,proto=tcp,nolock,noatime,sync,noacl,_netdev 0 0 
[root@newnode ~]# mount -a
[root@newnode ~]# df -h
192.168.1.26:/   64G  6.2G   58G  10% /mnt
[root@newnode ~]# rpcinfo -p 192.168.1.55
   program vers proto   port  service
    100005    3   udp   4242  mountd
    100005    1   tcp   4242  mountd
    100000    2   udp    111  portmapper
    100000    2   tcp    111  portmapper
    100005    3   tcp   4242  mountd
    100005    2   tcp   4242  mountd
    100003    3   tcp   2049  nfs
    100005    2   udp   4242  mountd
    100005    1   udp   4242  mountd
```



# Exercise

## 1 如何查看Hadoop集群文件系统的根以及怎么创建

查看

```shell
 [root@nn01 hadoop]# /usr/local/hadoop/bin/hadoop fs -ls /
```

创建

```shell
[root@nn01 hadoop]# /usr/local/hadoop/bin/hadoop fs -mkdir  /aaa    
```

## 2 如何增加一个新的节点

1）增加一个新的节点node4

```shell
[root@hadoop5 ~]# echo node4 > /etc/hostname     //更改主机名为node4
[root@hadoop5 ~]# hostname node4
[root@node4 ~]# yum -y install rsync
[root@node4 ~]# yum -y install java-1.8.0-openjdk-devel
[root@node4 ~]# mkdir /var/hadoop
[root@nn01 .ssh]# ssh-copy-id 192.168.1.25
[root@nn01 .ssh]# vim /etc/hosts
192.168.1.21  nn01
192.168.1.22  node1
192.168.1.23  node2
192.168.1.24  node3
192.168.1.25  node4
[root@nn01 .ssh]# scp /etc/hosts 192.168.1.25:/etc/
[root@nn01 ~]# cd /usr/local/hadoop/
[root@nn01 hadoop]# vim ./etc/hadoop/slaves
node1
node2
node3
node4
[root@nn01 hadoop]# for i in {22..25}; do rsync -aSH --delete /usr/local/hadoop/
\ 192.168.1.$i:/usr/local/hadoop/  -e 'ssh' & done        //同步配置
[1] 1841
[2] 1842
[3] 1843
[4] 1844
[root@node4 hadoop]# ./sbin/hadoop-daemon.sh start datanode  //启动
2）查看状态    
[root@node4 hadoop]# jps
24439 Jps
24351 DataNode
```

## 3 如何设置同步带宽

```
[root@node4 hadoop]# ./bin/hdfs dfsadmin -setBalancerBandwidth 60000000
Balancer bandwidth is set to 60000000
[root@node4 hadoop]# ./sbin/start-balancer.sh
```

## 4 启动NFS需要注意什么

portmap服务只能用root用户启动，nfs3只能用代理用户启动，用root用户执行jps可以看到portmap和nfs3，代理用户执行jps看不到portmap

```shell
[root@nfsgw ~]# /usr/local/hadoop/sbin/hadoop-daemon.sh --script ./bin/hdfs start portmap        //portmap服务只能用root用户启动
starting portmap, logging to /usr/local/hadoop/logs/hadoop-root-portmap-nfsgw.out
[root@nfsgw ~]# jps
23714 Jps
23670 Portmap
[root@nfsgw ~]# su - nfs
Last login: Mon Sep 10 12:31:58 CST 2018 on pts/0
[nfs@nfsgw ~]$ cd /usr/local/hadoop/
[nfs@nfsgw hadoop]$ ./sbin/hadoop-daemon.sh  --script ./bin/hdfs start nfs3  
//nfs3只能用代理用户启动
starting nfs3, logging to /usr/local/hadoop/logs/hadoop-nfs-nfs3-nfsgw.out
[nfs@nfsgw hadoop]$ jps                    
1362 Jps
1309 Nfs3 
[root@nfsgw hadoop]# jps            //root用户执行可以看到portmap和nfs3
1216 Portmap
1309 Nfs3
1374 Jps
```



> 如有侵权，请联系作者删除



﻿@[TOC]( Data import and export & management table records & matching conditions & MySQL management tools | Cloud computing )

---

# 1. 字段约束

## 1.1 问题

- 练习基本约束的使用
- 练习主键的使用
- 练习复合主键的使用
- 练习外键的使用

具体要求如下：
如图-1所示设置约束条件

## 1.2 步骤

**步骤一：练习基本约束的使用**

1. 创建如图-1所示的约束条件

![在这里插入图片描述](https://img-blog.csdnimg.cn/d588514fdabc4ee5a5a80e40d9441b1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－1

```sql
]# mysql  -uroot   -pNSD123...a   //管理员登录
Mysql>
mysql> create database if not exists db2; //建库
Query OK, 1 row affected, 1 warning (0.00 sec)
mysql> create table  db2.t2 (      
class   char(9),      
name    char(10) not null  ,     
age     tinyint  not null default  19 ,     
likes   set("a","b","c","d")  default  "a,b" 
);
mysql> desc db2.t2; //查看表结构
+-------+----------------------+------+-----+---------+-------+
| Field | Type                 | Null | Key | Default | Extra |
+-------+----------------------+------+-----+---------+-------+
| class | char(9)              | YES  |     | NULL    |       |
| name  | char(10)             | NO   |     | NULL    |       |
| age   | tinyint(4)           | NO   |     | 19      |       |
| likes | set('a','b','c','d') | YES  |     | a,b     |       |
+-------+----------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
mysql>
mysql> insert into  t2  values (null,"bob",29,"c,d"); //插入符合约束的记录
Query OK, 1 row affected (0.05 sec)
mysql> insert into  t2(class,name) values ("nsd1902","tom");//测试默认值
Query OK, 1 row affected (0.05 sec)
mysql> insert into  t2  values (null,null,null,null);
ERROR 1048 (23000): Column 'name' cannot be null  //不允许赋null值
MariaDB [db2]>
mysql> select  * from db2.t1;  //查看记录
+---------+------+-----+-------+
| class   | name | age | likes |
+---------+------+-----+-------+
| NULL    | bob  |  29 | c,d   |
| nsd1902 | tom  |  19 | a,b   |
+---------+------+-----+-------+
2 rows in set (0.00 sec)
mysql>
```

**步骤二：练习主键的使用**
字段设置了主键标签后，字段的值必须唯一且不允许赋null值

1. 建表时，创建主键

```sql
Mysql> create  database if not  exists db2;
mysql> CREATE TABLE db2.biao01(
    -> id int(4) PRIMARY KEY,                      //在字段后加primary key 命令
    -> name varchar(8)
    -> );
Query OK, 0 rows affected (0.19 sec)
mysql> DESC db2.biao01; //查看表结构 字段有PRI标记
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   | PRI | NULL    |       |
| name  | varchar(8) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

或者：

```sql
mysql> CREATE TABLE db2.biao02(
    -> id int(4),
    -> name varchar(8),
    -> PRIMARY KEY(id)              //所有字段定义完，最后使用primary key()命令指定
    -> );
Query OK, 0 rows affected (0.17 sec)
```

2. 删除与添加主键
   如果要移除某个表的PRIMARY KEY约束，需要通过ALTER TABLE指令修改。比如，以下操作将清除biao01表的主键索引。

```sql
mysql> DESC db2.biao01;  //删除前 字段id 有主键标记PRI
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   | PRI | NULL    |       |
| name  | varchar(8) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
mysql> ALTER TABLE db2.biao01 DROP PRIMARY KEY;  //删除主键
Query OK, 0 rows affected (0.49 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC db2.biao01; //再次查看没有PRI标记了
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   |     | NULL    |       |
| name  | varchar(8) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
mysql> ALTER TABLE db2.biao01 add PRIMARY KEY(id);  //添加主键
Query OK, 0 rows affected (0.49 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC db2.biao01;  //查看 字段id 有主键标记PRI
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   | PRI | NULL    |       |
| name  | varchar(8) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

3. 与auto_increment连用
   字段必须整型数值类型且是主键，插入记录不给字段赋值，通过自加1的计算结果给字段赋值。

```sql
//给字段加增长属性
mysql> CREATE TABLE db2.tea6( id int primary key  AUTO_INCREMENT,  
name varchar(4) , age int(2)  );
mysql> desc db2.tea6;   //字段多的auto_increment
+-------+------------+------+-----+---------+----------------+
| Field | Type       | Null | Key | Default | Extra          |
+-------+------------+------+-----+---------+----------------+
| id    | int(11)    | NO   | PRI | NULL    | auto_increment |
| name  | varchar(4) | YES  |     | NULL    |                |
| age   | int(2)     | YES  |     | NULL    |                |
+-------+------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
mysql> 
//自加1计算结果赋值测试
mysql> insert into db2.tea6(name,age) values("nb",25),("yaya",19);
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0
mysql> select  * from db2.tea6;
+----+------+------+
| id | name | age  |
+----+------+------+
|  1 | nb   |   25 |  第1条记录编号1
|  2 | yaya |   19 |  第2条记录编号2
+----+------+------+
2 rows in set (0.00 sec)
mysql> insert into db2.tea6(name,age) values("jim",29);  //插入第3条记录
Query OK, 1 row affected (0.03 sec)
mysql> select  * from db2.tea6;
+----+------+------+
| id | name | age  |
+----+------+------+
|  1 | nb   |   25 |
|  2 | yaya |   19 |
|  3 | jim  |   29 | //第3条记录编号为3 
+----+------+------+
3 rows in set (0.00 sec)
mysql> 
```

Auto_increment 依赖 primay key , 有自增长设置是 字段的主键 不能被删除，
要先删除自增长 ，主键才能删除。

```sql
mysql> ALTER TABLE db2.tea6 DROP PRIMARY KEY; //删除主键报错
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
mysql> ALTER TABLE tea6 MODIFY id int(4) NOT NULL; //删除auto_increment
Query OK, 0 rows affected (0.75 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> ALTER TABLE db2.tea6 DROP PRIMARY KEY;                  //删除主键
Query OK, 0 rows affected (0.39 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc db2.tea6;                                         //确认清除结果
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   |     | NULL    |       |
| name  | varchar(4) | NO   |     | NULL    |       |
| age   | int(2)     | NO   |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
3 rows in set (0.01 sec)
```

**步骤三：练习复合主键的使用**

1. 创建复合主键
   复合主键：表中的多个字段一起做主键，复合主键字段的值不允许同时相同

```sql
//把字段cip和port 一起设置为主键
mysql> create table db2.t5(
cip  char(15) ,  //客户端地址
port smallint , //服务端口号
status enum("deny","allow") , //对服务的访问状态
primary key(cip,port)  //指定主键字段
);
Query OK, 0 rows affected (0.19 sec)
mysql> desc db2.t5;// 2个字段都有主键的PRI标记
+--------+----------------------+------+-----+---------+-------+
| Field  | Type                 | Null | Key | Default | Extra |
+--------+----------------------+------+-----+---------+-------+
| cip    | char(15)             | NO   | PRI | NULL    |       |
| port   | smallint(6)          | NO   | PRI | NULL    |       |
| status | enum('deny','allow') | YES  |     | NULL    |       |
+--------+----------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

2. 验证复合主键

```sql
//插入记录
mysql>insert into db2.t5 
values ("1.1.1.1",22,"allow"),("1.1.1.1",80,"deny"),("2.1.1.1",80,"allow");
Query OK, 3 rows affected (0.03 sec)
Records: 3  Duplicates: 0  Warnings: 0
mysql> select * from db2.t5;
+---------+------+--------+
| cip     | port | status |
+---------+------+--------+
| 1.1.1.1 |   22 | allow  | 
| 1.1.1.1 |   80 | deny   | //与第1条地址重复 但端口没有重复
| 2.1.1.1 |   80 | allow  | //与第2条端口重复 但地址没有重复
+---------+------+--------+
3 rows in set (0.01 sec)
//主键字段值同时重复报错
mysql> insert into db2.t5 values ("2.1.1.1",80,"deny");
ERROR 1062 (23000): Duplicate entry '2.1.1.1-80' for key 'PRIMARY'
```

**步骤四：练习外键的使用**

1. 创建参考表员工表（yg表)

```sql
mysql> CREATE TABLE db2.yg(
    -> yg_id int primary key AUTO_INCREMENT,   //员工编号（ 自增长）
    -> name char(16)  //员工姓名
    -> )engine=innodb;
Query OK, 0 rows affected (0.15 sec)
Mysql>
//查看表结构
mysql> desc db2.yg;
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| yg_id | int(11)  | NO   | PRI | NULL    | auto_increment |
| name  | char(16) | YES  |     | NULL    |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
mysql> 
```

2. 创建gz表，用来记录员工的工资信息

其中gz_id需要参考员工工号，即gz表的gz_id字段设为外键，将yg表的yg_id字段作为参考键：

```sql
mysql> CREATE TABLE db2.gz(
    -> gz_id  int,
    -> gz float(7,2),
    -> FOREIGN KEY(gz_id) REFERENCES yg(yg_id)  //创建外键
    -> ON UPDATE CASCADE ON DELETE CASCADE      //同步更新、同步删除
    -> )engine=innodb;
Query OK, 0 rows affected (0.23 sec)
Mysql>
mysql> show create table db2.gz \G     //查看外键 ，外键名gz_ibfk_1
*************************** 1. row ***************************
       Table: gz
Create Table: CREATE TABLE `gz` (
  `gz_id` int(11) DEFAULT NULL,
  `gz` float(7,2) DEFAULT NULL,
  KEY `gz_id` (`gz_id`),
  CONSTRAINT `gz_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `yg` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
mysql> 
//外键删除演示  通过外键名 删除字段的外键设置
mysql> alter table db2.gz drop foreign key  gz_ibfk_1;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0
//查看后没有外键了
mysql> show create table db2.gz \G
*************************** 1. row ***************************
       Table: gz
Create Table: CREATE TABLE `gz` (
  `gz_id` int(11) DEFAULT NULL,
  `gz` float(7,2) DEFAULT NULL,
  KEY `gz_id` (`gz_id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
//添加外键
mysql> alter table db2.gz add  FOREIGN KEY (gz_id) REFERENCES  yg (yg_id) ON DELETE CASCADE ON UPDATE CASCADE;
Query OK, 0 rows affected (0.62 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> 
//再次查看 
mysql> show create table db2.gz \G   
*************************** 1. row ***************************
       Table: gz
Create Table: CREATE TABLE `gz` (
  `gz_id` int(11) DEFAULT NULL,
  `gz` float(7,2) DEFAULT NULL,
  KEY `gz_id` (`gz_id`),
  CONSTRAINT `gz_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `yg` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
mysql> 
```

3. 验证外键

```sql
//yg表插入记录 （添加2个员工）
mysql> insert into db2.yg (name ) values ("jerry"),("tom");
Query OK, 2 rows affected (0.03 sec)
Records: 2  Duplicates: 0  Warnings: 0
//查看yg表记录 ,只有编号1 和 2 的员工
mysql> select  * from db2.yg;
+-------+-------+
| yg_id | name  |
+-------+-------+
|     1 | jerry |
|     2 | tom   |
+-------+-------+
2 rows in set (0.00 sec)
mysql> 
//向工资表里插入记录,  
mysql> insert into  db2.gz values (1,20000),(2,30000);  //工号1和2 的可以正常插入
Query OK, 2 rows affected (0.04 sec)
Records: 2  Duplicates: 0  Warnings: 0
mysql> select  * from db2.gz;
+-------+----------+
| gz_id | gz       |
+-------+----------+
|     1 | 20000.00 |
|     2 | 30000.00 |
+-------+----------+
2 rows in set (0.00 sec)
mysql> 
mysql> insert into  db2.gz values (3,50000); //没有工号3的员工报错
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`db2`.`gz`, CONSTRAINT `gz_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `yg` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE)
mysql> 
//员工表添加第3条记录
mysql> insert into db2.yg(name) values("lili");  
Query OK, 1 row affected (0.03 sec)
mysql> select  * from db2.yg;  //有编号是3的员工了
+-------+-------+
| yg_id | name  |
+-------+-------+
|     1 | jerry |
|     2 | tom   |
|     3 | lili  |
+-------+-------+
3 rows in set (0.00 sec)
mysql> insert into  db2.gz values (3,50000);  //工资表添加记录成功
Query OK, 1 row affected (0.05 sec)
mysql> select  * from db2.gz;  //查看工资表记录
+-------+----------+
| gz_id | gz       |
+-------+----------+
|     1 | 20000.00 |
|     2 | 30000.00 |
|     3 | 50000.00 |
+-------+----------+
3 rows in set (0.00 sec)
mysql> 
```

4. 验证同步更新与删除

```sql
//将yg表中Jerry用户的yg_id修改为8
mysql> update yg set yg_id=8 where name="jerry";
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> select  * from db2.yg;
+-------+-------+
| yg_id | name  |
+-------+-------+
|     2 | tom   |
|     3 | lili  |
|     8 | jerry |
+-------+-------+
3 rows in set (0.00 sec)
mysql> 
//同时也会发现，gz表中Jerry用户的gz_id也跟着变了：
mysql> select  * from db2.gz;
+-------+----------+
| gz_id | gz       |
+-------+----------+
|     8 | 20000.00 |
|     2 | 30000.00 |
|     3 | 50000.00 |
+-------+----------+
3 rows in set (0.00 sec)
mysql> 
//删除工号是8的员工
mysql> delete from db2.yg where yg_id = 8;
Query OK, 1 row affected (0.03 sec)
mysql> select  * from db2.yg;
+-------+------+
| yg_id | name |
+-------+------+
|     2 | tom  |
|     3 | lili |
+-------+------+
2 rows in set (0.00 sec)
mysql> 
 //工资表的编号8的记录也没有了
mysql> select  * from db2.gz;
+-------+----------+
| gz_id | gz       |
+-------+----------+
|     2 | 30000.00 |
|     3 | 50000.00 |
+-------+----------+
2 rows in set (0.00 sec)
mysql> 
```

# 2. MySQL索引

## 2.1 问题

- 练习创建索引
- 练习查看索引
- 练习删除索引
- 练习添加索引

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习创建索引**

创建表的时候指定INDEX索引字段

```sql
mysql> create database if not exists  home; //创建库home
Query OK, 1 row affected (0.00 sec)
```

允许有多个INDEX索引字段。比如，以下操作在home库中创建了tea4表，将其中的id、name作为索引字段：

```sql
mysql> USE home;
Database changed
mysql> CREATE TABLE tea4(
    -> id char(6) NOT NULL,
    -> name varchar(6) NOT NULL,
    -> age int(3) NOT NULL,
    -> gender ENUM('boy','girl') DEFAULT 'boy',
    -> INDEX(id),INDEX(name)
    -> );
Query OK, 0 rows affected (0.59 sec)
```

**步骤二：查看索引**

查看新建tea4表的字段结构，可以发现两个非空索引字段的KEY标志为MUL：

```sql
mysql> DESC tea4;
+--------+--------------------+------+-----+---------+-------+
| Field  | Type               | Null | Key | Default | Extra |
+--------+--------------------+------+-----+---------+-------+
| id     | char(6)            | NO   | MUL | NULL    |       |
| name   | varchar(6)         | NO   | MUL | NULL    |       |
| age    | int(3)             | NO   |     | NULL    |       |
| gender | enum('boy','girl') | YES  |     | boy     |       |
+--------+--------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
//查看详细信息
mysql> SHOW INDEX FROM tea4\G
*************************** 1. row ***************************
        Table: tea4
   Non_unique: 1
     Key_name: id
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE                          //使用B树算法
      Comment: 
Index_comment: 
*************************** 2. row ***************************
        Table: tea4
   Non_unique: 1
     Key_name: nianling                       //索引名称
 Seq_in_index: 1
  Column_name: age                            //字段名称
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
Mysql>
```

**步骤三：删除索引**

比如，删除tea4表中名称为named的INDEX索引字段：

```sql
mysql> drop INDEX name ON tea4;                  //删除name字段的索引
Query OK, 0 rows affected (0.18 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tea4;                                      //确认删除结果
+--------+--------------------+------+-----+---------+-------+
| Field  | Type               | Null | Key | Default | Extra |
+--------+--------------------+------+-----+---------+-------+
| id     | char(6)            | NO   | MUL | NULL    |       |
| name   | varchar(6)         | NO   |     | NULL    |       |
| age    | int(3)             | NO   |     | NULL    |       |
| gender | enum('boy','girl') | YES  |     | boy     |       |
+--------+--------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

**步骤四：添加索引**

比如，针对tea4表的age字段建立索引，名称为 nianling：

```sql
mysql> CREATE INDEX nianling ON tea4(age);      //针对指定字段创建索引
Query OK, 0 rows affected (0.62 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tea4;                                  //确认创建结果
+--------+--------------------+------+-----+---------+-------+
| Field  | Type               | Null | Key | Default | Extra |
+--------+--------------------+------+-----+---------+-------+
| id     | char(6)            | NO   | MUL | NULL    |       |
| name   | varchar(6)         | NO   |     | NULL    |       |
| age    | int(3)             | NO   | MUL | NULL    |       |
| gender | enum('boy','girl') | YES  |     | boy     |       |
+--------+--------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
Mysql>
```

# 3. 用户授权

## 3.1 问题

1. 添加用户dba007，对所有库和所有表有完全权限、且有授权权限，密码为123qqq…A 客户端为网络中的所有主机。
2. 撤销root从本机访问权限，然后恢复。
3. 允许192.168.4.0/24网段主机使用root连接数据库服务器，对所有库和所有表有完全权限、密码为123qqq…A 。
4. 允许任意主机使用webuser用户连接数据库服务器，仅对tarena库有查询,插入,更新,删除记录的权限，密码为123qqq…A
5. 撤销webuser用户的权限，使其仅有查询记录权限。
6. 删除dba007用户

## 3.2 步骤

实现此案例需要按照如下步骤进行。在数据库服务器192.168.4.50主机做用户授权，在能与192.168.4.50主机能ping同的其他主机测试50主机的用户授权，在测试主机执行 which mysql || yum -y install mysql-community-client 提供连接命令mysql

**步骤一：用户授权**

1. 添加用户dba007，对所有库和所有表有完全权限、且有授权权限，密码为123qqq…A 客户端为网络中的所有主机。

```sql
// 50主机管理员root登录
[root@host50 ~]# mysql -uroot -pNSD123...a
//加用户dba007，对所有库和所有表有完全权限、且有授权权限，密码为123qqq…A  客户端为网络中的所有主机。
mysql> grant all on *.* to dba007@"%" identified by "123qqq...A" with grant option;
Query OK, 0 rows affected, 1 warning (0.00 sec)
//查看授权用户dba007的权限 （通过编号2的练习 测试 dba007用户的权限）
mysql> show grants for  dba007@"%";
+---------------------------------------------------------------+
| Grants for dba007@%                                           |
+---------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'dba007'@'%' WITH GRANT OPTION |
+---------------------------------------------------------------+
1 row in set (0.00 sec)
mysql> 
```

2. 撤销root从本机访问的权限，然后恢复

```shell
//在任何客户端使用dba007用户 连接50主机
[root@host51 ~]# mysql -h192.168.4.50 -udba007 -p123qqq...A
Mysql>
//查看可以使用root用来连接的客户端地址
mysql> select host,user from mysql.user where user="root";
+-------------+------+
| host        | user |
+-------------+------+
| 192.168.4.% | root | //192.168.4.0/24 网段所有主机
| localhost   | root |  //本机登录
+-------------+------+
2 rows in set (0.00 sec)
mysql> 
//查看root用户本机登录的访问权限
mysql> show grants for root@"localhost";
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION        |  //可以把自己的权限复制给其他用户
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql> 
//撤销授权权限
mysql> revoke grant option on  *.* from  root@"localhost";
Query OK, 0 rows affected (0.00 sec)
//撤销对库的权限
mysql> revoke all on  *.* from  root@"localhost";
Query OK, 0 rows affected (0.00 sec)
//查看权限
mysql> show grants for root@"localhost";
+--------------------------------------------------------------+
| Grants for root@localhost                                    |
+--------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'root'@'localhost'                     |无权限
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION |
+--------------------------------------------------------------+
2 rows in set (0.00 sec)
//测试权限撤销： 在50主机使用root用户登录
[root@host50 ~]# mysql -hlocalhost -uroot -pNSD123...a
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 38
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>   //可以登录
//查看登录用户信息
mysql> select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)
mysql> 
//查看访问权限
mysql> show grants;
+--------------------------------------------------------------+
| Grants for root@localhost                                    |
+--------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'root'@'localhost'                     |
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION |
+--------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql> 
//测试权限
mysql> show databases;  //只能看到虚拟库
+--------------------+
| Database           |
+--------------------+
| information_schema |
+--------------------+
1 row in set (0.00 sec)
mysql> create database gamedb;  //创建新库 被拒绝
ERROR 1044 (42000): Access denied for user 'root'@'localhost' to database 'gamedb'
mysql> select  * from tarena.user; //查看表记录被拒绝
ERROR 1142 (42000): SELECT command denied to user 'root'@'localhost' for table 'user'
mysql> 
    Mysql> exit; //断开连接
```

在网络中的任意主机使用dba007连接50主机，恢复root本地登录权限

```shell
[root@dbsvr1 ~]# mysql -h192.168.4.50 -udba007 -p123qqq...A //dba007用户登录
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 24
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>
//设置root用户本机登录的权限 
mysql> grant all on  *.* to root@"localhost" identified by "NSD123...a" with grant option;
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> SHOW GRANTS FOR root@localhost;              //查看权限
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION | //有了
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION        |
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql> exit                                      //退出当前MySQL连接
Bye
//在50本机使用root用户登录
[root@dbsvr1 ~]# mysql -u root -p                 //重新以root登入
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> CREATE DATABASE newdb2014;                  //成功创建新库
Query OK, 1 row affected (0.00 sec)
```

3. 允许root从192.168.4.0/24访问，对所有库表有完全权限，密码为123qqq…A

```sql
//在50本机使用root用户登录
[root@host50 ~]# mysql -hlocalhost -uroot -pNSD123...a
Mysql>
//用户授权：允许root从192.168.4.0/24访问，对所有库表有完全权限，密码为123qqq…A
mysql> GRANT all ON *.* TO root@'192.168.4.%' IDENTIFIED BY  "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> 
//再次从192.168.4.0/24网段的客户机访问
[root@host51 ~]# mysql -h192.168.4.50 -uroot -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 32
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> 
mysql> select user();  //查看登录用户信息
+-------------------+
| user()            |
+-------------------+
| root@192.168.4.51 | 
+-------------------+
1 row in set (0.00 sec)
mysql> 
mysql> show grants;  查看访问权限
+-----------------------------------------------------+
| Grants for root@192.168.4.%                         |
+-----------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.4.%' |
+-----------------------------------------------------+
1 row in set (0.00 sec)
mysql> 
//测试权限 （建库、表 ，记录的增删改查 ，库表的删除 ）
mysql> CREATE DATABASE rootdb;                  //创建新库rootdb
Query OK, 1 row affected (0.06 sec)
mysql> SHOW DATABASES; //查看已有库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| home               |
| mysql              |
| performance_schema |
| rootdb             |   //新建的rootdb库
| sys                |
| userdb             |
+--------------------+
7 rows in set (0.01 sec)
```

4. 允许任意主机使用webuser用户连接数据库服务器，仅对tarena库有查询,插入,更新,删除记录的权限，密码为123qqq…A

```sql
//数据库管理员本机登录
[root@host50 ~]# mysql -hlocalhost -uroot -pNSD123...a
mysql> grant select,insert,update,delete on tarena.* to webuser@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> show grants for webuser@"%";  //查看webuser用户权限 ，对所有库表没有任何软件仅对tarena库有权限
+---------------------------------------------------------------------+
| Grants for webuser@%                                                |
+---------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'webuser'@'%'                                 |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `tarena`.* TO 'webuser'@'%' |
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql> 
//测试授权：在任何主机使用webuser用户连接50主机
[root@host51 ~]# mysql -h192.168.4.50 -uwebuser -p123qqq...A  
mysql> select user(); //查看用户信息
+----------------------+
| user()               |
+----------------------+
| webuser@192.168.4.51 |
+----------------------+
1 row in set (0.00 sec)
mysql> show grants;  //查看权限
+---------------------------------------------------------------------+
| Grants for webuser@%                                                |
+---------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'webuser'@'%'                                 |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `tarena`.* TO 'webuser'@'%' |
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql>
//执行除select  insert  update  delete 之外的权限被拒绝
mysql> drop table tarena.user;
ERROR 1142 (42000): DROP command denied to user 'webuser'@'192.168.4.51' for table 'user'
mysql> 
Mysql>exit  //断开连接
```

5. 撤销webuser用户权限，使其仅有查询记录权限。

```sql
//在50主机管理员登录
[root@host50 ~]# mysql -hlocalhost -uroot -pNSD123...a
mysql>
//撤销 webuser用户权限，使其仅有查询记录权限。
mysql> revoke insert,update,delete on tarena.* from webuser@"%";
Query OK, 0 rows affected (0.00 sec)
//查看webuser用户权限
mysql> show grants for webuser@"%";
+---------------------------------------------+
| Grants for webuser@%                           |
+---------------------------------------------+
| GRANT USAGE ON *.* TO 'webuser'@'%'          |
| GRANT SELECT ON `tarena`.* TO 'webuser'@'%' | //只剩select权限了
+---------------------------------------------+
2 rows in set (0.00 sec)
```

6. 删除dba007用户

```sql
// 在50主机管理员登录
[root@host50 ~]# mysql -hlocalhost -uroot -pNSD123...a
Mysql>
//查看已有的授权用户 是否有dba007用户
mysql> select user , host from mysql.user where user="dba007";
+--------+------+
| user   | host |
+--------+------+
| dba007 | %    |
+--------+------+
1 row in set (0.00 sec)
//删除dba007用户
mysql> drop user dba007@"%";
Query OK, 0 rows affected (0.00 sec)
//再次查看没有dba007用户了
mysql> select user , host from mysql.user where user="dba007";
Empty set (0.00 sec)
Mysql>
//在客户端使用dba007用户连接50主机 被拒绝
[root@host51 ~]# mysql -h192.168.4.50 -udba007 -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1045 (28000): Access denied for user 'dba007'@'192.168.4.51' (using password: YES)
[root@host51 ~]# 
```


# Exercise

## 1 简述MySQL数据库中插入、更新、查询、删除表记录的指令格式。

1. 插入记录指令格式

```sql
insert  into   库.表   values(值列表);   //一次插入一条记录 给记录的所有字段赋值
insert  into   库.表   values(值列表),(值列表);  
//一次插入多条记录 给记录的所有字段赋值
insert  into   库.表(字段名列表)   values(值列表); 
//一次插入1条记录 给记录的指定字段赋值
insert  into   库.表(字段名列表)   values(值列表)，(值列表); 
//一次插入多条记录 给记录的指定字段赋值
```

2. 更新记录指令格式

```sql
update  表名  set   字段名=值，字段名="值";         //批量修改
update  表名  set   字段名=值，字段名="值" where  条件; 
//修改符合条件的记录字段的值
```

3. 查询记录指令格式:

```sql
select  字段列表   from  表名; 
//查询所有记录指定字段的值。
select  字段列表   from  表名  where  条件表达式列表；
//查询与条件匹配记录指定字段的值。
```

4. 删除表记录指令格式：

```sql
delete  from  表名；         //删除表的所有记录。
delete  from  表名  where  条件；     //只删除符合条件的记录
```

## 2 查询综合练习题，按要求写出对应查询语句。

> 1. 添加记录编号字段id 在所有字段上方，字段值可以自动增长。
> 2. 显示uid 是四位数的用户的用户名和uid号。
> 3. 显示名字是以字母r 开头 且是以字母d结尾的用户名和uid号。
> 4. 查看gid 小于10的用户使用shell的种类。
> 5. 查看shell不是/bin/bash用户中uid号最大用户名及uid号。
> 6. 统计uid是3位数的用户的个数。

1. 添加记录编号字段id 在所有字段上方，字段值可以自动增长。

```sql
alter  table  userdb.userlist  add  id  int(2) primary key  auto_increment  first;
```

2. 显示uid 是四位数的用户的用户名和uid号。

```sql
select  name,uid  from userdb.userlist where uid >=1000 and uid<=9999; 或 select  name,uid  from userdb.userlist where uid  between  1000  and  9999; 或  select  name,uid  from userdb.userlist where uid regexp ‘^....$’;
```

3. 显示名字是以字母r 开头 且是以字母d结尾的用户名和uid号。

```sql
select name,uid  from userdb.userlist where  name regexp ‘^r.*d$’;
或
select user from mysql.user where user regexp '^r' and user regexp 'd$';
```

4. 查看gid 小于10的用户使用shell的种类。

```sql
select shell from userdb.userlist where uid<10 group by shell;
或
Select distinct shell from userdb.userlist where uid<10； 
```

5. 查看shell不是/bin/bash用户中uid号最大用户名及uid号。

```sql
select name,uid  from userdb.userlist where shell!=”/bin/bash” order by uid desc limit 1;
```

6. 统计uid是3位数的用户的个数。

```sql
select count(name) from userdb.userlist where uid >=100 and uid<=999;
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Data read and write separation & MySQL multi-instance | Cloud computing )

---

# 1. 实现MySQL读写分离

## 1.1 问题

- 搭建一主一从结构
- 配置maxscale代理服务器
- 测试配置

## 1.2 方案

使用4台虚拟机，如图-1所示。其中192.168.4.51和192.168.4.52，分别提供读、写服务，均衡流量，通过主从复制保持数据一致性，由MySQL代理192.168.4.57面向客户端提供服务，收到SQL写请求时，交给主服务器处理，收到SQL读请求时，交给从服务器处理。在客户机192.168.4.50测试配置。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eff406a549bd4b9d86e2bb1775e81913.png)
图－1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：搭建MySQL一主一从同步结构**

1）配置主服务器192.168.4.51

```shell
]# vim /etc/my.cnf
[mysqld]
server_id=51    //指定服务器ID号 
log-bin=master51        //启用binlog日志，并指定文件名前缀
...
[root@master10 ~]# systemctl restart mysqld        //重启mysqld
```

2）主服务器授权用户，并查看binlog日志信息

```shell
]# mysql -uroot -p123456
mysql> grant all on *.* to 'repluser'@'%' identified by '123456';
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master51.000001 |      449 |              |                  |                   |
+-----------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

3）配置从服务器192.168.4.52

```shell
]# vim /etc/my.cnf
[mysqld]
server_id=52 //指定服务器ID号，不要与Master的相同
:wq
]# systemctl restart mysqld
```

4）配置从服务器192.168.4.52，指定主服务器信息，日志文件、偏移位置（参考MASTER上的状态输出）

```shell
]# mysql -uroot -p123456
mysql> change master to master_host='192.168.4.51',
    -> master_user='repluser',
    -> master_password='123456',
    -> master_log_file='master51.000001',
    -> master_log_pos=449;
Query OK, 0 rows affected, 2 warnings (0.01 sec)
mysql> start slave;
Query OK, 0 rows affected (0.01 sec)
mysql> show  slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.4.51
                  Master_User: repluser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: master51.000001
          Read_Master_Log_Pos: 738
               Relay_Log_File: slave20-relay-bin.000002
                Relay_Log_Pos: 319
        Relay_Master_Log_File: master51.000001
             Slave_IO_Running: Yes        //IO线程YES
            Slave_SQL_Running: Yes        //SQL线程YES
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 738
              Relay_Log_Space: 528
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 10
                  Master_UUID: 95ada2c2-bb24-11e8-abdb-525400131c0f
             Master_Info_File: /var/lib/mysql/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400
                  Master_Bind: 
      Last_IO_Error_Timestamp: 
     Last_SQL_Error_Timestamp: 
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
           Retrieved_Gtid_Set: 
            Executed_Gtid_Set: 
                Auto_Position: 0
         Replicate_Rewrite_DB: 
                 Channel_Name: 
           Master_TLS_Version: 
1 row in set (0.00 sec)
```

5）测试配置，在主服务器本机创建数据库 aa库

```shell
]# mysql –uroot –p123456
mysql> create database aa;
Query OK, 1 row affected (0.00 sec)
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| aa                 |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
```

6）从服务器上查看，有aa库

```shell
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| aa                 |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
```

**步骤二：配置maxscale代理服务器**

1）环境准备

关闭防火墙和SElinux，保证yum源可以正常使用，安装提供服务的软件

```shell
]# rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm         //安装maxscale
warning: maxscale-2.1.2-1.rhel.7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID 8167ee24: NOKEY
Preparing...                          ################################# [100%]
Updating / installing...
   1:maxscale-2.1.2-1                 ################################# [100%]
```

2）修改主配置文件

```shell
]# vim /etc/maxscale.cnf
[maxscale]
threads=auto            //运行的线程的数量
[server1]            //定义数据库服务器
type=server
address=192.168.4.51        //主服务器ip
port=3306
protocol=MySQLBackend        
[server2]
type=server
address=192.168.4.52        //从服务器IP
port=3306
protocol=MySQLBackend
[MySQL Monitor]                //定义监控的数据库服务器
type=monitor
module=mysqlmon
servers=server1, server2        //监控的数据库列表，不能写ip
user=maxscalemon                    //监控用户
passwd=123qqq...A                //密码
monitor_interval=10000        
#[Read-Only Service]        //不定义只读服务
#type=service
#router=readconnroute
#servers=server1
#user=myuser
#passwd=mypwd
#router_options=slave
[Read-Write Service]            //定义读写分离服务
type=service
router=readwritesplit
servers=server1, server2
user=maxscalerouter            //路由用户
passwd=123qqq…A                //密码
max_slave_connections=100%
[MaxAdmin Service]        //定义管理服务
type=service
router=cli
#[Read-Only Listener]        //不定义只读服务使用的端口号
#type=listener
#service=Read-Only Service
#protocol=MySQLClient
#port=4008
[Read-Write Listener]            //定义读写服务使用的端口号
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006
[MaxAdmin Listener]        //管理服务使用的端口号
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016     //手动添加，不指定时使用的是默认端口在启动服务以后可以知道默认端口是多少
```

3）添加授权用户

根据maxscale.cnf文件配置，在主/从服务器上添加对应的授权用户，因为2台数据库服务器是主从同步结构，只在主数据库服务器添加用户即可，从服务器会自动同步

```shell
mysql> grant replication slave,replication client on *.* to  maxscalemon@'%' identified by "123qqq…A"; //授权监控用户
mysql> grant select on mysql.* to maxscalerouter@"%" identified by "123qqq…A"; //授权路由用户
```

4）查看授权用户

分别在主/从服务器上面查看

```shell
mysql> select user,host from mysql.user where user like “maxscale%”;
+----------------+------+
| user           | host |
+----------------+------+
| maxscalemon    | %    |
| maxscalerouter | %    |
+----------------+------+
2 rows in set (0.00 sec)
```

在代理服务器57主机，测试授权用户

```shell
]# yum -y  install mariadb  //安装提供mysql命令的软件包
]# mysql -h 192.168.4.51 -umaxscalemon -p123qqq…A
]# mysql -h 192.168.4.52 -umaxscalemon -p123qqq…A
]# mysql -h 192.168.4.51 -umaxscalerouter -p123qqq…A
]# mysql -h 192.168.4.52 -umaxscalerouter -p123qqq…A
```

5）启动服务代理服务

```shell
]# maxscale -f  /etc/maxscale.cnf   
]# ps -C  maxscale        //查看进程
PID TTY          TIME CMD
17930 ?        00:00:00 maxscale   
]# netstat  -antup | grep :4006  //查看读写分离端口
tcp6       0      0 :::4006      :::*                    LISTEN      17930/maxscale
]# netstat  -antup | grep :4016  //查看管理服务端口
tcp6       0      0 :::4016       :::*                    LISTEN      17930/maxscale
```

**步骤三：测试配置**

1）查看监控信息（在主机57 本机自己访问自己）

```shell
]# maxadmin  -uadmin -pmariadb -P4016
MaxScale> list  servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Master, Running
server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------
```

2）在主服务器上添加访问数据连接用户

在主服务器添加即可，从服务器会自动同步数据

```shell
mysql> create database gamedb;
mysql> create table gamedb.a(id int);
mysql> grant select,insert on  gamedb.* to  yaya66@"%" identified by "123qqq...A";
```

客户端连接代理服务57 访问数据

```shell
]# mysql -h192.168.4.57 -P4006 -uyaya66 -p123qqq...A
mysql> select * from gamedb.a;
mysql> insert into gamedb.a values(99);
mysql> select * from gamedb.a;
mysql> select * from gamedb.a;
Empty set (0.00 sec)
mysql>
mysql> insert into gamedb.a values(99);
Query OK, 1 row affected (0.06 sec)
mysql>
mysql> select * from gamedb.a;
+------+
| id |
+------+
| 99 |
+------+
1 row in set (0.00 sec)
```

3）验证57主机的数据读写分离功能
在从服务器添加新纪录

```shell
Mysql> insert into gamedb.values(52);
Mysql> select * from mysql> select * from gamedb.a;
+------+
| id |
+------+
| 99 |
| 52 |
+------+
```

在主服务器查看记录

```shell
Mysql> select * from mysql> select * from gamedb.a;
+------+
| id |
+------+
| 99 |
+------+
```

客户端连接代理服务器57 访问数据

```shell
]# mysql -h192.168.4.57 -P4006 -uyaya66 -p123qqq...A
mysql> select * from mysql> select * from gamedb.a;
+------+
| id |
+------+
| 99 |
| 52 |
+------+
```

# 2. 配置MySQL多实例

## 2.1 问题

在主机192.168.4.57上：
配置第1个MySQL实例

- 实例名称mysqld1、端口3307
- 数据库目录/dir2、pid文件mysqld1.pid
- 错误日志mysqld1.err、socket文件mysqld1.socket

配置第2个MySQL实例

- 实例名称mysqld2、端口3308
- 数据库目录/dir1、pid文件mysqld2.pid
- 错误日志mysqld2.err、socket文件mysqld2.socket

**步骤一：配置多实例（192.168.4.57上操作）**

什么是多实例：

在一台物理主机上运行多个数据库服务，可以节约运维成本，提高硬件利用率

1）解压软件、修改目录名、设置PATH路径

```shell
]# yum –y  install libaio
]# useradd  mysql
]# tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
]# PATH=/usr/local/mysql/bin:$PATH
]# vim /etc/bashrc
export PATH=/usr/local/mysql/bin:$PATH
:wq
```

2）编辑主配置文件/etc/my.cnf

每个实例要有独立的数据库目录、监听端口号、实例名称和独立的sock文件

```shell
]# vim /etc/my.cnf
[mysqld_multi]        //启用多实例
mysqld = /usr/local/mysql/bin/mysqld_safe        //指定进程文件路径
mysqladmin = /usr/local/mysql/bin/mysqladmin    //指定管理命令路径
user = root        //指定进程用户
[mysqld1]        //实例进程名称
port=3307        //端口号
datadir=/dir1        //数据库目录 ，要手动创建
socket=/dir1/mysqld1.sock        //指定sock文件的路径和名称
pid-file=/dir1/mysqld1.pid        //进程pid号文件位置
log-error=/dir1/mysqld1.err        //错误日志位置 
[mysqld2]
port=3308
datadir=/dir2
socket=/dir2/mysqld2.sock
pid-file=/dir2/mysqld2.pid
log-error=/dir2/mysqld2.err 
:wq
```

3）创建数据库目录

```shell
]# mkdir  /dir2
]# mkdir  /dir1
```

4）启动多实例

首次启动服务会做数据初始化 并初始和提示数据库管理员本机登录密码

```shell
[root@host57 ~]# mysqld_multi  start 1 //启动实例1
Installing new database in /dir1
2019-06-13T10:46:29.307866Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2019-06-13T10:46:30.997233Z 0 [Warning] InnoDB: New log files created, LSN=45790
2019-06-13T10:46:31.436904Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2019-06-13T10:46:31.582129Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 816bf015-8dc8-11e9-b492-525400cffedc.
2019-06-13T10:46:31.605276Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2019-06-13T10:46:31.606321Z 1 [Note] A temporary password is generated for root@localhost: ly#LryiFE5fT  管理员本机登录密码
]# ls /dir1 //查看数据库目录文件列表
auto.cnf  ib_buffer_pool  ibdata1  ib_logfile0  ib_logfile1  ibtmp1  mysql  mysql3307.log  mysql3307.pid  mysql3307.sock  mysql3307.sock.lock  performance_schema  sys
]# mysqld_multi  start 2  //启动实例2
Installing new database in /dir1
2019-06-13T10:56:55.580796Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2019-06-13T10:56:57.199217Z 0 [Warning] InnoDB: New log files created, LSN=45790
2019-06-13T10:56:57.571839Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2019-06-13T10:56:57.708168Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: f69f30fa-8dc9-11e9-8a17-525400cffedc.
2019-06-13T10:56:57.724096Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2019-06-13T10:56:57.724677Z 1 [Note] A temporary password is generated for root@localhost: qedTjrZs*8ma  管理员本机登录密码
]# ls /dir1 //查看数据库目录文件列表
auto.cnf  ib_buffer_pool  ibdata1  ib_logfile0  ib_logfile1  ibtmp1  mysql  mysql3308.log  mysql3308.pid  mysql3308.sock  mysql3308.sock.lock  performance_schema  sys
```

5）查看端口

```shell
]# netstat -utnlp  | grep :3307
tcp6       0      0 :::3307                 :::*             LISTEN      1151/mysqld         
]# netstat -utnlp  | grep :3308
tcp6       0      0 :::3308                 :::*            LISTEN      1339/mysqld         
]# netstat -utnlp | grep mysqld
tcp6       0      0 :::3307                 :::*            LISTEN      1151/mysqld         
tcp6       0      0 :::3308                 :::*           LISTEN      1339/mysqld         
# ps -C mysqld
  PID TTY          TIME CMD
 1151 pts/1    00:00:00 mysqld
 1339 pts/1    00:00:00 mysqld
[root@host57 ~]#
```

6）访问多实例
使用初始化密码登录实例1

```shell
[root@host57 ~]# mysql -uroot -p'ly#LryiFE5fT' -S /dir1/mysqld1.sock 
    mysql> alter user root@"localhost" identified by "123456";    //修改密码
mysql> exit
Bye
[root@host57 ~]# mysql -uroot -p123456  -S /dir1/mysqld1.sock //新密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.20 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
mysql> create database db1; //创建新库db1
Query OK, 1 row affected (0.00 sec)
mysql> show databases; //查看已有的库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db1                  |  //db1库
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
mysql> exit  //断开连接
Bye
[root@host56 ~]# ls /dir1  //查看数据库目录文件列表 有db1库的文件夹
auto.cnf        ibdata1      ibtmp1       mysqld1.pid          performance_schema
db1             ib_logfile0  mysql        mysqld1.socket       sys
ib_buffer_pool  ib_logfile1  mysqld1.err  mysqld1.socket.lock
[root@host56 ~]#
```

使用初始化密码登录实例2

```shell
[root@host57 ~]# mysql -uroot -p'qedTjrZs*8ma' -S /dir2/mysqld2.sock 
    mysql> alter user root@"localhost" identified by "654321";    //修改密码
mysql> exit
Bye
[root@host57 ~]# mysql -uroot –p654321  -S /dir2/mysqld2.sock //新密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.20 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
mysql>
mysql> create database db2;
Query OK, 1 row affected (0.00 sec)
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db2                |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
mysql> exit
Bye
[root@host56 ~]# ls /dir2
auto.cnf        ib_logfile0  mysqld2.err          performance_schema
db2             ib_logfile1  mysqld2.pid          sys
ib_buffer_pool  ibtmp1       mysqld2.socket
ibdata1         mysql        mysqld2.socket.lock
[root@host56 ~]#
```

7）停止多实例服务

```shell
mysqld_multi --user=root --password=密码 stop 实例编号

]# netstat -utnlp  | grep  mysqld
tcp6       0      0 :::3307                 :::*                    LISTEN      1250/mysql
tcp6       0      0 :::3308                 :::*                    LISTEN      1451/mysql
]# mysqld_multi  --user=root --password=123456  stop 2
 [root@host56 ~]# netstat -utnlp  | grep  mysqld
tcp6       0      0 :::3307                 :::*                    LISTEN      1250/mysql
]# mysql -uroot   -p123456   -S    /dir2/mysqld2.sock //拒绝连接
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/dir2/mysqld2.sock' (2)
```

# Exercise

## 1 请简述数据读写分离的原理

原理：

MySQL服务器，分别提供读、写服务，均衡流量，通过主从复制保持数据一致性，由MySQL代理服务接受客户端访问，收到SQL写请求时，交给主服务器处理，收到SQL读请求时，交从给服务器处理。

## 2 简述什么是MySQL多实例及多实例的优点？

在一台物理主机上运行多个数据库服务

优点：节约运维成本，提高硬件利用率

## 3 简述配置多实例的步骤。

1. 安装支持多实例服务的软件包
2. 修改主配置文件
3. 创建数据库目录
4. 启动多实例
5. 客户端访问测试

> 如有侵权，请联系作者删除



﻿@[TOC]( Data sharding overview & MyCAT service deployment & test configuration | Cloud computing )

---

# 1. 部署MyCAT服务

## 1.1 问题

- 数据库服务器192.168.4.53 使用db1库存储数据
- 数据库服务器192.168.4.54 使用db2库存储数据
- 数据库服务器192.168.4.55 使用db3库存储数据
- 主机 192.168.4.56 运行mycat服务，逻辑库名称TESTDB，连接用户名为adminplj，密码123qqq…A
- 客户端192.168.4.50访问mycat服务测试配置

## 1.2 方案

准备5台虚拟主机；其中主机192.168.4.56作为mycat服务器，192.168.4.53、192.168.4.54、192.168.4.55运行数据库服务，192.168.4.50作为客户端。具体如图-1所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a5a4ec623cfa4add80d383a49b4ee386.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置分片服务器（192.168.4.56）**

1）部署MyCat 运行环境

```shell
]# yum -y install java-1.8.0-openjdk //安装JDK

已安装:
java-1.8.0-openjdk.x86_64 1:1.8.0.161-2.b14.el7

作为依赖被安装:
alsa-lib.x86_64 0:1.1.4.1-2.el7
copy-jdk-configs.noarch 0:3.3-2.el7
giflib.x86_64 0:4.1.6-9.el7
java-1.8.0-openjdk-headless.x86_64 1:1.8.0.161-2.b14.el7
javapackages-tools.noarch 0:3.4.1-11.el7
libXtst.x86_64 0:1.2.3-1.el7
libxslt.x86_64 0:1.1.28-5.el7
lksctp-tools.x86_64 0:1.0.17-2.el7
python-javapackages.noarch 0:3.4.1-11.el7
python-lxml.x86_64 0:3.2.1-4.el7
tzdata-java.noarch 0:2018c-1.el7
完毕！
[root@mycat56 ~]# which java //查看命令
/usr/bin/java
[root@mycat56 ~]# java –version //显示版本
openjdk version "1.8.0_161"
OpenJDK Runtime Environment (build 1.8.0_161-b14)
OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode)
```

2）安装提供服务的软件包

```shell
[root@mycat56 ~]# tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz //解压源码
mycat/bin/wrapper-linux-ppc-64
……
……
mycat/version.txt
mycat/conf/log4j2.xml
mycat/bin/init_zk_data.sh
mycat/bin/startup_nowrap.sh
mycat/bin/dataMigrate.sh
mycat/bin/rehash.sh
mycat/logs/
mycat/catlet/
[root@mycat56 ~]#
[root@mycat56 ~]# mv mycat /usr/local/ //移动目录（非必须操作）
[root@mycat56 ~]# ls /usr/local/mycat/ //查看文件列表
bin catlet conf lib logs version.txt
[root@mycat56 ~]#
```

3）设置连账号

```shell
]# vim /usr/local/mycat/conf/server.xml
<user name="root">        //连接mycat服务时使用的用户名
     <property name="password">123456</property> //用户连接mycat用户时使用的密码
     <property name="schemas">TESTDB</property> //逻辑库名
</user>
<user name="user">
                <property name="password">user</property>
                <property name="schemas">TESTDB</property>
                <property name="readOnly">true</property>    //只读权限，连接mycat服务后只有读记录的权限,不写这一行则是可读可写    
</user>
:wq
```

4）配置数据分片

使用sed删除不需要的配置行(可选操作)

```shell
[root@mycat56 conf]# wc -l schema.xml  //删除前查看总行数
77 /root/schema.xml
[root@mycat56 conf]# sed -i  '56,77d' schema.xml //删除无关的配置行
[root@mycat56 conf]# sed -i  '39,42d' schema.xml
[root@mycat56 conf]# sed -i  '16,18d' schema.xml
[root@mycat56 conf]# wc -l schema.xml //删除后查看总行数
48 schema.xml
[root@mycat56 conf]# vim  /usr/local/mycat/conf/schema.xml 
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">
          
       <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">//对TESTDB库下的表做分片存储
                <!-- auto sharding by id (long) -->
                  
                <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />  //对travelrecord表做分片存储
                <!-- global table is auto cloned to all defined data nodes ,so can join
                        with any table whose sharding node is in the same data node -->
                <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />  //对company表做分片存储
                <table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />  
                <!-- random sharding using mod sharind rule -->
                <table name="hotnews"  dataNode="dn1,dn2,dn3"
                           rule="mod-long" /> 
                <table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile" /> 
                <table name="customer" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile"> 
                        <childTable name="orders" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id">
                                <childTable name="order_items" joinKey="order_id"
                                                        parentKey="id" />
                        </childTable>
                        <childTable name="customer_addr" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id" />
                </table>
                <!-- <table name="oc_call" primaryKey="ID" dataNode="dn1$0-743" rule="latest-month-calldate"
                        /> -->
        </schema>
//定义数据库主机名及存储数据的库
<dataNode name="dn1" dataHost="localhost53" database="db1" /> 
<dataNode name="dn2" dataHost="localhost54" database="db2" />
<dataNode name="dn3" dataHost="localhost55" database="db3" />
//定义localhost53主机名对应的数据库服务器ip地址
<dataHost name="localhost53" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100"> 
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM53" url="192.168.4.53:3306" user="adminplj"
                                   password="123qqq...A">
                </writeHost> 
 </dataHost>
    
     //定义localhost54主机名对应的数据库服务器ip地址
    <dataHost name="localhost54" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM54" url="192.168.4.54:3306" user="adminplj"
                                   password="123qqq...A">
                </writeHost> 
     </dataHost> 
    //定义localhost54主机名对应的数据库服务器ip地址
    <dataHost name="localhost55" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM55" url="192.168.4.55:3306" user="adminplj"
                                   password="123qqq...A">
                </writeHost>
     </dataHost>
:wq
```

5）配置数据库服务器

根据分片文件的设置在对应的数据库服务器上创建存储数据的数据库

```shell
mysql> create database db1;   //在数据库53上，创建db1库
mysql> create database db2;   //在数据库54上，创建db2库
mysql> create database db3;   //在数据库55上，创建db3库  
```

根据分片文件配置，在对应的数据库服务器上创建授权用户(3台数据库服务器都要添加，在数据库服务器本机管理员root用户登录后执行授权命令)

```shell
mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ; //在数据库服务器192.168.4.53 执行
mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ; //在数据库服务器192.168.4.54 执行 
mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ; //在数据库服务器192.168.4.55 执行
```

6）启动mycat服务

测试授权用户：在192.168.4.56主机，使用授权用户分别连接3台数据库服务器，若连接失败，请检查数据库服务器是否有对应的授权用户。

```shell
[root@mycat56 ~]# which  mysql || yum  -y  install  mariadb //安装提供mysql命令的软件包
//连接数据库服务器192.168.4.53
[root@mycat56 ~]# mysql -h192.168.4.53 -uadminplj -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 54
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> exit;   //连接成功 断开连接
Bye
[root@mycat56 ~]# 
//连接数据库服务器192.168.4.54
[root@mycat56 ~]# mysql -h192.168.4.54 -uadminplj -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 47
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> exit;   //连接成功 断开连接
Bye
[root@mycat56 ~]# 
//连接数据库服务器192.168.4.54
[root@mycat56 ~]# mysql -h192.168.4.55 -uadminplj -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 49
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> exit ;   //连接成功 断开连接
```

启动服务

```shell
[root@mycat56 ~]# /usr/local/mycat/bin/mycat start
Starting Mycat-server...
[root@mycat56 ~]#
```

查看服务状态

```shell
[root@mycat56 ~]# netstat  -utnlp  | grep  :8066  //查看端口
tcp6       0      0 :::8066                 :::*       LISTEN      2924/java           
[root@mycat56 ~]# 
[root@mycat56 ~]# ps -C java  //查看进程
  PID TTY          TIME CMD
 2924 ?        00:00:01 java
[root@mycat56 ~]#
```

**步骤二：测试配置**

1）客户端访问

在客户端192.168.4.50 连接分片服务器，访问数据

命令： mysql -hmycat主机的IP -P端口号 -u用户 -p密码

```shell
[root@client50 ~]# mysql -h192.168.4.56 -P8066 -uroot –p123456
mysql> show databases; //显示已有的库
+----------+
| DATABASE |
+----------+
| TESTDB   |
+----------+
1 row in set (0.00 sec)
mysql> USE TESTDB; //进入TESTDB库
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
mysql> 
mysql> show tables; //显示已有的表，配置文件里定义的表名
+------------------+
| Tables in TESTDB |
+------------------+
| company          |
| customer         |
| customer_addr    |
| employee         |
| goods            |
| hotnews          |
| orders           |
| order_items      |
| travelrecord     |
+------------------+
9 rows in set (0.00 sec)
mysql>exit；  //断开连接
```

# 2. 连接分片服务器存储数据

## 2.1 问题：

具体要求如下：

- 练习sharding-by-intfile分片规则的使用
- 练习mod-long分片规则的使用

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习sharding-by-intfile分片规则的使用**

1）查看配置文件，得知使用sharding-by-intfile分片规则的表名

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/schema.xml
<table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
rule="sharding-by-intfile" />
:wq
```

2）查看规则文件，得知sharding-by-intfile分片规则使用的函数

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/rule.xml
<tableRule name="sharding-by-intfile">
                <rule>
                        <columns>sharding_id</columns>  //数据分片字段名
                        <algorithm>hash-int</algorithm> //使用的函数名
                </rule>
</tableRule>
<function name="hash-int"
                class="io.mycat.route.function.PartitionByFileMap">
                <property name="mapFile">partition-hash-int.txt</property> //函数调用的配置文件
</function>
：wq
```

3）修改函数配置文件,添加dn3 数据节点

```shell
[root@mycat56 ~]# vim  /usr/local/mycat/conf/partition-hash-int.txt
10000=0   //当sharding_id字段的值是10000时,数据存储在数据节点dn1里
10010=1   //当sharding_id字段的值是10010时,数据存储在数据节点dn2里
10020=2   //当sharding_id字段的值是10020时,数据存储在数据节点dn3里
:wq
```

4）重启mycat服务，使其修改有效

```shell
[root@mycat56 ~]# /usr/local/mycat/bin/mycat  stop    //停止服务
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 conf]# netstat -utnlp  | grep  :8066  //无端口
[root@mycat56 conf]# ps –C  java //无进程
[root@mycat56 conf]#
[root@mycat56 conf]# /usr/local/mycat/bin/mycat  start  //启动服务
Starting Mycat-server...
[root@mycat56 conf]# 
[root@mycat56 conf]# netstat -utnlp  | grep  :8066 //有端口
tcp6       0      0 :::8066                 :::*           LISTEN      1364/java
[root@mycat56 conf]#
[root@mycat56 conf]# ps –C  java //有进程
PID TTY          TIME CMD
 1125 ?        00:00:01 java
[root@mycat56 conf]#
```

5）客户端连接分片服务器，存取数据

```shell
]#mysql -h192.168.4.56 -P8066 -uroot -p123456 //访问服务
mysql> use TESTDB; //进入TESTDB库
mysql> create table  employee( ID int primary key , sharding_id int,
    -> name char(15) , age  int ); //建表
Query OK, 0 rows affected (0.68 sec)
mysql> desc employee; //查看表结构
+-------------+----------+------+-----+---------+-------+
| Field       | Type     | Null | Key | Default | Extra |
+-------------+----------+------+-----+---------+-------+
| ID          | int(11)  | NO   | PRI | NULL    |       |
| sharding_id | int(11)  | YES  |     | NULL    |       |
| name        | char(15) | YES  |     | NULL    |       |
| age         | int(11)  | YES  |     | NULL    |       |
+-------------+----------+------+-----+---------+-------+
4 rows in set (0.00 sec)
Mysql>insert into employee(ID,sharding_id,name,age) //插入表记录
values 
(1,10000,"bob",19), //存储在53服务器的db1库的employee表里
(2,10010,"tom",21), //存储在54服务器的db2库的employee表里
(3,10020,"lucy2",16); //存储在55服务器的db3库的employee表里
Query OK, 3 rows affected (0.07 sec)
Records: 3  Duplicates: 0  Warnings: 0
mysql> select  * from employee; //查看表记录
+----+-------------+------+------+
| ID | sharding_id | name | age  |
+----+-------------+------+------+
|  1 |       10000 | bob  |   19 |
|  2 |       10010 | tom  |   21 |
|  3 |       10020 | lucy |   16 |
+----+-------------+------+------+
3 rows in set (0.06 sec)
mysql>insert into employee(ID,sharding_id,name,age)
values 
(4,10000,"bob2",19), //存储在53服务器的db1库的employee表里
(5,10000,"tom2",21), //存储在53服务器的db1库的employee表里
(6,10000,"lucy2",16); //存储在53服务器的db1库的employee表里
Query OK, 3 rows affected (0.07 sec)
Records: 3  Duplicates: 0  Warnings: 0
mysql> select  * from employee;   //查看表记录                                        +----+-------------+-------+------+
| ID | sharding_id | name  | age  |
+----+-------------+-------+------+
|  1 |       10000 | bob   |   19 |
|  4 |       10000 | bob2  |   19 |
|  5 |       10000 | tom2  |   21 |
|  6 |       10000 | lucy2 |   16 |
|  3 |       10020 | lucy  |   16 |
|  2 |       10010 | tom   |   21 |
+----+-------------+-------+------+
6 rows in set (0.00 sec)
```

6）在数据库服务器本机，查看表记录

在数据库服务器192.168.4.53 查看数据

```shell
[root@host53 ~]# mysql -uroot -p123qqq...A -e "select * from db1.employee"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------------+-------+------+
| ID | sharding_id | name  | age  |
+----+-------------+-------+------+
|  1 |       10000 | bob   |   19 |
|  4 |       10000 | bob2  |   19 |
|  5 |       10000 | tom2  |   21 |
|  6 |       10000 | lucy2 |   16 |
+----+-------------+-------+------+
[root@host53 ~]#
```

在数据库服务器192.168.4.54 查看数据

```shell
[root@host54 ~]#  mysql -uroot -p123qqq...A -e "select * from db2.employee"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------------+------+------+
| ID | sharding_id | name | age  |
+----+-------------+------+------+
|  2 |       10010 | tom  |   21 |
+----+-------------+------+------+
[root@host54 ~]#
```

在数据库服务器192.168.4.55 查看数据

```shell
[root@host55 ~]#  mysql -uroot -p123qqq...A -e "select * from db3.employee"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------------+------+------+
| ID | sharding_id | name | age  |
+----+-------------+------+------+
|  3 |       10020 | lucy |   16 |
+----+-------------+------+------+
[root@host55 ~]#
```

**步骤二：练习mod-long分片规则的使用**

1）查看配置文件，得知使用mod-long分片规则的表名

注意要删除 primaryKey="ID" autoIncrement="true" 不然无法存储数据

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/schema.xml
<table name="hotnews" dataNode="dn1,dn2,dn3" rule="mod-long" />
:wq
```

2）查看规则文件，得知 mod-long分片规则使用的函数

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/rule.xml
<tableRule name="mod-long">
                <rule>
                        <columns>id</columns>  //数据分片字段
                        <algorithm>mod-long</algorithm> //函数名
                </rule>
        </tableRule>
<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
                <!-- how many data nodes -->
                <property name="count">3</property> //指定求模数字
</function>
：wq
```

3）重启mycat服务，使其修改有效

```shell
[root@mycat56 ~]# /usr/local/mycat/bin/mycat  stop    //停止服务
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 conf]# netstat -utnlp  | grep  :8066  //无端口
[root@mycat56 conf]# ps –C  java //无进程
[root@mycat56 conf]#
[root@mycat56 conf]# /usr/local/mycat/bin/mycat  start  //启动服务
Starting Mycat-server...
[root@mycat56 conf]# 
[root@mycat56 conf]# netstat -utnlp  | grep  :8066 //有端口
tcp6       0      0 :::8066                 :::*           LISTEN      1364/java
[root@mycat56 conf]#
[root@mycat56 conf]# ps –C  java //有进程
PID TTY          TIME CMD
 1125 ?        00:00:01 java
[root@mycat56 conf]#
```

4）客户端连接分片服务器，存取数据

```shell
]#mysql -h192.168.4.56 -P8066 -uroot -p123456 //访问服务
mysql> use TESTDB; //进入TESTDB库
mysql> create table hotnews(id int ,title char(30),comment char(200)); //建表
Query OK, 0 rows affected (0.79 sec)
mysql> desc hotnews; //查看表结构
+---------+-----------+------+-----+---------+-------+
| Field   | Type      | Null | Key | Default | Extra |
+---------+-----------+------+-----+---------+-------+
| id     | int(11)   | YES  |     | NULL    |       |
| title   | char(30)  | YES  |     | NULL    |       |
| comment | char(200) | YES  |     | NULL    |       |
+---------+-----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> insert into hotnews(id,title,comment)values(9,"sc","xxxxx"); //插入第1条表记录，9和3取余 余0 记录存储在53服务器的db1库里
Query OK, 1 row affected (0.11 sec)
mysql> insert into hotnews(id,title,comment)values(10,"xx","haha");//插入第2条表记录，10和3取余 余1 记录存储在54服务器的db2库里
Query OK, 1 row affected (0.05 sec)
mysql> insert into hotnews(id,title,comment)values(11,"yy","zz");//插入第3条表记录，11和3取余 余2 记录存储在55服务器的db3库里
Query OK, 1 row affected (0.03 sec)
mysql> select  * from hotnews; //查看表记录
+------+-------+---------+
|   id | title | comment |
+------+-------+---------+
|   11 | yy    | zz      |
|   10 | xx    | haha    |
|    9 | sc    | xxxxx   |
+------+-------+---------+
3 rows in set (0.01 sec)
```

5）在数据库服务器本机，查看表记录

在数据库服务器192.168.4.53 查看数据

```shell
[root@host53 ~]# mysql -uroot -p123qqq...A -e "select * from db1.hotnews"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+-------+---------+
|  id  | title | comment |
+------+-------+---------+
|    9 | sc    | xxxxx   |
+------+-------+---------+
[root@host53 ~]#
```

在数据库服务器192.168.4.54 查看数据

```shell
[root@host54 ~]#  mysql -uroot -p123qqq...A -e "select * from db2.hotnews"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+-------+---------+
|   id  | title | comment |
+------+-------+---------+
|   10 | xx    | haha    |
+------+-------+---------+
[root@host54 ~]# [root@host54 ~]#
```

在数据库服务器192.168.4.55 查看数据

```shell
[root@host55 ~]#  mysql -uroot -p123qqq...A -e "select * from db3.hotnews"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+-------+---------+
|   id   | title | comment |
+------+-------+---------+
|   11 | yy    | zz      |
+------+-------+---------+
[root@host55 ~]# 
```

# 3. 连接分片服务器存储数据

## 3.1 问题：

具体要求如下：

- 逻辑库名BBSDB
- 逻辑表名company2数据不分片，把数据存储到3台数据库服务器上
- 逻辑表名employee2 使用枚举法分片规则把数据存储到3台数据库服务器上

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置Mycat服务器**

1）添加新库

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/server.xml
<user name="root">
……
<property name="schemas">TESTDB,BBSDB</property>//指定逻辑库名
</user>
:wq
```

2）添加新表

```shell
[root@mycat56 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">              
            <schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
                    <table name="company2" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" /> //指定逻辑表名company2
                    <table name="employee2" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile" /> //指定逻辑表名employee2
          </schema>
          <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
                ……
                ……
</mycat:schema >
：wq
```

3）重启mycat服务

```shell
[root@mycat56 ~]# /usr/local/mycat/bin/mycat stop //停止服务
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 conf]# netstat -utnlp | grep :8066 //无端口
[root@mycat56 conf]# ps –C java //无进程
[root@mycat56 conf]#
[root@mycat56 conf]# /usr/local/mycat/bin/mycat start //启动服务
Starting Mycat-server...
[root@mycat56 conf]#
[root@mycat56 conf]# netstat -utnlp | grep :8066 //有端口
tcp6 0 0 :::8066 :::* LISTEN 1364/java
[root@mycat56 conf]#
[root@mycat56 conf]# ps –C java //有进程
PID TTY TIME CMD
1125 ? 00:00:01 java
[root@mycat56 conf]#
```

**步骤二：测试配置**

1）连接mycat服务器、建表、插入记录

```shell
[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456 //连接mycat服务器
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.6.29-mycat-1.6-RELEASE-20161028204710 MyCat Server (OpenCloundDB)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> show databases; //显示已有的数据库
+----------+
| DATABASE |
+----------+
| BBSDB | //逻辑库BBSDB
| TESTDB |
+----------+
2 rows in set (0.00 sec)
mysql> use BBSDB; //切换到BBSDB库
Reading table information for completion of table and column hames
You can turn off this feature to get a quicker startup with -A
Database changed
mysql> show tables; //查看表
+-----------------+
| Tables in BBSDB |
+-----------------+
| company | //逻辑表
| employee |
+-----------------+
2 rows in set (0.00 sec)
mysql> create table company(ID int primary key,name char(50),addr char(50));//建表
Query OK, 0 rows affected (1.01 sec)
mysql> desc company; //查看表表结构
+-------+----------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| ID | int(11) | NO | PRI | NULL | |
| name | char(50) | YES | | NULL | |
| addr | char(50) | YES | | NULL | |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> insert into company(ID,name,addr)values(1,"tarena","beijing");//插入记录
Query OK, 1 row affected (0.10 sec)
mysql> insert into company(ID,name,addr)values(2,"tmall","beijing");
Query OK, 1 row affected (0.15 sec)
mysql> insert into company(ID,name,addr)values(3,"sina","beijing");
Query OK, 1 row affected (0.13 sec)
mysql> select * from company; //查看表记录
+----+--------+---------+
| ID | name | addr |
+----+--------+---------+
| 1 | tarena | beijing |
| 2 | tmall | beijing |
| 3 | sina | beijing |
+----+--------+---------+
3 rows in set (0.04 sec)
```

2）在数据库服务器本机，查看表记录，在数据库服务器53本机查看。

```shell
 [root@host53 ~]# mysql -uroot -p123qqq...A -e "select * from db1.company2"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+--------+---------+
| ID | name   | addr    |
+----+--------+---------+
|  1 | tarena | beijing |
|  2 | tmall  | beijing |
|  3 | sina   | beijing |
+----+--------+---------+
[root@host53 ~]#
```

3）在数据库服务器54本机查看

```shell
 [root@host54 ~]# mysql -uroot -p123qqq...A -e "select * from db2.company2"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+--------+---------+
| ID | name   | addr    |
+----+--------+---------+
|  1 | tarena | beijing |
|  2 | tmall  | beijing |
|  3 | sina   | beijing |
+----+--------+---------+
[root@host54 ~]#
```

4）在数据库服务器55本机查看

```shell
 [root@host55 ~]# mysql -uroot -p123qqq...A -e "select * from db3.company"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+--------+---------+
| ID | name   | addr    |
+----+--------+---------+
|  1 | tarena | beijing |
|  2 | tmall  | beijing |
|  3 | sina   | beijing |
+----+--------+---------+
[root@host55 ~]#
```

# Exercise

## 1 什么是分库分表

将存放在一个数据库（主机）中的数据，按照特定方式进行拆分，分散存放到多个数据库（主机）中，以达到分散单台设备负载的效果

## 2 Mycat软件介绍


## 3 简述Mycat 支持多少种分片规则及名称？

一共支持10中分片规则
1）枚举法 sharding-by-intfile
2）固定分片 rule1
3）范围约定 auto-sharding-long
4）求模法 mod-long
5）日期列分区法 sharding-by-date
6）通配取模 sharding-by-pattern
7）ASCII码求模通配 sharding-by-prefixpattern
8）编程指定 sharding-by-substring
9）字符串拆分hash解析 sharding-by-stringhash
10）一致性hash sharding-by-murmur

## 4 阐述Mycat服务，下列文件的作用。server.xml、schema.xml、rule.xml

server.xml 设置客户端连接用户及逻辑库
schema.xml 配置表使用的分片规则、及存储数据的数据库服务器
rule.xml 分片规则文件

> 如有侵权，请联系作者删除



﻿@[TOC]( Database services Overview & building MySQL services & database basic management & MySQL data types | Cloud computing )

---

# 1. 构建MySQL服务器

## 1.1 问题

要求如下：

- 在IP地址192.168.4.50主机和192.168.4.51的主机上部署mysql服务
- 192.168.4.50主机设置数据库管理员root本机登录密码为123qqq...A
- 192.168.4.51主机设置数据库管理员root本机登录密码为NSD123...a

## 1.2 方案

克隆2台新虚拟机（红帽7操作系统）：
在eth0网卡配置ip地址
主机名称:host50、host51
拷贝软件mysql-5.7.17.tar 到新克隆的虚拟机里
关闭防火墙（如果有的话）
关闭SELinux（如果有的话）
配置yum源（本地源或网络源都可以）

## 1.3 步骤

实现此案例需要按照如下步骤进行(以主机host50为例演示)。

**步骤一：准备工作**

1）如果之前有mariadb，则需要先卸载，并删除对应的配置与数据：

```shell
[root@host50 ~]# systemctl  stop mariadb
```

2）删除/etc/my.cnf配置文件
此配置文件由RHEL自带的mariadb-libs库提供：

```shell
[root@host50 ~]# rm -rf /etc/my.cnf
```

3）删除数据

```shell
 [root@host50 ~]# rm -rf /var/lib/mysql/*
```

4）卸载软件包

```shell
 [root@host50 ~]# rpm -e --nodeps mariadb-server  mariadb 
警告：/var/log/mariadb/mariadb.log 已另存为/var/log/mariadb/mariadb.log.rpmsave
```

**步骤二：安装mysql软件包**
1）解压mysql-5.7.17.tar 软件包

```shell
[root@host50 ~]# tar -xvf mysql-5.7.17.tar               //解压mysql整合包
./mysql-community-client-5.7.17-1.el7.x86_64.rpm
./mysql-community-common-5.7.17-1.el7.x86_64.rpm
./mysql-community-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
./mysql-community-server-5.7.17-1.el7.x86_64.rpm
./mysql-community-test-5.7.17-1.el7.x86_64.rpm
```

2）安装MySQL软件包

```shell
[root@host50 ~]# yum  -y   install    mysql-community-*.rpm   //yum安装自动解决依赖
./mysql-community-client-5.7.17-1.el7.x86_64.rpm
./mysql-community-common-5.7.17-1.el7.x86_64.rpm
./mysql-community-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
./mysql-community-server-5.7.17-1.el7.x86_64.rpm
./mysql-community-test-5.7.17-1.el7.x86_64.rpm
```

3）启动MySQL数据库服务并设置开机自启
提示：第一次启动，需要初始化数据，会比较慢

```shell
[root@host50 ~]# systemctl start mysqld                  //启动mysql服务
[root@host50 ~]# systemctl enable mysqld                 //设置开机自启
[root@host50 ~]# systemctl status mysqld                 //查看mysql服务状态
● mysqld.service - MySQL Server
   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)
   Active: active (running) since 二 2018-08-28 10:03:24 CST; 8min ago
     Docs: man:mysqld(8)
           http://dev.mysql.com/doc/refman/en/using-systemd.html
 Main PID: 4284 (mysqld)
   CGroup: /system.slice/mysqld.service
           └─4284 /usr/sbin/mysqld --daemonize --pid-file=/var/r...
8月 28 10:02:56 localhost.localdomain systemd[1]: Starting MySQ...
8月 28 10:03:24 localhost.localdomain systemd[1]: Started MySQL...
Hint: Some lines were ellipsized, use -l to show in full.
[root@host50 ~]# ps -C  mysqld   //查看进程
  PID TTY          TIME CMD
20161 ?        00:00:00 mysqld
[root@host50 ~]# 
[root@host50 ~]# ss -utnlp  | grep 3306  //查看端口
tcp    LISTEN     0      80       :::3306                 :::*                   users:(("mysqld",pid=20161,fd=22))
[root@host50 ~]# 
```

**步骤三：连接MySQL服务器，修改密码**
1）查看初始密码

```shell
[root@host50 ~]#grep -i  'password' /var/log/mysqld.log
2017-04-01T18:10:42.948679Z 1 [Note] A temporary password is generated for root@localhost: mtoa>Av<p6Yk        //随机生成的管理密码为mtoa>Av<p6Yk
```

2）使用初始密码连接mysql服务

```shell
[root@host50 ~]# mysql -u root -p'mtoa>Av<p6Yk' //初始密码登录，
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 11
Server version: 5.7.17
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>                                     //登录成功后，进入SQL操作环境
```

3）重置数据库管理员root本机登录密码

```shell
mysql> show databases;  
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement  //提示必须修改密码
mysql> alter user  root@”localhost” identified by "123qqq...A";  //修改登陆密码必须要满足密码策略的要求
Query OK, 0 rows affected (0.00 sec)
mysql> exit //断开连接
[root@host50 ~]#
```

4）使用修改的密码登录

```shell
[root@host50 ~]# mysql -uroot –p123qqq...A   //使用修改后的密码登录
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 15
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
mysql> show  databases; //查看数据库（看到默认的4个库）
+--------------------+
| Database            |
+--------------------+
| information_schema |
| mysql                |
| performance_schema  |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
mysql> exit   //断开连接
```

# 2. 密码管理

## 2.1 问题

在192.168.4.50主机做如下练习：

- 修改密码策略
- 破解线下服务器root密码
- 破解线上服务器root密码
- 修改服务器root密码
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/9f365bc9947446f8bbabda5248338b56.png)

## 2.2 步骤

**步骤一：修改密码策略**

命令行修改临时有效

```shell
[root@host50 ~]# mysql -uroot -p123qqq...A          //管理员root登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 16
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
                                 
mysql> show variables  like "validate_password_%"; //查看与密码相关的全局变量 
+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | OFF    |
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |    //默认密码长度
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM |   //默认密码策略
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+
7 rows in set (0.00 sec)
mysql> set global validate_password_length = 6;  //修改密码最小长度
Query OK, 0 rows affected (0.00 sec)
mysql> set global validate_password_policy = 0 ;  //修改密码策略等级为0
Query OK, 0 rows affected (0.00 sec)
mysql> alter user  root@"localhost" identified by "123456";  //修改root密码
Query OK, 0 rows affected (0.03 sec)
mysql> exit; 断开连接
[root@host50 ~]# mysql -uroot -p123456  //新密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 28
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> 
```

永久配置，修改配置文件

```shell
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
validate_password_length = 6   //密码最小长度
validate_password_policy = 0   //密码等级
:wq
[root@host50 ~]# systemctl  restart mysqld   //重启服务
[root@host50 ~]# mysql -uroot -p123456  //登录
mysql> show variables like "validate_password_length";  //只查看密码长度
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| validate_password_length | 6     |
+--------------------------+-------+
1 row in set (0.00 sec)
mysql>  show variables like "validate_password_policy"; //只查看密码策略
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| validate_password_policy | LOW   |
+--------------------------+-------+
1 row in set (0.00 sec)
mysql> 
```

**步骤2：破解线下服务器root密码**
1）修改运行参数并重启服务
如果修改了密码策略必须恢复为默认的默默策略，不然服务无法跳过授权表启动

```shell
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
skip-grant-tables  #逃过授权表
#validate_password_length = 6   //注释掉
#validate_password_policy = 0   //注释掉
:wq
[root@host50 ~]# systemctl  restart mysqld    //重启服务
```

2）无密码登录

```shell
[root@host50 ~]# mysql    //无密码登录
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> update mysql.user set  authentication_string=password("123qqq...A")
    -> where user="root" and host="localhost";  //修改root用户本机登录密码(要符合默认的密码策略)
Query OK, 1 row affected, 1 warning (0.05 sec)
Rows matched: 1  Changed: 1  Warnings: 1
mysql> flush privileges;  //让修改生效
Query OK, 0 rows affected (0.02 sec)
mysql> exit  //断开连接
Bye
[root@host50 ~]#   
```

3）修改配置文件并重启服务

```shell
[root@host50 ~]#  vim  /etc/my.cnf
[mysqld]
#skip-grant-tables   //注释
validate_password_length = 6  //删除注释
validate_password_policy = 0  //删除注释
:wq
[root@host50 ~]# systemctl  restart mysqld
```

4）修改后的密码登录

```shell
[root@host50 ~]# mysql -uroot -p123qqq...A   //登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> 
```

**步骤三：破解线上服务器root密码（线上服务器的服务是不允许随便重启的）**
1）拷贝管理员能正常登录的数据库服务器的MySQL库覆盖本机的mysql库
把host51主机的mysql库拷贝给host50主机

```shell
[root@host50 ~]# scp -r root@192.168.4.51:/var/lib/mysql/mysql /var/lib/mysql/
root@192.168.4.51's password:  输入登录51主机的密码
```

2)重新加载数据

```shell
[root@host50 ~]# which  pstree  || yum -y install psmisc   安装pstree命令软件
/usr/bin/pstree
[root@host50 ~]# 
[root@host50 ~]# pstree -p | grep   mysqld  | head  -1   查看父进程pid号
           |-mysqld(20261)-+-{mysqld}(20262)
[root@host50 ~]# 
[root@host50 ~]# 
[root@host50 ~]# kill  -SIGHUP 20261    发送信号给进程
[root@host50 ~]#
```

3)使用和host51主机一样的密码连接服务

```shell
[root@host50 ~]# mysql -uroot -pNSD123...a    密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 9
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> 
```

**步骤四：修改root密码**
1）修改密码
需要指定旧密码，新密码才能修改

```shell
[root@host50 ~]# mysqladmin  -uroot -pNSD123...a  password "123qqq...A"
mysqladmin: [Warning] Using a password on the command line interface can be insecure.
Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.
 或
[root@host50 ~]# mysqladmin  -uroot  -p   password 
Enter password: 旧密码
New password: 新密码
Confirm new password: 再输入一遍新密码
Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.
[root@host50 ~]# 
```

2）使用修改后的密码登录

```shell
[root@host50 ~]# mysql -uroot -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 15
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>
```

# 3. 安装图形软件

## 3.1 问题：具体要求如下：

1. 在IP地址192.168.4.50主机安装phpmyadmin软件
2. 客户端通过访问phpmyadmin软件管理数据库

## 3.2 步骤

**步骤一：在IP地址192.168.4.50主机安装phpmyadmin软件。**

1）在 192.168.4.50主机部署LAP环境

```shell
[root@host50 ~]# yum -y install httpd  php  php-mysql  安装软件
[root@host50 ~]# rpm -q  httpd  php  php-mysql  查看是否安装成功
httpd-2.4.6-80.el7.centos.x86_64
php-5.4.16-45.el7.x86_64
php-mysql-5.4.16-45.el7.x86_64
[root@host50 ~]# 
[root@host50 ~]# systemctl start httpd  启动服务
[root@host50 ~]# systemctl enable httpd 开机运行
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
[root@host50 ~]#
```

2）安装phpmyadmin软件

事先把phpMyAdmin-2.11.11-all-languages.tar.gz软件从真机拷贝到50主机的/root目录下

```shell
[root@host50 ~]# tar -zxvf  phpMyAdmin-2.11.11-all-languages.tar.gz  解压软件
[root@host50 ~]# ls  查看解压后的名字
Desktop                           phpMyAdmin-2.11.11-all-languages.tar.gz
phpMyAdmin-2.11.11-all-languages
[root@host50 ~]# 
[root@host50 ~]# mv phpMyAdmin-2.11.11-all-languages /var/www/html/phpmyadmin  移动并改名
```

3) 修改配置文件

```shell
[root@host50 ~]# cd /var/www/html/phpmyadmin/   进入安装目录
[root@host50 phpmyadmin]# 
[root@host50 phpmyadmin]# cp config.sample.inc.php config.inc.php 拷贝模板文件，生成主配置文件config.inc.php  
[root@host50 phpmyadmin]# vim +17 config.inc.php 只需要修改第17行
$cfg['blowfish_secret'] = 'plj123';  随便添点字符就可以
:wq
```

**步骤二：客户端通过访问phpmyadmin软件管理数据库。**

1. 打开真机浏览器，地址栏输入网址 http://192.168.4.50/phpmyadmin

登录用户名 root
密码 管理员本机登录密码

如图-1、图-2所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/2afb8655bd244c06ad999b6513d9b191.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-1

![在这里插入图片描述](https://img-blog.csdnimg.cn/f316c2f8678d4d32ae28d7aa70c03279.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

# 4 查询条件

## 4.1 问题：具体要求如下：

- 练习别名、拼接、去重
- 练习数值比较的使用
- 练习字符比较的使用
- 练习范围匹配的使用
- 练习模糊匹配的使用
- 练习正则匹配的使用
- 练习逻辑比较的使用

## 5.2 步骤

环境准备（host50主机做如下操作）

```shell
使用备份文件创建数据
[root@host50 ~]# ls   查看备份文件
Desktop    tarena.sql
[root@host50 ~]# 
[root@host50 ~]# 
[root@host50 ~]# mysql -uroot -p123qqq...A  < tarena.sql  使用备份文件创建数据
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
[root@host50 ~]# mysql -uroot -p123qqq...A  管理员登录
mysql> use tarena; 进入tarena库
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
mysql> show tables;  查看表
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| employees        |
| salary           |
| user             |
+------------------+
4 rows in set (0.00 sec)
mysql> 
```

练习使用的user表说明如图-1所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/85844dabfe064f0db864f9d4637825d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

**步骤一：练习别名、拼接、去重**

```sql
//别名
mysql> select name as 姓名 , homedir  家目录 from  tarena.user;
+-----------------+--------------------+
| 姓名            | 家目录             |
+-----------------+--------------------+
| root            | /root              |
| bin             | /bin               |
| daemon          | /sbin              |
| adm             | /var/adm           |
| lp              | /var/spool/lpd     |
//拼接
mysql> select concat(name, "-" , uid ) from tarena.user;
+--------------------------+
| concat(name, "-" , uid ) |
+--------------------------+
| root-0                   |
| bin-1                    |
| daemon-2                 |
| adm-3                    |
| lp-4                     |
| sync-5                   |
//去重
mysql> select distinct gid from tarena.user;
+-------+
| gid   |
+-------+
|     0 |
|     1 |
|     2 |
|     4 |
|     7 |
|    12 |
|   100 |
|    50 |
```

**步骤二、练习数值比较的使用**

符号两边要是数值或是数值类型的字段

```sql
//查看uid号和号相等的用户名、UID号、gid号
mysql> select name ,uid,gid from tarena.user where uid = gid ;
+-----------------+-------+-------+
| name            | uid   | gid   |
+-----------------+-------+-------+
| root            |     0 |     0 |
| bin             |     1 |     1 |
| daemon          |     2 |     2 |
| nobody          |    99 |    99 |
| systemd-network |   192 |   192 |
| dbus            |    81 |    81 |
//查看uid号不等与gid号的用户名、UID号、gid号
mysql> select name ,uid,gid from tarena.user where uid != gid ;
+----------+------+------+
| name     | uid  | gid  |
+----------+------+------+
| adm      |    3 |    4 |
| lp       |    4 |    7 |
| sync     |    5 |    0 |
| shutdown |    6 |    0 |
| halt     |    7 |    0 |
| mail     |    8 |   12 |
//查看表记录的前5行
mysql> select  * from  tarena.user where  id <= 5;  
+----+--------+----------+------+------+---------+----------------+---------------+
| id | name   | password | uid  | gid  | comment | homedir        | shell         |
+----+--------+----------+------+------+---------+----------------+---------------+
|  1 | root   | x        |    0 |    0 | root    | /root          | /bin/bash     |
|  2 | bin    | x        |    1 |    1 | bin     | /bin           | /sbin/nologin |
|  3 | daemon | x        |    2 |    2 | daemon  | /sbin          | /sbin/nologin |
|  4 | adm    | x        |    3 |    4 | adm     | /var/adm       | /sbin/nologin |
|  5 | lp     | x        |    4 |    7 | lp      | /var/spool/lpd | /sbin/nologin |
+----+--------+----------+------+------+---------+----------------+---------------+
5 rows in set (0.01 sec)
mysql> 
```

**步骤三、练习字符比较的使用**

```sql
//查找名字叫apache的用户
mysql> select name from tarena.user where name="apache"; 
+--------+
| name   |
+--------+
| apache |
+--------+
1 row in set (0.00 sec)
//查看shell是/bin/bash的用户
mysql> select name , shell from tarena.user 
where shell = "/bin/bash" ;
+------+-----------+
| name | shell     |
+------+-----------+
| root | /bin/bash |
| plj  | /bin/bash |
+------+-----------+
2 rows in set (0.00 sec)
//查看shell不是/bin/bash的用户
mysql> select name , shell from tarena.user where shell != "/bin/bash" ;
+-----------------+----------------+
| name            | shell          |
+-----------------+----------------+
| bin             | /sbin/nologin  |
| daemon          | /sbin/nologin  |
| adm             | /sbin/nologin  |
| lp              | /sbin/nologin  |
//查找uid字段没有数据的记录
mysql> select name , uid from tarena.user where uid is null ; 
+------+------+
| name | uid  |
+------+------+
| bob  | NULL |
+------+------+
1 row in set (0.00 sec)
mysql> 
//查看uid字段不是空的记录
mysql> select name , uid from tarena.user where uid is not  null ; 
+-----------------+-------+
| name            | uid   |
+-----------------+-------+
| root            |     0 |
| bin             |     1 |
| daemon          |     2 |
| adm             |     3 |
| lp              |     4 |
| sync            |     5 |
| shutdown        |     6 |
//没有数据
mysql> select name , comment from tarena.user where comment is null;
 +------+---------+
| name | comment |
+------+---------+
| bob  | NULL    |
+------+---------+
1 row in set (0.00 sec)
//零个字符
mysql> select name , comment from tarena.user where comment="" ; 
+---------+---------+
| name    | comment |
+---------+---------+
| postfix |         |
| chrony  |         |
| plj     |         |
+---------+---------+
3 rows in set (0.00 sec)
mysql> 
```

**步骤四、练习范围匹配的使用**

```sql
//查看uid号是1或3或5或7的记录
mysql> select name,uid,shell from tarena.user where uid in  (1,3,5,7); 
+------+------+---------------+
| name | uid  | shell         |
+------+------+---------------+
| bin  |    1 | /sbin/nologin |
| adm  |    3 | /sbin/nologin |
| sync |    5 | /bin/sync     |
| halt |    7 | /sbin/halt    |
+------+------+---------------+
4 rows in set (0.01 sec)
mysql> 
//查看shell不是/bin/bash 或 /sbin/nologin的用户
mysql> select name,uid,shell from tarena.user where shell not in  ("/bin/bash","/sbin/nologin"); 
+----------+------+----------------+
| name     | uid  | shell          |
+----------+------+----------------+
| sync     |    5 | /bin/sync      |
| shutdown |    6 | /sbin/shutdown |
| halt     |    7 | /sbin/halt     |
| mysql    |   27 | /bin/false     |
+----------+------+----------------+
4 rows in set (0.00 sec)
mysql> 
//查看uid 在10到30之间的记录，包括10和30本身
mysql> select name , uid , gid  from tarena.user where uid between 10 and 30 ;
+----------+------+------+
| name     | uid  | gid  |
+----------+------+------+
| operator |   11 |    0 |
| games    |   12 |  100 |
| ftp      |   14 |   50 |
| rpcuser  |   29 |   29 |
| mysql    |   27 |   27 |
+----------+------+------+
5 rows in set (0.00 sec)
mysql> 
```

**步骤五、练习模糊匹配的使用**

```sql
//查看名字是3个字符的
mysql> select name from tarena.user where name like "___";
+------+
| name |
+------+
| bin  |
| adm  |
| ftp  |
| rpc  |
| plj  |
| bob  |
+------+
6 rows in set (0.00 sec)
mysql>
//查看名字至少是4个字符的 
mysql> select name from tarena.user where name like "__%__"; 
+-----------------+
| name            |
+-----------------+
| root            |
| daemon          |
| sync            |
| shutdown        |
| halt            |
| mail            |
| operator        |
| games           |
| nobody          |
| systemd-network |
| dbus            |
| polkitd         |
| sshd            |
| postfix         |
| chrony          |
| rpcuser         |
//查看名字里有字母a的
mysql> select name from tarena.user where name like "%a%"; 
+----------+
| name     |
+----------+
| daemon   |
| adm      |
| halt     |
| mail     |
| operator |
| games    |
| haproxy  |
| apache   |
+----------+
8 rows in set (0.00 sec)
mysql> 
```

**步骤六、练习正则匹配的使用**

```sql
//查看名字必须是r开头且是t结尾的名字
mysql> select name from tarena.user where name regexp "^r.*t$"; 
+------+
| name |
+------+
| root |
+------+
1 row in set (0.00 sec)
mysql> 
//查看名字是字母r 开头或字母t结尾的名字
mysql> select name from tarena.user where name regexp "^r|t$"; 
+---------+
| name    |
+---------+
| root    |
| halt    |
| rpc     |
| rpcuser |
+---------+
4 rows in set (0.00 sec)
mysql> 
//查看名字里有数字的
mysql> select name from tarena.user where name regexp "[0-9]"; 
Empty set (0.00 sec)
//看名字以数字开头的
mysql> select name from tarena.user where name regexp "^[0-9]"; 
Empty set (0.00 sec)
mysql> 
```

步骤七、练习逻辑比较的使用

```sql
//查看名字叫mysql 或者uid 是 0 的 记录
mysql> select name , uid from tarena.user where name = "mysql"  or uid = 0 ;  
+-------+------+
| name  | uid  |
+-------+------+
| root  |    0 |
| mysql |   27 |
+-------+------+
2 rows in set (0.00 sec)
//查看名字叫mysql并且uid号 还必须是零的记录
mysql> select name , uid from tarena.user where name = "mysql"  and uid = 0 ;
Empty set (0.00 sec)
mysql>
 //查看uid 是0 的记录 
mysql> select name, uid from tarena.user where uid = 0 ;
+------+------+
| name | uid  |
+------+------+
| root |    0 |
+------+------+
1 row in set (0.00 sec)
//查看uid不是0的记录
mysql> select name, uid from tarena.user where not uid = 0 ; 
+-----------------+-------+
| name            | uid   |
+-----------------+-------+
| bin             |     1 |
| daemon          |     2 |
| adm             |     3 |
| lp              |     4 |
| sync            |     5 |
| shutdown        |     6 |
// 既有and又有or  优先匹配and
mysql> select name , uid from tarena.user where name = "root" or name = "bin" and uid = 1 ; 
+------+------+
| name | uid  |
+------+------+
| root |    0 |
| bin  |    1 |
+------+------+
2 rows in set (0.00 sec)
// () 先匹配or 再匹配and
mysql> select name , uid from tarena.user where (name = "root" or name = "bin") and uid = 1 ;  
+------+------+
| name | uid  |
+------+------+
| bin  |    1 |
+------+------+
1 row in set (0.00 sec)
mysql> 
```

# Exercise

## 1 简述当前主流RDBMS软件有哪些？开源且跨平台的数据库软件有哪些？

当前主流的数据库服务器软件有： Oracle 、 DB2 、 SQL SERVER 、MySQL 等 ，其中只有MySQL是既开源又跨平台的数据库服务软件。

## 2 简述MySQL数据库的服务进程名、默认端口、默认数据库目录？

服务进程名：mysqld
默认监听端口号：3306
默认数据库目录：/var/lib/mysql

## 3 简述MySQL默认的4个库叫什么名字？哪个库里的数据不占用物理磁盘空间？

MySQL默认的4个库分别是 information_schema 、performance_schema 、mysql 、sys 其中information_schema库不占用物理磁盘空间。

## 4 请列出MySQL常用的数据类型，并写出定义这些数据类型所使用的关键字。

MySQL常用的数据类型有：字符类型、数值类型、日期时间类型、枚举类型
字符类型：　char　、　varchar　、　blob、　text
数值类型：　tinyint 、smallint　、int　、bigint 、float 、 double
日期时间类型： year 、 date 、 time 、 datetime 、 timestamp
枚举类型： enum 、 set

## 5 简述以下MySQL函数的功能。

> year() 、date()　、month() 、day()　、time()、now()

year()　获取指定时间中的年
date()　获取指定时间中的年月日
month() 获取指定时间中的月
day()　 获取指定时间中的日期
time()　获取指定时间中的时间（小时分钟秒）
now()　 获取当前时间（年月日小时分钟秒）

## 6 在studentdb库里创建stu_info表，结构要求如图-1所示。

> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f2bfa5bc9fc44a45b057bf1dd5bca4a6.png)
> 图-1

```sql
create  database  studentdb;
create  table  studentdb.stuinfo(
stu_id int(2),
name  varchar(10),
age  tinyint(2) unsigned,
sex  enum(“boy”,”girl”),
likes set(“book”,”music”,”game”,”film”)
);
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Deploy Dashboard & Prometheus & HPA clusters | Cloud computing )

---

# 1. 安装部署dashboard

## 1.1 问题

本案例要求安装部署dashboard，具体要求如下：

1. 导入镜像到私有仓库
2. 修改配置文件recommended.yaml
3. 添加NodePort端口
4. 修改镜像地址
5. 部署dashboard
6. 创建管理用户admin-user
7. 使用token登录页面访问

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署dashboard（在master主机操作）**

所有镜像及资源文件在云盘 kubernetes/v1.17.6/dashboard/目录，各位同学提前下载素材。

1）导入镜像到私有镜像仓库（192.168.1.100服务器）

镜像文件在云盘第四阶段kubernetes/v1.17.6/dashboard/目录下，各位同学需要提前下载。

需要导入的镜像包括：

- dashboard.tar.gz 主服务镜像
- metrics-scraper.tar.gz 收集监控信息插件

```shell
[root@master ~]# docker load  -i dashboard.tar.gz
[root@master ~]# docker images            #查看dashboard镜像的名称
[root@master ~]# docker tag  旧名称   192.168.1.100:5000/dashboard:v2.0.0
[root@master ~]# docker push  192.168.1.100:5000/dashboard:v2.0.0
[root@master ~]# docker load  -i metrics-scraper.tar.gz
[root@master ~]# docker images            #查看metrics-scraper镜像的名称
[root@master ~]# docker tag  旧名称   192.168.1.100:5000/metrics-scraper:v1.0.4
[root@master ~]# docker push  192.168.1.100:5000/metrics-scraper:v1.0.4
```

2）创建相关资源完成部署

资源文件在云盘 kubernetes/v1.17.6/dashboard/目录，各位同学提前下载素材。

```shell
[root@master dashboard]# vim recommended.yaml
          # 190 行修改为
          image: 192.168.1.100:5000/dashboard:v2.0.0
          # 274 行修改为
          image: 192.168.1.100:5000/metrics-scraper:v1.0.4
[root@master dashboard]# kubectl apply -f recommended.yaml
# ---------------------------------- 查询验证 --------------------------------------
[root@master dashboard]# kubectl -n kubernetes-dashboard get pod
NAME                                         READY   STATUS    RESTARTS   AGE
dashboard-metrics-scraper-57bf85fcc9-vsz74   1/1     Running   0          52s
kubernetes-dashboard-7b7f78bcf9-5k8vq        1/1     Running   0          52s
[root@master dashboard]# kubectl -n kubernetes-dashboard get service
NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)
dashboard-metrics-scraper   ClusterIP   10.254.76.85     <none>        8000/TCP
kubernetes-dashboard        ClusterIP   10.254.211.125   <none>        443/TCP
# ---------------------------------- 对外发布服务 -----------------------------------
[root@master dashboard]# vim service.yaml
---
kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  ports:
    - port: 443
      nodePort: 30443                # 新添加
      targetPort: 8443
  selector:
    k8s-app: kubernetes-dashboard
  type: NodePort                     # 新添加
[root@master dashboard]# kubectl apply -f service.yaml 
service/kubernetes-dashboard configured
[root@master dashboard]# kubectl -n kubernetes-dashboard get service
NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE
dashboard-metrics-scraper   ClusterIP   10.254.66.25     <none>        8000/TCP        2m6s
kubernetes-dashboard        NodePort    10.254.165.155   <none>        443:30443/TCP   2m6s
[root@master dashboard]#
```

3）验证

浏览器访问任意节点IP的30443端口(http://任意节点:30443 端口

)即可查看Web页面，效果如图-1所示。

![img](https://img-blog.csdnimg.cn/img_convert/70a1de5ea34b921d344c444778840c1d.png)

图-1

4）创建管理用户

素材在云盘 kubernetes/v1.17.6/dashboard/admin-token.yaml

```shell
[root@master dashboard]# cat admin-token.yaml          #查看、学习资源文件
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard
[root@master dashboard]# kubectl create -f admin-token.yaml   #创建资源
```

5）查看登录的Token信息

先通过get screts查看名称，该名称是随机的，然后再通过查询到的名称继续查询对应的Token信息。

```shell
[root@master ~]# kubectl -n kubernetes-dashboard get secrets 
NAME             TYPE                                  
admin-user-token-xxx    kubernetes.io/service-account-token  ... ...
[root@master ~]# kubectl -n kubernetes-dashboard describe secrets \
... ...
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IjJyTE9nZWpWLWFhTXV6cnJla3U4aX
NngxVTZjV2M5Y0FYOWR0ancifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9 ... ...
```

再次使用浏览器访问任意节点IP的30090端口(http://任意节点:30090 端口

)即可查看Web页面，输入Token，效果如图-2所示。

![img](https://img-blog.csdnimg.cn/img_convert/842a1ae8791e7064aefec7c890e4dea4.png)

图-2



# 2. 安装部署pometheus（一）

## 2.1 问题

本案例安装部署pometheus，具体要求如下：

1. 安装Prometheus operator
2. 安装Prometheus server
3. 安装Prometheus adapter
4. 安装metrics-state
5. 安装node-exporter
6. 安装 altermanager
7. 安装 grafana

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：导入所有后续需要的镜像到私有镜像仓库（在master主机操作操作）**

所有镜像文件在云盘第四阶段kubernetes/v1.17.6/prometheus/images目录下，各位同学需要提前下载。

需要导入的镜像包括：

- prometheus.tar.gz
- prometheus-operator.tar.gz
- prometheus-config-reloader.tar.gz
- prometheus-adapter.tar.gz
- node-exporter.tar.gz
- kube-rbac-proxy.tar.gz
- kube-metrics.tar.gz
- grafana.tar.gz
- configmap-reload.tar.gz
- alertmanager.tar.gz

注意：tab修改标签时，只需要修改服务器即可，禁止修改镜像原来的名称与标签。

```shell
[root@master ~]# docker load -i prometheus.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  旧名称   192.168.1.100:5000/prometheus:v2.11.0
[root@master ~]# docker push  192.168.1.100:5000/prometheus:v2.11.0
[root@master ~]# docker load -i prometheus-operator.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/prometheus-operator:v0.35.1
[root@master ~]# docker push  192.168.1.100:5000/prometheus-operator:v0.35.1
[root@master ~]# docker load -i prometheus-config-reloader.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/prometheus-config-reloader:v0.35.1
[root@master ~]# docker push \
192.168.1.100:5000/prometheus-config-reloader:v0.35.1
[root@master ~]# docker load -i prometheus-adapter.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/prometheus-operator:v0.35.1
[root@master ~]# docker push 192.168.1.100:5000/prometheus-operator:v0.35.1
[root@master ~]# docker load -i node-exporter.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/node-exporter:v1.0.0
[root@master ~]# docker push 192.168.1.100:5000/node-exporter:v1.0.0
[root@master ~]# docker load -i kube-rbac-proxy.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/kube-rbac-proxy:v0.4.1
[root@master ~]# docker push 192.168.1.100:5000/kube-rbac-proxy:v0.4.1
[root@master ~]# docker load -i kube-metrics.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/kube-state-metrics:v1.9.2
[root@master ~]# docker push 192.168.1.100:5000/kube-state-metrics:v1.9.2
[root@master ~]# docker load -i alertmanager.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/grafana:6.4.3
[root@master ~]# docker push 192.168.1.100:5000/grafana:6.4.3
[root@master ~]# docker load -i    configmap-reload.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/configmap-reload:v0.3.0
[root@master ~]# docker push 192.168.1.100:5000/configmap-reload:v0.3.0
[root@master ~]# docker load -i    alertmanager.tar.gz
[root@master ~]# docker images            #查看镜像的名称
[root@master ~]# docker tag  \
旧名称  192.168.1.100:5000/alertmanager:v0.18.0
[root@master ~]# docker push 192.168.1.100:5000/alertmanager:v0.18.0
```

**步骤二：修改资源文件部署各种容器服务（在master主机操作操作）**

所有资源的素材文件都在云盘第四阶段kubernetes/v1.17.6/Prometheus/目录下。各位同学需要提前下载整个目录到master主机。

1）安装operator

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim setup/prometheus-operator-deployment.yaml
27  - --config-reloader-image=192.168.1.100:5000/configmap-reload:v0.3.0
28  - --prometheus-config-reloader=192.168.1.100:5000/prometheus-config-reloader:v0.35.1
29  image: 192.168.1.100:5000/prometheus-operator:v0.35.1
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f setup/
```

2）安装Prometheus server

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim prom-server/prometheus-prometheus.yaml
14      baseImage: 192.168.1.100:5000/prometheus
34      version: v2.11.0
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f prom-server/
```

3）安装prom-adapter

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim prom-adapter/prometheus-adapter-deployment.yaml
28         image: 192.168.1.100:5000/k8s-prometheus-adapter-amd64:v0.5.0
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f prom-adapter/
```

4）安装metrics-state

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim metrics-state/kube-state-metrics-deployment.yaml
24            image: 192.168.1.100:5000/kube-rbac-proxy:v0.4.1
41            image: 192.168.1.100:5000/kube-rbac-proxy:v0.4.1
58            image: 192.168.1.100:5000/kube-state-metrics:v1.9.2
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f metrics-state/
```

5）安装node-exporter

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim node-exporter/node-exporter-daemonset.yaml
27            image: 192.168.1.100:5000/node-exporter:v1.0.0
57            image: 192.168.1.100:5000/kube-rbac-proxy:v0.4.1
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f node-exporter/
```

6）安装alertmanager

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim alertmanager/alertmanager-alertmanager.yaml
09     baseImage: 192.168.1.100:5000/alertmanager
18     version: v0.18.0
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f alertmanager/
```

7）安装grafana

需要修改资源文件，默认资源文件制定的是从官网下载镜像启动容器，我们需要修改为自己的192.168.1.100私有镜像仓库的路径。

```shell
[root@master prometheus]# vim grafana/grafana-deployment.yaml
19    - image: 192.168.1.100:5000/grafana:6.4.3
#提示：上面这些镜像的链接路径如果不知道，可以使用docker images查看。
[root@master prometheus]# kubectl apply -f grafana/
```



# 3. 发布服务pometheus（二）

## 3.1 问题

本案例延续前面的案例3，继续部署pometheus，具体要求如下：

## 3.2 步骤

**步骤三：对外发布grafana服务（在master主机操作）**

相关资源文件共享在云盘第四阶段kubernetes/v1.17.6/prometheus/ grafana/grafana-service.yaml。

下面使用使用nodePort发布服务将容器的3000端口映射到真机节点的30000端口。

```shell
[root@master prometheus]# vim grafana/grafana-service.yaml
... ...
spec:
  type: NodePort
  ports:
  - name: http
    port: 3000
    nodePort: 30000
    targetPort: http
... ...
[root@master prometheus]# kubectl  apply  -f  grafana/grafana-service.yaml
```

使用浏览器访问任意节点的30002端口，即可访问到Web网页，效果如图-4所示。

![img](https://img-blog.csdnimg.cn/img_convert/bafd9cd31bc8d818f7b42145683ee4df.png)

图-4



# 4. 配置grafana

## 4.1 问题

本案例要求配置grafana，具体要求如下。

1. 配置数据源
2. 展示监控页面

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置grafana（在任意主机操作）**

1）登录

登录的默认用户和密码：admin/admin

第一次登录需要修改密码，效果如图-5所示。

![img](https://img-blog.csdnimg.cn/img_convert/906ef6fed6459a18fb71192fbbd506a3.png)

图-5

2）修改数据源地址

我们添加的数据为prometheus

数据源就是 Prometheus service 的地址

可以填写prometheus的Service内部的DNS名称

http://prometheus-k8s.monitoring.svc.cluster.local:9090

如何查看到这个DNS的域名呢？可以执行如下的命令即可。

```shell
[root@master ~]# kubectl -n monitoring get service
NAME               TYPE             CLUSTER-IP       EXTERNAL-IP    PORT(S)
grafana          NodePort       10.254.169.248        <none>         3000:30002/TCP
prometheus-k8s  NodePort       10.254.44.72    <none>              9090:30001/TCP
... ...
# 找到这里的prometheus-k8s名称后
# 在它的后面附加一个固定的monitoring.svc.cluster.local:9090
# 连接在一起就是：http://prometheus-k8s.monitoring.svc.cluster.local:9090
```

点击如图-6和图-7所示的按钮，修改数据源。

添加数据源Prometheus，名字随意，URL需要填写Prometheus内部的DNS名称，

默认端口号 9090。

![img](https://img-blog.csdnimg.cn/img_convert/a2e095d9cd4a1f2d2b5608e448921cc9.png)

图-6

![img](https://img-blog.csdnimg.cn/img_convert/2df52cfdff35dd5c27ae06098e5f0993.png)

图-7

3）导入模板

导入模板，需要正确配置后点击保存和测试后开始添加仪表盘

点开import，输入模板ID，效果如图-8所示。

![img](https://img-blog.csdnimg.cn/img_convert/69ecb2fdd8ff0c12b11fe3330513b01b.png)

图-8

常用的模块为315，如图-9所示。

![img](https://img-blog.csdnimg.cn/img_convert/d8f992662f272253af1800a8ba930b0c.png)

图-9

数据源就是刚刚定义的 Prometheus，如图-10所示。

![img](https://img-blog.csdnimg.cn/img_convert/33396cb1c9e586e6b143872c13a350bb.png)

图-10

最后查看监控效果，如图-11和图-12所示。



图-11



![img](https://img-blog.csdnimg.cn/img_convert/4348e84fbbfcbe882ad1bd24ed9f60a0.png)

图-12



# 5. HPA集群

## 5.1 问题

本案例利用监控指标实现HPA集群，具体要求如下。

1. 完成一个弹性集群

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署一个弹性集群（在master主机操作）**

1）查看、学习资源文件

```shell
[root@master ~]# vim myhpa.yaml 
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myweb
spec:
  selector:
    matchLabels:
      app: apache
  replicas: 1
  template:
    metadata:
      labels:
        app: apache
    spec:
      containers:
      - name: apache
        image: 192.168.1.100:5000/myos:httpd
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 200m
      restartPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  selector:
    app: apache
  type: ClusterIP
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-app
  annotations:
    kubernetes.io/ingress.class: "nginx"
spec:
  backend:
    serviceName: web-service
    servicePort: 80
---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: myweb
spec:
  minReplicas: 1
  maxReplicas: 3
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myweb
  targetCPUUtilizationPercentage: 50
[root@master ~]# kubectl apply -f hpa-example.yaml
[root@master ~]# kubectl get hpa
NAME    REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
myweb   Deployment/myweb   0%/50%    1         3         1          15m
```

**步骤二：压力测试**

想办法对前面创建的容器进行压力测试，消耗容器CPU资源！！！

**步骤三：查看动态扩容效果**

```shell
[root@master ~]# kubectl get hpa 
NAME    REFERENCE          TARGETS    MINPODS   MAXPODS   REPLICAS   AGE
myweb  Deployment/myweb   287%/50%   1         3         3          16m
[root@master ~]# kubectl  get pod
NAME                     READY   STATUS    RESTARTS   AGE
myweb-7f89fc7b66-kzhj5   1/1     Running   0          16m
myweb-7f89fc7b66-nh4kn   1/1     Running   0          21s
myweb-7f89fc7b66-q2jnf   1/1     Running   0          21s
#当容器CPU占用过高时，集群可以自动扩容
-----------------------------------------------------------------------------
[root@master ~]# kubectl get hpa 
NAME    REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
myweb   Deployment/myweb   1%/50%    1         3         3          20m
[root@master ~]# kubectl  get pod
NAME                     READY   STATUS    RESTARTS   AGE
myweb-7f89fc7b66-kzhj5   1/1     Running   0          22m
# 当容器CPU占用率恢复正常时，容器可以自动缩减
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Deploy Git version control system & optimize Web server | Cloud computing )

---

# 1. 部署Git版本控制系统

## 1.1 问题

部署Git版本控制系统，管理网站代码，实现如下效果：

- 基于SSH协议的服务器
- 基于Git协议的服务器
- 基于HTTP协议的服务器
- 上传代码到版本仓库

## 1.2 方案

生产环境应该有一台独立的Git服务器，这里为了节约主机资源，我们使用数据库主机同时做完Git服务器，如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/34e9d1fd351c461d82c2d243193e4083.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

主机配置如表-1所示。

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/4dca72bc790143d0a646af7540465e61.png)


## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署SSH协议的版本控制服务器**

1）安装软件包，创建空仓库。

```shell
[root@database ~]# yum -y install git
[root@database ~]# mkdir /var/lib/git/
[root@database ~]# git init --bare /var/lib/git/wordpress.git        #创建空仓库
```

2）登陆web1服务器克隆git仓库，上传网站代码到git服务器。

```shell
[root@web1 var]# git config --global push.default simple
[root@web1 var]# git config --global user.email you@example.com
[root@web1 var]# git config --global user.name "Your Name"
[root@web1 var]# cd /var/
[root@web1 var]# git clone root@192.168.2.21:/var/lib/git/wordpress.git
[root@web1 var]# cd /var/wordpress
[root@web1 wordpress]# cp -a /usr/local/nginx/html/*  ./
[root@web1 wordpress]# git add .
[root@web1 wordpress]# git commit -m "wordpress code"
[root@web1 wordpress]# git push
root@192.168.2.21's password:<输入192.168.2.21主机root的密码>
```

**步骤二：部署Git协议的版本控制服务器**

1）安装软件包（192.168.2.21操作）

```shell
[root@database ~]# yum -y install git-daemon
```

2）修改配置文件，启动Git服务

```shell
[root@database ~]# cat /usr/lib/systemd/system/git@.service
#仅查看即可
[root@database ~]# systemctl start git.socket
[root@database ~]# systemctl status git.socket
```

3)客户端测试（使用web2做完客户端主机，192.168.2.12）

在web2执行clone等同于是把代码又备份了一份。

```shell
[root@web2 ~]# cd /var/
[root@web2 var]# git clone git://192.168.2.21/wordpress.git
```

**步骤三：部署HTTP协议的版本控制服务器**

1. 安装软件包（192.168.2.21操作）

```shell
[root@database ~]# yum -y install httpd gitweb
```

2. 修改配置文件

```shell
[root@database ~]# vim /etc/gitweb.conf
$projectroot = "/var/lib/git";                        #添加一行
```

3. 启动服务

```shell
[root@database ~]# systemctl start httpd
```

4. 客户端验证

```shell
火狐浏览器访问 firefox http://192.168.2.21/git
```

访问网页可以查看到wordpress仓库，点击tree菜单后可以看到如图-2所示的代码。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6932c3430a194a67a1d24286e78db43e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-2

# 2. 优化Web服务器

## 2.1 问题

优化Web服务器，实现如下效果：

- 自定义网站404错误页面
- 升级nginx至1.15.8版本，开启status模块
- 编写日志切割脚本，实现每周五备份日志
- 开启gzip压缩功能，提高数据传输效率
- 开启文件缓存功能

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：自定义404错误页面**

1）优化前测试（客户端访问一个不存在的页面）。

```shell
客户端浏览器访问： firefox http://www.lab.com/git
```

2) 修改Nginx配置文件，自定义错误页面

```shell
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
[root@web3 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
```

3) 重启nginx

```shell
[root@web1 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@web2 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@web3 ~]# /usr/local/nginx/sbin/nginx -s reload
```

**步骤二：升级nginx版本，开启status模块**

1. 配置、编译新的nginx（web1、web2、web3做相同操作，下面以web1为例）

```shell
[root@web1 ~]# tar  -xf   nginx-1.15.8.tar.gz
[root@web1 ~]# cd  nginx-1.15.8
[root@web1 nginx-1.15.8]# ./configure     \
--with-http_ssl_module         \
--with-http_stub_status_module
[root@web1 nginx-1.15.8]# make
```

2) 备份老版本nginx，更新新版本nginx

```shell
[root@web1 nginx-1.15.8]# mv /usr/local/nginx/sbin/nginx{,.old}
[root@web1 nginx-1.15.8]# cp objs/nginx  /usr/local/nginx/sbin/
```

3. 修改配置文件

```shell
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf
... ...
location /status {
                stub_status on;
                 allow 192.168.2.0/24;          #允许哪个网段查看状态页面
                 deny all;                       #拒绝谁访问查看状态页面
        }
... ...
```

4. 升级或重启服务

注意：必须在nginx-1.15.8源码包目录下执行make upgrade命令。

```shell
[root@web1 nginx-1.15.8]# make upgrade
```

或者手动执行killall命令杀死进程后重新启动，没有killall命令则需要安装psmisc软件包。

```shell
[root@web1 ~]# killall nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
```

**步骤三：编写日志切割脚本**

1）编写脚本（以web1为例）

```shell
[root@web1 ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
```

2）创建计划任务

```shell
[root@web1 ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh
```

**步骤四：对页面进行压缩处理**

1）修改Nginx配置文件

```shell
[root@web1 ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types
.. ..
}
```

**步骤五：服务器内存缓存**

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。

```shell
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
//文件句柄的有效时间是60秒，60秒后过期
//只有访问次数超过5次会被缓存
} 
```

**附加知识（常见面试题）**

1. Git的主要功能是什么。它的常用命令有哪些？

答：
Git是一个分布式的版本控制软件，支持离线操作，主要功能为版本控制，支持日志、数据恢复等功能。

主要命令：
git clone、git add、git commit、git log、git branch、git checkout、git pull、git merge等。

2. 工作中你都写过什么脚本？

答：
监控脚本（监控系统、监控服务、监控硬件信息、监控性能、安全监控等）

系统初始化脚本（创建目录，创建账户，安装软件包，设置权限，修改内核参数等）

一键部署（源码安装脚本）

备份脚本（自动备份数据库，备份网站数据，备份日志，备份配置文件等）

日志分析脚本（分析日志数据，汇总并统计相关信息，如PV、UV等）

3. Nginx你用到哪些模块,在proxy模块中你配置哪些参数？

答：
ngx_http_core_module（核心模块，包含http、server_name、root等配置参数）
ngx_http_access_module（访问控制模块，包含allow和deny配置参数）
ngx_http_auth_basic_module（用户认证模块，包含auth_basic等配置参数）
ngx_http_charset_module（字符集模块，包含charset utf8等配置参数）
ngx_http_fastcgi_module（fastcgi模块，包含fastcgi_pass等配置参数）
ngx_http_gzip_module（压缩模块，包含gzip、gzip_type等配置参数）
ngx_http_limit_conn_module（限制并发量模块，包含limit_conn等参数）
ngx_http_log_module（日志模块，包含access_log等配置参数）
ngx_http_proxy_module（代理模块，包含proxy_pass等配置参数）
ngx_http_rewrite_module（地址重写模块，包含rewrite、break、last等配置参数）
ngx_http_ssl_module（加密模块，包含ssl_certificate、ssl_certificate_key等参数）
ngx_http_stub_status_module（状态模块，包含stub_status配置参数）
ngx_http_upstream_module(调度器模块，包含upstream、hash、ip_hash等配置参数)
ngx_stream_core_module（4层代理模块）

在proxy模块中有proxy_pass、proxy_cache、proxy_cache_path、proxy_connect_timeout、proxy_limit_rate等参数）

4. HTTP常见状态码有哪些，分别是什么含义？

答案参考前面的运维课程

5. linux系统中你会用什么命令查看硬件使用的状态信息?

答：
uptime、lscpu查看CPU
free查看内存
lsblk、df、iostat查看磁盘
ifconfig、ip a s查看网卡
dmidecode查看主板设备信息

6. 如果你用 grep -i "error" 过滤只是包含error的行，想同时过滤error上面和下面的行如何实现？

答：
grep -i "error" 文件 -A 后面的行数 -B 前面的行数
grep -i "error" 文件 -C 前后的行数

> 如有侵权，请联系作者删除



﻿@[TOC]( Deploy GitLab & configure GitLab & CI/CD Overview & Deploy Jenkins | Cloud computing )

---

# 1. 部署GitLab

## 1.1 问题

本案例要求搭建一台GitLab服务器，要求如下：

- 准备环境（容器环境）
- 安装GitLab

## 1.2 方案

实验环境准备（沿用DAY01的实验环境）：

1）准备两台RHEL8虚拟机，主机名分别为develop和git。
2）develop主机的IP地址为192.168.4.10，不需要配置网关和DNS。
3）git主机的IP地址为192.168.4.20，不需要配置网关和DNS。
4）给develop和git两台主机配置可用的YUM源。

备注：跨网段走路由，相同网段不需要配置网关就可以互联互通！

实验拓扑如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e64887bbb64440c6bb38479e88794720.png)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备（在192.168.4.20主机操作）**

1）防火墙、SELinux。

```shell
[root@git ~]# firewall-cmd --set-default-zone=trusted
[root@git ~]# setenforce 0
[root@git ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

2)修改sshd默认端口。

因为Git是通过SSH协议形式访问，后面需要启动GitLab容器，该容器需要占用22端口，而电脑的sshd服务也需要占用22端口（端口冲突），所以需要提前修改sshd默认端口，将端口修改为2022。

注意：修改后需要重新登录一次虚拟机（重新登录需要指定端口）。

```shell
[root@git ~]# vim /etc/ssh/sshd_config
Port 2022                                               #17行
[root@git ~]# systemctl restart sshd
[root@git ~]# exit
真机# ssh -p 2022  192.168.4.20 
```

3）准备容器环境。

提示：gitlab_zh.tar在第二阶段素材目录中，需要先将该素材拷贝到192.168.4.20主机。（比如拷贝到/root目录）

```shell
[root@git ~]# dnf  -y   install   podman
[root@git ~]# podman load < ./gitlab_zh.tar
[root@git ~]# podman images
REPOSITORY               TAG      IMAGE ID          CREATED       SIZE
localhost/gitlab_zh   latest   1f71f185271a       2 years ago   1.73 GB
```

4）创建数据目录

容器无法持久保存数据，需要将真机目录和容器目录绑定，实现数据永久保存。

```shell
[root@git ~]# mkdir -p /srv/gitlab/{config,logs,data}
```

**步骤二：启动GitLab容器(192.168.4.20操作)**

1）启动容器

```shell
[root@git ~]# touch /etc/resolv.conf                       
#如果没有该文件则创建文件，防止无法podman run启动容器
[root@git ~]# podman run -d -h gitlab --name gitlab \
-p 443:443 -p 80:80 -p 22:22 \
--restart=always \
-v /srv/gitlab/config:/etc/gitlab \
-v /srv/gitlab/logs:/var/log/gitlab \
-v /srv/gitlab/data:/var/opt/gitlab \
gitlab_zh
```

注释：
-d将容器放入后台启动。
-h设置容器的主机名为gitlab。
--name设置容器名称为gitlab。
-p进行端口映射，将git主机的443、80、22端口和git上面运行的容器端口绑定

这样以后任何人访问git主机(192.168.4.20)的22端口也就是在访问容器里面的22端口，任何人访问git主机(192.168.4.20)的80端口也就是访问容器里面的80端口。

-v将git主机上面的目录和容器里面的目录绑定，git主机的/srv/gitlab/config目录对应容器里面的/etc/gitlab/目录，其他目录同理。

`最后的gitlab_zh是镜像名称。`

2）配置systemd，实现容器开机自启动(选做实验)

生成service文件，-n是容器的名称，给gitlab容器生成service文件

```shell
[root@git ~]# cd /usr/lib/systemd/system
[root@git ~]# podman generate systemd -n gitlab --files
[root@git ~]# cd ~
```

设置开机自启动

```shell
[root@git ~]# systemctl enable container-gitlab.service
```

3）初始化登录密码（真机使用浏览器访问GitLab页面）

```shell
# firefox http://192.168.4.20
```

GitLab默认用户名为root，第一次访问需要设置密码，效果如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c3d641098f82444ba786a70ceef9c442.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-2

设置密码后即可使用新设置的密码登录（密码要8位，有字母符号数字组成），效果如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9a78cdbf827b4552bd316a53fd423b74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-3

# 2. 配置GitLab

## 2.1 问题

沿用练习一，配置GitLab，具体要求如下：

- 创建GitLab用户和组
- 创建GitLab项目
- 客户端管理GitLab项目
- 上传代码

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建用户和组**

1）创建用户，点击GitLab页面的小扳手图标，创建用户，效果如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ce650ecab70844bd8ffbd40b9fbce4bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

创建jerry用户，点击《编辑》设置用户的密码，效果如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3f9ca450e574b5ba33e52d87e4f3cd1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

2）创建组

点击GitLab页面的小扳手图标，创建组，效果如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0b50385939d8411c8b107381cea7b525.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

设置组名称（组名称为devops）以及可见等级（等级为公开），效果如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bd0802f7837441cda8808a284bdf5cf0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-7

3）将用户加入到组（将jerry用户加入devops组），效果如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/77aaeb5c6c944b0fa600f0f0b813e84e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

**步骤二：创建GitLab项目**

1）创建项目，效果如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/468c06d8bb7f49ebb23d6922deb84af9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-9

2）设置项目名称、组、可见等级，效果如图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c1be8df2650f46799ce17bde3a56ff31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-10

**步骤三：管理GitLab项目**

1）客户端使用密码管理GitLab项目（在192.168.4.10主机操作）

```shell
[root@develop ~]# git config --global user.name "Administrator"
[root@develop ~]# git config --global user.email "admin@example.com"
[root@develop ~]# git clone http://192.168.4.20/devops/myproject.git
[root@develop ~]# cd myproject
[root@develop myproject]# touch README.md
[root@develop myproject]# git add README.md
[root@develop myproject]# git commit -m "add README"
[root@develop myproject]# git push -u origin master
Username for 'http://192.168.4.20': jerry    #这里输入用户名
Password for 'http://jerry@192.168.4.20':    #这里输入密码
```

2）客户端生成SSH密钥（在192.168.4.10主机操作）

```shell
[root@develop myproject]# rm -rf /root/.ssh/known_hosts  #删除之前的ssh远程记录
[root@develop myproject]# ssh-keygen                   #生成ssh密钥文件
[root@develop myproject]# cat ~/.ssh/id_rsa.pub       #查看密钥文件
ssh-rsa 
AAAAB3NzaC1yc2EAAAADAQABAAABAQDPVwP8E7TtKha9H8Ec+CU2n19aIPo9sUa/pdM7gRaf0yG+Bcdy
Q7Hgi6pI51IhX6tat46L5tLkAY7urVeEmnPtUk/TVIUc0smJPXYKIggOCr2dDd9s1S0
```

3）使用jerry用户登录GitLab页面

jerry用户第一次登录页面需要重置一次密码，密码可以与旧密码相同。效果如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/38e34527b02f47bb87cb620883317b35.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-11

4）上传密钥

将刚刚192.168.4.10上面创建的密钥文件内容上传到GitLab。

点击右上角账户图标，点击《设置》，点击展开按钮，点击《SSH密钥》，然后将develop主机生成的密钥文件内容复制到GitLab上面。效果如图-12、图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/73f1a057037844598d1f3bb59c372b72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-12

![在这里插入图片描述](https://img-blog.csdnimg.cn/b5ec8c264f5742039fea38a42855a034.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-13

5）使用密钥管理GitLab项目

首先要查看下基于SSH连接方式的链接，如图-14所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a9b1bb57b28048ceae052d3e86ae75ab.png)
图-14

```shell
[root@develop myproject]# git remote remove origin
[root@develop myproject]# git remote add \
origin git@192.168.4.20:devops/myproject.git
```

#重要备注:

前面的案例使用http协议访问clone了服务器的代码仓库，这里把之前的http服务器信息删除（remove：删除），然后在添加新的服务器信息(add：添加)，使用ssh协议访问服务器。

```shell
[root@develop myproject]# echo hello word >> README.md
[root@develop myproject]# git add .
[root@develop myproject]# git commit -m "modify readme"
[root@develop myproject]# git push -u origin master
```

6) 上传静态页面代码（代码在第二阶段素材lnmp_soft.tar.gz中）

需要提前将真机的网页素材scp拷贝到develop虚拟机用户的家目录，解压lnmp_soft.tar.gz，在该压缩包里面有一个www_template.zip文件。

```shell
[root@develop ~]# dnf  -y  install   unzip tar
[root@develop ~]# unzip  www_template.zip
[root@develop ~]# cp -r www_template/*   myproject/
[root@develop ~]# cd  myproject/
[root@develop myproject]# git add .
[root@develop myproject]# git commit -m  "web site"
[root@develop myproject]# git push -u origin master
[root@develop myproject]# git tag  v1
[root@develop myproject]# git push -u origin v1
```

通过tag可以给代码设置版本标签，如v1，v2，v3等等。

# 3. 部署Jenkins

## 3.1 问题

沿用练习二，部署CI/CD环境，部署Jenkins，具体要求如下：

- 准备实验环境
- 部署Jenkins、初始化Jenkins
- 管理Jenkins插件、调整系统配置

## 3.2 方案

实验环境准备：

1）5台RHEL8虚拟机，主机名分别为develop、git、jenkins、web1和web2。
2）develop主机的IP地址为192.168.4.10，不需要配置网关和DNS。
3）git主机的IP地址为192.168.4.20，不需要配置网关和DNS。
4）jenkins主机的IP地址为192.168.4.30，不需要配置网关和DNS。
5）web1和web2主机的IP地址分别为192.168.4.100和192.168.4.200，不需要配置网关和DNS。
6）所有主机都需要配置可用的系统YUM源，设置防火墙信任所有，SELinux放行所有。

备注：跨网段走路由，相同网段不需要配置网关就可以互联互通！实验拓扑如图-15所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/60ce027f22934b2f92200f5a706141d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-15

**步骤一：环境准备**

1）设置防火墙和SELinux（仅以一台主机为例，其他所有主机都需要操作）

```shell
[root@git ~]# firewall-cmd --set-default-zone=trusted
[root@git ~]# setenforce 0
[root@git ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

2）安装依赖软件（git、postfix、java JDK）。

注意：仅在jenkins主机操作！

```shell
[root@jenkins ~]# dnf -y install git
[root@jenkins ~]# dnf -y install postfix
[root@jenkins ~]# dnf -y install mailx
[root@jenkins ~]# dnf -y install java-11-openjdk
[root@jenkins ~]# systemctl enable postfix --now
```

备注：Git（版本控制软件）、postfix（邮件服务器软件）、mailx（邮件客户端软件）、openjdk（Java JDK工具）。

**步骤二：部署、初始化Jenkins**

1）安装、启动Jenkins。

```shell
[root@jenkins ~]# dnf -y install ./jenkins-2.263.1-1.1.noarch.rpm
[root@jenkins ~]# systemctl enable jenkins
[root@jenkins ~]# systemctl start jenkins
#设置jenkins服务为开机自启动服务，并立刻启动该服务
```

2）初始化Jenkins

真机浏览器访问Jenkins页面（firefox http://192.168.4.30:8080）。

第一次访问会提示初始密码的位置（密码在/var/lib/Jenkins/secrets/initialAdminPassword文件中），效果如图-16所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3e1db9d154d044a2a14f500ac62d5077.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-16

初始化时选择不安装插件，效果如图-17和图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/efb4485369944d55b5299ae83faebcb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-17

![在这里插入图片描述](https://img-blog.csdnimg.cn/148c5fb55b38445b9ca9e3271224e1c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-18

使用默认的admin用户登录，完成初始化操作，效果如图-19，图-20，图-21所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e9126dcd9c3444b4a1b13fbcbd2d427a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-19

![在这里插入图片描述](https://img-blog.csdnimg.cn/1380bc4a3e1c4acdaed8bdd3236101bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-20

![在这里插入图片描述](https://img-blog.csdnimg.cn/c6d961eccdd84eb59dcc6423231c5c82.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-21

**步骤三：管理Jenkins插件、系统配置**

1）重置管理员密码。

重置密码如图-22所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/98868ea72a0643dd9647579a9c0ebd6a.png)
图-22

使用新密码重新登录，如图-23所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/49221c05ace4411f87d7aa81355d30c6.png)
图-23

2）插件管理。

查看插件列表，效果如图-24、图-25所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0884b407f8dc4160bb29020c76aebd79.png)
图-24

![在这里插入图片描述](https://img-blog.csdnimg.cn/f1a277b39f694097a96ae6cece36d4bc.png)
图-25

拷贝插件文件到Jenkins目录，Jenkins插件目录为插件目录：/var/lib/jenkins/plugins/。

Jenkins插件文件在第二阶段素材目录：jenkins_plugins.tar.gz。

插件包含：中文插件、Git插件等。

需要提前将真机素材拷贝到Jenkins虚拟机。

`警告：cp拷贝时需要-p选项保留权限!!!`

[root@jenkins ~]# tar -xf  jenkins_plugins.tar.gz
[root@jenkins ~]# cp -rp jenkins_plugins/* /var/lib/jenkins/plugins/
[root@jenkins ~]# systemctl restart jenkins
重新登录Jenkins网页控制台，如图-26所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5b664fce86044ea0a74279be8f9f63a1.png)
图-26

再次查看插件列表，效果如图-27、图-28所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/26f09caf4e284477aa55e1199edcafc6.png)
图-27

![在这里插入图片描述](https://img-blog.csdnimg.cn/c2d1cdf5824f43e6aa35da916948f02d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-28

3）调整系统设置，配置邮箱，效果如图-29、图-30所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b8bb7553b97949fb9a452acd31f3ae0d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-29

![在这里插入图片描述](https://img-blog.csdnimg.cn/4873fc9f584d4f7abb9cb4d5ead75d80.png)
图-30

附加思维导图，如图-31所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/146db67469404d50950ae73e8198b53f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-31



# Exercise

## 1 podman从本地文件加载镜像的命令是什么?

```shell
# podman  load  < ./文件名
```

## 2 Podman实现端口映射和目录映射的选项是什么？

```shell
-p可以实现端口映射，-v可以实现目录映射
```

## 3 如何给git代码仓库创建版本标签？

```shell
# git  tag  <标签>
```

## 4 什么是CI/CD？

CI（Continuous Integration）
持续集成：开发人员的自动化流程。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。

CD（Continuous Delivery）
持续交付：通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitLab 或容器注册表），然后由运维团队将其部署到实时生产环境中。

目的就是确保尽可能减少部署新代码时所需的工作量。

## 5 Jenkins默认插件目录是什么？

/var/lib/jenkins/plugins/

> 如有侵权，请联系作者删除



﻿@[TOC]( Deploy LNMP & Nginx+FastCGI & Nginx advanced technology | Cloud computing )

---

# 1 案例1：部署LNMP环境

## 1.1 问题

安装部署Nginx、MariaDB、PHP环境

- 安装部署Nginx、MariaDB、PHP、PHP-FPM；
- 启动Nginx、MariaDB、FPM服务；
- 并测试LNMP是否工作正常。

## 1.2 方案

目前的网站一般都会有动态和静态数据，默认nginx仅可以处理静态数据，用户访问任何数据都是直接返回对应的文件，如果如果访问的是一个脚本的话，就会导致直接返回一个脚本给用户，而用户没有脚本解释器，也看不懂脚本源代码！网站拓扑如图-1所示。

因此需要整合LNMP（Linux、Nginx、MySQL、PHP）实现动态网站效果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/40d0cb7ce6164334a4b6af357f9b0d81.png)
图1

LNMP在CentOS系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。

操作过程中需要安装的软件列表如下：

- nginx
- mariadb、mariadb-server、mariadb-devel
- php、php-fpm、php-mysql

备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装软件**

1）使用yum安装基础依赖包

```shell
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel
```

2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）

```shell
[root@proxy ~]# useradd -s /sbin/nologin  nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --user=nginx   --group=nginx \
> --with-http_ssl_module
[root@proxy ~]# make && make install
.. ..
```

3）安装MariaDB

Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：

```shell
[root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
```

4）php和php-fpm

```shell
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install  php-fpm
```

**步骤二：启动服务**

1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）

这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。

```shell
[root@proxy ~]# systemctl stop httpd                   //如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx 
```

2）启动MySQL服务

```shell
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动
```

3）启动PHP-FPM服务

```shell
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动
```

# 2. 构建LNMP平台

## 2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：

1. 配置Fast-CGI支持PHP网页
2. 创建PHP测试页面，测试使用PHP连接数据库的效果

## 2.2 方案

使用2台RHEL7虚拟机，其中一台作为LNMP服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/604c3348f66541a98f6db90ff9a12ec1.png)
图-2


Nginx结合FastCGI技术即可支持PHP页面架构，如图-3所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/35b06de23bfd4bd09a2c2933b1e246d5.png)
图-3

因此本案例，需要延续练习一的实验内容，通过修改Nginx及php-fpm配置文件实现对PHP页面的支持。

注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一： php-fpm配置文件**

1）查看php-fpm配置文件（实验中不需要修改该文件）

```shell
[root@proxy etc]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32                //最大进程数量
pm.start_servers = 15                //最小进程数量
```

**步骤二：修改Nginx配置文件并启动服务**

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;       #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

**步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面**

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：

```shell
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>
```

2）创建PHP测试页面,连接并查询MariaDB数据库。

可以参考lnmp_soft/php_scripts/mysql.php:

```shell
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
//注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
//localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>
```

3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：

```shell
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php
```

4）LNMP常见问题

Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。

# 3. 地址重写

## 3.1 问题

沿用练习二，通过调整Nginx服务端配置，实现以下目标：

1. 所有访问a.html的请求，重定向到b.html;
2. 所有访问192.168.4.5的请求重定向至www.tmooc.cn；
3. 所有访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面；
4. 实现firefox与curl访问相同页面文件，返回不同的内容。

## 3.2 方案

关于Nginx服务器的地址重写，主要用到的配置参数是rewrite：

- rewrite regex replacement flag
- rewrite 旧地址 新地址 [选项]

案例：

- 访问http://www.360buy.com会自动跳转至http://www.jd.com。
- 访问http://www.baidu.com会自动跳转至https://www.baidu.com。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改配置文件(访问a.html重定向到b.html)**

1）修改Nginx服务配置：

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite  /a.html  /b.html;            
location / {
    root   html;
index  index.html index.htm;
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html
```

2）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
```

3）客户端测试

```shell
[root@client ~]# firefox  http://192.168.4.5/a.html
```

**步骤二：访问a.html重定向到b.html（跳转地址栏）**

1）修改Nginx服务配置：

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;            
location / {
    root   html;
index  index.html index.htm;
}
}
```

2）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端测试（仔细观察浏览器地址栏的变化）

```shell
[root@client ~]# firefox  http://192.168.4.5/a.html
```

**步骤三：修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)**

1) 修改Nginx服务配置

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/  http://www.tmooc.cn/;
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}
```

2）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端测试（真实机测试，真实机才可以连接tmooc）

```shell
[root@room9pc01 ~]# firefox  http://192.168.4.5
```

**步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)**

1) 修改Nginx服务配置

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;
location / {
    root   html;
index  index.html index.htm;
}
}
```

2）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端测试（真实机测试，真实机才可以连接tmooc）

```shell
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test
```

**步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)**

1) 创建网页目录以及对应的页面文件：

```shell
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
```

2) 修改Nginx服务配置

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}
#这里，~符号代表正则匹配，*符号代表不区分大小写
if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;
}
}
```

3）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

4）客户端测试

```shell
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html
```

5）地址重写格式【总结】

rewrite 旧地址 新地址 [选项];
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permanent 永久重定向


# Exercise

## 1 简述什么是LNMP

LNMP是网站运行平台。

- L：操作系统（Linux）
- N：网站服务软件（Nginx）
- M：数据库服务软件（MariaDB）
- P：网站开发语言（PHP、perl、python）

## 2 部署LNMP时，如何修改Nginx配置文件

```shell
[root@nginx ~]# vim /usr/local/nginx/nginx.conf
.. ..
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           # fastcgi_param   SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi_conf;
        }
.. ..
```

## 3 地址重写的好处

- 缩短URL，隐藏实际路径提高安全性；
- 易于用户记忆和键入；
- 易于被搜索引擎收录。

## 4 使用Nginx实现域名跳转

> 要求：访问www.tarena.com时自动跳转至bbs.tarena.com

```shell
[root@nginx ~]# cat /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  www.tarena.com;
location / {
    root   html;
index  index.html index.htm;
rewrite ^/ http://bbs.tarena.com/;
}
}
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Project Overview & Deploy the mysql database service & deploy the NFS shared storage service & configure the website service & test the configuration | Cloud computing )

---

# 1. 配置逻辑卷

## 1.1 问题

具体配置如下：

- 添加磁盘
- 磁盘分区
- 创建LV
- 格式化

## 1.2 方案

分别给2台虚拟机添加2块5G的磁盘。如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/abadcdae7ef7468ea730890c14cf0161.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)

图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：磁盘分区(2台数据库服务器都配置)**

1）创建分区，每块盘分1个区即可

```shell
[root@mysql11 ~]# fdisk  -l /dev/vdb  //查看磁盘容量
磁盘 /dev/vdb：5368 MB, 5368709120 字节，10485760 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
[root@mysql11 ~]#
[root@mysql11 ~]# fdisk  -l /dev/vdc //查看磁盘容量
磁盘 /dev/vdc：5368 MB, 5368709120 字节，10485760 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
[root@mysql11 ~]#
[root@mysql11 ~]# fdisk  /dev/vdb   //磁盘分区
欢迎使用 fdisk (util-linux 2.23.2)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
Device does not contain a recognized partition table
使用磁盘标识符 0x882d04b7 创建新的 DOS 磁盘标签。
命令(输入 m 获取帮助)：n  //创建分区
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p   //创建主分区
分区号 (1-4，默认 1)：1  //指定编号
起始 扇区 (2048-10485759，默认为 2048)：  //起始柱面数
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-10485759，默认为 10485759)：//结束柱面数
将使用默认值 10485759
分区 1 已设置为 Linux 类型，大小设为 5 GiB
命令(输入 m 获取帮助)：w  //保存退出
The partition table has been altered!
Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@mysql11 ~]#
[root@mysql11 ~]# fdisk  /dev/vdc   //给vdc盘分区
欢迎使用 fdisk (util-linux 2.23.2)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
Device does not contain a recognized partition table
使用磁盘标识符 0x5184f504 创建新的 DOS 磁盘标签。
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
分区号 (1-4，默认 1)：1
起始 扇区 (2048-10485759，默认为 2048)：
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-10485759，默认为 10485759)：
将使用默认值 10485759
分区 1 已设置为 Linux 类型，大小设为 5 GiB
命令(输入 m 获取帮助)：w
The partition table has been altered!
Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@mysql11 ~]#
```

2）查看分区

```shell
[root@mysql11 ~]# fdisk  -l /dev/vdb
磁盘 /dev/vdb：5368 MB, 5368709120 字节，10485760 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x882d04b7
   设备 Boot      Start         End      Blocks   Id  System
/dev/vdb1            2048    10485759     5241856   83  Linux 
[root@mysql11 ~]#
[root@mysql11 ~]#
[root@mysql11 ~]# fdisk  -l /dev/vdc
磁盘 /dev/vdc：5368 MB, 5368709120 字节，10485760 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x5184f504
   设备 Boot      Start         End      Blocks   Id  System
/dev/vdc1            2048    10485759     5241856   83  Linux
[root@mysql11 ~]#
```

**步骤二：创建LV**

1）安装提供命令的软件

```shell
    [root@mysql11 ~]# rpm  -q  lvm2 || yum -y  install  lvm2  //安装软件
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
local_repo                                                              | 3.6 kB  00:00:00
正在解决依赖关系
--> 正在检查事务
---> 软件包 lvm2.x86_64.7.2.02.177-4.el7 将被 安装
……
……
已安装:
  lvm2.x86_64 7:2.02.177-4.el7
作为依赖被安装:
  device-mapper-event.x86_64 7:1.02.146-4.el7
  device-mapper-event-libs.x86_64 7:1.02.146-4.el7
  device-mapper-persistent-data.x86_64 0:0.7.3-3.el7
  libaio.x86_64 0:0.3.109-13.el7
  lvm2-libs.x86_64 7:2.02.177-4.el7
完毕！
[root@mysql11 ~]#
```

2）创建PV

```shell
 [root@mysql11 ~]#
[root@mysql11 ~]# pvcreate  /dev/vdb1 /dev/vdc1   //创建PV
  Physical volume "/dev/vdb1" successfully created.
  Physical volume "/dev/vdc1" successfully created.
[root@mysql11 ~]#
[root@mysql11 ~]# pvscan //查看PV信息
  PV /dev/vdb1                lvm2 [<5.00 GiB / 0    free]
  PV /dev/vdc1                lvm2 [<5.00 GiB / 0    free]
  PV /dev/sda2   VG centos   lvm2 [<9.00 GiB / 0    free]
  Total: 3 [<18.99 GiB] / in use: 3 [<18.99 GiB] / in no VG: 0 [0   ]
[root@mysql11 ~]# [root@mysql11 ~]#
```

3）创建VG

```shell
[root@mysql11 ~]# vgcreate  vg0 /dev/vdb1 /dev/vdc1  //创建vg  名称vg0
  Volume group "vg0" successfully created
[root@mysql11 ~]# 
[root@mysql11 ~]# vgdisplay  vg0  //查看vg0详细信息
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  2
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               9.99 GiB  //总大小
  PE Size               4.00 MiB
  Total PE              2558      //PE总个数
  Alloc PE / Size       2558 / 9.99 GiB
  Free  PE / Size       0 / 0   
  VG UUID               l1MQ7u-CeXC-fdkP-mJCT-0GqP-1gFQ-qKxWNA
  [root@mysql11 ~]#
```

4）创建LV

```shell
 [root@mysql11 ~]# lvcreate  -L 9.99G -n lv0  vg0 //创建LV 名称为lv0 大小9.99G
  Rounding up size to full physical extent 9.99 GiB
  Logical volume "lv0" created.
[root@mysql11 ~]# 
 [root@mysql11 ~]# lvdisplay  /dev/vg0/lv0 //查看lv0信息
  --- Logical volume ---
  LV Path                /dev/vg0/lv0
  LV Name                lv0
  VG Name                vg0
  LV UUID                SciSrm-cp8l-4ZR2-wydh-xg6V-KMiI-pgW0j5
  LV Write Access        read/write
  LV Creation host, time mysql11, 2021-02-02 10:33:35 -0500
  LV Status              available
  # open                 1
  LV Size                9.99 GiB  //总大小
  Current LE             2558
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
   
[root@mysql11 ~]#
```

5）格式化

```shell
[root@mysql11 ~]# mkfs.xfs  /dev/vg0/lv0  //格式化为 xfs 文件系统
meta-data=/dev/vg0/lv0           isize=512    agcount=4, agsize=654848 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=2619392, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@mysql11 ~]# blkid  /dev/vg0/lv0   //查看文件系统类型
/dev/vg0/lv0: UUID="3e06f58f-8793-4800-b444-676f5a07fe10" TYPE="xfs"
[root@mysql11 ~]#
```

# 2. 配置数据库服务器

## 2.1 问题

具体操作如下：

1. 安装MySQL软件
2. 挂载LV分区
3. 启动服务
4. 管理员登录

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装软件MySQL服务软件(2台数据库服务器都要安装)**

1）解包软件

```shell
 [root@mysql11 ~]# tar -xvf mysql-5.7.17.tar
./mysql-community-client-5.7.17-1.el7.x86_64.rpm
./mysql-community-common-5.7.17-1.el7.x86_64.rpm
./mysql-community-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
./mysql-community-server-5.7.17-1.el7.x86_64.rpm
./mysql-community-test-5.7.17-1.el7.x86_64.rpm
[root@mysql11 ~]#
[root@mysql11 ~]# ls *.rpm
mysql-community-client-5.7.17-1.el7.x86_64.rpm
mysql-community-common-5.7.17-1.el7.x86_64.rpm
mysql-community-devel-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
mysql-community-libs-5.7.17-1.el7.x86_64.rpm
mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
mysql-community-server-5.7.17-1.el7.x86_64.rpm
mysql-community-test-5.7.17-1.el7.x86_64.rpm
[root@mysql11 ~]#
```

2）安装软件

```shell
[root@mysql11 ~]# yum -y  install mysql-community-*.rpm
已加载插件：fastestmirror
正在检查 mysql-community-client-5.7.17-1.el7.x86_64.rpm: mysql-community-client-5.7.17-1.el7.x86_64
mysql-community-client-5.7.17-1.el7.x86_64.rpm 将被安装
……
……
已安装:
  mysql-community-client.x86_64 0:5.7.17-1.el7                             mysql-community-common.x86_64 0:5.7.17-1.el7
  mysql-community-devel.x86_64 0:5.7.17-1.el7                              mysql-community-embedded.x86_64 0:5.7.17-1.el7
  mysql-community-embedded-compat.x86_64 0:5.7.17-1.el7                    mysql-community-embedded-devel.x86_64 0:5.7.17-1.el7
  mysql-community-libs.x86_64 0:5.7.17-1.el7                               mysql-community-libs-compat.x86_64 0:5.7.17-1.el7
  mysql-community-minimal-debuginfo.x86_64 0:5.7.17-1.el7                  mysql-community-server.x86_64 0:5.7.17-1.el7
  mysql-community-test.x86_64 0:5.7.17-1.el7
作为依赖被安装:
  perl-Data-Dumper.x86_64 0:2.145-3.el7                                      perl-JSON.noarch 0:2.59-2.el7
完毕！
[root@mysql11 ~]#
```

**步骤二：挂载lv设备**

1）设置开机挂载

```shell
[root@mysql11 ~]# blkid /dev/vg0/lv0
/dev/vg0/lv0: UUID="3e06f58f-8793-4800-b444-676f5a07fe10" TYPE="xfs"
[root@mysql11 ~]#
[root@mysql11 ~]# vim /etc/fstab
/dev/vg0/lv0    /var/lib/mysql xfs      defaults        0 0
:wq
[root@mysql11 ~]#
```

2）查看挂载信息

```shell
[root@mysql11 ~]# mount -a
[root@mysql11 ~]# mount | grep  “/var/lib/mysql”
/dev/mapper/vg0-lv0 on /var/lib/mysql type xfs (rw,relatime,attr2,inode64,noquota)
[root@mysql11 ~]#
```

**步骤三：启动服务**

1）启动服务(俩台数据库服务器都要启动服务)

```shell
[root@mysql11 ~]# systemctl start  mysqld
[root@mysql11 ~]#
[root@mysql11 ~]# ls /var/lib/mysql
auto.cnf    client-cert.pem  ibdata1      ibtmp1      mysql.sock.lock     public_key.pem   sys
ca-key.pem  client-key.pem   ib_logfile0  mysql       performance_schema  server-cert.pem
ca.pem      ib_buffer_pool   ib_logfile1  mysql.sock  private_key.pem     server-key.pem
[root@mysql11 ~]#
[root@mysql11 ~]# systemctl enable  mysqld
[root@mysql11 ~]#
[root@mysql11 ~]# netstat -utnlp  | grep  :3306
tcp6       0      0 :::3306                 :::*                    LISTEN      1531/mysqld
[root@mysql11 ~]#
[root@mysql11 ~]# df -h | grep  "/var/lib/mysql"  //查看数据库目录容量
/dev/mapper/vg0-lv0       10G  166M  9.9G    2% /var/lib/mysql
[root@mysql11 ~]#
```

**步骤四：管理员登录**

1）查看初始密码

```shell
[root@mysql11 ~]# grep “password”  /var/log/mysqld.log
2019-07-05T01:56:51.895852Z 1 [Note] A temporary password is generated for root@localhost: bB0*uCmu:.Kj
[root@mysql11 ~]#
[root@mysql11 ~]# mysql -uroot -p'bB0*uCmu:.Kj'  //初始密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.17
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>
```

2）修改登录密码

```shell
mysql> alter user root@"localhost" identified by "123qqq...A"; //修改密码
Query OK, 0 rows affected (0.01 sec)
mysql>
mysql> exit
Bye
[root@mysql11 ~]#
```

3）新密码登录

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> show  databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
```

# 3. 配置主从同步

## 3.1 问题

配置步骤如下：

1. 配置主服务器
2. 配置从服务器

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置主服务器**

1）启用binlog日志

```shell
[root@mysql11 ~]# vim /etc/my.cnf
[mysqld]
server_id=11
log-bin=master11
:wq
[root@mysql11 ~]# systemctl  restart mysqld
[root@mysql11 ~]#
```

2）用户授权

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
mysql>
mysql> grant replication  slave  on  *.*  to  repluser@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.04 sec)
mysql>
```

3）查看日志信息

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master11.000001 |      441 |              |                  |                   |
+-----------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
mysql>
```

**步骤二：配置从服务器**

1）指定server_id

```shell
[root@mysql22 ~]# vim /etc/my.cnf
[mysqld]
server_id=22
:wq
[root@mysql22 ~]# systemctl  restart mysqld
```

2）指定主服务器信息

```shell
[root@mysql22 ~]# mysql -uroot -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.17 MySQL Community Server (GPL)
Mysql>
mysql> change master to  master_host="192.168.4.11",master_user="repluser",
    -> master_password="123qqq...A",master_log_file="master11.000001",master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.41 sec)
mysql>
```

3）启动slave进程

```shell
mysql> start slave ;
Query OK, 0 rows affected (0.02 sec)
mysql>
```

4）查看状态信息

```shell
[root@mysql22 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
[root@mysql22 ~]#
[root@mysql22 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep -i 192.168.4.11
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.11
[root@mysql22 ~]#
```

# 4. 配置读写分离服务

## 4.1 问题

配置步骤如下：

1. 安装软件
2. 修改配置文件
3. 配置数据库服务器
4. 启动服务
5. 查看服务状态
6. 查看监控信息

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置读写分离服务**

1）安装软件

```shell
[root@maxscale77 ~]# rpm -ivh  maxscale-2.1.2-1.rhel.7.x86_64.rpm //安装软件
警告：maxscale-2.1.2-1.rhel.7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 8167ee24: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:maxscale-2.1.2-1                                                   (  2%################################# [100%]
[root@maxscale77 ~]#
[root@maxscale77 ~]# ls /etc/maxscale.cnf  //主配置文件
/etc/maxscale.cnf
[root@maxscale77 ~]# ls /var/log/maxscale/   //日志目录
```

2）修改配置文件

```shell
[root@maxscale77 ~]# vim  /etc/maxscale.cnf
[maxscale]  //服务线程数量
threads=auto
[server1] //第1台数据库服务器
type=server
address=192.168.4.11
port=3306
protocol=MySQLBackend
[server2]  //第2台数据库服务器
type=server
address=192.168.4.22
port=3306
protocol=MySQLBackend
[MySQL Monitor] //指定监控数据库服务器server1 和 server2
type=monitor
module=mysqlmon
servers=server1,server2
user=mysqla   //监控用户
passwd=123qqq...A  //密码
monitor_interval=10000
[Read-Write Service]  //定义读写分离服务
type=service
router=readwritesplit
servers=server1,server2
user=mysqlb  //路由用户
passwd=123qqq...A  //密码
max_slave_connections=100%
[MaxAdmin Service]  //定义管理服务
type=service
router=cli
[Read-Write Listener]  //定义读写分离服务端口
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006  //端口号
[MaxAdmin Listener]  //定义管理服务端口
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016 //端口号
:wq
[root@maxscale77 ~]#
```

**步骤二：配置数据库服务器**

1）创建用户：在主服务器上添加，从服务器查看即可

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql> grant replication slave, replication client on *.*
    -> to  mysqla@"%"identified by "123qqq...A";
mysql> grant select  on  mysql.*  to
    -> mysqlb@"%" identified by "123qqq...A";
mysql>
```

2) 从服务器查看授权用户

```shell
[root@mysql22 ~]# mysql -uroot -p123qqq...A -e 'select user,host from mysql.user where user like "maxscale%" '
mysql: [Warning] Using a password on the command line interface can be insecure.
+----------------+------+
| user           | host |
+----------------+------+
| mysqla    | %    |
| mysqlb    | %    |
+----------------+------+
[root@mysql22 ~]#
```

**步骤三：启动maxsacle服务**

1）启动服务

```shell
 [root@maxscale77 ~]# maxscale  -f /etc/maxscale.cnf
```

2）查看服务信息（进程 和 端口）

```shell
[root@maxscale77 ~]# ps -C maxscale
  PID TTY          TIME CMD
23254 ?        00:00:00 maxscale
[root@maxscale77 ~]#
[root@maxscale77 ~]# netstat -utnlp  | grep  maxscale
tcp6       0      0 :::4006                 :::*                    LISTEN      23254/maxscale
tcp6       0      0 :::4016                 :::*                    LISTEN      23254/maxscale
[root@maxscale77 ~]#
```

3）在maxscale服务本机访问管理服务，查看监控信息

```shell
[root@maxscale77 ~]# maxadmin  -uadmin  -pmariadb -P4016
MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.11    |  3306 |           0 | Master, Running
server2            | 192.168.4.22    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------
MaxScale>
MaxScale> exit
[root@maxscale77 ~]#
```

# 5. 准备NFS服务存储磁盘

## 5.1 问题

具体配置如下：

1. 添加磁盘
2. 磁盘分区
3. 创建LV
4. 格式化

## 5.2 方案

给NFS服务器主机添加1块3G的磁盘。如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/66b7eb1fef524aef82fe02864441f030.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-2

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：磁盘分区**

1）创建分区，分1个区即可

```shell
[root@nfs30 ~]# fdisk  -l /dev/vdb  //查看磁盘信息
磁盘 /dev/vdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
[root@nfs30 ~]#
[root@nfs30 ~]# fdisk  /dev/vdb   //磁盘分区
欢迎使用 fdisk (util-linux 2.23.2)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
Device does not contain a recognized partition table
使用磁盘标识符 0x67bb10cf 创建新的 DOS 磁盘标签。
命令(输入 m 获取帮助)：n  //新建分区
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p):
Select (default p): p //创建主分区
分区号 (1-4，默认 1)： //回车
起始 扇区 (2048-20971519，默认为 2048)： //回车
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-20971519，默认为 20971519)：//回车
将使用默认值 20971519
分区 1 已设置为 Linux 类型，大小设为 10 GiB
命令(输入 m 获取帮助)：w  //保存退出
The partition table has been altered!
Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@nfs30 ~]#
```

2）查看分区

```shell
 [root@nfs30 ~]# fdisk  -l /dev/vdb
磁盘 /dev/vdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x67bb10cf
   设备 Boot      Start         End      Blocks   Id  System
/dev/vdb1            2048    20971519    10484736   83  Linux
[root@nfs30 ~]#
```

**步骤二：挂载磁盘**

1）格式化

```shell
[root@nfs30 ~]# mkfs.xfs /dev/vdb1  //格式化
meta-data=/dev/vdb1              isize=512    agcount=4, agsize=655296 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=2621184, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@nfs30 ~]#
[root@nfs30 ~]# blkid /dev/vdb1  //查看
/dev/vdb1: UUID="81740d7a-51f1-4ce1-a830-7b6517cc778e" TYPE="xfs"
[root@nfs30 ~]#
```

2）配置开机挂载

```shell
 [root@nfs30 ~]# vim  /etc/fstab   //修改配置文件
/dev/vdb1       /sitedir        xfs     defaults        0 0
[root@nfs30 ~]#
[root@nfs30 ~]# mkdir /sitedir  //创建挂载目录
[root@nfs30 ~]# chmod o+w /sitedir   //赋予写权限
[root@nfs30 ~]# mount –a  //加载文件中所有未加载的设备
[root@nfs30 ~]# mount | grep  "/sitedir"  //查看加载信息
/dev/vdb1 on /sitedir type xfs (rw,relatime,attr2,inode64,noquota)
[root@nfs30 ~]#
```

# 6. 配置NFS服务

## 6.1 问题

具体配置如下：

1. 安装软件
2. 修改配置文件
3. 启动服务
4. 查看共享信息

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署NFS服务**

1）安装软件

```shell
[root@nfs30 ~]# yum -y install  nfs-utils   rpcbind
已安装:
  nfs-utils.x86_64 1:1.3.0-0.54.el7                  rpcbind.x86_64 0:0.2.0-44.el7
作为依赖被安装:
  gssproxy.x86_64 0:0.7.0-17.el7                     keyutils.x86_64 0:1.5.8-3.el7
  libbasicobjects.x86_64 0:0.1.1-29.el7              libcollection.x86_64 0:0.7.0-29.el7
  libevent.x86_64 0:2.0.21-4.el7                     libini_config.x86_64 0:1.3.1-29.el7
  libnfsidmap.x86_64 0:0.25-19.el7                   libpath_utils.x86_64 0:0.2.1-29.el7
  libref_array.x86_64 0:0.1.5-29.el7                 libtirpc.x86_64 0:0.2.4-0.10.el7
  libverto-libevent.x86_64 0:0.2.5-4.el7             quota.x86_64 1:4.01-17.el7
  quota-nls.noarch 1:4.01-17.el7                     tcp_wrappers.x86_64 0:7.6-77.el7
完毕！
[root@nfs30 ~]#
```

2）修改配置文件

```shell
[root@nfs30 ~]# 
[root@nfs30 ~]# vim /etc/exports
/sitedir *(rw)
:wq
[root@nfs30 ~]# exportfs –r  //加载配置
[root@nfs30 ~]#
```

**步骤二：启动服务**

1）启动服务

```shell
[root@nfs30 ~]# systemctl  start rpcbind
[root@nfs30 ~]#
[root@nfs30 ~]# systemctl  start nfs
[root@nfs30 ~]#
[root@nfs30 ~]# systemctl  enable nfs
Created symlink from /etc/systemd/system/multi-user.target.wants/nfs-server.service to /usr/lib/systemd/system/nfs-server.service.
[root@nfs30 ~]#
[root@nfs30 ~]# systemctl  enable rpcbind
[root@nfs30 ~]#
```

2）查看共享信息

```shell
[root@nfs30 ~]# showmount  -e localhost
Export list for localhost:
/sitedir *
[root@nfs30 ~]#
```

# 7. 配置网站服务

## 7.1 问题

具体配置如下：

1. 安装软件
2. 挂载共享存储
3. 启动服务

## 7.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装软件**

1）安装软件

```shell
[root@web33 ~]# yum -y install java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64  //安装JDK
[root@web33 ~]# tar -zxvf apache-tomcat-8.0.30.tar.gz //解压tomcat源码
[root@web33 ~]#mv apache-tomcat-8.0.30 /usr/local/tomcat //方便管理移动目录
[root@web33 ~]#yum -y install  mysql-connector-java //安装连接mysql服务软件
[root@web33 ~]#cp /usr/share/java/mysql-connector-java.jar /usr/local/tomcat/lib/ //拷贝连接命令
[root@web33 ~]# rm -rf /usr/local/tomcat/webapps/ROOT/*  //删除默认的网页文件
[root@web33 ~]# yum -y install nfs-utils //安装提供showmount命令软件
```

步骤二：挂载共享

1）查看共享目录

```shell
[root@web33 ~]# showmount  -e 192.168.4.30  //查看共享
Export list for 192.168.4.30:
/sitedir *
[root@web33 ~]#
```

2）挂载共享目录

```shell
[root@web33 ~]# vim /etc/fstab  //配置开机挂载
192.168.4.30:/sitedir   /usr/local/tomcat/webapps/ROOT   nfs     defaults        0 0
:wq
[root@web33 ~]# mount –a  //加载所有未加载的设备
```

3）查看挂载

```shell
[root@web33 ~]# mount  | grep "sitedir" //查看挂载
192.168.4.30:/sitedir on /usr/local/tomcat/webapps/ROOT type nfs4 (rw,relatime,vers=4.1,rsize=65536,wsize=65536,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=192.168.4.33,local_lock=none,addr=192.168.4.30)
[root@web33 ~]# systemctl  enable remote-fs.target //设置远程加载服务开机运行
```

**步骤三：启动服务**

1）启动服务

```shell
[root@web33 ~]# /usr/local/tomcat/bin/startup.sh
[root@web33 ~]#  echo “/usr/local/tomcat/bin/startup.sh” >> /etc/rc.local  //设置服务开机运行
[root@web33 ~]# chmod +x  /etc/rc.local
```

2）查看服务运行信息

```shell
 [root@web33 ~]# netstat  -utnlp  | grep java
tcp6       0      0 127.0.0.1:8005          :::*                    LISTEN      83033/java          
tcp6       0      0 :::8009                 :::*                    LISTEN      83033/java          
tcp6       0      0 :::8080                 :::*                    LISTEN      83033/java          
```

# 8. 测试配置

## 8.1 问题

具体配置如下：

1. 测试NFS服务
2. 测试MySQL服务
3. 测试Tomcat连接MySQL服务

## 8.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：测试NFS服务**

1）在nfs服务器创建网页 test.html

```shell
[root@nfs30 ~]# echo  "web test page" > /sitedir/test.html
[root@nfs30 ~]#
[root@nfs30 ~]# ls /sitedir/
test.html
[root@nfs30 ~]#
```

2）在客户端访问网站服务

```shell
[root@room9pc17 ~]# curl  http://192.168.4.33/test.html  //访问网站33主机
web test page
[root@room9pc17 ~]#
```

**步骤二：测试MySQL服务**

1）在主数据库服务器上添加，访问数据的连接用户

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql> create database gamedb; //建库
mysql> create table gamedb.user(name char(10)); //建表
mysql> grant select,insert,update,delete on gamedb.* to yaya99@"%" identified by "123qqq...A"; //用户授权
```

2）在从服务器查看是否同步数据

```shell
 [root@mysql22 ~]# mysql -uroot -p123qqq...A
mysql> show grants for yaya99@"%"; //查看授权用户
+--------------------------------------------------------------------+
| Grants for yaya99@%                                                |
+--------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'yaya99'@'%'                                 |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `gamedb`.* TO 'yaya99'@'%' |
+--------------------------------------------------------------------+
2 rows in set (0.00 sec)
mysql> desc gamedb.user; //查看库表
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(10) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
mysql> insert into  gamedb.user values("xdd"); //用来验证数据读写分离
mysql> select  * from gamedb.user;
+------+
| name |
+------+
| xdd  |
+------+
1 row in set (0.00 sec)
mysql>
```

3）测试读写分离服务

在网站服务器上，连接数据读写分离服务器77

```shell
[root@web33 ~]# yum -y  install mariadb     //安装提供连接命令软件
已安装:
  mariadb.x86_64 1:5.5.56-2.el7
作为依赖被安装:
  mariadb-libs.x86_64 1:5.5.56-2.el7
完毕！
[root@web33 ~]#
[root@web33 ~]# mysql -h192.168.4.77 -P4006 -uyaya99 -p123qqq...A //连接读写分离服务
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 23258
Server version: 10.0.0 2.1.2-maxscale MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MySQL [(none)]>
```

4）查询数据

```shell
MySQL [(none)]> select  * from gamedb.user; //显示的是从服务器上的数据
+------+
| name |
+------+
| xdd  |
+------+
1 row in set (0.00 sec)
MySQL [(none)]>
```

5）存储数据

```shell
MySQL [(none)]> insert into gamedb.user values("pmm"); //插入记录
Query OK, 1 row affected (0.05 sec)
MySQL [(none)]> select  * from gamedb.user; //查看记录
+------+
| name |
+------+
| xdd  |
| pmm  |
+------+
2 rows in set (0.00 sec)
MySQL [(none)]>
```

6）在主服务器本机登录查看数据

```shell
[root@mysql11 ~]# mysql -uroot -p123qqq...A -e "select  * from  gamedb.user"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| name |
+------+
| pmm  |
+------+
[root@mysql11 ~]#
```

**步骤三：Tomcat连接MySQL服务**

1）在nfs服务共享目录编写网页文件

```shell
[root@nfs30 ~]# vim /sitedir/linkdb.jsp
<%@ page language="java" import="java.util.*" pageEncoding="gbk"%>
<%@ page import="java.naming.*" %>
<%@ page import="java.sql.*" %>
<html>
     <body>
          <%
          Class.forName("com.mysql.jdbc.Driver");
Connection con=DriverManager.getConnection("jdbc:mysql://192.168.4.11:3306/gamedb","yaya99","123qqq...A");
Statement state=con.createStatement();
String sql="insert into user values('TOM')";
state.executeUpdate(sql);
           %>
           <h1>data save ok</h1>
     </body>
</html>
:wq
```

2）在浏览器地址栏里输入网站访问

```shell
http://192.168.4.33:8080/linkdb.jsp
```

3）在据库服务器查看数据

```shell
[root@mysql11 ~]# mysql -uadmin -p123qqq...A -e 'select  * from gamedb.user'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| name |
+------+
| TOM  |
| xdd  |
| pmm  |
+------+
[root@mysql11 ~]#
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Disk space management & swap space | Cloud computing )

---

# 1 案例1：硬盘分区及格式化

## 1.1 问题

本例要求熟悉硬盘分区结构，使用fdisk分区工具在磁盘 /dev/sdb 上按以下要求建立分区：

1. 采用默认的 msdos 分区模式
2. 第1个分区 /dev/sdb1 的大小为 200MiB
3. 第2个分区 /dev/sdb2 的大小为 2000MiB
4. 第3个分区 /dev/sdb3 的大小为 1000MiB

完成分区后，能够配置开机自动挂载 /dev/sdb2 分区：

1. 文件系统类型为 EXT4
2. 将其挂载到 /mnt/part2 目录

## 1.2 方案

fdisk分区工具用来建立msdos分区方案，其交互模式中的主要指令如下：

- m：列出指令帮助
- p：查看当前的分区表信息
- n：新建分区
- d：删除分区
- q：放弃分区更改并退出
- w：保存对分区表所做的更改

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：新建分区表**

1）打开fdisk工具，操作磁盘/dev/sdb

```shell
[root@server0 ~]# fdisk  /dev/sdb
Welcome to fdisk (util-linux 2.23.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.
Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x9ac1bc10.
Command (m for help):                         //交互操作提示信息
```

2）新建第1个分区/dev/sdb1

```shell
Command (m for help): n                                  //新建分区
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p                                 //类型为p（主分区）
Partition number (1-4, default 1): 1                     //分区编号1
First sector (2048-20971519, default 2048):              //起始位置默认
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-20971519, default 20971519): +200M  
Partition 1 of type Linux and of size 200 MiB is set      //结束位置+200MiB大小
Command (m for help): p                                  //确认当前分区表
.. ..
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      411647      204800   83  Linux
```

3）新建第2个分区/dev/sdb2

```shell
Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p                                 //类型为p（主分区）
Partition number (2-4, default 2): 2                    //分区编号2
First sector (411648-20971519, default 411648):         //起始位置默认
Using default value 411648
Last sector, +sectors or +size{K,M,G} (411648-20971519, default 20971519): +2000M
Partition 2 of type Linux and of size 2 GiB is set       //结束位置+2000MiB大小
Command (m for help): p                                  //确认当前分区表
.. ..
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      411647      204800   83  Linux
/dev/sdb2          411648     4507647     2048000   83  Linux
```

4）新建第3个分区/dev/sdb3

```shell
Command (m for help): n     
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p): p
Partition number (3,4, default 3): 3
First sector (4507648-20971519, default 4507648): 
Using default value 4507648
Last sector, +sectors or +size{K,M,G} (4507648-20971519, default 20971519): +1000M
Partition 3 of type Linux and of size 1000 MiB is set
Command (m for help): p                                  //确认当前分区表
.. ..
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      411647      204800   83  Linux
/dev/sdb2          411648     4507647     2048000   83  Linux
/dev/sdb3         4507648     6555647     1024000   83  Linux
```

5）保存分区更改，退出fdisk分区工具

```shell
Command (m for help): w                                  //保存并退出
The partition table has been altered!
Calling ioctl() to re-read partition table.
Syncing disks.
```

6）刷新分区表

```shell
[root@server0 ~]# partprobe  /dev/vdb         //重新检测磁盘分区
//或者
[root@server0 ~]# reboot                     //对已使用中磁盘的分区调整，应该重启一次
.. ..
```

**步骤二：格式化及挂载分区**

1）将分区/dev/sdb2格式化为EXT4文件系统

```shell
[root@server0 ~]# mkfs.ext4  /dev/sdb2
.. .. 
Allocating group tables: done  
Writing inode tables: done 
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
```

2）配置开机自动挂载

```shell
[root@server0 ~]# vim  /etc/fstab
.. ..
/dev/sdb2       /mnt/part2      ext4    defaults        0 0
```

3）创建挂载点，并验证挂载配置

```shell
[root@server0 ~]# mkdir  /mnt/part2                 //创建挂载点
[root@server0 ~]# mount  -a                         //挂载fstab中的可用设备
[root@server0 ~]# df  -hT  /mnt/part2/                 //检查文档所在的文件系统及设备
Filesystem     Type  Size  Used Avail Use% Mounted on
/dev/sdb2      ext4  1.9G  5.9M  1.8G   1% /mnt/part2
```

# 2. 分区扩展Swap空间

## 2.1 问题

1. 从磁盘sdd上划分一个2G的分区sdd1
2. 将/dev/sdd1格式化为Swap文件系统
3. 启用/dev/sdd1分区，查看Swap空间大小
4. 停用/dev/sdd1分区，查看Swap空间大小

## 2.2 方案

首先要明白Swap分区空间是来源于硬盘，而要想扩充Swap空间的大小，思路很简单就是把硬盘的分区格式成Swap文件系统，再扩充到Swap空间中区。

对于Swap分区有它独立的格式化命令和扩充命令，这里要和普通分区的格式化命令和挂载命令区分开。此外它还有独立查看Swap空间组成的命令。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：从磁盘sdd上划分一个2G的分区sdd1**

命令操作如下所示：

```shell
[root@localhost ~]# fdisk /dev/sdd
欢迎使用 fdisk (util-linux 2.23.2)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
Device does not contain a recognized partition table
使用磁盘标识符 0x6faf1c3f 创建新的 DOS 磁盘标签。
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p):                  #回车
Using default response p
分区号 (1-4，默认 1)：        #回车
起始 扇区 (2048-41943039，默认为 2048)：     #回车
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-41943039，默认为 41943039)：+2G  
分区 1 已设置为 Linux 类型，大小设为 2 GiB
命令(输入 m 获取帮助)：p
磁盘 /dev/sdd：21.5 GB, 21474836480 字节，41943040 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x6faf1c3f
   设备 Boot      Start         End      Blocks   Id  System
/dev/sdd1            2048     4196351     2097152   83  Linux
命令(输入 m 获取帮助)：w
The partition table has been altered!
Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@localhost ~]#
```

**步骤二：将/dev/sdd1格式化为swap文件系统**

命令操作如下所示：

```shell
[root@localhost ~]# mkswap /dev/sdd1   //格式化为swap文件系统
Setting up swapspace version 1, size = 1951740 KiB
no label, UUID=848ca15c-a03e-4e0b-9ac0-bfd6507d0b7e
```

**步骤三：启用/dev/sdd1分区，查看swap空间大小**

命令操作如下所示：

```shell
[root@localhost ~]# swapon –s          //未启用之前，查看swap空间组成成员
Filename                                Type            Size    Used    Priority
/dev/sda5                               partition       8388600 0       -1
[root@localhost ~]# swapon /dev/sdd1  //启用/dev/sdd1交换分区
[root@localhost ~]# swapon –s          //启用之后，查看swap空间组成成员
Filename                                Type            Size    Used    Priority
/dev/sda5                               partition       8388600 0       -1
/dev/sdd1                               partition       1951736 0       -2
[root@localhost ~]#
```

**步骤四：停用/dev/sda8分区，查看swap空间大小**

命令操作如下所示：

```shell
[root@localhost ~]# swapoff /dev/sdd1   //停用/dev/sdd1交换分区
[root@localhost ~]# swapon -s
Filename                                Type            Size    Used    Priority
/dev/sda5                               partition       8388600 0       -1
[root@localhost ~]#
```

# 3. 文件扩展Swap空间

## 3.1 问题

1. 使用dd命令创建一个大小为2048MB的交换文件，放在/opt/swap.db
2. 将swap.db文件格式化成Swap文件系统
3. 启用swap.db文件，查看Swap空间大小
4. 停用swap.db文件，查看Swap空间大小

## 3.2 方案

Swap空间来源于硬盘空间，这个思路不变。我们可以换种方式，来扩展Swap空间。就是可以创建一个大的文件，文件占用的是磁盘空间，再将这个文件格式化使用。这个方式是可行的，但难点在于文件怎么生成呢？我们可以用dd这条命令。

例如 dd if=/dev/zero of=/opt/swap.db bs=1M count=2048 ，相关说明如下：

- dd：为命令字。
- if：读取数据的来源是哪，而/dev/zero是一个特殊的设备它可以产生无限的数据，常用来与dd命令搭配使用。
- of：将数据写入到哪里去，可以是其他设备，也可以是指定路径下的一个文件名。
- bs：每次读取和写入数据的大小为1M。
- count：为读取和写入的次数为2048次。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用dd命令创建一个大小为2048MB的交换文件，放在/opt/swap.db**

命令操作如下所示：

```shell
[root@localhost ~]# dd if=/dev/zero of=/opt/swap.db bs=1M count=2048
记录了2048+0 的读入
记录了2048+0 的写出
2147483648字节(2.1 GB)已复制，95.5419 秒，22.5 MB/秒
[root@localhost ~]# ls -lh /opt/swap.db 
-rw-r--r--. 1 root root 2.0G 2月  27 21:24 /opt/swap.db
```

**步骤二：将swap.db文件格式化成Swap文件系统**

命令操作如下所示：

```shell
[root@localhost ~]# mkswap /opt/swap.db       //将文件格式化为Swap文件系统
mkswap: /opt/swap.db: warning: don't erase bootbits sectors
        on whole disk. Use -f to force.
Setting up swapspace version 1, size = 2097148 KiB
no label, UUID=4dc743fd-86a6-477b-a3fc-a811f41dbd43
[root@localhost ~]#
```

**步骤三：启用swap.db文件，查看Swap空间大小**

命令操作如下所示：

```shell
[root@localhost ~]# swapon /opt/swap.db  //启用swap.db文件
[root@localhost ~]# swapon -s
Filename                                Type            Size    Used    Priority
/dev/sda5                               partition       8388600 0       -1
/opt/swap.db                            file            2097144 0       -2
[root@localhost ~]#
```

**步骤四：停用swap.db文件，查看Swap空间大小**

命令操作如下所示：

```shell
[root@localhost ~]# swapoff /opt/swap.db //停用swap.db文件
[root@localhost ~]# swapon -s
Filename                                Type            Size    Used    Priority
/dev/sda5                               partition       8388600 0       -1
[root@localhost ~]#
```

# Exercise

## 1 列出创建ext3、ext4、xfs、vfat文件系统的格式化工具及用法

mkfs.ext3 分区设备路径

mkfs.ext4 分区设备路径

mkfs.xfs 分区设备路径

mkfs.vfat 分区设备路径

## 2 简述/etc/fstab开机挂载配置记录的格式组成

设备路径  挂载点  类型  参数  备份标记  检测顺序

## 3 分区标识。

执行（ ）或（ ）可以查看系统中已挂载的分区设备信息。执行（ ）命令可以重新识别分区表信息，使用（ ）命令可以查看块设备的UUID标识符。


- df -h
- mount
- partprobe
- blkid


> 如有侵权，请联系作者删除



﻿@[TOC]( DNS service basics & special resolution & cache DNS & DNS master-slave architecture | Cloud computing )

---

# 1. 搭建单区域DNS服务器

## 1.1 问题

本例要求要求为DNS区域tedu.cn搭建一台DNS服务器，以便用户能通过域名的方式访问网站。测试阶段主要提供以下正向记录：

1. svr7.tedu.cn ---> 192.168.4.7
2. pc207.tedu.cn ---> 192.168.4.207
3. www.tedu.cn ---> 192.168.4.100
   配置完成后在客户机上验证查询结果。

## 1.2 方案

快速构建DNS服务器的基本过程：

1. 安装 bind、bind-chroot 包
2. 建立主配置文件 /etc/named.conf
3. 建立地址库文件 /var/named/.. ..
4. 启动 named 服务

配置及使用DNS客户端的基本过程：

1. 修改配置文件/etc/resolv.conf，添加nameserver=DNS服务器地址
2. 使用host命令查询，提供目标域名作为参数

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置DNS服务器svr7**

1）安装 bind、bind-chroot 包

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@svr7 ~]# yum  -y  install  bind  bind-chroot
.. ..
```

2）建立主配置文件 /etc/named.conf

```shell
[root@svr7 ~]# mv  /etc/named.conf  /etc/named.conf.origin          //备份默认配置
[root@svr7 ~]# vim  /etc/named.conf                             //建立新配置
options {
    directory  "/var/named";                          //地址库默认存放位置
};
zone  "tedu.cn" {                                  //定义正向DNS区域
    type  master;                                     //主区域
    file  "tedu.cn.zone";                             //自定义地址库文件名
};
```

3）建立地址库文件 /var/named/tedu.cn.zone

```shell
[root@svr7 ~]# cd  /var/named/                              //进地址库目录
[root@svr7 named]# cp  -p  named.localhost  tedu.cn.zone      //参考范本建地址库文件
[root@svr7 named]# vim  tedu.cn.zone                          //修订地址库记录
$TTL 1D                                          //文件开头部分可保持不改
@   IN SOA  @ rname.invalid. (
                    0   ; serial
                    1D  ; refresh
                    1H  ; retry
                    1W  ; expire
                    3H )    ; minimum
@       NS  svr7.tedu.cn.                          //本区域DNS服务器的FQDN
svr7    A   192.168.4.7                         //为NS主机提供A记录
pc207   A   192.168.4.207                         //其他正向地址记录.. ..
www  A   192.168.4.100
```

4）启动 named 服务，并设置开机自启

```shell
[root@svr7 named]# systemctl  restart  named  
[root@svr7 named]# systemctl  enable  named
Created symlink from /etc/systemd/system/multi-user.target.wants/named.service to /usr/lib/systemd/system/named.service.
```

**步骤二：配置DNS客户机pc207并测试**

1）修改配置文件/etc/resolv.conf，指定默认使用哪一台DNS服务器

```shell
[root@localhost ~]# setenforce 0
[root@localhost ~]# firewall-cmd --set-default-zone=trusted
[root@pc207 ~]# vim  /etc/resolv.conf 
nameserver  192.168.4.7
.. ..
```

2）使用host命令查询，提供目标域名作为参数

```shell
[root@pc207 ~]# host  svr7.tedu.cn
svr7.tedu.cn has address 192.168.4.7
[root@pc207 ~]# host  pc207.tedu.cn
pc207.tedu.cn has address 192.168.4.207
[root@pc207 ~]# host  www.tedu.cn
www.tedu.cn has address 192.168.4.100
```

使用host测试DNS查询结果时，如果不方便修改/etc/resolv.conf文件，也可以采用“host 目标域名 DNS服务器地址”形式临时指定使用哪一台DNS服务器。

```shell
[root@pc207 ~]# host  pc207.tedu.cn  192.168.4.7
Using domain server:
Name: 192.168.4.7
Address: 192.168.4.7#53
Aliases: 
pc207.tedu.cn has address 192.168.4.207
```

# 2. 特殊DNS解析

## 2.1 问题

沿用案例1，本例要求掌握DNS轮询、泛域名解析的配置，实现的目标如下：

1. 为站点 www.tedu.cn 提供DNS轮询解析，三台Web服务器节点的IP地址分别为：192.168.4.100、192.168.4.110、192.168.4.120
2. 配置泛域名解析实现以下解析记录：任意名称.tedu.cn ---> 119.75.217.56
3. 

## 2.2 方案

DNS轮询：FQDN ---> IP地址1、IP地址2、.. ..
泛域名解析（站点名不确定）：多个FQDN ---> 一个IP地址

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置DNS轮询**

1）修改DNS服务器上tedu.cn区域的地址库文件，在末尾添加轮询地址记录

```shell
[root@svr7 ~]# vim  /var/named/tedu.cn.zone 
.. ..
www        A    192.168.4.100
www        A    192.168.4.110
www        A    192.168.4.120
```

2）重启系统服务named

```shell
[root@svr7 named]# systemctl  restart  named
```

3）在客户机pc207上测试轮询记录

针对目标www.tedu.cn执行多次查询，观察第1条结果的变化：

```shell
[root@pc207 ~]# host  www.tedu.cn
www.tedu.cn has address 192.168.4.100          //第1个结果为192.168.4.100
www.tedu.cn has address 192.168.4.110
www.tedu.cn has address 192.168.4.120
[root@pc207 ~]# host  www.tedu.cn
www.tedu.cn has address 192.168.4.120          //第1个结果为192.168.4.120
www.tedu.cn has address 192.168.4.110
www.tedu.cn has address 192.168.4.100
[root@pc207 ~]# host  www.tedu.cn
www.tedu.cn has address 192.168.4.110          //第1个结果为192.168.4.110
www.tedu.cn has address 192.168.4.120
www.tedu.cn has address 192.168.4.100
```

步骤二：配置多对一的泛域名解析

1）修改DNS服务器上指定区域的地址库文件，在末尾添加*通配地址记录

```shell
[root@svr7 ~]# vim  /var/named/tedu.cn.zone 
.. ..
*       A   119.75.217.56
```

2）重启系统服务named

```shell
[root@svr7 named]# systemctl  restart  named
```

3）在客户机pc207上测试多对一的泛域名解析记录

当查询未知站点（地址库中没有明确记录）时，以 * 对应的IP地址反馈：

```shell
[root@pc207 ~]# host  station123.tedu.cn
station123.tedu.cn has address 119.75.217.56
[root@pc207 ~]# host  movie.tedu.cn
movie.tedu.cn has address 119.75.217.56
[root@pc207 ~]# host  tts8.tedu.cn
tts8.tedu.cn has address 119.75.217.56
```

# 3. 搭建并测试缓存DNS

## 3.1 问题

本例要求熟悉缓存DNS的工作过程，准备一台可上网的RHEL7虚拟机，并完成下列任务：

1. 安装 bind、bind-chroot 包
2. 搭建并测试基于全局转发器的缓存DNS

## 3.2 方案

权威/官方DNS服务器的特点：

- 至少管理一个DNS区域,，需要IANA等官方机构授权
- 典型应用：根域DNS、一级域DNS、二级域DNS、三级域DNS、.. ..

缓存DNS服务器的特点：

- 不需要管理任何DNS区域，但是能够替客户机查询，而且通过缓存、复用查询结果来加快响应速度
- 典型应用：ISP服务商、企业局域网

缓存DNS服务器的解析记录来源：

- 方式1：全局转发：将请求转发给指定的公共DNS（其他缓存DNS），请求递归服务
- 方式2：根域迭代：依次向根、一级、二级……域的DNS服务器迭代

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为虚拟机pc207提供上网条件**

1）为虚拟机添加一块新的网卡，选择NAT或Bridge模式

若选择NAT模式（地址转换），则新加网卡的上网参数由虚拟化平台自动设置。

若选择Bridge模式（桥接），则新加网卡的上网参数需要参考真实网络的主机，必要时请网络管理员提供支持。

此处所列地址信息可帮助大家理解上网条件，但不作为练习的配置依据：

```shell
[root@pc207 ~]# ifconfig  eth1                      //检查新增网卡的IP地址
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.70.129  netmask 255.255.255.0  broadcast 192.168.70.255
.. ..
[root@pc207 ~]# route  -n                          //确认已配好默认网关
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.70.2    0.0.0.0         UG    100    0        0 eth1
192.168.70.0    0.0.0.0         255.255.255.0   U     100    0        0 eth1
.. ..
[root@pc207 ~]# cat  /etc/resolv.conf              //确认第一DNS为外部可用DNS地址
nameserver 192.168.70.2
.. ..
```

2）确保从主机pc207可访问到外部DNS

访问默认DNS可用（本机正常连网需要）：

```shell
[root@pc207 ~]# host  www.qq.com
www.qq.com has address 111.30.132.101
www.qq.com has IPv6 address 240e:e1:8100:28::2:16
```

访问指定DNS可用（全局转发的前提条件）：

```shell
[root@pc207 ~]# host  www.qq.com  202.106.0.20      //国内公共DNS服务器之一
Using domain server:
Name: 202.106.0.20
Address: 202.106.0.20#53
Aliases: 
www.qq.com has address 111.30.132.101
www.qq.com is an alias for qq.com.edgesuite.net.
qq.com.edgesuite.net is an alias for a1574.b.akamai.net.
www.qq.com is an alias for qq.com.edgesuite.net.
qq.com.edgesuite.net is an alias for a1574.b.akamai.net.
```

**步骤二：将pc207配置为缓存DNS（全局转发式）**

1）安装bind、bind-chroot软件包

```shell
[root@pc207 ~]# yum  -y  install  bind  bind-chroot
.. ..
```

2）建立主配置文件/etc/named.conf

当收到来自客户机的DNS查询请求时，转发到外网的其他DNS服务器

```shell
[root@pc207 ~]# vim  /etc/named.conf
options {
    forwarders  { 202.106.0.20; };
};
```

3）启动系统服务named，并设置开机自启

```shell
[root@pc207 ~]# systemctl  restart  named
[root@pc207 ~]# systemctl  enable  named
```

4）可向缓存DNS服务器pc207查询到公共域名（百度、网易等站点）

```shell
[root@pc207 ~]# host  www.baidu.com  192.168.4.207           //查百度的站点IP
Using domain server:
Name: 192.168.4.207
Address: 192.168.4.207#53
Aliases: 
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 111.13.100.92
www.a.shifen.com has address 111.13.100.91
[root@pc207 ~]# host  www.163.com  192.168.4.207                //查网易的站点IP
Using domain server:
Name: 192.168.4.207
Address: 192.168.4.207#53
Aliases: 
www.163.com is an alias for www.163.com.lxdns.com.
www.163.com.lxdns.com is an alias for 163.xdwscache.ourglb0.com.
163.xdwscache.ourglb0.com has address 111.11.31.104
163.xdwscache.ourglb0.com has address 111.11.31.114
```

# 4. 构建主/从DNS服务器

## 4.1 问题

准备2台虚拟机，配置实现DNS主/从结构，相关要求如下：

- 主DNS的域名为svr7.tedu.cn，IP地址为192.168.4.7/24
- 从DNS的域名为pc207.tedu.cn，IP地址为192.168.4.207
- 主、从均能够解析tts7.tedu.cn --> 118.45.29.31
- 当主DNS的tts7.tedu.cn记录的IP地址变更为4.4.4.4以后，从DNS能够自动同步此更改

## 4.2 方案

使用2台虚拟机，其中一台作为主DNS服务器（192.168.4.7）、另外一台作为从DNS服务器（192.168.4.207）；同时，这两台虚拟机中的任何一台都可以作为测试用的Linux客户机。

主DNS的配置关键——修改named.conf配置文件，为从DNS设置授权：

```shell
options {
        .. ..
        allow-transfer {
                从DNS服务器的IP地址;
        }; 
};
```

从DNS的配置关键——无需手动建立解析记录，只需修改named.conf配置文件：

```shell
zone "tedu.cn" IN {
        type slave;                                  //类型为slave
        file "slaves/tedu.cn.zone";                //下载存放位置
        masters { 主DNS服务器的IP地址; }; 
}; 
```

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：主DNS授权从DNS服务器，允许其下载地址记录**

1）修改named.conf配置文件，授权从DNS服务器，允许其下载地址记录

```shell
[root@svr7 ~]# vim /etc/named.conf
options  {
        directory  "/var/named";
        allow-transfer { 192.168.4.207;  };           //授权从DNS服务器
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
.. ..
```

2）修改区域记录文件，为从DNS添加NS记录，并设置测试A记录

```shell
[root@svr7 ~]# vim /var/named/tedu.cn.zone 
$TTL   86400
@   IN   SOA   @    root.tedu.cn.  (
    2015052201                                          ;更新序列号
    4H                                                  ;刷新时间
    15M                                                 ;重试间隔
    4H                                                  ;超时时间
    1D                                                  ;无效记录的生存时间
)
@       IN      NS      svr7.tedu.cn.                  //指定主DNS记录
@       IN      NS      pc207.tedu.cn.                //指定从DNS记录
svr7    IN      A       192.168.4.7                  //主DNS的A记录
pc207   IN      A       192.168.4.207                    //从DNS的 A记录
tts7    IN      A       118.45.29.31                     //tts7.tedu.cn解析记录
.. ..                                            //其他A记录
```

3）重新加载named服务

```shell
[root@svr7 ~]# service named restart  
停止 named：.                                              [确定]
启动 named：                                               [确定]
```

**步骤二：建立从DNS服务器**

1）使用yum安装DNS服务相关软件包

```shell
[root@pc207 ~]# yum -y install bind bind-chroot
.. ..
[root@pc207 ~]# rpm -q bind bind-chroot
.. ..
```

2）建立/etc/named.conf配置文件

```shell
[root@svr7 ~]# mv  /etc/named.conf  /etc/named.conf.bak      //备份默认配置
[root@svr7 ~]# vim  /etc/named.conf              //建立新配置
options {
        directory "/var/named";
};
zone "tedu.cn" IN {                            //同步区域
        type slave;                                  //类型为从区域
        file "slaves/tedu.cn.zone";              //区域文件存储位置
        masters { 192.168.4.7; };                   //指定主DNS的IP地址
};
```

3）重新加载named服务

```shell
[root@svr7 ~]# service named restart  
停止 named：.                                              [确定]
启动 named：                                               [确定]
```

确认区域配置文件已经自动下载，即同步成功：

```shell
[root@pc207 ~]# ls /var/named/slaves/
tedu.cn.zone
```

**步骤三：客户机查询测试**

1）向主DNS查询域名tts7.tedu.cn，反馈结果应为118.45.29.31

```shell
[root@pc207 ~]# nslookup  tts7.tedu.cn  192.168.4.7
Server:        192.168.4.7
Address:    192.168.4.7#53
Name:   tts7.tedu.cn
Address:   118.45.29.31
```

2）向从DNS查询域名tts7.tedu.cn，也能获得结果为118.45.29.31

```shell
[root@pc207 ~]# nslookup  tts7.tedu.cn  192.168.4.207
Server:        192.168.4.207
Address:    192.168.4.207#53
Name:   tts7.tedu.cn
Address:   118.45.29.31
```

3）测试解析记录的同步

在主DNS上修改A记录tts7.tedu.cn，将IP地址改为4.4.4.4，同时将序列号+1更新，保存并启用新配置：

```shell
[root@svr7 ~]# vim /var/named/tedu.cn.zone
$TTL   86400
@   IN   SOA   @    root.tedu.cn.  (
    2015052202                                    //修改记录后，此序号应变更
    .. ..
)
.. ..
tts7    IN      A       4.4.4.4                     //修改tts7解析记录
[root@svr7 ~]# service named restart              //重启named服务
停止 named：                                               [确定]
启动 named：                                               [确定]
```

然后在客户端重复测试第1）和2）步骤，反馈的解析结果都应该是4.4.4.4：

```shell
[root@pc207 ~]# nslookup  tts7.tedu.cn  192.168.4.7
Server:        192.168.4.7
Address:    192.168.4.7#53
Name:   tts7.tedu.cn
Address:  4.4.4.4                              //向主DNS查询的结果
[root@pc207 ~]# nslookup  tts7.tedu.cn  192.168.4.207
Server:        192.168.4.207
Address:    192.168.4.207#53
Name:   tts7.tedu.cn                         //向从DNS查询的结果
Address:   4.4.4.4
```

# Exercise

## 1 简述DNS地址记录中类型NS、A的含义

NS记录为域名服务器记录（本域权威DNS的FQDN）；

A记录为正向解析记录（FQDN --> IP地址）。

## 2 对于DNS服务器来说，递归查询和迭代查询分别表示什么

对于一台DNS服务器来说：

若允许递归，则当客户端请求解析的域名非本DNS管辖时，本DNS会向其他DNS服务器代询；

若不允许递归，则当客户端请求解析的域名非本DNS管辖时，本DNS会放弃代询 —— 但是，如果目标地址位于已知的某个授权子域，本DNS会告知客户端对应的子DNS服务器的地址信息（即迭代）。

## 3 DNS正向解析的作用是( )

A. 将IP地址转换为域名

B. 将域名转换为IP地址

C. 将IP地址转换为主机名

D. 将主机名转化为IP地址

正确答案：B。

## 4 DNS常见的资源类型

> 配置DNS区域的解析记录时，常见的资源类型如下，请写出各自的作用：
>
> - A记录
> - MX记录
> - CNAME记录
> - NS记录

A记录为正向解析记录，MX记录为邮件服务器记录，CNAME记录为别名记录，NS记录为域名服务器记录

> 如有侵权，请联系作者删除



﻿@[TOC]( File object & function foundation & module foundation | Cloud computing )

---

# 1. 模拟cp操作

## 1.1 问题

创建cp.py文件，实现以下目标：

1. 将/bin/ls“拷贝”到/root/目录下
2. 不要修改原始文件

## 1.2 方案

获取用户原文件名和新文件名，打开原文件，打开新文件，从打开的原文件中读取数据，写入到打开的新文件中，关闭两个文件

cp代码的过程中，需要注意的部分在于：

如果一个文件过大，你将无法直接读取数据到内存，此时，使用while循环语句，分次读取数据，每次读4096字节，读取数据为空时，结束循环，将数据写入到目标文件

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
 [root@localhost day03]# vim cp.py 
#!/usr/bin/env python3
f1 = open('/bin/ls', 'rb')
f2 = open('/root/ls', 'wb')
data = f1.read()
f2.write(data)
f1.close()
f2.close()
```

或将上面的代码改为以下写法：

循环读取文件中数据，避免读取数据过大

```shell
[root@localhost day03]# vim cp2.py 
#!/usr/bin/env python3
src_fname = '/bin/ls'
dst_fname = '/tmp/ls'
src_fobj = open(src_fname, 'rb')
dst_fobj = open(dst_fname, 'wb')
while True:
    data = src_fobj.read(4096)   # 每次读4096字节
    if data == b'':              # 读不到数据意味着读写完毕，中断循环
        break
    dst_fobj.write(data)         # 将数据写到目标文件
src_fobj.close()
dst_fobj.close()
```

或将上面的代码改为以下写法：

With打开文件读取数据或写入数据后，文件会直接关闭

```shell
[root@localhost day03]# vim cp3.py 
#!/usr/bin/env python3
src_fname = '/bin/ls'
dst_fname = '/root/ls'
with open(src_fname, 'rb') as src_fobj:
    with open(dst_fname, 'wb') as dst_fobj:
        while True:
            data = src_fobj.read(4096)
            if not data:
                break
            dst_fobj.write(data)
```

或将上面的代码改为以下写法：

sys.argv方法表示空列表，执行脚本时输入命令： python3 cp_func.py /bin/ls /root/ls，表示sys.argv=[cp_func.py，‘/bin/ls’，‘/root/ls’]，所以，调用copy函数时，列表切片方式获取实参为（‘/bin/ls’，‘/root/ls’）

```shell
[root@localhost day03]# vim cp_func.py 
#!/usr/bin/env python3
import sys
def copy(src_fname, dst_fname):
    src_fobj = open(src_fname, 'rb')
    dst_fobj = open(dst_fname, 'wb')
    while True:
        data = src_fobj.read(4096)
        if not data:
            break
        dst_fobj.write(data)
    src_fobj.close()
    dst_fobj.close()
copy(sys.argv[1], sys.argv[2])
```

**步骤二：测试脚本执行**

```shell
[root@localhost day03]# python3 cp.py
[root@localhost day03]# cd /root
[root@localhost ~]# ls
core  ls
[root@localhost day03]# python3 cp2.py
[root@localhost day03]# cd /root
[root@localhost ~]# ls
core  ls
[root@localhost day03]# python3 cp3.py
[root@localhost day03]# cd /root
[root@localhost ~]# ls
core  ls
[root@localhost day03]# python3 cp_func.py /bin/ls /root/ls
[root@localhost day03]# cd /root
[root@localhost ~]# ls
core  ls
```

# 2. 生成随机密码

## 2.1 问题

创建randpass.py脚本，要求如下：

1. 编写一个能生成8位随机密码的程序
2. 使用random的choice函数随机取出字符
3. 改进程序，用户可以自己决定生成多少位的密码

## 2.2 方案

导入random模块，通过random静态对象调用choice()方法，从自定义字符串all_chs中获取随机项，将获取到的随机字符ch与原result值进行拼接，将最终字符串结果返回给函数，for循环每循环一次获取一个随机字符，密码位数由循环次数决定，循环次数由传递参数值决定。

此程序需要注意的部分在于：

1. 导入String模块，其中ascii_letters是生成所有字母，从a-z和A-Z，digits是生成所有数字0-9
2. 将整个生成随机密码的代码封装进gen_pass()函数中，当模块文件直接执行时，调用函数即可输出结果
3. 参数传递问题：调用函数无实参时，函数调用默认参数，有实参时，函数调用实际参数

# 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day03]# vim randpass.py
#!/usr/bin/env python3
import random
import string
all_chs = string.digits + string.ascii_letters
def gen_pass(n=8):
    result = ''
    for i in range(n):
        ch = random.choice(all_chs)
        result += ch
    return result
if __name__ == '__main__':
    print(gen_pass())
    print(gen_pass(4))  
```

或将上面的代码改为以下写法：

利用列表推导式更简洁输出数据

```shell
[root@localhost day03]# vim randpass2.py
#!/usr/bin/env python3
from random import choice
from string import ascii_letters, digits
all_chs = ascii_letters + digits
def randpass(n=8):
    result = [choice(all_chs) for i in range(n)]
    return ''.join(result)  # 将列表的字符拼接起来
if __name__ == '__main__':
    print(randpass())
    print(randpass(4))
```

**步骤二：测试脚本执行**

```shell
[root@localhost day03]# python3 randpass.py
82wi2gOP
XzMi
[root@localhost day03]# python3 randpass.py
5wMoDEgC
BDpc
[root@localhost day03]# python3 randpass.py
Ige2VGod
Az0z
[root@localhost day03]# python3 randpass2.py 
eajAocMH
edW1
```

# Exercise

## 1 读取一个文本文件的内容，有哪些方法？

- read()：读取指定数目的字节
- readline()：读取一行
- readlines()：读取全部内容，生成一个字符串列表，文件的每一行是列表中的每一项
- 通过for循环进行遍历

## 2 打开文件时，文件对象的访问模式有r、w和a。它们的区别是什么？

- r：以读方式打开（文件不存在则报错）
- w：以写方式打开（文件存在则清空，不存在则创建）
- a：以追加模式打开（必要时创建新文件）

## 3 有一个名为fobj的文件对象，fobj.seek(0, 2)表示什么？

- 表示将文件指针移动到文件的结尾

## 4 函数默认的返回值是什么？如何自己手工指定返回值，使用哪个关键字？

- 函数返回值默认是None
- 通过return关键字返回指定的结果。

## 5 python中如何使用位置参数？

- python将位置参数放到sys模块的argv列表中了
- sys.argv列表中的第一个元素是python脚本本身
- sys.argv列表中的其他元素是命令行上其他的命令行参数，对应shell脚本的$1、$2等

> 如有侵权，请联系作者删除



﻿@[TOC]( Function foundation & function advanced application & module | Cloud computing )

---

# 1. 简单的加减法数学游戏

## 1.1 问题

编写math_game.py脚本，实现以下目标：

1. 随机生成两个100以内的数字
2. 随机选择加法或是减法
3. 总是使用大的数字减去小的数字
4. 如果用户答错三次，程序给出正确答案

## 1.2 方案

创建4个函数，分别实现返回两数之和、返回两数之差、判断表达式正确性、是否继续计算四种方法：

1. 首先调用main()函数（是否继续计算功能），main函数利用循环无限次调用exam()函数进行计算，计算结束，用户选择是否继续（此过程利用try语句捕获索引错误、ctrl+c（中断）错误、ctrl+d错误），如果选择n即结束循环，不再调用exam()函数，否则循环继续

2. 调用exam()函数：

a) 输出运算公式：利用列表切片将随机生成的两个数打印（这两个数利用random模块及列表生成式随机生成，并利用sort()方法进行降序排序，确保相减时一直是大的数字减小的数字），利用random模块随机生成“+”“-”号，输出在两数之间

b) 用户输入值，利用for循环进行三次判断，如果运算公式结果与用户输入值相同，循环结束，系统输出“你赢了”，exam()函数执行结束，否则系统输出“你答错了”，循环继续，3次都回答错误，利用循环的else分支输出运算公式及结果

c) 上诉运算公式结果：利用random模块随机生成“+”“-”值对关系调用（其中“+”“-”号作为字典键，返回和函数add()及返回差函数sub()作为值，调用时将随机生成的两个数字作为参数传递给add()函数及sub()函数）

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shelll
[root@localhost day06]# vim math_game.py
#!/usr/bin/env python3
import random
def add(x, y):
    return x + y
def sub(x, y):
    return x - y
def exam():
    cmds = {'+': add, '-': sub}  # 将函数存入字典
    nums = [random.randint(1, 100) for i in range(2)] # 生成两个数
    nums.sort(reverse=True)  # 降序排列
    op = random.choice('+-')
    result = cmds[op](*nums)  # 调用存入字典的函数，把nums列表拆开，作为参数传入
    prompt = "%s %s %s = " % (nums[0], op, nums[1])
    for i in range(3):
        try:
            answer = int(input(prompt))
        except:
            continue
        if answer == result:
            print('你真棒，答对了！')
            break  # 答对了就不要再回答了，结束循环
        else:
            print('答错了')
    else:
        print("%s%s" % (prompt, result))   # 只有循环不被break才执行
def main():
    while True:
        exam()
        try:
            go_on = input('Continue(y/n)? ').strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt, EOFError):
            go_on = 'n'
        if go_on in 'nN':
            print('\nBye-bye.')
            break
if __name__ == '__main__':
    main()
```

实现此案例还可利用while循环：

```shelll
[root@localhost day06]# vim mygui.py
#!/usr/bin/env python3
import random
def add(x, y):
    return x + y
def sub(x, y):
    return x - y
def exam():
    cmds = {'+': add, '-': sub}  # 将函数存入字典
    nums = [random.randint(1, 100) for i in range(2)] # 生成两个数
    nums.sort(reverse=True)  # 降序排列
    op = random.choice('+-')
    result = cmds[op](*nums)  # 调用存入字典的函数，把nums列表拆开，作为参数传入
    prompt = "%s %s %s = " % (nums[0], op, nums[1])
    tries = 0
    while tries < 3:
        try:
            answer = int(input(prompt))
        except:
            continue
        if answer == result:
            print('你真棒，答对了！')
            break  # 答对了就不要再回答了，结束循环
        else:
            print('答错了')
            tries += 1
    else:
        print("%s%s" % (prompt, result))   # 只有循环不被break才执行
def main():
    while True:
        exam()
        try:
            go_on = input('Continue(y/n)? ').strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt, EOFError):
            go_on = 'n'
        if go_on in 'nN':
            print('\nBye-bye.')
            break
if __name__ == '__main__':
    main()
```

**步骤二：测试脚本执行**

```shelll
[root@localhost day06]# python3 math_game.py 
54 + 19 = 
54 + 19 = 
54 + 19 = 73
你真棒，答对了！
Continue(y/n)? y
60 + 39 = 99
你真棒，答对了！
Continue(y/n)? y
18 + 15 = 33
你真棒，答对了！
Continue(y/n)? y
35 + 20 = 55
你真棒，答对了！
Continue(y/n)? y
37 + 35 = 72
你真棒，答对了！
Continue(y/n)? y
77 - 57 = 20
你真棒，答对了！
Continue(y/n)? y
35 + 23 = 5
答错了
35 + 23 = 6
答错了
35 + 23 = 7
答错了
35 + 23 = 58
Continue(y/n)? y
75 + 47 = 122
你真棒，答对了！
Continue(y/n)? ^C
Bye-bye.
```

# 2. 进制转换函数

## 2.1 问题

创建myint.py脚本，要求如下：

1. 基于int内建函数，创建int2函数，实现2进制字符串转换成10制数整数
2. 基于int内建函数，创建int8函数，实现8进制字符串转换成10制数整数
3. 基于int内建函数，创建int16函数，实现16进制字符串转换成10制数整数

## 2.2 方案

1. 导入functools模块

2. 修改现有的int函数，将base参数固定值

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shelll
[root@localhost day06]# vim myint.py
# 改造int函数，将base=2固定下来，生成的新函数叫int2
int2 = partial(int, base=2)
print(int2('10101100'))
int8 = partial(int, base=8)
print(int8('11'))
int16 = partial(int, base=16)
print(int16('11'))
```

步骤二：测试脚本执行，结果如图-1、图-2、图-3所示：

```shelll
[root@localhost day06]# python3 myint.py
172
9
17
```

# 3. 备份程序

## 3.1 问题

编写backup.py脚本，实现以下目标：

1. 需要支持完全和增量备份
2. 周一执行完全备份
3. 其他时间执行增量备份
4. 备份文件需要打包为tar文件并使用gzip格式压缩

## 3.2 方案

整体框架创建3个函数，分别实现完全备份、增量备份、文件加密3种功能：

1. 首先导入time模块，利用if进行判断，如果当地时间是星期一，执行完全备份函数，否则执行增量备份函数，其中，通配符%a代表时间星期几缩写，上传参数分别为要备份的原目录、目标目录、md5字典存放目录

2. 调用完全备份函数：

a) 首先获取新文件名，将新文件名放入目标目录下，目的是定义备份文件的绝对路径，以写压缩方式打开目标目录下新文件，将原目录写入新文件中，完成完全备份，其中os.path.join作用是将目录名和文件的基名拼接成一个完整的路径

b) 了解os.walk()目录遍历器输出文件结构，利用for循环将要备份原目录中文件遍历出来作为字典键值对键， md5加密结果作为字典键值对的值（此时将原目录中文件作为上传参数调用文件加密函数），存入空字典中，字典中每个文件对应一个md5值，最后将字典写入到md5字典存放目录中

3. 调用文件加密函数：将原目录文件循环读取逐一加密，返回加密结果

4. 调用增量备份函数：

a) 增量备份函数代码与完全备份函数基本一致

b) 区别在于，备份前要先以二进制读方式打开md5字典存放目录，读取旧数据，判断旧数据中键对应的加密值与新加密值是否相同，如果不相同，则将新增内容写入到目标文件中（即只备份新数据）

5. 注意：md5主要用于原文件与新文件判断

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shelll
[root@localhost day06]# vim backup.py
#!/usr/bin/env python3
import time
import os
import tarfile
import hashlib
import pickle
#用于判断两个文件是否相同，提取每个文件中的前4字节的内容然后输出md5码进行比较
def check_md5(fname):
    m = hashlib.md5()
    with open(fname, 'rb') as fobj:
        while True:
            data = fobj.read(4096)
            if not data:
                break
            m.update(data)
    return m.hexdigest()
def full_backup(src_dir, dst_dir, md5file):
    fname = os.path.basename(src_dir.rstrip('/'))
    fname = '%s_full_%s.tar.gz' % (fname, time.strftime('%Y%m%d'))
    fname = os.path.join(dst_dir, fname)
    md5dict = {}
    tar = tarfile.open(fname, 'w:gz')
    tar.add(src_dir)
    tar.close()
    for path, folders, files in os.walk(src_dir):
        for each_file in files:
            key = os.path.join(path, each_file)
            md5dict[key] = check_md5(key)
    with open(md5file, 'wb') as fobj:
        pickle.dump(md5dict, fobj)
def incr_backup(src_dir, dst_dir, md5file):
    fname = os.path.basename(src_dir.rstrip('/'))
    fname = '%s_incr_%s.tar.gz' % (fname, time.strftime('%Y%m%d'))
    fname = os.path.join(dst_dir, fname)
    md5dict = {}
    with open(md5file, 'rb') as fobj:
        oldmd5 = pickle.load(fobj)
    for path, folders, files in os.walk(src_dir):
        for each_file in files:
            key = os.path.join(path, each_file)
            md5dict[key] = check_md5(key)
    with open(md5file, 'wb') as fobj:
        pickle.dump(md5dict, fobj)
    tar = tarfile.open(fname, 'w:gz')
    for key in md5dict:
        if oldmd5.get(key) != md5dict[key]:
            tar.add(key) 
    tar.close()
if __name__ == '__main__':
    # mkdir /tmp/demo; cp -r /etc/security /tmp/demo
    src_dir = '/tmp/demo/security'
    dst_dir = '/var/tmp/backup'   # mkdir /var/tmp/backup
    md5file = '/var/tmp/backup/md5.data'
    if time.strftime('%a') == 'Mon':
        full_backup(src_dir, dst_dir, md5file)
    else:
        incr_backup(src_dir, dst_dir, md5file)
```

**步骤二：测试脚本执行**

```shelll
[root@localhost day07]# python3 backup.py 
[root@localhost day07]# cd /var/tmp/backup/
[root@localhost backup]# ls
md5.data  security_full_20180502.tar.gz  security_incr_20180502.tar.gz
```

# Exercise

## 1 以下函数定义是否正确？为什么？

> ```shelll
> def myfunc(age=22, name):
> pass
> ```

- 不正确。因为函数的参数的一个要求是非关键字参数必须在关键字参数前面。

## 2 编写函数时，如果函数的参数个数不固定，可能有N个也可能一个没有，该如何解决？

- 使用参数组，如：
- *arg：表示将非关键字参数保存到名为arg的元组中
- **kwarg：表示将关键字参数保存到名为kwarg的字典中

## 3 请将以下函数改为匿名函数。

> ```shelll
> def add(x, y):
>  return x + y
> ```

```shelll
add = lambda x, y: x + y
```

## 4 请通过map()函数简化以下代码。

> ```shelll
> time_str = '2019-12-1'
> time_str = time_str.split('-')
> year = int(time_str[0])
> month = int(time_str[1])
> date = int(time_str[2])
> ```

```shelll
year, month, date = map(int, time_str.split('-'))
```

## 5 分析以下代码。请问变量x的值是什么？为什么？

> ```shelll
> x = 10
> def change_x():
>  global x
>  x = 'hello'
> print(x)
> ```

- x的值是10。因为change_x函数没有调用。

## 6 使用递归函数，计算6的阶乘。

```shelll
def fac(n):
    if n == 1:
        return 1
    return n * fac(n - 1)
if __name__ == '__main__':
    print(fac(6))
```

## 7 Python的模块命名有哪些约定？

- 首字符可以是字母或下划线
- 后续字符可以是字母、数字或下划线
- 区分大小写

## 8 python文件和模块的关系是什么？

- 文件是物理上组织的代码的形式，模块是逻辑上组织代码的形式
- 将文件的扩展名.py移除就是模块名

## 9 在导入模块时，python到哪些路径查找模块文件。

- sys.path所定义的路径
- PYTHONPATH环境变量所定义的路径

> 如有侵权，请联系作者删除



﻿@[TOC]( Huawei cloud management & cloud host management & cloud project combat | Cloud computing )

---

# 1 案例1：创建虚拟私有云

## 1.1 问题

本案例要求：

- 创建虚拟私有云

## 1.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：创建虚拟私有云，如图-1

![img](https://img-blog.csdnimg.cn/img_convert/1c68fd33ae091dace0ec324574d89008.png)
图-1

选择区域，名称等，如图-2：

![img](https://img-blog.csdnimg.cn/img_convert/ea635ad8656c508020948bc706ad8705.png)
图-2



# 2 案例2：购买云主机

## 2.1 问题

本案例要求在华为云上购买 2 台云主机实现如下操作：

- 云主机 ecs-proxy（登录方式，密码）
- 云主机 ecs-host （登录方式，密钥）

## 2.2 步骤

实现此案例需要按照如下步骤进行。

选择弹性云服务器ECS，如图-3

![img](https://img-blog.csdnimg.cn/img_convert/002c7e63b65136f05f0a262d24d7e812.png)
图-3

选择按需购买ECS，选择型号和系统后，查看价格，如图-4

![img](https://img-blog.csdnimg.cn/img_convert/7a3a8e525beb7c1eba3ad445e614a2c6.png)
![img](https://img-blog.csdnimg.cn/img_convert/12c2274b6b3cbf7a99acaf20f9c5c2a0.png)
图-4

网络配置，如图-5

![img](https://img-blog.csdnimg.cn/img_convert/9b0d2ea4ef9a56d03df262bc40eaea83.png)
图-5

设置密码，如图-6

![img](https://img-blog.csdnimg.cn/img_convert/dec1cd2f6fafdc12c4b4117bba37b900.png)
图-6

使用云主机，如图-7

![img](https://img-blog.csdnimg.cn/img_convert/f9d6921348052ee3e3c377ffdd4e9945.png)
![img](https://img-blog.csdnimg.cn/img_convert/6def085eded9c4f85e3d69fbcc6fb7c2.png)
图-7



# 3 案例3：弹性公网IP与安全组配置

## 3.1 问题

本案例要求购买弹性公网 IP 和带宽：

- 在云主机上配置华为云私网YUM源
- 安装软件测试bash-completion
- 让云主机可以访问互联网
- 配置安全组
- 允许互联网用户访问云主机服务

## 3.2 步骤

实现此案例需要按照如下步骤进行。

如何使用 华为云私网Yum源？

在文档中心搜索 "华为云 yum 源"

https://support.huaweicloud.com/ecs_faq/ecs_faq_1003.html

在云主机上配置华为云 Yum 源 (2台)

配置以后使用 yum repolist 查看

安装 bash-completion 进行测试

配置yum源，并测试

```shell
[root@localhost ~]# rm -rf /etc/yum.repos.d/*.repo
[root@localhost ~]# curl -o \ 
/etc/yum.repos.d/CentOS-Base.repo \ http://mirrors.myhuaweicloud.com/repo/CentOS-Base-7.repo
[root@localhost ~]# yum install –y bash-completion
```

购买弹性公网IP，如图-8和图-9所示。

![img](https://img-blog.csdnimg.cn/img_convert/38479cac7381d94de4706b05f328b3cb.png)
图-8

![img](https://img-blog.csdnimg.cn/img_convert/692853f297e8a2128928c992263e2ac5.png)
图-9

绑定公网IP，如图-10所示。

![img](https://img-blog.csdnimg.cn/img_convert/2f05ca5f5b4c1d75090a904503a82e9d.png)
图-10

设置安全组，如图-11、图-12、图-13所示。

![img](https://img-blog.csdnimg.cn/img_convert/770cd26446a0ccde5a001b5724ca276a.png)
图-11

![img](https://img-blog.csdnimg.cn/img_convert/ca9730ebe80d38fed30ab3d7073be447.png)
图-12

![img](https://img-blog.csdnimg.cn/img_convert/f04d059cb4ac3ec642bc15e396746382.png)
图-13

连接公网IP，如图-14。

![img](https://img-blog.csdnimg.cn/img_convert/6ad917646b7212c16b333d7ffc5f7fa5.png)
图-14



# 4 案例4：创建模板机和跳板机

## 4.1 问题

本案例要求创建模板机和跳板机：

- ecs-proxy 跳板机
- ecs-host 模板

## 4.2 步骤

实现此案例需要按照如下步骤进行。

```shell
# 配置yum源
[root@ecs-proxy ~]# rm -rf /etc/yum.repos.d/*.repo
[root@ecs-proxy ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.myhuaweicloud.com/repo/CentOS-Base-7.repo
[root@ecs-proxy ~]# yum clean all
[root@ecs-proxy ~]# yum makecache
[root@ecs-proxy ~]# yum install -y net-tools lftp rsync psmisc vim-enhanced tree vsftpd  bash-completion createrepo lrzsz iproute
[root@ecs-proxy ~]# mkdir /var/ftp/localrepo
[root@ecs-proxy ~]# cd /var/ftp/localrepo
[root@ecs-proxy ~]# createrepo  .
[root@ecs-proxy ~]# createrepo --update . # 更新
[root@ecs-proxy ~]# systemctl enable --now vsftpd
# 优化系统服务
[root@ecs-proxy ~]# systemctl stop postfix atd tuned
[root@ecs-proxy ~]# yum remove -y postfix at audit tuned kexec-tools firewalld-*
[root@ecs-proxy ~]# vim /etc/cloud/cloud.cfg
# manage_etc_hosts: localhost 注释掉这一行
[root@ecs-proxy ~]# reboot
# 安装配置ansible管理主机
[root@ecs-proxy ~]# tar zxf ansible_centos7.tar.gz
[root@ecs-proxy ~]# yum install -y ansible_centos7/*.rpm
[root@ecs-proxy ~]# ssh-keygen -t rsa -b 2048 -N '' -f /root/.ssh/id_rsa
[root@ecs-proxy ~]# chmod 0400 /root/.ssh/id_rsa
[root@ecs-proxy ~]# ssh-copy-id -i /root/.ssh/id_rsa 模板主机IP
```

2）配置模板机

```shell
[root@ecs-host ~]# rm -rf /etc/yum.repos.d/*.repo
[root@ecs-host ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.myhuaweicloud.com/repo/CentOS-Base-7.repo
[root@ecs-host ~]# vim /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever – Localrepo
baseurl=ftp://192.168.1.252/localrepo
enabled=1
gpgcheck=0
[root@ecs-host ~]# yum clean all
[root@ecs-host ~]# yum makecache
[root@ecs-host ~]# yum repolist
[root@ecs-host ~]# yum install -y net-tools lftp rsync psmisc vim-enhanced tree lrzsz bash-completion iproute
# 优化系统服务
[root@ecs-host ~]# systemctl stop postfix atd tuned
[root@ecs-host ~]# yum remove -y postfix at audit tuned kexec-tools firewalld-*
[root@ecs-host ~]# vim /etc/cloud/cloud.cfg
# manage_etc_hosts: localhost 注释掉这一行
[root@ecs-host ~]# yum clean all 
[root@ecs-host ~]# poweroff
# 注：配置完成以后，关机，在华为云主机管理菜单中把模板主机系统硬盘做成镜像，供以后使用
```



# 5 案例5：部署网站实战

## 5.1 问题

本案例要求部署网站：

- 购买3台云主机（web服务器）
- 安装配置 web 集群（推荐playbook方式）

## 5.2 步骤

实现此案例需要按照如下步骤进行。

```shell
[root@ecs-proxy ~]# mkdir -p web-site
[root@ecs-proxy ~]# cd web-site
[root@ecs-proxy ~]# vim ansible.cfg
[defaults]
inventory         = hostlist
host_key_checking = False
[root@ecs-proxy ~]# vim hostlist
[web]
192.168.1.[11:13]
[root@ecs-proxy ~]# vim web_install.yaml
---
- name: web 集群安装
  hosts: web
  tasks:
  - name: 安装 apache 服务 
    yum:
      name: httpd,php
      state: latest
      update_cache: yes
  - name: 配置 httpd 服务 
    service:
      name: httpd
      state: started
      enabled: yes
  - name: 部署网站网页
    unarchive:
      src: files/webhome.tar.gz
      dest: /var/www/html/
      copy: yes
      owner: apache
      group: apache
[root@ecs-proxy ~]# mkdir files
# 上传 webhome.tar.gz 到 files 目录下
[root@ecs-proxy ~]# ansible-playbook web_install.yaml
```

部署完成之后，购买弹性负载均衡ELB，如图-15

![img](https://img-blog.csdnimg.cn/img_convert/78e87c85a5c0419b1f7152b8570d95b8.png)
图-15

添加监听器和后端服务器，如图-16和图-17所示。

![img](https://img-blog.csdnimg.cn/img_convert/894c82445c332bc41fbe053c61498beb.png)
图-16

![img](https://img-blog.csdnimg.cn/img_convert/85c0b347d0e9c9c4a9c1f7c58082aa30.png)
图-17

绑定公网IP，测试访问，如图-18所示。

![img](https://img-blog.csdnimg.cn/img_convert/2137e62b9f03da8e864113efba281a62.png)
图-18

> 如有侵权，请联系作者删除



﻿@[TOC]( Incremental recovery & data query expansion | Cloud computing )

---

# 1. MySQL视图

## 1.1 问题

具体如下：

1. 视图基本使用练习
2. 视图进阶练习

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：视图基本使用练习**

```sql
// 创建包含员工名、email和部门名的视图
mysql> use tarena;
mysql> create view emp_view
    -> as
    ->   select name, email, dept_name
    ->   from employees as e
    ->   inner join departments as d
    ->   on e.dept_id=d.dept_id;
Query OK, 0 rows affected (0.01 sec)
// 查询视图中数据
mysql> select * from emp_view;
mysql> select * from emp_view where dept_name='运维部';
+-----------+--------------------+-----------+
| name      | email              | dept_name |
+-----------+--------------------+-----------+
| 廖娜      | liaona@tarena.com  | 运维部    |
| 窦红梅    | douhongmei@tedu.cn | 运维部    |
| 聂想      | niexiang@tedu.cn   | 运维部    |
| 陈阳      | chenyang@tedu.cn   | 运维部    |
| 戴璐      | dailu@tedu.cn      | 运维部    |
| 陈斌      | chenbin@tarena.com | 运维部    |
+-----------+--------------------+-----------+
6 rows in set (0.00 sec)
//创建包含员工名、工资总额的视图
mysql> create view emp_sal_view
    -> as
    ->   select name, date, basic+bonus as total
    ->   from employees as e
    ->   inner join salary as s
    ->   on e.employee_id=s.employee_id;
Query OK, 0 rows affected (0.00 sec)
mysql> select * from emp_sal_view where year(date)=2020 and month(date)=12;
   //创建包涵用户名、uid号、shell的视图
   mysql> create view  tarena.v1  as select name , uid ,shell  from  tarena.user;
Query OK, 0 rows affected (0.02 sec)
//查看条目数
mysql> select count(*) from tarena.v1;
+----------+
| count(*) |
+----------+
|       23 |
+----------+
1 row in set (0.00 sec)
//查看视图表结构
mysql> desc tarena.v1;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(20) | YES  |     | NULL    |       |
| uid   | int(11)  | YES  |     | NULL    |       |
| shell | char(30) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> 
//查看已有的表
mysql> show tables;
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| emp_sal_view     | 视图表
| emp_view         |视图表
| employees        |
| salary           |
| user             |
| v1               |视图表
+------------------+
7 rows in set (0.00 sec)
mysql> 
//查看所有表的状态(7张表 7行状态信息)
 mysql> show table status \G
*************************** 1. row ***************************
           Name: departments   #表名
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 8
 Avg_row_length: 2048
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: 9
    Create_time: 2021-09-09 18:04:21
    Update_time: 2021-09-09 18:04:21
     Check_time: NULL
      Collation: utf8mb4_general_ci
       Checksum: NULL
 Create_options: 
        Comment:  #没有说明
*************************** 2. row ***************************
           Name: emp_sal_view
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
*************************** 3. row ***************************
           Name: emp_view  #视图名
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW     #视图表
*************************** 4. row ***************************
           Name: employees
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 133
 Avg_row_length: 123
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 134
    Create_time: 2021-09-09 18:04:21
    Update_time: 2021-09-09 18:04:21
     Check_time: NULL
      Collation: utf8mb4_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
*************************** 5. row ***************************
           Name: salary
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 8066
 Avg_row_length: 44
    Data_length: 360448
Max_data_length: 0
   Index_length: 163840
      Data_free: 0
 Auto_increment: 9577
    Create_time: 2021-09-09 18:04:21
    Update_time: 2021-09-10 10:12:50
     Check_time: NULL
      Collation: utf8mb4_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
*************************** 6. row ***************************
           Name: user
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 23
 Avg_row_length: 712
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: 28
    Create_time: 2021-09-09 18:04:23
    Update_time: 2021-09-10 10:20:13
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options: 
        Comment: 
*************************** 7. row ***************************
           Name: v1
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
7 rows in set (0.00 sec)
mysql> 
//只查看指定表的状态  
mysql> show table status  where name="v1" \G
*************************** 1. row ***************************
           Name: v1
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
1 row in set (0.00 sec)
mysql> 
//只查看是视图的表
mysql> show table status  where comment="view" \G
*************************** 1. row ***************************
           Name: emp_sal_view
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
*************************** 2. row ***************************
           Name: emp_view
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
*************************** 3. row ***************************
           Name: v1
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
3 rows in set (0.00 sec)
mysql> 
//查看视图对应的基表
mysql> show create view v1 \G
*************************** 1. row ***************************
                View: v1
         Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `user`.`name` AS `name`,`user`.`uid` AS `uid`,`user`.`shell` AS `shell` from `user`
character_set_client: utf8
collation_connection: utf8_general_ci
1 row in set (0.00 sec)
mysql> 
//在视图表里查看bin用户信息
mysql> select * from v1 where name = "bin";
+------+------+---------------+
| name | uid  | shell         |
+------+------+---------------+
| bin  |    2 | /sbin/nologin |
+------+------+---------------+
1 row in set (0.00 sec)
//在基表里查bin用户信息
mysql> select * from user where name = "bin";
+----+------+----------+------+------+---------+---------+---------------+
| id | name | password | uid  | gid  | comment | homedir | shell         |
+----+------+----------+------+------+---------+---------+---------------+
|  2 | bin  | x        |    2 |    1 | bin     | /bin    | /sbin/nologin |
+----+------+----------+------+------+---------+---------+---------------+
1 row in set (0.00 sec)
mysql> 
//修改视图表bin用户的shell 
mysql> update v1 set shell=null where  name ="bin";
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//user表里bin用户的 shell 也改变了 
mysql> select * from user where name = "bin";
+----+------+----------+------+------+---------+---------+-------+
| id | name | password | uid  | gid  | comment | homedir | shell |
+----+------+----------+------+------+---------+---------+-------+
|  2 | bin  | x        |    2 |    1 | bin     | /bin    | NULL  |
+----+------+----------+------+------+---------+---------+-------+
1 row in set (0.00 sec)
mysql> 
//在视图表里删除bin用户
mysql> delete from v1 where name = "bin" ;
Query OK, 1 row affected (0.03 sec)
//user表里bin用户也没有了 
mysql> select * from user where name = "bin";
Empty set (0.00 sec)
mysql> 
//在user表里添加新记录
mysql>insert 
into user(name,password,uid,gid,comment,homedir,shell)values("yaya","x",999,999,"test user","/home/yaya","/bin/bash")；
Query OK, 1 row affected (0.04 sec)
//视图表v1 也多了1条记录
mysql> select * from v1 where name = "yaya";
+------+------+-----------+
| name | uid  | shell     |
+------+------+-----------+
| yaya |  999 | /bin/bash |
+------+------+-----------+
1 row in set (0.00 sec)
mysql> 
//在视图表里添加新记录
mysql> insert into  v1  values("jing",1000,"/bin/bash");
Query OK, 1 row affected (0.09 sec)
//在user表里也能查看到
mysql> select  * from user where name = "jing";
+----+------+----------+------+------+---------+---------+-----------+
| id | name | password | uid  | gid  | comment | homedir | shell     |
+----+------+----------+------+------+---------+---------+-----------+
| 29 | jing | NULL     | 1000 | NULL | NULL    | NULL    | /bin/bash |
+----+------+----------+------+------+---------+---------+-----------+
1 row in set (0.00 sec)
mysql> 
//在user 表里删除记录
mysql> delete from user where name = "jing";
Query OK, 1 row affected (0.02 sec)
//在视图表v1里查不到了 
mysql> select  * from v1 where name = "jing";
Empty set (0.00 sec)
mysql> 
//删除视图 emp_view
mysql> drop view emp_view;  
Query OK, 0 rows affected (0.00 sec)
mysql> 
```

**步骤二：视图进阶练习**

1. OR REPLACE修改视图

```sql
mysql> use tarena ;
Database changed
   //创建视图v2
mysql> create view v2 as select name,uid from tarena.user ;
Query OK, 0 rows affected (0.02 sec)
mysql> create view v2 as select name,uid , gid , shell  from tarena.user ;
ERROR 1050 (42S01): Table 'v2' already exists  #提示v2已经存在
mysql> create OR REPLACE view v2 as select name,uid , gid, shell  from tarena.user ;
Query OK, 0 rows affected (0.03 sec)  #命令执行成功
//创建练习的user3
mysql> create table tarena.user3  
select name , uid from  tarena.user where id <= 4;
Query OK, 3 rows affected (0.23 sec)
Records: 3  Duplicates: 0  Warnings: 0
mysql> select  * from tarena.user3;
+--------+------+
| name   | uid  |
+--------+------+
| root   |    1 |
| daemon |    3 |
| adm    |    4 |
+--------+------+
3 rows in set (0.00 sec)
mysql> 
//内连接查询
mysql> select  * from user3  inner join user where user3.uid=user.uid ;
+--------+------+----+--------+----------+------+------+---------+----------+---------------+
| name   | uid  | id | name   | password | uid  | gid  | comment | homedir  | shell         |
+--------+------+----+--------+----------+------+------+---------+----------+---------------+
| root   |    1 |  1 | root   | x        |    1 |    0 | root    | /root    | /bin/bash     |
| daemon |    3 |  3 | daemon | x        |    3 |    2 | daemon  | /sbin    | /sbin/nologin |
| adm    |    4 |  4 | adm    | x        |    4 |    4 | adm     | /var/adm | /sbin/nologin |
+--------+------+----+--------+----------+------+------+---------+----------+---------------+
3 rows in set (0.01 sec)
//创建视图表v4
mysql> create view  v4 as select  * from user3  inner join user where user3.uid=user.uid ;
ERROR 1060 (42S21): Duplicate column name 'name' 报错
mysql> 
//定义字段别名
mysql> create view  v4 as 
select  user3.name as username , user3.uid as user_id , user.*  from 
user3  inner join user 
where user3.uid=user.uid ;
Query OK, 0 rows affected (0.03 sec)
mysql> select  * from v4;
+----------+---------+----+--------+----------+------+------+---------+----------+---------------+
| username | user_id | id | name   | password | uid  | gid  | comment | homedir  | shell         |
+----------+---------+----+--------+----------+------+------+---------+----------+---------------+
| root     |       1 |  1 | root   | x        |    1 |    0 | root    | /root    | /bin/bash     |
| daemon   |       3 |  3 | daemon | x        |    3 |    2 | daemon  | /sbin    | /sbin/nologin |
| adm      |       4 |  4 | adm    | x        |    4 |    4 | adm     | /var/adm | /sbin/nologin |
+----------+---------+----+--------+----------+------+------+---------+----------+---------------+
3 rows in set (0.00 sec)
mysql> 
```

3. With check option

local 仅检查当前视图的限制
cascaded 同时要满足基表的限制（默认值）

```sql
//创建视图v6 并指定检测方式
mysql> create view v6 as select  name , uid  from tarena.user 
where uid  <= 10  with check option;
Query OK, 0 rows affected (0.04 sec)
//查看默认检测方式
mysql> show create view v6  \G
*************************** 1. row ***************************
                View: v6
         Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v6` AS select `user`.`name` AS `name`,`user`.`uid` AS `uid` from `user` where (`user`.`uid` <= 10) WITH CASCADED CHECK OPTION
character_set_client: utf8
collation_connection: utf8_general_ci
1 row in set (0.00 sec)
mysql> 
mysql>
//创建视图v7 基表是 视图v6
mysql> create view v7 as select  * from v6 
where uid >= 5 with local check option;
Query OK, 0 rows affected (0.04 sec)
//查看检测方式
mysql> show create view v7  \G
*************************** 1. row ***************************
                View: v7
         Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v7` AS select `v6`.`name` AS `name`,`v6`.`uid` AS `uid` from `v6` where (`v6`.`uid` >= 5) WITH LOCAL CHECK OPTION
character_set_client: utf8
collation_connection: utf8_general_ci
1 row in set (0.00 sec)
mysql> 
//测试验证方式
mysql> update v7 set uid = 1 where name="lp"; #不满足v7自身的条件uid>=5 
ERROR 1369 (HY000): CHECK OPTION failed 'tarena.v7'
mysql> 
mysql> update v7 set uid = 12 where name="lp"; #超出基表v6条件 uid<= 10
ERROR 1369 (HY000): CHECK OPTION failed 'tarena.v7'
mysql> 
mysql> update v7 set uid = 9 where name="lp"; #uid=9 #既满足自身条件又满足基表条件
Query OK, 1 row affected (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> 
mysql> update v6 set uid = 20 where name = "lp"; #不满足自身的条件uid<=10
ERROR 1369 (HY000): CHECK OPTION failed 'tarena.v6'
mysql> 
mysql> update v6 set uid = 2 where name = "lp"; #满足自身的条件uid<=10
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> 
```

## 2. 存储过程基本管理

## 2.1 问题

具体如下：

1. 练习创建存储过程
2. 练习存储过程的查看、调用、删除

## 2.2 步骤

实现此案例需要按照如下步骤进行。
**步骤一：练习创建存储过程**

语法

```sql
DELIMITER  //
CREATE PROCEDURE 存储过程名()
BEGIN
    一组合法的sql语句;
END
DELIMITER ;
```

命令行结束符

MySQL默认以";"为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码，通过“DELIMITER ;”把分隔符还原。

示例

```sql
mysql> drop database if exists mydb;
mysql> create database if not exists mydb default charset utf8mb4;
mysql> use mydb;
mysql> create table departments like tarena.departments; //复制表结构
mysql> select  * from  departments;
Empty set (0.00 sec)
mysql> desc departments;
+-----------+-------------+------+-----+---------+----------------+
| Field     | Type        | Null | Key | Default | Extra          |
+-----------+-------------+------+-----+---------+----------------+
| dept_id   | int(4)      | NO   | PRI | NULL    | auto_increment |
| dept_name | varchar(10) | YES  |     | NULL    |                |
+-----------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
mysql> delimiter //
mysql> create procedure dep_pro()
    begin
      insert into departments values
      (1, '人事部'), (2, '财务部');
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
```

**步骤二:练习存储过程的查看、调用、删除**

```sql
//查看所有的存储过程
mysql> select  db , name  from mysql.proc where type="procedure";
+--------+-------------------------------------+
| db     | name                                |
+--------+-------------------------------------+
| mydb   | dep_pro                             |
| sys    | create_synonym_db                   |
| sys    | diagnostics                         |
| sys    | execute_prepared_stmt               |
| sys    | ps_setup_disable_background_threads |
| sys    | ps_setup_disable_consumer           |
| sys    | ps_setup_disable_instrument         |
| sys    | ps_setup_disable_thread             |
| sys    | ps_setup_enable_background_threads  |
| sys    | ps_setup_enable_consumer            |
| sys    | ps_setup_enable_instrument          |
| sys    | ps_setup_enable_thread              |
| sys    | ps_setup_reload_saved               |
| sys    | ps_setup_reset_to_default           |
| sys    | ps_setup_save                       |
| sys    | ps_setup_show_disabled              |
| sys    | ps_setup_show_disabled_consumers    |
| sys    | ps_setup_show_disabled_instruments  |
| sys    | ps_setup_show_enabled               |
| sys    | ps_setup_show_enabled_consumers     |
| sys    | ps_setup_show_enabled_instruments   |
| sys    | ps_statement_avg_latency_histogram  |
| sys    | ps_trace_statement_digest           |
| sys    | ps_trace_thread                     |
| sys    | ps_truncate_all_tables              |
| sys    | statement_performance_analyzer      |
| sys    | table_exists                        |
| tarena | say48                               |
+--------+-------------------------------------+
28 rows in set (0.00 sec)
mysql> 
//查看指定存储过程功能代码
mysql> select  db , name ,body from mysql.proc where name="dep_pro" \G
*************************** 1. row ***************************
  db: mydb    # 库名
name: dep_pro #存储过程名
body: begin
insert into departments values (1,"人事部"),(2,"财务部"); #功能代码
end
1 row in set (0.00 sec)
mysql> 
//执行存储过程
mysql> call dep_pro() ;
Query OK, 2 rows affected (0.00 sec)
//查看表记录
mysql> select * from departments ;
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
|       1 | 人事部    |
|       2 | 财务部    |
+---------+-----------+
2 rows in set (0.00 sec)
//删除存储过程
mysql> drop procedure mydb.dep_pro;
Query OK, 0 rows affected (0.00 sec)
//查看不到存储过程了
mysql> select  db , name ,body from mysql.proc where name="dep_pro" \G
Empty set (0.00 sec)
mysql> 
```

# 3. 存储过程进阶管理

## 3.1 问题

具体如下：

- 练习系统变量的查看与赋值
- 练习用户变量的查看与赋值
- 练习局部变量的使用
- 练习存储过程参数的使用

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习系统变量的查看与赋值**

```sql
mysql> show global variables;   # 查看所有全局变量mysql> show session variables;  # 查看所有会话变量
//查看满足条件的部分变量(不指定global的话，默认为会话变量)
mysql> show global variables like '%char%'; 
#查看某个系统变量 变量结构为@@变量名、@@global.变量名、@@session.变量名mysql> select @@tx_isolation;   # 默认为会话变量+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec)​mysql> select @@global.character_set_system;+-------------------------------+| @@global.character_set_system |+-------------------------------+| utf8                          |+-------------------------------+1 row in set (0.00 sec)​​mysql> select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+1 row in set (0.00 sec)
mysql> set @@global.autocommit=0;    #全局变量
Query OK, 0 rows affected (0.00 sec)
mysql> select @@global.autocommit; #全局变量
+---------------------+
| @@global.autocommit |
+---------------------+
|                   0 |
+---------------------+
1 row in set (0.00 sec)
mysql> show session variables like "%buffer%"; //查看会话变量
mysql> set session sort_buffer_size = 40000;  //修改会话变量值
```

**步骤二：练习用户变量的查看与赋值**

```sql
mysql> set @user='tom';
Query OK, 0 rows affected (0.00 sec)
mysql> select count(*) from employees into @count;
Query OK, 1 row affected (0.00 sec)
mysql> select @user;
+-------+
| @user |
+-------+
| tom   |
+-------+
1 row in set (0.00 sec)
mysql> select @count;
+--------+
| @count |
+--------+
|    133 |
+--------+
1 row in set (0.00 sec)
```

**步骤三：练习局部变量的使用**
作用域:仅在定义它的GEGIN/END中有效
定义变量
DECLARE 变量 类型
DECLARE 变量 类型 DEFAULT 值

示例代码

```sql
//创建存储过程
Mysql> use  tarena;
mysql> delimiter  //
mysql> create procedure say48()
     begin
     declare name char(10);
     declare age int default 21;
     set name = "plj";
     select  name , age;
     end
     //
mysql> delimiter  ;
//调用存储过程 ，可以输出变量的值
mysql> call say48();
+------+------+
| name | age  |
+------+------+
| plj  |   21 |
+------+------+
1 row in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
mysql> 
//调用存储过程后，无法输出变量的值
mysql> select name ,age ;
ERROR 1054 (42S22): Unknown column 'name' in 'field list'  #报错
mysql> 
mysql> select @name ,@age ;  #没有定义
+-------+------+
| @name | @age |
+-------+------+
| NULL  | NULL |
+-------+------+
1 row in set (0.00 sec)
mysql> 
```

**步骤四：练习存储过程参数的使用**

语法：

```sql
CREATE PROCEDURE 存储过程名(参数列表)BEGIN    一组合法的sql语句;END
```

参数列表包含三部分：

参数模式
IN：需要调用者传值，与Python函数的参数作用类似
OUT：该参数可以作为输入。与Python函数的返回值类似
INOUT：既可以作为输入又可以作为输出

参数名： 存储数据的变量名
参数类型： MySQL服务支持的数据类型即可

1. 使用IN参数

```sql
mysql> use tarena;
mysql> delimiter //
mysql> create procedure empcount_pro(IN dept_no int)
    begin
       select dept_id, count(*) from employees
       where dept_id=dept_no
       group by dept_id;
    end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
#统计编号1 的部门人数个数
mysql> call empcount_pro(1); 
+---------+----------+
| dept_id | count(*) |
+---------+----------+
|       1 |        8 |
+---------+----------+
1 row in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
#统计编号2 的部门人数个数
mysql> call empcount_pro(2);
+---------+----------+
| dept_id | count(*) |
+---------+----------+
|       2 |        5 |
+---------+----------+
1 row in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
mysql> 
```

2. 使用OUT参数

```sql
mysql> use tarena;
mysql> delimiter //
mysql> create procedure empemail_pro(IN emp_name varchar(10), OUT mail varchar(25))
     begin
       select email into mail
       from employees
       where name=emp_name;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
    /添加做验证的用户
mysql> insert into employees(name,email) values("john","john@163.com"),("jerry","jerry@tedu.cn");
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0
//调用存储过程
mysql> call empemail_pro('john',@m);  
Query OK, 1 row affected (0.00 sec)
//查看变量的值
mysql> select @m;
+--------------+
| @m           |
+--------------+
| john@163.com |
+--------------+
1 row in set (0.00 sec)
//调用存储过程
mysql> call empemail_pro('jerry',@m);
Query OK, 1 row affected (0.00 sec)
//查看变量的值
mysql> select @m;
+---------------+
| @m            |
+---------------+
| jerry@tedu.cn |
+---------------+
1 row in set (0.00 sec)
mysql> 
```

3. 使用INOUT参数

```sql
mysql> delimiter //
mysql> create procedure myadd(INOUT i int)
     begin
       set i=i+100;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> set @n=8;
Query OK, 0 rows affected (0.00 sec)
mysql> call myadd(@n);
Query OK, 0 rows affected (0.00 sec)
mysql> select @n;
+------+
| @n   |
+------+
|  108 |
+------+
1 row in set (0.00 sec)
```

# 4. 流程控制

## 4.1 问题

具体如下：

- 练习顺序结构
- 练习分支结构
- 练习循环结构与流程控制语句

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习顺序结构**

if语句语法

```sql
IF 条件 TEHN
  语句;
END IF;
IF 条件 TEHN
  语句1;
ELSE
  语句2;
END IF;
IF 条件1 TEHN
  语句1;
ELSEIF 条件2 TEHN
  语句2;
ELSE
  语句3;
END IF;
```

示例

```sql
mysql> use tarena;
mysql> delimiter //
mysql> create procedure deptype_pro(IN no int, OUT dept_type varchar(5))
     begin
       declare type varchar(5);
       select dept_name into type from departments
       where dept_id=no;
       if type='运维部' then
         set dept_type='技术部';
       elseif type='开发部' then
         set dept_type='技术部';
       elseif type='测试部' then
         set dept_type='技术部';
       else
         set dept_type='非技术部';
       end if;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
   
mysql> call deptype_pro(1, @t);
Query OK, 1 row affected (0.00 sec)
mysql> select @t;
+--------------+
| @t           |
+--------------+
| 非技术部     |
+--------------+
1 row in set (0.00 sec)
mysql> call deptype_pro(3, @t1);
Query OK, 1 row affected (0.00 sec)
mysql> select @t1;
+-----------+
| @t1       |
+-----------+
| 技术部    |
+-----------+
1 row in set (0.00 sec)
```

**步骤二：练习分支结构**

```sql
Case语句语法

CASE 变量|表达多|字段
WHEN 判断的值1 THEN 返回值1;
WHEN 判断的值2 THEN 返回值2;
... ...
ELSE 返回值n;
END CASE;
```

示例

```sql
mysql> delimiter //
mysql> create procedure deptype_pro2(IN no int, OUT dept_type varchar(5))
    -> begin
    ->   declare type varchar(5);
    ->   select dept_name into type from departments
    ->   where dept_id=no;
    ->   case type
    ->   when '运维部' then set dept_type='技术部';
    ->   when '开发部' then set dept_type='技术部';
    ->   when '测试部' then set dept_type='技术部';
    ->   else set dept_type='非技术部';
    ->   end case;
    -> end//
mysql> call deptype_pro2(1, @tt)//
Query OK, 1 row affected (0.00 sec)
mysql> select @tt//
+--------------+
| @tt          |
+--------------+
| 非技术部     |
+--------------+
1 row in set (0.00 sec)
mysql> call deptype_pro2(3, @tt2)//
Query OK, 1 row affected (0.00 sec)
mysql> select @tt2//
+-----------+
| @tt2      |
+-----------+
| 技术部    |
+-----------+
1 row in set (0.00 sec)
mysql> delimiter ;
```

**步骤三：练习循环结构与流程控制语句**
循环语句语法

```sql
[标签:]WHILE 循环条件 DO
  循环体;
END WHILE [标签];
```

示例

```sql
mysql> delimiter //
mysql> create procedure while_pro(IN i int)
     begin
       declare j int default 1;
       while j<i do
         insert into departments(dept_name) values('hr');
         set j=j+1;
       end while;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> call while_pro(3);
Query OK, 1 row affected (0.00 sec)
```

2. 使用LEAVE结束循环。此处LEAVE相当于其他语言的break

```sql
mysql> delimiter //
mysql> create procedure while_pro2(IN i int)
    begin
      declare j int default 1;
       a:while j<i do
         insert into departments(dept_name) values('hr');
         if j>=2 then leave a;
         end if;
        set j=j+1;
       end while a;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> call while_pro2(3);
Query OK, 1 row affected (0.07 sec)
mysql> select  * from departments;
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
|       1 | 人事部    |
|       2 | 财务部    |
|       3 | 运维部    |
|       4 | 开发部    |
|       5 | 测试部    |
|       6 | 市场部    |
|       7 | 销售部    |
|       8 | 法务部    |
|       9 | hr        |
|      10 | hr        |
+---------+-----------+
11 rows in set (0.00 sec)
mysql> 
```

3. 使用ITERATE跳过本次循环。此处的ITERATE相当于其他整语言的continue

```sql
mysql> delimiter //
mysql> create procedure while_pro3(IN i int)
    begin
    declare j int default 0;
    a:while j<i do
    set j=j+1;
    if mod(j, 2)=0 then iterate a;
    end if;
    insert into departments(dept_name) values(concat('hr', j));
    end while a;
    end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> call while_pro3(3);
Query OK, 1 row affected (0.03 sec)
mysql> select  * from departments;
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
|       1 | 人事部    |
|       2 | 财务部    |
|       3 | 运维部    |
|       4 | 开发部    |
|       5 | 测试部    |
|       6 | 市场部    |
|       7 | 销售部    |
|       8 | 法务部    |
|       9 | hr        |
|      10 | hr        |
|      11 | hr1       | 
|      12 | hr3       |
+---------+-----------+
10 rows in set (0.00 sec)
```

4. loop循环:没有条件的死循环
   语法

```sql
[标签:]LOOP
  循环体;
END LOOP [标签]
```

示例

```sql
//死循环
mysql> delimiter //
mysql> create procedure p1() 
begin 
declare age int default 29;  #变量要在循环体外定义 
loop select age; 
end loop ; 
end//
mysql> delimiter ;
Mysql>  call  p1()  #无限输出 按ctrl +c  结束
//指定循环结束条件
mysql> delimiter //
mysql> create procedure loop_pro()
     begin
       declare i int default 0;
       a:loop
         set i=i+1;
         if i>5 then leave a;
         end if;
         insert into departments(dept_name) values(concat('hr1', i));
       end loop a;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> call loop_pro();
Query OK, 1 row affected (0.00 sec)
```

5）repeat循环:至少循环一次
语法

```sql
[标签:]REPEAT
  循环体;
UNTILE 循环结束条件
END REPEAT [标签]
```

示例

```sql
mysql> delimiter //
mysql> create procedure repeat_pro(IN i int)
    begin
    declare j int default 1;
       a:repeat
        set j=j+1;
         insert into departments(dept_name) values('sales');
       until j>i
       end repeat a;
     end //
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;
mysql> call repeat_pro(3);
Query OK, 1 row affected (0.08 sec)
mysql> select * from departments;
```

# Exercise

## 1 简述读取日志内容恢复数据格式

```sql
mysqlbinlog  [选项]  /目录名/binlog日志文件名 |  mysql  -uroot  -p密码 
```

## 2 简述查看日志内容选项。

```sql
--start-position=数字  起始偏移量
--stop-position=数字  结束偏移量
--start-datetime=”yyyy/mm/dd  hh:mm:ss” 起始时间
--stop-datetime=”yyyy/mm/dd  hh:mm:ss” 结束时间
```

> 如有侵权，请联系作者删除



﻿

@[TOC]( Installing the Linux OS & Linux Basic Operations | Cloud computing )

---

# 1. 装机预备技能

## 1.1 问题

1. RHEL与CentOS系统有什么关联？
2. Linux系统中第三块SCSI硬盘如何表示？

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：RHEL系统与CentOS系统的渊源**

RHEL是红帽公司提供的商业版Linux系统，若要获取DVD镜像、安全更新等技术服务支持，一般需要付费订阅；不过构成RHEL系统的各种软件包都是基于GPL开源协议免费发布的。

CentOS是一个社区性质的Linux系统，相当于RHEL的一个克隆版本，它采用了构成RHEL系统的各种软件包重新组装、开发而成，并且在此过程中做了一些优化、必要的Bug修复；CentOS系统的版本会稍晚于同版本的RHEL系统发布，其构成、管理方式与同版本的RHEL系统几乎一模一样，而且能够找到大量开放的软件源，因此受到很多企业的欢迎。

目前，CentOS已经被Red Hat公司所收购，仍然可自由使用。

**步骤二：Linux系统中第三块SCSI硬盘如何表示？**

在Linux系统中，第三块SCSI硬盘如何表示利用/dev/sdc表示

# 2 案例2：安装一台LINUX虚拟机

## 2.1 问题

基于KVM虚拟机环境新安装一各LINUX操作系统，主要完成以下事项：

1. 新建一台虚拟机，硬盘30GB，内存1GB
2. 为此虚拟机安装LINUX操作系统，采取自动分区方案
3. 软件包定制

## 2.2 方案

在虚拟机环境练习装机过程——通过菜单组`应用程序`-->`系统工具`-->`虚拟系统管理器`，打开KVM虚拟化的图形管理程序（如图-1所示），添加一台虚拟机，将LINUX系统的ISO镜像文件作为此虚拟机的安装光盘。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2408ee32ce0c4deab65a4fcb5e71b7b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：新建一台LINUX虚拟机**

> 1）启动“新建虚拟机”向导程序

单击虚拟系统管理器左上方的“新建”按钮，即可打开 `新建虚拟机` 向导窗口；为新建虚拟机指定名称，安装方式选择从本地ISO镜像安装（如图-2所示），单击 `前进`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0e83d38a3a174a9886820bf0d44c8c0d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16,align:center)
图-2

> 2）指定ISO文件位置、系统版本

通过“浏览”找到正确的LINUX安装镜像文件的路径，操作系统类型选择 `Linux` ，版本选择 `CentOS 7.0`（如图-3所示），单击 `前进`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8df37343e1a94deab3666ada249bc93b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图－3

> 3）指定虚拟机内存与CPU核心数

内存建议设为2048MB，CPU默认1个即可（如图-4所示），单击 `前进`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/136f41fe3e1044c9bc46c560c889fb3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图－4

> 4）指定虚拟机的磁盘大小

此处建议选择30GB，（如图-5所示），单击 `前进`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/73e55ed366ee4a49bb34d88fffe83e1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图－5

> 5）确认并完成创建

查看虚拟机最终配置信息，建议展开 `高级选项`，将虚拟网络选择为 `private1`（如图-6所示），单击“完成”后将会自动运行新建的虚拟机。

![在这里插入图片描述](https://img-blog.csdnimg.cn/dd0a5ed5b07d48688dd10e5c6fc05cfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图－6

**步骤二：启动虚拟机电源，安装Linux系统**

> 1）运行Linux安装程序

打开新虚拟机的电源后，会自动从光盘引导主机（因为新磁盘没有引导信息，自动找其他启动设备），进入CentOS系统的安装选择界面。按上箭头键选择第一项 `Install CentOS 7`（如图-7所示），然后按Enter键启动安装程序。

![在这里插入图片描述](https://img-blog.csdnimg.cn/adefaafb05574351934b057c1d36eece.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－7

> 2）选择语言类型

建议初学者选择 `简体中文（中国）`以降低难度（如图-8所示），单击“继续”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3e0511dcb6734704ac071134f4add0ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－8

> 3）自定义磁盘分区方案

在 `安装信息摘要` 的列表界面中，单击 `系统` --> `安装位置`（如图-9所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4e820eb10b7d4ce5b49cf554b221c577.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－9

打开 `安装目标位置` 界面以后，选择 `安装位置` 下的 `自动配置分区`  （如图-10所示），单击上方的 `完成` 按钮。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e27b7303ecf14bdc8824662b9509bb88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-10

> 4）选择要安装的软件包

单击 `安装信息摘要` 界面中的 `软件选择` 接下来在 `基本环境` 下选取 `带GUI的服务器` （如图-11所示），单击 `完成` 按钮返回。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d4352fe6e1d7413fbecf096b63990f41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－11

> 5）确认并开始安装

检查 `安装信息摘要界面` ，确保所有带叹号的部分都已经完成，然后单击右下方的 `开始安装` 按钮（如图-12所示），将会执行正式安装。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e0da078e86d442d39ae50595738a25c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－12

在安装执行期间，根据页面提示（如图-13所示）单击 `ROOT密码` 后为root用户设置一个密码（注意：若密码太简单需要按两次 `完成` 按钮！！），无需创建其他用户。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6a18d2936bef49d69b96a8504e5ca73e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-13

设置好密码以后，只要等待安装结束就行了（如图-14所示）。根据系统性能及选取的软件包不同，安装过程一般需要5~30分钟。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0a3d9c12075a4313bfc791a49aec02d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)图-14

**6）结束安装过程**

全部安装执行完毕后，会提示重启主机（如图-15所示），根据提示操作即可。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2d0ce3959d94428aae9238937771b6d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－15

**步骤三：初始化配置**

完成LINUX系统的安装过程后，第一次启动时会要求进行初始化设置。

> 1）确认许可协议,如图-16与图-17所示，点击`完成`
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f30d741b6f72438d9b567d07b62f3c0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
> 图-16

![在这里插入图片描述](https://img-blog.csdnimg.cn/248be8dfe587485688cbf8d60ebb4697.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-17

> 2）选择 `完成配置` （如图-18所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/abd9c18f529245579a4cee68ac0cedb9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-18

3）选择语言，如图-19所示，点击 `前进` 

![在这里插入图片描述](https://img-blog.csdnimg.cn/a3bf086feb384fbf8968fe955c0b8e9b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-19

> 4）选择`语言输入`，建议选择`汉语pinyin`（如图-20所示）

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b0d28adb1d3459d95328a7661f5608c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)

图-20

> 5）隐私如图-21所示，点击 `前进` 

/

图-21

> 6）时区如图-22所示，选择 `上海` 

/

图-22

> 7）在线账号如图-23所示，选择 `跳过` 

/

图-23

> 8）接下来只要单击 `开始使用` 即可

![在这里插入图片描述](https://img-blog.csdnimg.cn/fe95dfd1c37a4296b4f3e31c1a02cacc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-24

自动登入（以后登录时需要提供密码）到桌面环境（如图-25所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/64a0a8f5556f4f14b5ea50da1dd28732.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)

图-25

至此，整个LINUX虚拟机系统的安装就完成了。

**3 案例3：使用LINUX图形桌面**

## 3.1 问题

本例要求熟悉新装LINUX系统的图形桌面环境，完成下列任务：

>更改桌面背景图片
>打开应用程序 “Firefox Web Browser”
>添加一个普通用户账号（4参考自己姓名的拼音）
>注销，换新用户登录
>重启此系统

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：以root用户登入到图形桌面**

将新装的LINUX系统关机、重新开机，启动完毕会看到登录界面（如图-26所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2358a9fd9ede4108939a5a4da7f95eae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-26

单击展示的用户列表下方的`未列出？`，然后根据提示输入管理员用户名root（如图-27所示），单击`下一步`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e878dcb37f7e4c75b37e94bdb944495b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-27

接下来再根据提示输入root用户的正确口令（如图-28所示），单击“登录”按钮即成功进入图形桌面环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eab0ae949a80452dabd260dddce75b0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-28

**步骤二：完成简单的桌面操作**

> 1）更改桌面背景图片

在桌面空白处右击，选择 `更改桌面背景` ，在弹出的对话框中单击 `背景` 并选取自己所喜爱的图片即可（如图-29所示）；如果需要更改锁屏图片，可以单击旁边的 `锁屏` 去选择。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec045c61bfcd40f4ab53f68b93c771c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)

图-29

> 2）打开Firefox网页浏览器

单击桌面菜单组`应用程序`-->`互联网`-->`Firefox Web Browser`（如图-30所示），可以打开火狐网页浏览器程序。

![在这里插入图片描述](https://img-blog.csdnimg.cn/07857dfe2c044ac582497c52d8775673.png)
图-30

> 3）添加一个普通用户账号（参考自己姓名的拼音）

单击桌面菜单组 `应用程序` --> `系统工具` --> `设置`（如图-31所示），可以打开系统设置平台。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2e8754e9443944788fa318c33c0b6959.png)
图-31

点击 `详细信息`（如图-32所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8ce1a749fd964dfe986b1c5d06ff7bb4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-32

然后点击 `用户` 管理窗口后，可以通过右上方的按钮来添加用户账号。根据自己的姓名拟定一个用户名，添加此账号即可（如图-33所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cbfabfd990234383b7f0611d82090100.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-33

> 4）注销，换新用户登录

单击桌面右上角的电源按钮，在弹出窗口中展开用户右侧的下拉列表，根据需要选择 `切换用户` 或者 `注销`（如图-34所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/167ac2f39e094593b98356d44f78bb94.png)
图-34

> 5）重启此系统

单击桌面右上角的电源按钮，在弹出窗口中再单击右下的电源标识（如图-35所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b0143f10094b43439e88ae8670944b35.png)
图-35

接下来会提示操作类型，根据需要选择 `取消`、`重启`、`关机` 即可（如图-36所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bf12fdd9442a41fea7d02cfe3776ab2f.png)
图-36

# 4. Linux命令行基本操作

## 4.1 问题

本例要求熟悉新装LINUX系统中命令行界面的获取方法，并通过命令行完成下列任务：

>查看内核版本、主机名、IP/MAC地址
>查看CPU型号/频率、内存大小
>切换到根目录，确认当前位置、列出有哪些子目录
>返回到 /root 目录，确认当前位置
>重启当前系统

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：获取命令行界面的不同方法**

> 1）虚拟控制台切换

LINUX系统默认提供6个虚拟控制台（tty1 ~ tty6），每个控制台可以独立登录、执行不同的任务。其中tty1默认开启图形桌面，tty2 ~ tty6只开启字符模式。

通过组合快捷键Ctrl+Alt+Fn可以在不同的虚拟控制台之间切换，这里的Fn代表F1~F6键中的某一个。例如，当处在正常的图形桌面时，按Ctrl+Alt+F3组合键可以切换到控制台tty3，登录后即进入纯字符模式的命令行界面；如果需要返回之前的图形桌面，则再按键Ctrl+Alt+F1组合键即可。

> 2）桌面右键菜单

在桌面空白处右击，或者通过资源管理器浏览文件夹时在空白处右击，可以看到右键菜单中出现“在终端中打开”项（如图-37所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/aa5329bdf6e043d5a0636d21a61853a9.png)
图-37

单击“在终端中打开”项即可获得以图形窗口展现的命令行终端程序（如图-38所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/64178a18aedd40b6a27d457973198bd0.png)
图-38

> 3）`应用程序` 相应菜单

通过桌面菜单组`应用程序`-->`工具`-->`终端`，也可以打开以图形窗口展现的命令行终端程序。

**步骤二：简单命令行操作练习**

> 1）查看内核版本、主机名、IP/MAC地址

检查红帽发行信息：

```shell
[root@svr7 桌面]# cat /etc/redhat-release 
Red Hat Enterprise Linux Server release 7.5 (Maipo)
```

列出内核版本：

```shell
[root@svr7 桌面]# uname -r
3.10.0-327.el7.x86_64
```

> 2）查看CPU型号/频率、内存大小

列出CPU处理器信息：

```shell
[root@svr7 桌面]# lscpu
Architecture:          x86_64 
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                1
On-line CPU(s) list:   0
Thread(s) per core:    1
Core(s) per socket:    1
座：                 1
NUMA 节点：         1
厂商 ID：           GenuineIntel 
CPU 系列：          6
型号：              13
型号名称：        QEMU Virtual CPU version (cpu64-rhel6)
步进：              3
CPU MHz：             2693.762
BogoMIPS：            5387.52
超管理器厂商：  KVM
虚拟化类型：     完全
L1d 缓存：          32K
L1i 缓存：          32K
L2 缓存：           4096K
NUMA 节点0 CPU：    0
```

检查内存大小、空闲情况

```shell
[root@svr7 桌面]# cat /proc/meminfo 
MemTotal:        1016904 kB
MemFree:          245364 kB
MemAvailable:     566664 kB
Buffers:            2116 kB
Cached:           417372 kB
SwapCached:            0 kB
Active:           267272 kB
Inactive:         381760 kB
.. ..
```

> 3）切换到根目录，确认当前位置、列出有哪些子目录

切换目录、确认当前位置：

```shell
[root@svr7 桌面]# cd  /
[root@svr7 /]# pwd
/
```

> 4）返回到 /root 目录，确认当前位置

```shell
[root@svr7 /]# cd  /root
[root@svr7 ~]# pwd
/root
```

> 5）重启当前系统

```shell
[root@svr7 ~]# reboot
.. ..
```


# Exercise

## 1 请列举你所知道的Linux发行版

常见的Linux发行版：

- Red Hat Enterprise Linux 5/6/7
- CentOS 5/6/7
- Suse Linux Enterprise 11
- Debian Linux 6.0
- Ubuntu Linux 13.04/13.10
- Oracle Linux 6

## 2 Linux系统的根目录、/dev目录的作用是什么

- /：linux文件系统的起点，linux所有的文件都放在其中。
- /dev：存放硬盘、键盘、鼠标、光驱等各种设备文件。

## 3 从Linux桌面环境如何快速切换到字符控制台终端

按组合键Ctrl+Alt+Fn，其中Fn为F2、F3、F4、F5、F6键中的任何一个。

## 4 如何查看当前主机的CPU处理信息

```shell
[root@svr7 ~]# lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
.. ..
厂商 ID：           GenuineIntel
CPU 系列：          6
型号：              13
型号名称：        QEMU Virtual CPU version (cpu64-rhel6)
.. ..
```


> 如有侵权，请联系作者删除



﻿@[TOC]( Introduction to cluster and LVS & LVS-NAT cluster & LVS-DR cluster | Cloud computing )

---

# 1. ipvsadm命令用法

## 1.1 问题

准备一台Linux服务器，安装ipvsadm软件包，练习使用ipvsadm命令，实现如下功能：

- 使用命令添加基于TCP一些的集群服务
- 在集群中添加若干台后端真实服务器
- 实现同一客户端访问，调度器分配固定服务器
- 会使用ipvsadm实现规则的增、删、改
- 保存ipvsadm规则

## 1.2 方案

安装ipvsadm软件包，关于ipvsadm的用法可以参考man ipvsadm资料。

常用ipvsadm命令语法格式如表-1及表-2所示。

表－1 ipvsadm命令选项
![在这里插入图片描述](https://img-blog.csdnimg.cn/268676a35c424473adb61afa000a8793.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


表－2 ipvsadm语法案例
![在这里插入图片描述](https://img-blog.csdnimg.cn/a1a96470768847dd94c3cca228b8bc92.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用命令增、删、改LVS集群规则**

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）

```shell
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
```

2）为集群添加若干real server

```shell
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             router    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4
```

3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)

```shell
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             router    1      0          0         
  -> 192.168.2.200:80             masq      2      0          0         
  -> 192.168.2.201:80             masq      2      0          0         
  -> 192.168.2.202:80             masq      1      0          0
```

4）修改read server（使用-g选项，将模式改为DR模式）

```shell
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g
```

5）查看LVS状态

```shell
[root@proxy ~]# ipvsadm -Ln
```

6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）

```shell
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m
```

7）永久保存所有规则（非必须的操作）

```shell
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
```

注意：永久规则需要确保ipvsadm服务为开机启动服务才可以。

（systemctl enable ipvsadm）。

8）清空所有规则

```shell
[root@proxy ~]# ipvsadm -C
```

# 2. 部署LVS-NAT集群

## 2.1 问题

使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：

- 集群对外公网IP地址为192.168.4.5
- 调度器内网IP地址为192.168.2.5
- 真实Web服务器地址分别为192.168.2.100、192.168.2.200
- 使用加权轮询调度算法，真实服务器权重任意

## 2.2 方案

实验拓扑结构主机配置细节如表-3所示，注意下面的网卡名称仅为参考，不能照抄。

表-3
![在这里插入图片描述](https://img-blog.csdnimg.cn/51367f8f0f674388bf677f4570e506b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


使用4台虚拟机，1台作为Director调度器、2台作为Real Server、1台客户端，拓扑结构如图-1所示，注意：web1和web2必须配置网关地址。

![在这里插入图片描述](https://img-blog.csdnimg.cn/559804ef6683450db5bd8585f45661a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置基础环境**

1）设置Web服务器

```shell
[root@web1 ~]# yum -y install httpd        #安装软件
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html    #创建网页文件
[root@web1 ~]# firewall-cmd --set-default-zone=trusted            #设置防火墙
[root@web1 ~]# setenforce  0
[root@web1 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config  
[root@web2 ~]# yum -y install httpd        #安装软件
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html    #创建网页文件
[root@web2 ~]# firewall-cmd --set-default-zone=trusted            #设置防火墙
[root@web2 ~]# setenforce  0
[root@web2 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

2）启动Web服务器软件

```shell
[root@web1 ~]# systemctl restart httpd
[root@web2 ~]# systemctl restart httpd
```

如何验证？

完成后可以使用proxy主机测试下是否可以访问web1和web2

```shell
[root@proxy ~]# curl http://192.168.2.100
[root@proxy ~]# curl http://192.168.2.200
```

3）配置网关，将web1和web2的网关设置为192.168.2.5（不能照抄网卡名称）

如果有4网段的IP，则临时将该网卡关闭nmcli con down 网卡名称

```shell
[root@web1 ~]# nmcli connection modify eth1 \
ipv4.method manual ipv4.gateway 192.168.2.5
#备注:网卡名称不能照抄,需要自己查看下2.100的网卡名称
[root@web1 ~]# nmcli connection up eth1
[root@web1 ~]# ip route show                #查看默认网关
default via 192.168.2.5 dev eth1          #提示：这里default后面的IP就是默认网关
#英语词汇：default（默认，预设值）
… …
[root@web2 ~]# nmcli connection modify eth1 \
ipv4.method manual ipv4.gateway 192.168.2.5
#备注:网卡名称不能照抄,需要自己查看下2.200的网卡名称
[root@web2 ~]# nmcli connection up eth1
[root@web2 ~]# ip route show        #查看默认网关，default后面的IP就是默认网关
```

**为什么需要配置网关？**

实验拓扑如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea9708a3784c41b1a74bcf5471383252.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-2

为了方便下面所有的IP都采用简写,如4.10代表192.168.4.10，2.100代表192.168.2.100。

英语词汇：source（src）代表源地址，destination（dest或dst）代表目标地址。

LVS采用的是路由器的NAT通讯原理！通讯流程如下：

1. 客户端发送请求数据包(src:4.10,dst:4.5)

2. 数据包被发送给LVS调度器，调度器做NAT地址转换（外网转内网，内网转外网）
   a)数据包被修改为src:4.10,dst:2.100(dst也有可能被修改为2.200，随机的）
   b)LVS调度器把数据包转发给后端真正的web服务器（2.100）

3. web1收到数据包开始回应数据（rsc:2.100，dst:4.10）
   备注：谁访问就给谁回复数据，因为src是4.10，所以应该给4.10回应数据！
   但是，自己是2.100，对方是4.10，跨网段默认无法通讯，如何解决？？？
   Web1和web2都需要设置默认网关（也就是192.168.2.5）

4. web1想发送数据给4.10但是又无法与其通讯，所以数据包被交给默认网关

5. LVS调度器（软路由）收到后端web发送过来的数据后，再次做NAT地址转换
   a)数据包被修改为src:4.5,dst:4.10
   b)LVS调度器把数据包转发给客户端主机

6. 客户端接收网页数据内容

注意：客户端访问的是4.5，最后是4.5给客户端回复的网页数据！！！！

**步骤二：部署LVS-NAT模式调度器**

1)确认调度器的路由转发功能(如果已经开启，可以忽略)

```shell
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward     #开启路由转发，临时有效
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward          #查看效果
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
#修改配置文件，设置永久规则，英语词汇：forward（转寄，转发，发送，向前）
```

2）创建集群服务器

```shell
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
# -A(add)是创建添加虚拟服务器集群
# -t(tcp)后面指定集群VIP的地址和端口，协议是tcp协议
# -s后面指定调度算法，如rr（轮询）、wrr（加权轮询）、lc（最少连接）、wlc（加权最少连接）等等
```

3）添加真实服务器

```shell
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
#-a(add)往虚拟服务器集群中添加后端真实服务器IP,指定往-t 192.168.4.5:80这个集群中添加
#-r(real)后面跟后端真实服务器的IP和端口，这里不写端口默认是80端口
#-w(weight)指定服务器的权重，权重越大被访问的次数越多，英语词汇：weight（重量，分量）
#-m指定集群工作模式为NAT模式，如果是-g则代表使用DR模式，-i代表TUN模式
```

4）查看规则列表（L是list查看，n是number数字格式显示）

```shell
[root@proxy ~]# ipvsadm -Ln
```

5)设置防火墙，SELinux

```shell
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
[root@proxy ~]# setenforce  0
[root@proxy ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

**步骤三：客户端测试**

客户端client主机使用curl命令反复连接http://192.168.4.5，查看访问的页面是否会轮询到不同的后端真实服务器。

# 3. 部署LVS-DR集群

## 3.1 问题

使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：

- 客户端IP地址为192.168.4.10
- LVS调度器VIP地址为192.168.4.15
- LVS调度器DIP地址设置为192.168.4.5
- 真实Web服务器地址分别为192.168.4.100、192.168.4.200
- 使用加权轮询调度算法，权重可以任意

说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。

## 3.2 方案

使用4台虚拟机，1台作为客户端、1台作为Director调度器、2台作为Real Server，拓扑结构如图-3所示。实验拓扑结构主机配置细节如表-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/44fb1edd10154ea2b7280c942f0451af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

表-4
![在这里插入图片描述](https://img-blog.csdnimg.cn/ffae73a2e1724567b44656cf4598266a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)

为什么本实验中web1和web2要采用4网段IP？如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb58a67d5bf94964a7aa925845f8d1be.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-4

LVS NAT实验请求数据包从LVS调度器进，web的相应数据包也从LVS调度器出，那么LVS调度器就需要承载所有数据的压力，会成为整个集群的瓶颈！！

本实验LVS DR模式的核心需求是希望web1和web2可以不走调度器返回数据！

但是如图-4所示，如果web1和web2采用2.100和2.200这样2网段的IP，又不希望给4.10回复数据走LVS调度器（也就是不给web1和web2配置默认网关为2.5），最后是无法跨网段通讯的！！！

怎么办？核心需求是希望web1和web2可以直接返回数据给客户端！！！

想让web1和web2可以直接返回数据给客户端，可以给web1和web2配置4网段IP，如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/66de3b0a3d3a445fab3ee1be7a11ed75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-5

这样就可以了吗？答案是否定的！！！网络中的基本原则是A访问B，必须是B返回数据给A，现在4.10访问4.5，最终4.100给4.10返回网页数据，所有数据包都会被丢弃！！！

那怎么办呢？地址欺骗！

![在这里插入图片描述](https://img-blog.csdnimg.cn/74fd3801654444f1a3168e936d50d3e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-6

如图-6所示，我们给web1和web2再额外添加一个伪装的IP地址，这个IP地址因为是用来做地址欺骗用的，假的就是假的，不能暴露（必须配置在lo本地回环网卡上面）。

lo网卡上面默认配置的IP是127.0.0.1。

如果你家里有非法的1000W，你会天天出去跟别人说你有1000W吗?

## 3.3 步骤

实现此案例需要按照如下步骤进行。

说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址（本案例为192.168.4.15）；
VIP必须配置在虚拟接口（目的是防止地址冲突）；
RIP是后端服务器的真实IP地址（本案例为192.168.4.100和192.168.4.200）；
DIP是调度器与后端服务器通信的IP地址（本案例为192.168.4.5）。

**步骤一：配置实验网络环境**

1）设置Proxy服务器的VIP和DIP

**注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口，网卡名称不能照抄！！！**

```shell
[root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0  ifcfg-eth0:0
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
#网卡类型为：以太网卡
BOOTPROTO=none
#none手动配置IP，或者dhcp自动配置IP
NAME=eth0:0
#网卡名称
DEVICE=eth0:0
#设备名称
ONBOOT=yes
#开机时是否自动激活该网卡
IPADDR=192.168.4.15
#IP地址
PREFIX=24
#子网掩码
[root@proxy ~]# systemctl restart network        #重启网络服务
[root@proxy ~]# ip  a  s             #会看到一个网卡下面有两个IP地址
```

常见问题：RHEL7和Centos7系统中有两个管理网络的服务，有可能冲突？

解决方法：关闭NetworkManager服务后重启network即可。

2）设置Web1服务器网络参数（不能照抄网卡名称）

```shell
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
```

接下来给web1配置VIP地址。

注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。

```shell
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo  ifcfg-lo:0
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
#设备名称
IPADDR=192.168.4.15
#IP地址
NETMASK=255.255.255.255
#子网掩码
NETWORK=192.168.4.15
#网络地址
BROADCAST=192.168.4.15
#广播地址
ONBOOT=yes
#开机是否激活本网卡
NAME=lo:0
#网卡名称
```

防止地址冲突的问题：

这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突；

sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。

```shell
[root@web1 ~]# vim /etc/sysctl.conf
#文件末尾手动写入如下4行内容,英语词汇：ignore（忽略、忽视），announce（宣告、广播通知）
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应（防止进站冲突）
#本机不要向外宣告自己的lo回环地址是192.168.4.15（防止出站冲突）
[root@web1 ~]# sysctl -p
```

重启网络服务

```shell
[root@web1 ~]# systemctl restart network        #重启网络服务
[root@web1 ~]# ip  a   s           #会看到一个网卡下面有两个IP地址
```

常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）

```shell
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network
```

3）设置Web2服务器网络参数（不能照抄网卡名称）

```shell
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
```

接下来给web2配置VIP地址

注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。

```shell
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo  ifcfg-lo:0
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
#设备名称
IPADDR=192.168.4.15
#IP地址
NETMASK=255.255.255.255
#子网掩码
NETWORK=192.168.4.15
#网络地址
BROADCAST=192.168.4.15
#广播地址
ONBOOT=yes
#开机是否激活该网卡
NAME=lo:0
#网卡名称
```

防止地址冲突的问题：

这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突；

sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。

```shell
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容，英语词汇：ignore（忽略、忽视），announce（宣告、广播通知）
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应（防止进站冲突）
#本机不要向外宣告自己的lo回环地址是192.168.4.15（防止出站冲突）
[root@web2 ~]# sysctl -p
```

重启网络服务

```shell
[root@web2 ~]# systemctl restart network        #重启网络服务
[root@web2 ~]# ip a  s                 #会看到一个网卡下面有两个IP地址
```

常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）

```shell
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network
```

**步骤二：proxy调度器安装软件并部署LVS-DR模式调度器**

1）安装软件（如果已经安装，此步骤可以忽略）

```shell
[root@proxy ~]# yum -y install ipvsadm
```

2）清理之前实验的规则，创建新的集群服务器规则

```shell
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
## -A(add)是创建添加虚拟服务器集群
# -t(tcp)后面指定集群VIP的地址和端口，协议是tcp协议
# -s后面指定调度算法，如rr（轮询）、wrr（加权轮询）、lc（最少连接）、wlc（加权最少连接）等等
```

3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)

```shell
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
#-a(add)往虚拟服务器集群中添加后端真实服务器IP,指定往-t 192.168.4.15:80这个集群中添加
#-r(real)后面跟后端真实服务器的IP和端口，这里不写端口默认是80端口
#-w(weight)指定服务器的权重，权重越大被访问的次数越多，英语词汇：weight（重量，分量）
#-m指定集群工作模式为NAT模式，如果是-g则代表使用DR模式，-i代表TUN模式
```

4）查看规则列表（L代表list查看规则，n代表number数字格式显示）

```shell
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   1      0          0
```

**步骤三：客户端测试**

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。

注意：本实验不可以在proxy主机（LVS调度器）使用curl访问网页验证！！！

为什么？请思考图-7示意图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/427f53c758a143b1aee621af30b72948.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-7

扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)

```shell
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/null
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done
```

附加思维导图，如图-7所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5aa01e1ff410434591955e29f7cf9be1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-7


# Exercise

## 1 集群有哪些类别？

- 高性能计算集群HPC：通过以集群开发的并行应用程序，解决复杂的科学问题。
- 负载均衡（LB）集群：客户端访问负载可以在计算机集群中尽可能平均地分摊处理。
- 高可用（HA）集群：当集群中的一个系统发生故障时，集群软件迅速做出反应，将该系统的任务分配到集群中其它正在工作的系统上执行。

## 2 LVS的负载平衡方式有哪些？

- VS/NAT：通过网络地址转换实现的虚拟服务器。Director将用户请求报文的目的地址改成选定的Real Server地址后，转发给Real Server。大并发访问时，调度器的性能成为瓶颈。
- VS/DR：直接使用路由技术实现虚拟服务器。通过改写请求报文的MAC地址，将请求发至Real Server，Real Server直接响应客户端。
- VS/TUN：通过隧道方式实现虚拟服务器。Director采用隧道技术将请求发至Real Server后，Real Server直接响应客户端。

## 3 写出至少四种LVS负载平衡的调度算法

- 轮询（Round Robin）
- 加权轮询（Weighted Round Robin）
- 最少连接（Least Connections）
- 加权最少连接（ Weighted Least Connections ）
- 基于局部性的最少链接（Locality-Based Least Connections）
- 带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）
- 目标地址散列（Destination Hashing）
- 源地址散列（Source Hashing）
- 最短的期望的延迟（Shortest Expected Delay Scheduling SED）
- 最少队列调度（Never Queue Scheduling NQ）

## 4 解释下面LVS配置的作用？

> ```shell
> [root@svr1 ~]# ipvsadm -A -t 10.10.10.1:80 -s wrr
> [root@svr1 ~]# ipvsadm -a -t 10.10.10.1:80 -r 192.168.10.11 -m > -w 1
> ```

1）创建虚拟服务器，VIP为10.10.10.1，采用的调度算法为wrr。

2）向虚拟服务器中加入节点，并指定权重为1，负载均衡方式为VS/NAT。

> 如有侵权，请联系作者删除



﻿@[TOC]( Iptables Typical application of firewall & filter table control & extended matching & NAT table | Cloud computing )

---

# 1. iptables基本管理

## 1.1 问题

本案例要求练习iptables命令的使用，按照要求完成以下任务：

- 关闭firewalld，开启iptables服务
- 查看防火墙规则
- 追加、插入防火墙规则
- 删除、清空防火墙规则

## 1.2 方案

iptables防火墙具有4表5链，4表分别是filter表、nat表、raw表、mangle表，5链分别是INPUT链、OUTPUT链、FORWARD链、PREROUTING链、POSTROUTING链。防火墙规则要求写在特定表的特定链中，效果如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0092b87b4e304d2eb2b054c20a9e54db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

步骤一：关闭firewalld，启动iptables服务

1）关闭firewalld服务器

```shell
[root@proxy ~]# systemctl stop firewalld.service 
[root@proxy ~]# systemctl disable firewalld.service
```

**步骤二：熟悉iptables框架**

1）iptables的4个表（区分大小写）：
iptables默认有4个表，nat表（地址转换表）、filter表（数据过滤表）、raw表（状态跟踪表）、mangle表（包标记表）。

2）iptables的5个链（区分大小写）：
INPUT链（入站规则）
OUTPUT链（出站规则）
FORWARD链（转发规则）
PREROUTING链（路由前规则）
POSTROUTING链（路由后规则）

**步骤三：iptables命令的基本使用方法**

1）iptabels语法格式

```shell
[root@proxy ~]# iptables  [-t 表名]  选项  [链名]  [条件]  [-j 目标操作]
[root@proxy ~]# iptables  -t  filter  -I  INPUT -p  icmp  -j  REJECT
[root@proxy ~]# iptables -F    #清空所有规则
[root@proxy ~]# iptables -t filter -I  INPUT   -p  icmp  -j  ACCEPT
[root@proxy ~]# iptables  -I  INPUT  -p  icmp  -j  REJECT
#注意事项与规律：
#可以不指定表，默认为filter表
#可以不指定链，默认为对应表的所有链
#按顺序匹配，匹配即停止，如果没有找到匹配条件，则执行防火墙默认规则
#选项/链名/目标操作用大写字母，其余都小写
########################################################################
#目标操作：
# ACCEPT：允许通过/放行
# DROP：直接丢弃，不给出任何回应
# REJECT：拒绝通过，必要时会给出提示
# LOG：记录日志，然后传给下一条规则
```

iptables命令的常用选项如表-1所示。

表-1 iptables常用选项
![在这里插入图片描述](https://img-blog.csdnimg.cn/ffbc2d73537d4052a4f04384279b64a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


2）iptables命令的使用案例

创建规则的案例：

```shell
[root@proxy ~]# iptables -F           #清空所有规则
[root@proxy ~]# iptables  -t  filter  -A  INPUT  -p tcp  -j  ACCEPT
#追加规则至filter表中的INPUT链的末尾，允许任何人使用TCP协议访问本机
[root@proxy ~]# iptables  -I  INPUT  -p  udp  -j  ACCEPT
#插入规则至filter表中的INPUT链的开头，允许任何人使用UDP协议访问本机
[root@proxy ~]# iptables  -I  INPUT 2  -p  icmp  -j  ACCEPT
#插入规则至filter表中的INPUT链的第2行，允许任何人使用ICMP协议访问本机
```

查看iptables防火墙规则

```shell
[root@proxy ~]# iptables  -nL  INPUT                    #仅查看INPUT链的规则
target     prot opt source               destination
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0
[root@proxy ~]# iptables  -L  INPUT  --line-numbers        #查看规则，显示行号
num  target     prot opt source         destination
1    ACCEPT     udp   --  anywhere     anywhere
2    ACCEPT     icmp --   anywhere     anywhere
3    ACCEPT     tcp  --   anywhere     anywhere
```

删除规则，清空所有规则

```shell
[root@proxy ~]# iptables  -D  INPUT  3
#删除filter表中INPUT链的第3条规则
[root@proxy ~]# iptables  -nL  INPUT                #查看规则，确认是否删除
[root@proxy ~]# iptables  -F
#清空filter表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  nat  -F
#清空nat表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  mangle  -F
#清空mangle表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  raw  -F
#清空raw表中所有链的防火墙规则
```

设置防火墙默认规则

```shell
[root@proxy ~]# iptables  -t  filter  -P  INPUT  DROP     #设置INPUT链默认规则为DROP
[root@proxy ~]# iptables  -nL
Chain INPUT (policy DROP)
… …
[root@proxy ~]# iptables  -t  filter  -P  INPUT  ACCEPT     #设置INPUT链默认规则为ACCEPT
```

# 2. filter过滤和转发控制

## 2.1 问题

本案例要求创建常用主机防火墙规则以及网络防火墙规则：

1. 针对Linux主机进行出站、入站控制
2. 利用ip_forward机制实现Linux路由/网关功能
3. 在Linux网关上实现数据包转发访问控制

## 2.2 方案

根据防火墙保护的对象不同，防火墙可以分为主机型防火墙与网络型防火墙，如图-2所示。

主机型防火墙，主要保护的是服务器本机（过滤威胁本机的数据包）。

网络防火墙，主要保护的是防火墙后面的其他服务器，如web服务器、FTP服务器等。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e27523f8ec754de9b33b01632acfb8d1.png)
图-2

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：iptables防火墙规则的条件**

iptables防火墙可以根据很多规则进行过滤行为，具体常用的过滤条件如表-2所示。

表-2 iptables过滤条件
![在这里插入图片描述](https://img-blog.csdnimg.cn/0ff5357b5faf45288fed0ae4747f8cc1.png)
**步骤二：主机型防火墙案例**

```shell
[root@proxy ~]# iptables -I INPUT -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -s 192.168.2.100 -j REJECT
[root@proxy ~]# iptables -I INPUT -d 192.168.2.5 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -i eth0 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables  -A  INPUT -s  192.168.2.0/24  -j  DROP
#丢弃192.168.2.0/24网络中所有主机发送给本机的所有数据包
[root@proxy ~]# iptables -A  INPUT -s  114.212.33.12  -p tcp --dport 22 -j  REJECT
#拒绝114.212.33.12使用tcp协议远程连接本机ssh（22端口）
```

**步骤三：网络型防火墙案例**

1）网络型防火墙案例

部署如表-3所示的网络拓扑，一定要把proxy主机的路由转发功能打开。

表-3 实验拓扑（网卡名称仅供参考）
![在这里插入图片描述](https://img-blog.csdnimg.cn/065309ebe1f94ed1bf225a3f17aeaf46.png)


1）client主机配置IP、添加网关（网卡名称仅供参考，不能照抄）

注意：如果client主机有2网段IP的网卡，必须要关闭该网卡

```shell
[root@client ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.10/24 autoconnect yes
[root@client ~]# nmcli connection modify eth0 ipv4.gateway 192.168.4.5
[root@client ~]# nmcli connection up eth0
[root@client ~]# iptables -F
```

2）proxy主机配置IP、添加网关、开启路由转发（网卡名称仅供参考，不能照抄）

```shell
 [root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 autoconnect yes
[root@proxy ~]# nmcli connection up eth1
[root@proxy ~]# iptables -F
```

Linux内核默认支持软路由功能，通过修改内核参数即可开启或关闭路由转发功能。

```shell
[root@proxy ~]# echo 0 > /proc/sys/net/ipv4/ip_forward            #关闭路由转发
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            #开启路由转发
#注意以上操作仅当前有效，计算机重启后无效
[root@proxy ~]# echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
#修改/etc/sysctl.conf配置文件，可以实现永久有效规则
```

3）web1主机配置IP、添加网关（网卡名称仅供参考，不能照抄）

注意：如果web1主机有4网段IP的网卡，必须要关闭该网卡

```shell
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 autoconnect yes
[root@web1 ~]# nmcli connection modify eth0 ipv4.gateway 192.168.2.5
[root@web1 ~]# nmcli connection up eth0
```

4）确认不同网络的联通性

```shell
[root@client ~]# ping 192.168.2.100
[root@web1 ~]# ping 192.168.4.10
```

5）在web1主机上启动http服务

```shell
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "test page" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
```

没有防火墙的情况下client访问web服务

```shell
[root@client ~]# curl http://192.168.2.100                    #成功
```

设置proxy主机的防火墙规则，保护防火墙后面的Web服务器

```shell
[root@proxy ~]# iptables -I FORWARD -s 192.168.4.10 -p tcp --dport 80 -j DROP
```

设置完防火墙规则后，再次使用client客户端访问测试效果

```shell
[root@client ~]# curl http://192.168.2.100                    #失败
```

**步骤三：禁ping的相关策略**

ping的流程（A主机pingB主机）如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d15f8b2d52f64beeae6748c5ecd44af3.png)
图-3

1）默认直接禁ping的问题？

```shell
[root@proxy ~]# iptables -I INPUT -p icmp -j DROP
#设置完上面的规则后，其他主机确实无法ping本机，但本机也无法ping其他主机
#当本机ping其他主机，其他主机回应也是使用icmp，对方的回应被丢弃
```

2）禁止其他主机ping本机，允许本机ping其他主机

```shell
[root@proxy ~]# iptables  -A  INPUT  -p icmp  \
 --icmp-type echo-request  -j  DROP
#仅禁止入站的ping请求，不拒绝入站的ping回应包
···
注意：关于ICMP的类型，可以参考help帮助，参考命令如下：
```shell
[root@proxy ~]# iptables -p icmp --help
```

# 3. 防火墙扩展规则

## 3.1 问题

本案例要求熟悉使用iptables的扩展规则，实现更丰富的过滤功能，完成以下任务：

1. 根据MAC地址封锁主机
2. 在一条规则中开放多个TCP服务
3. 根据IP范围设置封锁规则

## 3.2 方案

iptables在基本过滤条件的基础上还扩展了很多其他条件，在使用时需要使用-m参数来启动这些扩展功能，语法如下：

iptables 选项 链名称 -m 扩展模块 --具体扩展条件 -j 动作

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：根据MAC地址过滤**

1）根据IP过滤的规则，当对方修改IP后，防火墙会失效

```shell
[root@proxy ~]# iptables -F
[root@proxy ~]# iptables -I INPUT -s 192.168.4.10 -p tcp --dport 22 -j DROP
#设置规则禁止192.168.4.10使用ssh远程本机
```

但是，当client主机修改IP地址后，该规则就会失效，注意因为修改了IP，对client主机的远程连接会断开。 根据MAC地址过滤，可以防止这种情况的发生。

```shell
[root@client ~]# ip link show eth0                    #查看client的MAC地址
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff
[root@proxy ~]# iptables  -A  INPUT  -p tcp --dport 22\
 -m   mac --mac-source  52:54:00:00:00:0b  -j  DROP
#拒绝52:54:00:00:00:0b这台主机远程本机
```

**步骤二：基于多端口设置过滤规则**

1）一次需要过滤或放行很多端口时会比较方便

```shell
[root@proxy ~]# iptables  -A  INPUT  -p tcp   \
 -m  multiport --dports  20,25,80,110,143,16501:16800  -j  ACCEPT
#一次性开启20,25,80,110,143,16501到16800所有的端口
```

提示，多端口还可以限制多个源端口，但因为源端口不固定，一般不会使用，限制多个源端口的参数是--sports.

**步骤三：根据IP地址范围设置规则**

1）允许从 192.168.4.10-192.168.4.20 主机ssh远程登录本机

```shell
[root@proxy ~]# iptables  -A  INPUT  -p tcp  --dport  22  \
 -m  iprange  --src-range  192.168.4.10-192.168.4.20   -j  ACCEPT
```

注意，这里也可以限制多个目标IP的范围，参数是--dst-range,用法与--src-range一致。

2）禁止从 192.168.4.0/24 网段其他的主机ssh远程登录本机

```shell
[root@proxy ~]# iptables -A INPUT -p tcp --dport 22  -s 192.168.4.0/24  -j  DROP
```

# 4. 配置SNAT实现共享上网

## 4.1 问题

本案例要求设置防火墙规则，允许位于局域网中的主机可以访问外网，主要包括下列服务：

1. 搭建内外网案例环境
2. 配置SNAT策略实现共享上网访问

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：搭建内外网案例环境**

表-4 实验拓扑
![在这里插入图片描述](https://img-blog.csdnimg.cn/d8dccd4a5e4846888b7f2d5967636774.png)


这里，我们设定192.168.2.0/24网络为外部网络，192.168.4.0/24为内部网络。

现在，在外部网络中有一台web服务器192.168.2.100，因为设置了网关，client已经可以访问此web服务器了。但，如果查看web1的日志就会发现，日志里记录的是192.168.4.10在访问网页。

我们需要实现的效果是，client可以访问web服务器，但要伪装为192.168.2.5后再访问web服务器(模拟所有位于公司内部的电脑都使用的是私有IP，希望访问外网，就需要伪装为公司的外网IP后才可以)。

**步骤二：设置防火墙规则，实现IP地址的伪装（SNAT源地址转换）**

1）确保proxy主机开启了路由转发功能

```shell
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            #开启路由转发
```

2）设置防火墙规则，实现SNAT地址转换

```shell
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING \
 -s  192.168.4.0/24 -p tcp --dport 80  -j SNAT  --to-source 192.168.2.5
```

3）登陆web主机查看日志

```shell
[root@web1 ~]# tail  /var/log/httpd/access_log
.. ..
192.168.2.5 - - [12/Aug/2018:17:57:10 +0800] "GET / HTTP/1.1" 200 27 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
```

通过日志会发现，客户端是先伪装为了192.168.2.5之后再访问的web服务器！

4）扩展知识，对于proxy外网IP不固定的情况可以执行下面的地址伪装，动态伪装IP。

```shell
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING \
 -s  192.168.4.0/24 -p tcp --dport 80 -j MASQUERADE
```

最后，所有iptables规则都是临时规则，如果需要永久保留规则需要执行如下命令:

安装iptables-services并启动服务，保存防火墙规则。

```shell
[root@proxy ~]# yum -y install iptables-services
[root@proxy ~]# systemctl start iptables.service
[root@proxy ~]# systemctl enable iptables.service
[root@proxy ~]# iptables -F
[root@proxy ~]# service  iptables save           #保存防火墙规则
```

附加思维拓扑图，如图-4所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/34150420c5a1454588cc08094bf95019.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4


# Exercise

## 1 iptables的4表和5链分别是什么？

1）4表包括：nat表、filter表、raw表、mangle表
2）5链包括：INPUT链、OUTPUT链、FORWARD链、PREROUTING链、POSTROUTING链

## 2 查看iptables防火墙规则的命令是什么？

```shell
[root@svr7 ~]# iptables  -nL  INPUT
target     prot opt source               destination
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0
[root@svr7 ~]# iptables  -L  INPUT  --line-numbers
num  target     prot opt source         destination
1    ACCEPT     udp   --  anywhere     anywhere
2    ACCEPT     icmp --  anywhere     anywhere
3    ACCEPT     tcp  --  anywhere        anywhere
```

## 3 清空iptables防火墙规则的命令是什么？

```shell
[root@svr7 ~]# iptables  -D  INPUT  3
[root@svr7 ~]# iptables  -nL  INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
[root@svr7 ~]# iptables  -F
[root@svr7 ~]# iptables  -t  nat  -F
[root@svr7 ~]# iptables  -t  mangle  -F
[root@svr7 ~]# iptables  -t  raw  -F
```

4 如何开启的Linux的路由转发功能？

```shell
# echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
```

或者

```shell
# echo 1 > /proc/sys/net/ipv4/ip_forward
```

## 5 创建一条iptables防火墙规则，实现SNAT源地址转换的命令。

```shell
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING \
 > -s  192.168.4.0/24  -p tcp –dport 80 -j SNAT  --to-source  192.168.2.5
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Jenkins project management & build distribution server & automation go live & Ansible foundation | Cloud computing )

---

# 1 案例1：Jenkins项目管理

## 1.1 问题

本案例要求管理Jenkins项目，要求如下：

- 创建Jenkins项目
- 修改Jenkins项目配置

## 1.2 方案

实验环境准备（沿用DAY02的实验环境）：

1）5台RHEL8虚拟机，主机名分别为develop、git、jenkins、web1和web2。
2）develop主机的IP地址为192.168.4.10，不需要配置网关和DNS。
3）git主机的IP地址为192.168.4.20，不需要配置网关和DNS。
4）jenkins主机的IP地址为192.168.4.30，不需要配置网关和DNS。
5）web1和web2主机的IP地址分别为192.168.4.100和192.168.4.200，不需要配置网关和DNS。
6）所有主机都需要配置可用的系统YUM源，设置防火墙信任所有，SELinux放行所有。

备注：跨网段走路由，相同网段不需要配置网关就可以互联互通！实验拓扑如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a443fc463ff94bb388e8c267332c0303.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

程序类型：编译型（如C、C++）和解释型（如Python、JavaScript）。

CI/CD流程：Jenkins下载代码、打包代码、编译代码、测试代码、上线服务器。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建项目**

1）浏览器访问Jenkins服务器8080端口。

firefox或google-chrome http://192.168.4.30:8080。

登录后，点击《新建任务》，创建jenkins项目，效果如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5687697bb5504cbaa97d62696821a1e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

填写任务名称，选择任务风格，效果如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f4fb7e7f00054a91942cf1c14c2a8bcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-3

设置Git参数，效果如图-4所示。

默认Jenkins会拉取最新版本的代码，这里的设置可以让Jenkins拉取特定的分支或标签（tag）的代码。注意：这里的git参数名称后面会经常用到！

![在这里插入图片描述](https://img-blog.csdnimg.cn/3c41e301a28d4c1cbb2835d83f499646.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

继续设置Git参数，定义Git仓库的URL路径，以及需要下载克隆的版本或分支，效果如图-5所示。注意这里的URL是前面课程GitLab创建的代码仓库的链接地址。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8250fe4740f74f94be503e72236cabc6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

2)构建（build）Jenkins项目。

首先需要找到刚刚常见的项目，如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/275517dc123d478592cff7611cb2333d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

在项目菜单下选择《Build with Parameters》,效果如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2ffd7eae850440cc9735dc6a5ecb0e18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-7

此时Jenkins会自动连接GitLab服务器获取仓库数据，我们可以选择一个版本，点击《开始构建》，效果如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1f8d0567aae442fcadd692d71d69297e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-8

接下来可以在控制台中查看构建日志，查看构建过程，效果如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/97b851f563074babbe82f735591326cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-9

3）查看Jenkins拉取的代码数据。

在Jenkins服务器操作（192.168.4.30主机操作），默认Jenkins会加拉取的代码数据保存到/var/lib/Jenkins/workspace/目录。

[root@jenkins ~]# ls /var/lib/jenkins/
[root@jenkins ~]# ls /var/lib/jenkins/workspace/
[root@jenkins ~]# ls /var/lib/jenkins/workspace/myweb/
[root@jenkins ~]# rm -rf  /var/lib/jenkins/workspace/myweb/*
4）修改项目配置

如果代码有多个版本或分支，每次都将代码拉取到相同位置，会产生数据覆盖，我们可以修改项目配置，将不同的版本和分支数据保存到不同子目录下。

点击《配置》，重新修改Jenkins项目配置，如图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b46430267c674cccb38ad41449f21d7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-10

为Jenkins项目添加附加动作行为，将代码拉取输出到子目录，效果如图-11所示。

注意：这里的子目录调用了前面Git参数的名称（$web）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/735a354c6be04c8bb157b593e0e17d34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-11

设置邮件通知，在构建失败时可以给特定人员发送邮件，效果如图-12所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/526e7dd4378d4fabaaca4f3e1a215fd1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-12

5）再次构建项目，并查看数据。

重新构建项目，效果如图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1c4e530646d344c7872ef0066c0386e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-13

在Jenkins服务器查看数据（在192.168.4.30主机操作）。

[root@jenkins ~]# # ls /var/lib/jenkins/workspace/myweb/

# 2. 构建分发服务器

## 2.1 问题

沿用练习一，构建分发服务器，具体要求如下：

- 安装、配置vsftpd
- 修改项目配置
- 重新构建项目

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装、配置FTP共享服务器（仅在192.168.4.30主机操作）**

1）设置防火墙、SELinux。

```shell
[root@jenkins ~]# firewall-cmd --set-default-zone=trusted
[root@jenkins ~]# setenforce 0
[root@jenkins ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

2) 安装配置vsftpd、启动服务

```shell
[root@jenkins ~]# dnf  -y   install   vsftpd              #安装软件
[root@jenkins ~]# vim /etc/vsftpd/vsftpd.conf            #修改vsftpd配置文件
anonymous_enable=YES                       #12行          #允许匿名访问ftp
[root@jenkins ~]# mkdir -p /var/ftp/deploy/packages
#创建目录，未来jenkins将拉取的代码数据拷贝到该目录，共享给应用服务器
#-p是创建多级子目录
[root@jenkins ~]# chown -R :jenkins /var/ftp/deploy/
#修改权限将目录所属组修改为jenkins
[root@jenkins ~]# chmod -R 775 /var/ftp/deploy/
#修改权限让jenkins组对该目录有读写权限
[root@jenkins ~]# systemctl enable vsftpd --now
#设置服务为开机自启动服务，并立刻启动该服务
```

**步骤二：修改GitLab项目配置**

1）修改项目配置，添加构建步骤。

添加构建步骤，效果如图-14所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b84d63b576a6403ebdd36ff4bf9c48dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-14

2）编写构建脚本，脚本内容如下。

```shell
pkg_dir=/var/ftp/deploy/packages
cp -r myweb-$web $pkg_dir
rm -rf $pkg_dir/myweb-$web/.git
cd $pkg_dir/
tar czf myweb-$web.tar.gz myweb-$web
rm -rf myweb-$web
md5sum myweb-$web.tar.gz | awk '{print $1}' > myweb-$web.tar.gz.md5
cd ..
echo -n $web > ver.txt
```

注释说明：
第一行，定义变量pkg_dir，变量值为ftp共享目录。
第二行，将jenkins拉取到/var/lib/Jenkins/workspace/myweb-$web目录的数据拷贝的ftp共享目录。
第三行，上一步拷贝过来的数据目录下包含一个隐藏.git目录，删除该git仓库目录。
第四行，cd到ftp共享目录下。
第五行，将ftp共享目录下的代码数据打包。
第六行，将ftp共享目录下的代码数据目录删除（上一步已经打包数据）。
第七行，校验打包文件的HASH值（哈希值），并将结果写入到一个文件中。
第八行，返回上一级目录。
第九行，将当前Git版本信息写入ver.txt文件。

3）重新构建项目，查看数据。
重新构建项目，如图-15所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/597c4998c4d3458b801a5177e560c507.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-15

使用浏览器访问FTP服务，查看数据。
firefox 或者google-chrom 访问ftp://192.168.4.30/deploy/packages/
效果如图-16所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bd236fd2e0124d42bded4a121fcded73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-16

# 3. 自动化上线

## 3.1 问题

沿用练习二，部署web服务器完成自动化上线，具体要求如下：

- 安装配置httpd
- 编写上线脚本
- 完成整个工作流程

## 3.2 方案

实验拓扑如图-17所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ad2fa8db4a144e2787cad78552be50e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-17

**步骤一：部署Web服务器**

1）设置防火墙和SELinux

```shell
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
[root@web1 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0
[root@web2 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

2）安装、配置httpd。

```shell
[root@web1 ~]# dnf  -y  install   httpd  wget   tar        #安装httpd、tar和wget
[root@web1 ~]# systemctl  enable  httpd   --now     #设置开启自启，并立刻启动
[root@web2 ~]# dnf  -y  install   httpd  wget  tar          #安装httpd、tar和wget
[root@web2 ~]# systemctl  enable  httpd   --now     #设置开启自启，并立刻启动
```

**步骤二：编写自动化上线脚本**

1）web1和web2自动从jenkins共享服务器下载代码实现持续部署。

这里仅以web1为例编写脚本，可以结合计划任务实现周期性自动上线持续部署。

```shell
[root@web1 ~]# vim web.sh
#!/bin/bash
#定义变量，指定FTP共享路径
ftp_url=ftp://192.168.4.30/deploy
#定义变量，指定网页根路径
web_dir=/var/www/html
#定义函数，行数名为down_file，该函数的作用是从FTP服务器下载代码数据到网站根目录
down_file(){
#获取FTP服务器上面最新构建的代码版本号
#curl是基于命令行的浏览器,-s选项为静默访问，不显示下载过程（可以自己对比不是用-s的差异）
  version=$(curl -s $ftp_url/ver.txt)
#将服务器上面的版本文件下载到web服务器的/var/www/html/目录下
#wget为下载工具（如果没有则需要安装），-q选项为静默模式下载，不显示下载过程
#-O选项可以指定将文件下载到哪里，这里是下载到/var/www/html/ver.txt
  wget -q $ftp_url/ver.txt -O $web_dir/ver.txt
#下载代码数据的打包文件，根据前面获取的版本号，下载对应的版本数据打包文件
  wget -q $ftp_url/packages/myweb-$version.tar.gz -O $web_dir/myweb-$version.tar.gz
#对下载下来的数据打包文件计算HASH值（哈希值），awk过滤仅显示第一列数据结果
  hash=$(md5sum $web_dir/myweb-$version.tar.gz| awk '{print $1}')
#使用curl访问ftp服务器上面的HASH值
  ftp_hash=$(curl -s $ftp_url/packages/myweb-$version.tar.gz.md5)
#对比本地和FTP服务的HASH值是否一致，如果不一致代表数据损坏了
#如果一致就可以解压该数据包，将数据解压到网站根目录下/var/www/html/
  if [ "$hash" == "$ftp_hash" ];then
     tar -xf $web_dir/myweb-$version.tar.gz -C $web_dir
  fi
}
#判断如果本地没有/var/www/html/ver.txt文件，则直接调用前面的函数下载代码数据
if [ ! -f $web_dir/ver.txt ];then
  down_file
fi
#盘如果本地有/var/www/html/ver.txt文件，则判断本地版本文件和FTP版本文件是否一致
#一致就不再下载FTP的数据，如果不一致则调用前面的函数下载新的代码数据包
if [ -f $web_dir/ver.txt ];then
  ftp_ver=$(curl -s $ftp_url/ver.txt)
  local_ver=$(cat $web_dir/ver.txt)
  if [ "$ftp_ver" != "$local_ver" ];then
      down_file
  fi
fi
[root@web1 ~]# chmod +x  web.sh                #添加可执行权限
[root@web1 ~]# ./web.sh                         #执行脚本
```

**步骤三：完成整理工作流程。**

1）工作流程。

开发人员编写代码，将代码上传到GitLab服务器，Jenkins从GitLab服务器上面拉取最新代码数据到本地，根据Jenkins项目配置，将代码拉取到本地后，可以进行编译、测试、打包等工作，最后将数据包写入到共享服务器，应用服务器最后从共享服务器拉取数据实现上线功能。

2）开发人员修改代码、上传代码（主机192.168.4.10操作）

```shell
[root@develop ~]# cd myproject                   #进入仓库目录
[root@develop myproject]# vim  index.html                #修改首页文件第4行内容
修改前：
<title>Home</title>
修改后：
<title>Tarena</title>
[root@develop myproject]# git add .                       #添加修改记录
[root@develop myproject]# git commit -m "modify index"      #提交修改  
[root@develop myproject]# git tag  v2                         #添加代表版本标签
[root@develop myproject]# git push origin master             #推送数据到服务器
[root@develop myproject]# git push origin v2                 #推送数据到服务器
```

3）Jenkins重新构建项目，效果如图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f6b7d3c48454529a518f7b1c3d02597.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-18

4）在web服务器执行上线脚本完成持续部署。

在192.168.4.100和192.168.4.200操作，这里仅以web1为例。

```shell
[root@web1 ~]# ./web.sh
```

# 4. 部署Ansible

## 4.1 问题

本案例要求先快速搭建好一个Ansible平台，并测试环境，要求如下：

- 创建实验主机（控制端和被控制端）
- 配置SSH实验环境
- 安装Ansible自动化软件
- 修改Ansible配置

## 4.2 方案

准备如表-1所示的实验环境，操作系统为RHEL8，配置主机名称、IP地址、YUM源。

表-1 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/30932e1decb24348a8be0506661c7921.png)
ansible原理：
控制端主机自带很多模块（模块就是脚本）；
ansible通过ssh远程被管理主机，将控制端的模块（脚本）或命令传输到被管理主机；
在被管理端主机执行模块（脚本）或命令，执行不同的模块或命令可以实现不同的功能；
最后ansible退出ssh远程。
绝大多数模块（脚本）都需要参数才能执行成功！！！类似于shell脚本的位置变量！

拓扑结构如图-19所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b0bf958227e849ee9b9b3a6ee8e3e1d6.png)
图-19

提醒：全天的实验不需要死记硬背每个模块的每个参数，所有参数都可以查看帮助！

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备基础环境**
控制节点要求：

- 域名解析（为了方便后期操作，可以不做）
- 配置SSH密钥（ansible是基于ssh实现远程控制）
- 安装Ansible软件

1）Control控制节点
修改/etc/hosts，在文件中手动添加如下内容，修改该文件的目的是做域名解析。

```shell
[root@control ~]# vim  /etc/hosts        #修改文件，手动添加如下内容（不要删除文件原来的内容）
192.168.4.253    control    
192.168.4.11        node1    
192.168.4.12        node2    
192.168.4.13        node3    
192.168.4.14        node4    
192.168.4.15        node5
```

如何验证？

```shell
[root@control ~]# ping  node1               #可以使用ping命令依次ping所有域名    
```

配置SSH密钥实现免密码登录（非常重要）

Ansible是基于SSH远程的原理实现远程控制，如果控制端主机无法免密登录被管理端主机，后续的所有试验都会失败！！

```shell
[root@control ~]#  ssh-keygen         #生成ssh密钥
[root@control ~]#  for i in node1 node2 node3 node4 node5
do
ssh-copy-id   $i 
done
#拷贝密钥到远程主机
#提示：拷贝密钥到远程主机时需要输入对方电脑的账户密码才可以！！
#拷贝密钥到node1就需要输入node1对应账户的密码，拷贝密钥到node2就需要输入node2对应的密码
```

如何验证？

警告：如果有任何一台主机远程还需要密码，就不要往下继续操作，后面实验都会失败！！！

```shell
[root@control ~]# ssh  node1            #使用ssh命令依次远程所有主机都可以免密码登录
[root@node1 ~]# exit                     #退出ssh远程登录
```

2)部署Ansible软件（仅Control主机操作，软件包在ansible_soft目录）。

```shell
安装软件方案1(提前直接将软件包拷贝到control安装):
[root@control ~]# tar -xf   ansible_soft.tar.gz
[root@control ~]# cd ansible_soft
[root@control ansible_soft]# dnf  -y  install   *
```

```shell
安装软件方案2(配置YUM安装ansible软件):
1)真机做YUM源服务器
[root@localhost ~]# tar -xf /linux-soft/2/ansible_soft.tar.gz -C /var/ftp/
[root@localhost ~]# dnf -y install createrepo
[root@localhost ~]# createrepo /var/ftp/ansible_soft/
2)control虚拟机配置YUM，安装软件
[root@control ~]# vim  /etc/yum.repos.d/ansible.repo
[ansible]
name=ansible
baseurl=ftp://192.168.4.254/ansible_soft/
gpgcheck=0
[root@control ~]# dnf  -y  install   ansible
```

被控制节点要求：

- Ansible默认通过SSH协议管理机器
- 被管理主机要开启SSH服务，并允许控制主机登录
- 被管理主机需要安装有Python

**步骤二：修改配置文件**

主配置文件说明：

主配置文件ansible.cfg（主配置文件的内容可以参考/etc/ansible/ansible.cfg）

ansible配置文件查找顺序

首先检测ANSIBLE_CONFIG变量定义的配置文件（默认没有这个变量）

其次检查当前目录下的./ansible.cfg文件

再次检查当前用户家目录下~/ansible.cfg文件

最后检查/etc/ansible/ansible.cfg文件

1) 修改主配置文件。

```shell
[root@control ~]# mkdir  ~/ansible
[root@control ~]# vim  ~/ansible/ansible.cfg
[defaults]
inventory = ~/ansible/inventory            
#主机清单配置文件（inventory可以是任意文件名），英语词汇：inventory（清单、财产清单）
#forks = 5                                    #ssh并发数量
#host_key_checking = False                  #是否校验密钥（第一次ssh时是否提示yes/no）
`
2) 修改主机清单文件（清单文件名必须与主配置文件inventory定义的一致）。
```shell
[root@control ~]# vim  ~/ansible/inventory
[test]                    #定义主机组（组名称任意）
node1                    #定义组中的具体主机，组中包括一台主机node1
[proxy]                    #定义主机组（组名称任意），英语词汇：proxy（代理人，委托人）
node2                      #proxy组中包括一台主机node2
[webserver]
node[3:4]                 #这里的node[3:4]等同于node3和node4
[database]
node5
[cluster:children]        #嵌套组（children为关键字），不需要也可以不创建嵌套组
webserver                  #嵌套组可以在组中包含其他组
database
```

附加思维导图，如图-20所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a30f0af8b68e42a0a723c2d5a2706af3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-20


# Exercise

## 1 Jenkins默认会把GitLab仓库代码下载到哪个目录?

/var/lib/jenkins/workspace/

## 2 如何一条命令将vsftpd设置开启自启并立刻启动？

```shell
# systemctl enable vsftpd  --now
```

## 3 如何校验数据的哈希值（如md5值）？

```shell
# md5sum  <文件名>
```

## 4 Ansible基于什么实现的远程连接远程管理？

ssh

## 5 在ansible主配置文件中，定义主机清单的参数是什么？

inventory


> 如有侵权，请联系作者删除



﻿@[TOC]( Judgment statements & while loops & for loops | Cloud computing )

---

# 1. 判断合法用户

##1.1 问题
编写login2.py脚本，实现以下目标：

1. 提示用户输入用户名和密码
2. 将用户名和密码分别保存在变量中
3. 如果用户名为bob并且密码为123456，则输出Login successful，否则输出Login inorrect

## 1.2 方案

本题主要是复合的判断语句，写法有如下两种：

1. 使用两个判断语句，先判断用户名，如果用户名正确再判断密码是否正确

2. 在一个判断语句中，同时判断两个条件是否全部成立

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

在很多语言中，if后面的判断条件需要使用圆括号或方括号，但是python并不强制，可以直接将判断条件写在if后面，并不会产生错误。

有些时候，判断条件可能有多个（使用and或or连接），为了更好的可读性，建议在这种环境下，将多个条件分别用圆括号括起来。

```shell
[root@localhost day02]# vim login2.py
#!/usr/bin/env python3
username = input('username: ')
password = input('password: ')
if username == 'bob':
    if password == '123456':
        print('Login successful')
    else:
        print('Login incorrect')
else:
    print('Login incorrect')
```

或将上面的代码改为以下写法：

```shell
[root@localhost day02]# vim login2.py
#!/usr/bin/env python3
username = input('username: ')
password = input('password: ')
if username == 'bob' and password == '123456':
    print('Login successful')
else:
    print('Login incorrect')
```

**步骤二：测试脚本执行**

```shell
[root@localhost day02]# python3 login2.py
username: bob
password: 123456
Login successful
[root@localhost day02]# python3 login2.py
username: bob
password: abcd
Login incorrect
[root@localhost day02]# python3 login2.py
username: tom
password: 123456
Login incorrect
```

**步骤三：改进脚本**

脚本程序在运行时，应该将敏感的密码隐藏，不要显示在屏幕上。为了实现这个功能，可以使用getpass模块中的getpass方法。

getpass可以像Linux处理密码一样，屏幕上不出现任何字符，但是用户的输入可以保存到相应的变量中。

上面的代码可以改写为：

```shell
[root@localhost day02]# vim login2.py
#!/usr/bin/env python3
import getpass    #调用该函数可以在命令行窗口里面无回显输入密码
username = input('username: ')
password = getpass.getpass('password: ')
if username == 'bob' and password == '123456':
    print('\033[32;1mLogin successful!\033[0m')        #绿色粗体显示
else:
    print('\033[31;1mLogin incorrect!\033[0m')        #红色粗体显示
```

测试脚本执行：

```shell
[root@localhost day02]# python3 login2.py
username: bob
password: 123456               #此处所填写的密码将不在屏幕上显示
Login successful
[root@localhost day02]# python3 login2.py
username: tom
password: 123456               #此处所填写的密码将不在屏幕上显示
Login incorrect!
```

# 2. 编写判断成绩的程序

## 2.1 问题

编写grade.py脚本，根据用户输入的成绩分档，要求如下：

1. 如果成绩大分60分，输出“及格”
2. 如果成绩大于70分，输出“良”
3. 如果成绩大于80分，输出“好”
4. 如果成绩大于90分，输出“优秀”
5. 否则输出“你要努力了”

## 2.2 方案

本题需要注意的是逻辑顺序。在多分支的if语句中，自顶向下逐步匹配，一旦匹配则执行相应的子语句，其他语句将不再执行。

因此，在编写代码时要注意逻辑，成绩是100分也大于60分，如果把判断较小分数的语句写在前面，那么是凡大于60分的成绩都是输出“及格”，那么只有第一个判断语句会执行，所以应该把分值更高的判断写在上面。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day02]# vim grade.py
#!/usr/bin/env python3
score = int(input('成绩：'))
if score >= 90:
    print('优秀')
elif score >= 80:
    print('好')
elif score >= 70:
    print('良')
elif score >= 60:
    print('及格')
else:
    print('你要努力了！')
```

或将上面的代码改为以下写法：

```shell
score = int(input('成绩：'))
if score >= 60 and score < 70:
    print('及格')
elif 70 <= score < 80:
    print('良')
elif 80 <= score < 90:
    print('好')
elif score >= 90:
    print('优秀')
else:
    print('你要努力了！')
```

**步骤二：测试脚本执行**

```shell
[root@localhost day02]# python3 grade.py
成绩： 59
你要努力了！
[root@localhost day02]# python3 grade.py
成绩： 88
好
[root@localhost day02]# python3 grade.py
成绩： 64
及格
[root@localhost day02]# python3 grade.py
成绩： 75
良
[root@localhost day02]# python3 grade.py
成绩： 97
优秀
```

# 3. 编写石头剪刀布小游戏

## 3.1 问题

编写game.py脚本，实现以下目标：

1. 计算机随机出拳
2. 玩家自己决定如何出拳
3. 代码尽量简化

## 3.2 方案

引用random模块生成0-2的随机数，提示并获取用户的整数输入值，应用if扩展语句对随机数与输入值进行对比判断，满足指定条件，输出结果

为简化代码，玩家获胜条件中用and和or两个逻辑运算符进行多个条件内容的判断，用括号来区分运算优先级，所以用户获胜条件为以下3项中任意一项：

1. 用户输入剪刀并且随机数是布

2. 用户输入石头并且随机数是剪刀

3. 用户输入布并且随机数是石头

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
 [root@localhost day02]# vim game.py 
#!/usr/bin/env python3
import random
#1. 提示并获取用户的输入
player = int(input("请输入 0剪刀 1石头 2布:"))
#2. 让电脑出一个随机数
computer = random.randint(0,2)
#3. 判断用户的输入,然后显示对应的结果
#if 玩家获胜的条件:
if (player==0 and computer==2) or (player==1 and computer==0) or (player==2 and computer==1):
    print("赢了,,,,可以去买奶粉了.....")
#elif 玩家平局的条件:
elif player==computer:
    print("平局了,,,洗洗手决战到天亮....")
else:
    print("输了,,,回家拿钱 再来....")
```

或将上面的代码改为以下写法：

引用random模块choice方法随机生成‘石头’、‘剪刀’、‘布’中任意一项，提示并获取用户的输入字符，应用if扩展语句对随机数与输入值进行对比判断，满足指定条件，输出结果问题结果

```shell
import random
computer = random.choice(['石头', '剪刀', '布'])
player = input('请出拳(石头/剪刀/布)：')
# print('您出了:', player, '计算机出的是:', computer)
print('您出了: %s, 计算机出的是: %s' % (player, computer))
if player == '石头':
    if computer == '石头':
        print('平局')
    elif computer == '剪刀':
        print('You WIN!!!')
    else:
        print('You LOSE!!!')
elif player == '剪刀':
    if computer == '石头':
        print('You LOSE!!!')
    elif computer == '剪刀':
        print('平局')
    else:
        print('You WIN!!!')
else:
    if computer == '石头':
        print('You WIN!!!')
    elif computer == '剪刀':
        print('You LOSE!!!')
    else:
        print('平局')
```

**步骤二：测试脚本执行**

```shell
[root@localhost day02]# python3 game.py
请输入 0剪刀 1石头 2布:1
平局了,,,洗洗手决战到天亮....
[root@localhost day02]# python3 game.py
请输入 0剪刀 1石头 2布:0
赢了,,,,可以去买奶粉了.....
[root@localhost day02]# python3 game.py
请输入 0剪刀 1石头 2布:2
平局了,,,洗洗手决战到天亮....
[root@localhost day02]# python3 game.py
请输入 0剪刀 1石头 2布:1
赢了,,,,可以去买奶粉了.....
[root@localhost day02]# python3 game.py
请输入 0剪刀 1石头 2布:1
输了,,,回家拿钱 再来.... 
[root@localhost day02]# python3 game.py
请出拳(石头/剪刀/布)：石头
您出了: 石头, 计算机出的是: 石头
平局
[root@localhost day02]# python3 game.py
请出拳(石头/剪刀/布)：剪刀
您出了: 剪刀, 计算机出的是: 剪刀
平局
[root@localhost day02]# python3 game.py
请出拳(石头/剪刀/布)：布
您出了: 布, 计算机出的是: 剪刀
You LOSE!!!
[root@localhost day02]# python3 game.py
请出拳(石头/剪刀/布)：石头
您出了: 石头, 计算机出的是: 剪刀
You WIN!!!
```

**步骤三：改进脚本**

执行代码后，在终端显示中，根据提示输入‘石头、剪刀、布’对应数值，通过列表切片获取用户输入字符，引用random模块choice方法电脑随机生成‘石头’、‘剪刀’、‘布’中任意一项字符，将可赢组合放入列表中，如果随机生成电脑值与用户获取字符在可赢列表中，则为可赢组合，输出‘you win’，否则，输出‘you lose’

```shell
import random
all_choices = ['石头', '剪刀', '布']
win_list = [['石头', '剪刀'], ['剪刀', '布'], ['布', '石头']]
prompt = '''(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：'''
computer = random.choice(all_choices)
ind = int(input(prompt))
player = all_choices[ind]
print('您出了: %s, 计算机出的是: %s' % (player, computer))
if player == computer:
    print('\033[32;1m平局\033[0m')
elif [player, computer] in win_list:
    print('\033[31;1mYou WIN!!!\033[0m')
else:
    print('\033[31;1mYou LOSE!!!\033[0m')
```

测试脚本执行：

```shell
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：2
您出了: 布, 计算机出的是: 布
平局
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：1
您出了: 剪刀, 计算机出的是: 剪刀
平局
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：0
您出了: 石头, 计算机出的是: 石头
平局
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：1
您出了: 剪刀, 计算机出的是: 石头
You LOSE!!!
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：2
您出了: 布, 计算机出的是: 剪刀
You LOSE!!!
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：1
您出了: 剪刀, 计算机出的是: 石头
You LOSE!!!
[root@localhost day02]# python3 game2.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2)：0
您出了: 石头, 计算机出的是: 剪刀
You WIN!!!
```

# 4. 完善石头剪刀布小游戏

## 4.1 问题

编写game2.py脚本，实现以下目标：

1. 基于上节game.py程序
2. 实现循环结构，要求游戏三局两胜

## 4.2 方案

用while循环语句让游戏执行3次，在判断输赢之前用if嵌套方式先判断用户输入的值是否合法，如果合法进行输赢判断，如果不合法重新执行循环语句，三次游戏结束后，即循环结束后，用if语句判断赢了几次，赢得次数大于等于2次，获得最终胜利，否则为输

此程序需要注意的部分在于：

1. 要对每次赢局结果进行记录（即赢局次数加1）

2. 每局输赢判断之后，游戏次数一定要加1，否则游戏次数将永无休止

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day02]# vim game2.py
#!/usr/bin/env python3
import random
i = 1            #游戏次数
win = 0        #赢局次数
while i <= 3:
    #1. 提示并获取用户的输入
    player = int(input("请输入 0剪刀 1石头 2布:"))
    
    #2. 让电脑出一个随机数
    computer = random.randint(0,2)
#让用户输入合法
    if player==0 or player==1 or player==2:
        #3. 判断用户的输入,然后显示对应的结果
        if (player==0 and computer==2) or (player==1 and computer==0) or (player==2 and computer==1):
            print("第"+str(i)+"局"+"赢了")
            win += 1    
        elif player==computer:
            print("第"+str(i)+"局"+"平局")
        else:
            print("第"+str(i)+"局"+"输了")
        i += 1
    else:
        print("请重新输入合法数字")
#4. 判断最终猜拳结果：3局两胜    
if win >= 2:
    print("恭喜，你赢了！！")
else: 
    print("你输了！！")  
```

步骤二：测试脚本执行

```shell
[root@localhost day02]# python3 game2.py
请输入 0剪刀 1石头 2布:3
请重新输入合法数字
请输入 0剪刀 1石头 2布:1
第1局赢了
请输入 0剪刀 1石头 2布:2
第2局赢了
请输入 0剪刀 1石头 2布:3
请重新输入合法数字
请输入 0剪刀 1石头 2布:2
第3局平局
恭喜，你赢了！！
```

**步骤三：改进脚本**

```shell
import random
all_choices = ['石头', '剪刀', '布']
win_list = [['石头', '剪刀'], ['剪刀', '布'], ['布', '石头']]
prompt = """(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): """
cwin = 0
pwin = 0
while cwin < 2 and pwin < 2:
    computer = random.choice(all_choices)
    ind = int(input(prompt))
    player = all_choices[ind]
    print("Your choice: %s, Computer's choice: %s" % (player, computer))
    if player == computer:
        print('\033[32;1m平局\033[0m')
    elif [player, computer] in win_list:
        pwin += 1
        print('\033[31;1mYou WIN!!!\033[0m')
    else:
        cwin += 1
        print('\033[31;1mYou LOSE!!!\033[0m')
```

测试脚本执行：

```shell
[root@localhost day02]# python3 game3.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): 1
Your choice: 剪刀, Computer's choice: 剪刀
平局
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): 2
Your choice: 布, Computer's choice: 石头
You WIN!!!
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): 0
Your choice: 石头, Computer's choice: 剪刀
You WIN!!!
[root@localhost day02]# python3 game3.py 
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): 0
Your choice: 石头, Computer's choice: 布
You LOSE!!!
(0) 石头
(1) 剪刀
(2) 布
请选择(0/1/2): 1
Your choice: 剪刀, Computer's choice: 石头
You LOSE!!!
```

# 5. 猜数程序

## 5.1 问题

编写guess.py脚本，实现以下目标：

1. 系统随机生成100以内的数字
2. 要求用户猜生成的数字是多少
3. 最多猜5次，猜对结束程序
4. 如果5次全部猜错，则输出正确结果

## 5.2 方案

引用random模块生成1-100的随机数，用while循环语句让猜数字次数大于0，提示并获取用户输入整数值，在进行猜数字对错判断前先用if嵌套判断方式确定输入值是否合法，如果合法进行猜数字对错判断，判断结束后猜数字次数需减1，如果不合法重新进入循环，此时循环次数不减少

此程序需要注意的部分在于：

每局对错判断之后，猜数字次数一定要减1，这样猜数字次数等于0的时候，循环就结束了

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
 [root@localhost day02]# vim guess.py
#!/usr/bin/env python3
import random
secret = random.randint(1,100)        #生成随机数  
time = 5        #猜数字的次数  
print("---------欢迎来到猜数字的地方，请开始---------")  
while time > 0:  
    guess = int(input("*数字区间0-100，请输入你猜的数字:"))  
    print("你输入数字是：",guess) 
    if 0 <= guess < 100: 
        if guess == secret:  
            print("猜对了，真厉害")  
        else:  
            print("太遗憾了，你猜错了，你还有",time-1,"次机会")  
        time -= 1
    else:
        print("输入非法，请重新输入")  
print("游戏结束，正确的结果是：",secret) 
```

步骤二：测试脚本执行

```shell
[root@localhost day02]# python3 guess.py
---------欢迎来到猜数字的地方，请开始---------
*数字区间0-100，请输入你猜的数字:100
你输入数字是： 100
输入非法，请重新输入
*数字区间0-100，请输入你猜的数字:0
你输入数字是： 0
太遗憾了，你猜错了，你还有 4 次机会
*数字区间0-100，请输入你猜的数字:-1
你输入数字是： -1
输入非法，请重新输入
*数字区间0-100，请输入你猜的数字:12
你输入数字是： 12
太遗憾了，你猜错了，你还有 3 次机会
*数字区间0-100，请输入你猜的数字:34
你输入数字是： 34
太遗憾了，你猜错了，你还有 2 次机会
*数字区间0-100，请输入你猜的数字:56
你输入数字是： 56
太遗憾了，你猜错了，你还有 1 次机会
*数字区间0-100，请输入你猜的数字:89
你输入数字是： 89
太遗憾了，你猜错了，你还有 0 次机会
游戏结束，正确的结果是： 47
```

**步骤三：改进脚本**

```shell
import random
num = random.randint(1, 100)
counter = 0
while counter < 5:
    answer = int(input('guess the number: '))
    if answer > num:
        print('猜大了')
    elif answer < num:
        print('猜小了')
    else:
        print('猜对了')
        break
    counter += 1
else:  # 循环被break就不执行了，没有被break才执行
    print('the number is:', num)
```

测试脚本执行：

```shell
[root@localhost day02]# python3 guess2.py 
猜大了
guess the number: 30
猜小了
guess the number: 50
猜小了
guess the number: 70
猜小了
guess the number: 78
猜小了
the number is: 88
[root@localhost day02]# python3 guess2.py 
guess the number: 16
猜小了
guess the number: 90
猜大了
guess the number: 50
猜大了
guess the number: 30
猜对了
```

# 6. 斐波那契数列

## 6.1 问题

编写fib.py脚本，实现以下目标：

1. 斐波那契数列就是某一个数，总是前两个数之和，比如0，1，1，2，3，5，8
2. 使用for循环和range函数编写一个程序，计算有10个数字的斐波那契数列
3. 改进程序，要求用户输入一个数字，可以生成用户需要长度的斐波那契数列

## 6.2 方案

本题主要是for循环语句，写法有如下两种：

1. 输入一个变量确定列表长度，for循环用内置函数range确定循环次数，利用切片方法将列表fib最后两数之和追加到列表中，每循环一次追加一个值

2. for循环用内置函数range确定循环次数，每循环一次执行：将变量b的值赋值给变量a，并且将a b之和赋值给b，此时，a的新值是前一个b的值，b的新值是前面a b之和，让a成为数列中的值

## 6.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day03]# vim fib.py
#!/usr/bin/env python3
a, b = 0, 1
for i in range(10):
    print(a)
    a, b = b, a + b
```

或将上面的代码改为以下写法：

```shell
[root@localhost day03]# vim fib2.py
#!/usr/bin/env python3
fib = [0, 1]
l = int(input("数列长度: "))
for i in range(l - 2):
    fib.append(fib[-1] + fib[-2])
print(fib)
```

或将上面的代码改为以下写法：

```shell
[root@localhost day03]# vim fib_func.py
#!/usr/bin/env python3
def gen_fib(l):
    fib = [0, 1]
    for i in range(l - len(fib)):
        fib.append(fib[-1] + fib[-2])
    return fib  # 返回列表，不返回变量fib
a = gen_fib(10)
print(a)
print('-' * 50)
n = int(input("length: "))
print(gen_fib(n))  # 不会把变量n传入，是把n代表的值赋值给形参
```

**步骤二：测试脚本执行**

```shell
[root@localhost day03]# python3 fib.py
0
1
1
2
3
5
8
13
21
34
[root@localhost day03]# python3 fib2.py
数列长度: 9
[0, 1, 1, 2, 3, 5, 8, 13, 21]
[root@localhost day03]# python3 fib_func.py 
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
--------------------------------------------------
length: 9
[0, 1, 1, 2, 3, 5, 8, 13, 21]
```

# 7. 九九乘法表

## 7.1 问题

创建mtable.py脚本，要求如下：

1. 程序运行后，可以在屏幕上打印出九九乘法表
2. 修改程序，由用户输入数字，可打印任意数字的乘法表

## 7.2 方案

本题主要用for循环双层嵌套方式编写脚本，需要注意的是：

1. 外层for循环用内置函数range，将1~9范围内的每个数字，依次装入自定义变量i中，此时，变量i被循环赋值9次

2. 内层for循环将1~变量i范围内的每个数字，依次装入变量j中，此时变量j被循环赋值i次，此时外层for循环每循环一次，内层for循环i次

3. 内层for循环range取值节点应是外层变量i加1，这样内层变量j可以取到i的值

4. 程序最后print()相当于回车，每完成一次外部循环，执行回车，作用在于美化执行结果

## 7.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day03]# vim mtable.py
#!/usr/bin/env python3
for i in range(1, 10):            # [0, 1, 2]
    for j in range(1, i+1):         # i->0:[0], i->1: [0, 1], i->2: [0, 1, 2]
        print('%sX%s=%s' % (j, i, i*j), end=' ')
    print()
[root@localhost day03]# vim mtable.py
#!/usr/bin/env python3
i=1
while i<=9:
    j=1
    while j<=i:
        print("%d*%d=%d" % (j,i,j*i),end=" ")
        j+=1
    print("")
    i+=1
```

**步骤二：测试脚本执行**

```shell
[root@localhost day03]# python3 mtable.py
1X1=1 
1X2=2 2X2=4 
1X3=3 2X3=6 3X3=9 
1X4=4 2X4=8 3X4=12 4X4=16 
1X5=5 2X5=10 3X5=15 4X5=20 5X5=25 
1X6=6 2X6=12 3X6=18 4X6=24 5X6=30 6X6=36 
1X7=7 2X7=14 3X7=21 4X7=28 5X7=35 6X7=42 7X7=49 
1X8=8 2X8=16 3X8=24 4X8=32 5X8=40 6X8=48 7X8=56 8X8=64 
1X9=9 2X9=18 3X9=27 4X9=36 5X9=45 6X9=54 7X9=63 8X9=72 9X9=81
```

# Exercise

## 1 x的值为10，y的值为20，用条件表达式如何取出比较大的数字？

```shell
>>> x = 10
>>> y = 20
>>> s = x if x > y else y
>>> print(s)
20
```

## 2 while循环结构中，如果使用各种数据类型作为循环条件，哪些是True，哪些是False？

- 任何值为0的数字都是False，非0数字为True
- 其他数据类型，非空对象为True，空为False

## 3 简述循环语句中break、continue和else的作用？

- break：结束循环，程序将会跳出循环，到循环体下面的语句处继续执行
- continue：结束本次循环，程序将回到循环条件处，如果条件满足继续执行循环
- else：当循环正常结束时执行else的语句，如果循环被break中断，else也将不会执行。

## 4 通过for循环与range函数，打印100以内的奇数

```shell
for i in range(1, 101, 2):
    print(i)
```

> 如有侵权，请联系作者删除



﻿@[TOC]( K8S Resource object management & service and load balancing & Ingress | Cloud computing )

---

# 1. 创建DaemonSet资源文件

## 1.1 问题

本案例要求创建DaemonSet资源文件，具体要求如下：

1. 设置污点策略

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建daemonset资源（在master主机操作）**

1）查看、学习daemonset资源文件（仅查看即可）。

资源文件在云盘第四阶段kubernetes/v1.17.6/config/目录下。

```shell
[root@master ~]# vim mynginx.yaml
---
kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: mynginx
spec:
  selector:
    matchLabels:
      myapp: nginx
  template:
    metadata:
      labels:
        myapp: nginx
    spec:
      containers:
      - name: nginxcluster
        image: 192.168.1.100:5000/myos:nginx
        stdin: false
        tty: false
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl apply -f mynginx.yaml 
daemonset.apps/mynginx created
[root@master ~]# kubectl get pod -o wide
NAME            READY   STATUS    RESTARTS   AGE   IP            NODE
mynginx-77jtf   1/1     Running   0          6s    10.244.3.9    node-0001
mynginx-cwdzt   1/1     Running   0          6s    10.244.1.9    node-0003
mynginx-z2kl6   1/1     Running   0          6s    10.244.2.10   node-0002
[root@master ~]#
```

**步骤二：设置污点策略（在master主机操作）**

1）查看污点标签

污点标签包括：

- NoSchedule 不会被调度
- PreferNoSchedule 尽量不调度
- NoExecute 驱逐节点

```shell
[root@master ~]# kubectl describe node master
... ...
Taints:             node-role.kubernetes.io/master:NoSchedule
... ...
```

2）设置、删除污点标签

注意：可以自定义添加修改标签

注意：不要修改所有系统默认自带的标签

```shell
[root@master ~]# kubectl taint node node-0001 key=value:NoSchedule
# 给node-0001节点设置污点标签，设置NoSchedule标签
[root@master ~]# kubectl taint node node-0001 key-
# 删除node-0001的污点标签
```

**步骤二：设置污点策略（在master主机操作）**

nodeSelector是节点选择约束的最简单推荐形式。

我们可以给节点打上标签，根据标签来选择需要的节点

```shell
查看标签的命令：
[root@master ~]# kubectl  get node --show-labels
设置标签的命令
[root@master ~]# kubectl  label nodes <node-name> <label-key>=<label-value>
删除标签的命令
[root@master ~]# kubectl  label nodes <node-name> <label-key>-
```

污点案例：

```shell
[root@master ~]# kubectl delete -f mynginx.yaml 
daemonset.apps "mynginx" deleted
[root@master ~]# kubectl describe nodes |grep -P "^Taints"
Taints:             node-role.kubernetes.io/master:NoSchedule
Taints:             <none>
Taints:             <none>
Taints:             <none>
[root@master ~]# kubectl taint node node-0001 k1=v1:NoSchedule
node/node-0001 tainted
[root@master ~]# kubectl apply -f mynginx.yaml 
daemonset.apps/mynginx created
[root@master ~]# kubectl get pods
NAME            READY   STATUS    RESTARTS   AGE
mynginx-f2rxh   1/1     Running   0          4s
mynginx-n7xsw   1/1     Running   0          4s
[root@master ~]# kubectl taint node node-0001 k1-
node/node-0001 untainted
[root@master ~]# kubectl get pods
NAME            READY   STATUS    RESTARTS   AGE
mynginx-f2rxh   1/1     Running   0          105s
mynginx-hp6f2   1/1     Running   0          2s
mynginx-n7xsw   1/1     Running   0          105s
[root@master ~]#
```



# 2. 驱逐容器案例

```shell
[root@master ~]# kubectl apply -f myapache.yaml 
deployment.apps/myapache created
[root@master ~]# kubectl scale deployment myapache --replicas=3
deployment.apps/myapache scaled
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE     IP            NODE
myapache-7d689bf8f-xq7l6   1/1     Running   0          2m23s   10.244.3.11   node-0001
myapache-7d689bf8f-b4d5f   1/1     Running   0          9s      10.244.2.14   node-0002
myapache-7d689bf8f-mzcgw   1/1     Running   0          9s      10.244.1.13   node-0003
mynginx-hp6f2              1/1     Running   0          5m25s   10.244.3.10   node-0001
mynginx-f2rxh              1/1     Running   0          7m8s    10.244.2.11   node-0002
mynginx-4f7tl              1/1     Running   0          20s     10.244.1.12   node-0003
[root@master ~]# kubectl taint node node-0003 k1=v1:NoExecute
node/node-0003 tainted
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE     IP            NODE
myapache-7d689bf8f-xq7l6   1/1     Running   0          2m23s   10.244.3.11   node-0001
myapache-7d689bf8f-b4d5f   1/1     Running   0          9s      10.244.2.14   node-0002
myapache-7d689bf8f-mzcgw   1/1     Running   0          9s      10.244.2.15   node-0002
mynginx-hp6f2              1/1     Running   0          5m25s   10.244.3.10   node-0001
mynginx-f2rxh              1/1     Running   0          7m8s    10.244.2.11   node-0002
[root@master ~]# kubectl taint node node-0003 k1-
node/node-0003 untainted
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE     IP            NODE
myapache-7d689bf8f-xq7l6   1/1     Running   0          2m23s   10.244.3.11   node-0001
myapache-7d689bf8f-b4d5f   1/1     Running   0          9s      10.244.2.14   node-0002
myapache-7d689bf8f-mzcgw   1/1     Running   0          9s      10.244.2.15   node-0002
mynginx-hp6f2              1/1     Running   0          5m25s   10.244.3.10   node-0001
mynginx-f2rxh              1/1     Running   0          7m8s    10.244.2.11   node-0002
mynginx-9s9z4              1/1     Running   0          34s     10.244.1.14   node-0003
[root@master ~]#
```



# 3. job和cronjob控制器的创建资源文件

## 4.1 问题

本案例练习书写job和cronjob控制器的资源文件。

1. 熟悉job控制器的资源文件
2. 熟悉cronjob控制器的资源文件

## 4.2 步骤

实现此案例需要按照如下步骤进行。

注意：资源文件在云盘第四阶段kubernetes/v1.17.6/config/目录下。

各位同学需要提前将该目录下的素材下载到master主机。

**步骤一：创建job计划任务控制器（在master主机操作）**

job任务是单任务

```shell
[root@master ~]# vim myjob.yaml
---
apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: 192.168.1.100:5000/myos:v1804
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: OnFailure
[root@master config]# kubectl apply -f myjob.yaml 
job.batch/pi created
[root@master config]# kubectl get job
NAME   COMPLETIONS   DURATION   AGE
pi     1/1           2s         7s
[root@master config]# kubectl get pod
NAME                     READY   STATUS      RESTARTS   AGE
pi-gvfwj                 0/1     Completed   0          15s
# 查看终端结果
[root@master config]# kubectl logs pi-gvfwj
```

**步骤二：创建cronjob计划任务控制器（在master主机操作）**

cronjob任务的本质是多次创建job（周期性计划任务）

```shell
[root@master ~]# vim mycronjob.yaml 
---
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: cronjob-pi
spec:
  schedule: "*/1 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: pi
            image: 192.168.1.100:5000/myos:v1804
            command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
          restartPolicy: OnFailure
[root@master ~]# kubectl apply -f mycronjob.yaml 
cronjob.batch/cronjob-pi created
[root@master ~]# kubectl get cronjobs.batch 
NAME         SCHEDULE           SUSPEND   ACTIVE        LAST SCHEDULE   AGE
cronjob-pi   */1 * * * *        False     0             <none>          10s
[root@master ~]# kubectl get pod
NAME                            READY     STATUS      RESTARTS          AGE
cronjob-pi-1595410620-vvztx     0/1       Completed   0                 62s
```

提示：需要等待 1 分钟才能看到变化。



# 4. 编写service资源文件（一）

## 4.1 问题

本案例要求学习service资源文件，具体要求如下：

1. 创建service服务，访问后端apache
2. 测试负载均衡
3. Headless 服务

## 4.2 方案

注意事项：

今日课程所用到的案例需要依赖前面docker课程中制作的镜像，必须将前面课程中的镜像全部导入到私有仓库（192.168.1.100服务器），镜像列表如下：

busybox:latest

myos:v1804

myos:httpd

myos:php-fpm

myos:nginx

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建service资源（在master主机操作）**

1）创建2副本的Web服务容器

资源文件已经共享在云盘第四阶段kubernetes/v1.17.6/config/apache-example.yaml，各位同学需要提前下载至自己的master主机。

使用资源文件创建一个多部分的容器环境，默认多副本会自动分配到不同的主机上运行。

2）删除一个pod，观察变化

当发现某一个pod不能使用的时候RS会在其他机器上在创建一个相同的pod，及其对应的容器。

```shell
[root@master ~]# kubectl apply -f myapache.yaml 
deployment.apps/myapache created
[root@master ~]# kubectl scale deployment myapache --replicas=2
deployment.apps/myapache scaled
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE   IP            NODE
myapache-7d689bf8f-c268l   1/1     Running   0          13s   10.244.2.16   node-0002
myapache-7d689bf8f-4z225   1/1     Running   0          5s    10.244.1.15   node-0003
[root@master ~]# kubectl delete pod myapache-7d689bf8f-4z225 
pod "myapache-7d689bf8f-4z225" deleted
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE   IP            NODE
myapache-7d689bf8f-c268l   1/1     Running   0          38s   10.244.2.16   node-0002
myapache-7d689bf8f-mccqv   1/1     Running   0          13s   10.244.3.12   node-0001
[root@master ~]#
```

3）service

因为容器随时都也被重建，其IP地址也跟着随机变化，我们如何访问容器呢？

service就是解决这一个问题的方法，service会创建一个cluster ip，service总能找到对应的 pod，且 cluster ip保持不变，如果有pod对应多个容器，service 会自动在多个容器间实现负载均衡。

创建service的资源文件已经共享在云盘第四阶段kubernetes/v1.17.6/config/service-example.yaml，各位同学提前下载该资源文件。

```shell
[root@master ~]# vim clusterip.yaml 
---
kind: Service
apiVersion: v1
metadata:
  name: myapache
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  selector:
    myapp: httpd      # 标签必须与 deploy 资源文件中一致
  type: ClusterIP
[root@master config]# kubectl apply -f clusterip.yaml 
service/myapache created
[root@master config]# kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.254.0.1       <none>        443/TCP   22h
myapache     ClusterIP   10.254.235.248   <none>        80/TCP    4s
```

4）验证效果

Service提供的集群IP，仅可以在集群内可以直接访问服务，但集群外无法访问服务。

下面测试访问使用的集群IP是随机的，不能照抄！！！

```shell
[root@master ~]# kubectl apply -f mypod.yaml 
pod/mypod created
[root@master ~]# kubectl exec -it mypod -- /bin/bash
[root@mypod /]# curl http://10.254.235.248/info.php
<pre>
Array
(
    [REMOTE_ADDR] => 10.244.1.16
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /info.php
)
php_host:     myapache-7d689bf8f-mccqv
1229
[root@mypod /]# curl http://10.254.235.248/info.php
<pre>
Array
(
    [REMOTE_ADDR] => 10.244.1.16
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /info.php
)
php_host:     myapache-7d689bf8f-c268l
1229
[root@mypod /]#
# 在master上执行扩容节点
[root@master ~]# kubectl scale deployment myapache --replicas=3
# 服务本质是LVS规则
[root@master ~]# ipvsadm -L -n
TCP  10.254.235.248:80 rr
  -> 10.244.1.17:80               Masq    1      0          0         
  -> 10.244.2.16:80               Masq    1      0          0         
  -> 10.244.3.12:80               Masq    1      0          0        
-----------------------------------------------------------------------------------------
# 在pod里访问
[root@pod-example /]# curl http://10.254.78.148/info.php
... ...
php_host:     myapache-7d689bf8f-lpt89
... ...
php_host:     myapache-7d689bf8f-mccqv
... ...
php_host:     myapache-7d689bf8f-c268l
```

**步骤二：使用nodeport发布服务（在master主机操作）**

```shell
[root@master ~]# vim mynodeport.yaml 
---
kind: Service
apiVersion: v1
metadata:
  name: mynodeport
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  selector:
    myapp: httpd
  type: NodePort     # 指定服务类型
[root@master ~]# kubectl apply -f mynodeport.yaml 
[root@master ~]# kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
mynodeport   NodePort    10.254.105.233   <none>        80:31410/TCP   4s
#---------------------------所有node节点31410端口均可访问-----------------------------------
# 在跳板机上访问服务
[root@ecs-proxy ~]# curl http://192.168.1.31:31410/info.php
[root@ecs-proxy ~]# curl http://192.168.1.32:31410/info.php
[root@ecs-proxy ~]# curl http://192.168.1.33:31410/info.php
```



# 5. 编写service资源文件（二）

## 5.1 问题

本案例要求创建 headless 服务，具体要求如下：

1. 创建headless服务，并从集群外部测试访问效果

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建nodeport服务（在master主机操作）**

```shell
[root@master ~]# vim myheadless.yaml 
---
kind: Service
apiVersion: v1
metadata:
  name: myheadless
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  selector:
    myapp: httpd
  type: ClusterIP
  clusterIP: None      # 新添加
[root@master ~]# kubectl apply -f myheadless.yaml 
service/myheadless created
[root@master ~]# kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.254.0.1       <none>        443/TCP   22h
myapache     ClusterIP   10.254.235.248   <none>        80/TCP    7m52s
myheadless   ClusterIP   None             <none>        80/TCP    3s
#-----------------------------------进入pod查看解析结果------------------------------------
[root@master ~]# kubectl exec -it pod-example -- /bin/bash
[root@mypod /]# yum install -y bind-utils
[root@mypod /]# host myheadless.default.svc.cluster.local
myheadless.default.svc.cluster.local has address 10.244.3.12
myheadless.default.svc.cluster.local has address 10.244.1.17
myheadless.default.svc.cluster.local has address 10.244.2.16
```



# 6. 对外发布服务

## 6.1 问题

本案例主要练习ingress控制器，分别实现以下目标：

1. 安装配置ingress控制器
2. 通过ingress向外发布服务

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装ingress控制器（在master主机操作操作）**

ingress控制器对应的镜像文件已经共享在云盘第四阶段kubernetes/v1.17.6/ingress/ingress-nginx.tar.gz。各位同学需要提前下载。

1) 首先需要将ingress镜像上传至私有镜像仓库（192.168.1.100服务器）

```shell
[root@master ~]# docker load -i ingress-nginx.tar.gz
[root@master ~]# docker tag  quay.io/kubernetes-ingress-controller/nginx-ingress-controller  192.168.1.100:5000/nginx-ingress-controller:0.30.0
[root@master ~]# docker push 192.168.1.100:5000/nginx-ingress-controller:0.30.0
```

2) 验证仓库

```shell
[root@master ~]#curl http://192.168.1.100:5000/v2/nginx-ingress-controller/tags/list
{"name":"nginx-ingress-controller","tags":["0.30.0"]}
[root@master ~]# kubectl apply -f httpd-example-v1.yaml 
deployment.apps/web-example configured
```

3) 创建ingress资源

资源文件已经共享在云盘第四阶段kubernetes/v1.17.6/ingress/目录下，各位同学需要自行下载该资源文件，并需要修改该文件才可以使用。

修改资源文件mandatory.yaml，指定启动ingress容器时应该从私有仓库下载镜像，而默认指定的是官网。

```shell
[root@master ~]# vim ingress/mandatory.yaml            #修改镜像文件image的路径
221:  image: 192.168.1.100:5000/nginx-ingress-controller:0.30.0
[root@master ~]# kubectl create -f ingress/mandatory.yaml       #创建资源
namespace/ingress-nginx created
[root@master ~]# kubectl -n ingress-nginx  get  pod              #查看资源
NAME                                              READY       STATUS     RESTARTS   AGE
nginx-ingress-controller-fc6766d7-xtsp2       1/1         Running    0              50m
```

**步骤二：通过ingress对外发布容器服务（在master主机操作操作）**

1）创建资源，通过ingress映射内部服务

```shell
[root@master ~]# vim  ingress-example.yaml
---
apiVersion: extensions/v1beta1
kind: Ingress                            # 资源对象类型
metadata:
  name: my-app                        # ingress 资源名称
  annotations:
    kubernetes.io/ingress.class: "nginx"
spec:
  backend:                            # 后端服务
    serviceName: apache-service        # service 名称，需要查看之前实验创建的名称
    servicePort: 80                    # 服务端口号，是服务的 Port 
#注意：这里的apache-service是前面实验创建的service的名称
#前面service创建的集群IP只能在内部访问，现在通过inpress映射service
#用户访问ingress生成的IP就会自动映射到service的集群IP，集群IP再映射到容器IP
[root@master ~]# kubectl apply -f ingress-example.yaml
```

2）验证效果

```shell
[root@master ~]# kubectl  get  ingress       #查看ingress资源，查看inpressIP地址
NAME          HOSTS         ADDRESS          PORTS         AGE
my-app           *            192.168.1.31      80            16s
------------------------------------------------------------------------------
[root@localhost ~]# curl http://192.168.1.31           #现在，任意主机都可以访问服务
<pre>
Array
(
    [REMOTE_ADDR] => 10.244.6.1
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /
)
php_host:     apache-example-9d8577cf-lw74h
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Kali system & scanning and packet capture & SSH basic protection & service security | Cloud computing )

---

# 1. 扫描与抓包分析

## 1.1 问题

本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：

1. 使用nmap扫描来获取指定主机/网段的相关信息
2. 使用nmap执行脚本扫描
3. 使用tcpdump分析FTP访问中的明文交换信息

## 1.2 方案

Kali是基于Debian的Linux发行版，Kali Linux包含上百个安全相关工具

如：渗透测试、安全检测、密码安全、反向工程等，官网：kali.org。

准备实验环境，在真机执行命令命令初始化虚拟机。

**重要提示：kali虚拟机用户名为kali，密码为kali。**

```shell
#kali reset                    #初始化虚拟机
#virt-manager                  #打开kvm虚拟机管理器
```

修改网卡配置，《网络源》选择《private1：隔离网络》如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/06c86cc901a144d98aeeec6b2b7fdd81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

给kali虚拟机配置IP地址：

```shell
$ ip  a  s                      #查看网卡设备名称（设备名）
$ nmcli  connection  show     #查看网络连接名称（网卡名）
#注意：仔细区分网卡名和设备名称，两个名称有可能不一致(正常情况),配置IP时注意！！！
$ sudo nmcli connection modify "Wired connection 1" \
ipv4.method manual \
ipv4.addr 192.168.4.40/24 \
autoconnect yes
#配置IP地址，autoconnect设置网卡开机自动激活
#\代表换行符
$ sudo nmcli connection up "Wired connection 1" 
```

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用NMAP扫描来获取指定主机/网段的相关信息**

1）基本用法

```shell
基本用法：
# nmap  [扫描类型]  [选项]  <扫描目标 ...>
#常用的扫描类型
# -sS，TCP SYN扫描（半开）
# -sT，TCP 连接扫描（全开）
# -sU，UDP扫描
# -sP，ICMP扫描
# -A，目标系统全面分析
```

下面的实验请根据自己的实际情况进行测试，每个人的IP地址可能不一样！

2）检查192.168.4.5主机是否可以ping通（这里假设有192.168.4.5主机）

```shell
[kali@kali ~]$ sudo nmap  -sP  192.168.4.5
Starting Nmap 6.40 ( http://nmap.org ) at 2028-06-06 21:59 CST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for host3 (192.168.4.5)
Host is up (0.00036s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds
```

使用-n选项可以不执行DNS解析

```shell
[kali@kali ~]$ sudo nmap -n -sP  192.168.4.5
Starting Nmap 6.40 ( http://nmap.org ) at 2028-06-06 22:00 CST
Nmap scan report for 192.168.4.5
Host is up (0.00046s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.03 seconds
```

3）检查192.168.4.0/24网段内哪些主机可以ping通

[kali@kali ~]$ sudo nmap  -n  -sP  192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2027-05-17 18:01 CST
Nmap scan report for 192.168.4.5
Host is up.
Nmap scan report for 192.168.4.7
Host is up.
Nmap scan report for 192.168.4.120
Host is up (0.00027s latency).
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for 192.168.4.110
Host is up (0.00016s latency).
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00046s latency).
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 3.57 seconds

```
4）检查目标主机所开启的TCP服务
```shell
[kali@kali ~]$ sudo nmap -sT 192.168.4.254
Starting Nmap 5.51 ( http://nmap.org ) at 2028-05-17 17:55 CST
Nmap scan report for 192.168.4.254
Host is up (0.00028s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
25/tcp  open  smtp
80/tcp  open  http
110/tcp open  pop3
111/tcp open  rpcbind
143/tcp open  imap
443/tcp open  https
993/tcp open  imaps
995/tcp open  pop3s
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 1.31 seconds
```

5）检查192.168.4.0/24网段内哪些主机开启了FTP、SSH服务

```shell
[kali@kali ~]$ sudo nmap -p 21-22 192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2027-05-17 18:00 CST
Nmap scan report for 192.168.4.5
Host is up (0.000025s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
Nmap scan report for 192.168.4.7
Host is up.
PORT   STATE    SERVICE
21/tcp filtered ftp
22/tcp filtered ssh
Nmap scan report for 192.168.4.120
Host is up (0.00052s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for pc110.tarena.com (192.168.4.110)
Host is up (0.00038s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00051s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 4.88 seconds
```

6）检查目标主机所开启的UDP服务

```shell
[kali@kali ~]$ sudo nmap   -sU  192.168.4.5                #指定-sU扫描UDP
53/udp   open          domain
111/udp  open          rpcbind
```

7）全面分析目标主机192.168.4.100和192.168.4.5的操作系统信息

```shell
[kali@kali ~]$ sudo nmap -A 192.168.4.100,5
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:03 CST
Nmap scan report for 192.168.4.100                      #主机mail的扫描报告
Host is up (0.0016s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE  VERSION
21/tcp  open  ftp      vsftpd 2.2.2
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| -rw-r--r--    1 0        0            1719 Aug 17 13:33 UserB.pub
| -rw-r--r--    1 0        0             122 Aug 13 05:27 dl.txt
| drwxr-xr-x    2 14       0            4096 Aug 13 09:07 pub
| -rw-rw-r--    1 505      505           170 Aug 17 13:18 tools-1.2.3.tar.gz
|_-rw-rw-r--    1 505      505           287 Aug 17 13:22 tools-1.2.3.tar.gz.sig
22/tcp  open  ssh      OpenSSH 5.3 (protocol 2.0)
| ssh-hostkey: 1024 86:be:d6:89:c1:2d:d9:1f:57:2f:66:d1:af:a8:d3:c6 (DSA)
|_2048 16:0a:15:01:fa:bb:91:1d:cc:ab:68:17:58:f9:49:4f (RSA)
25/tcp  open  smtp     Postfix smtpd
80/tcp  open  http     Apache httpd 2.4.10 ((Red Hat))
|_http-methods: No Allow or Public header in OPTIONS response (status code 302)
| http-title: 302 Found
|_Did not follow redirect to https://192.168.4.100//
110/tcp open  pop3     Dovecot pop3d
|_pop3-capabilities: USER CAPA UIDL TOP OK(K) RESP-CODES PIPELINING STLS SASL(PLAIN)
111/tcp open  rpcbind
MAC Address: 00:0C:29:74:BE:21 (VMware)
No exact OS matches for host (If you know what OS is running on it, see http://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=5.51%D=8/19%OT=21%CT=1%CU=34804%PV=Y%DS=1%DC=D%G=Y%M=000C29%TM=52
OS:11ED90%P=x86_64-redhat-linux-gnu)SEQ(SP=106%GCD=1%ISR=10B%TI=Z%CI=Z%II=I
OS:%TS=A)OPS(O1=M5B4ST11NW6%O2=M5B4ST11NW6%O3=M5B4NNT11NW6%O4=M5B4ST11NW6%O
OS:5=M5B4ST11NW6%O6=M5B4ST11)WIN(W1=3890%W2=3890%W3=3890%W4=3890%W5=3890%W6
OS:=3890)ECN(R=Y%DF=Y%T=40%W=3908%O=M5B4NNSNW6%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O
OS:%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=
OS:0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%
OS:S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(
OS:R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=
OS:N%T=40%CD=S)
Network Distance: 1 hop
Service Info: Host:  mail.tarena.com; OS: Unix
TRACEROUTE
HOP RTT     ADDRESS
1   1.55 ms 192.168.4.100
```

**步骤二：使用nmap执行脚本扫描**

1）准备一台Vsftpd服务器（192.168.4.5主机操作）

```shell
[root@proxy ~]# yum -y install vsftpd
[root@proxy ~]# systemctl restart vsftpd
[root@proxy ~]# useradd  tom
[root@proxy ~]# echo 123 | passwd --stdin tom
```

2）FTP相关扫描脚本（在kali主机操作）

相关脚本存放目录：/usr/share/nmap/scripts/。

```shell
[kali@kali ~]$ sudo nmap  --script=ftp-anon.nse  192.168.4.5  -p 21
#匿名访问扫描
[kali@kali ~]$ sudo nmap  --script=ftp-syst.nse  192.168.4.5  -p  21
#扫描ftp软件相关信息（如版本号，是否有带宽限制，超时时间等）
[kali@kali ~]$ sudo nmap  --script=ftp-vsftpd-backdoor.nse 192.168.4.5  -p 21
#后门扫描
[kali@kali ~]$ sudo nmap  --script=ftp-brute.nse  192.168.4.5  -p 21
#暴力破解密码
```

3）SSH相关扫描（在kali主机操作）

```shell
[kali@kali ~]$ sudo nmap  --script=ssh-brute.nse 192.168.4.5 -p 22
#暴力破解ssh密码
[kali@kali ~]$ sudo vi /tmp/users.lst                  #新建文件，存储账户信息
root
tom
[kali@kali ~]$ sudo vi /tmp/pass.lst                   #新建文件，存储密码信息
123456
654321
[kali@kali ~]$ sudo nmap  --script=ssh-brute.nse \
--script-args userdb=/tmp/users.lst,passdb=/tmp/pass.lst  192.168.4.5 -p 22
#使用自己创建的账户和密码本暴力破解ssh密码
```

在192.168.4.5主机可以查看日志

```shell
[root@proxy ~]# tail  /var/log/secure                   #查看日志
```

4）HTTP相关扫描（kali主机操作）

这里假设192.168.4.5有http服务。

```shell
[kali@kali ~]$ sudo nmap  --script=http-methods.nse  192.168.4.5  -p 80
#请求方法扫描（如get，post，header等）
[kali@kali ~]$ sudo nmap  --script=http-sql-injection.nse 192.168.4.5  -p  80
#SQL注入扫描
```

备注：SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。

SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。

5）SMB相关扫描（kali主机操作）

这里假设有一台windows主机192.168.137.4。

```shell
[kali@kali ~]$ sudo nmap --script=smb-brute.nse 192.168.137.4
[kali@kali ~]$ sudo nmap --script=smb-brute.nse  \
--script-args=userdb=/密码本,passdb=/密码本  192.168.137.4  
```

6）暴力破解密码（kali主机操作）

```shell
$ sudo   john  --single  /etc/shadow              #破解傻瓜式密码
$ sudo   john   /etc/shadow                       #字典暴力破解（随时ctrl+c终止）
$ sudo   john  --wordlist=密码本   /etc/shadow   #使用自定义密码本破解
$ sudo   john  --show  /etc/shadow                #显示破解的密码
```

**步骤三：使用tcpdump分析FTP访问中的明文交换信息**

1）启用tcpdump命令行抓包（kali虚拟机操作）

执行tcpdump命令行，添加适当的过滤条件，只抓取访问主机192.168.4.5的21端口的数据通信 ，并转换为ASCII码格式的易读文本。

这里假设，192.168.4.5主机有vsftpd服务，如果没有需要提前安装并启动服务！！！

警告：案例中所有抓包命令都没有指定网卡，每位同学需要根据实际情况指定抓包网卡的名称。

```shell
[kali@kali ~]$ sudo tcpdump -i 网卡名称 -A host 192.168.4.5 and tcp port 21
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
.. ..                                            #进入等待捕获数据包的状态
#监控选项如下：
# -i，指定监控的网络接口（默认监听第一个网卡）
# -A，转换为 ACSII 码，以方便阅读
# -w，将数据包信息保存到指定文件
# -r，从指定文件读取数据包信息
#tcpdump的过滤条件：
# 类型：host（主机）、net（网段）、port（端口）、portrange（端口范围）
# 方向：src（源地址）、dst（目标地址）
# 协议：tcp、udp、ip、wlan、arp、……
# 多个条件组合：and、or、not
```

3）执行FTP访问，并观察tcpdump抓包结果

从kali主机访问主机192.168.4.5的vsftpd服务。

```shell
[kali@kali ~]$ ftp 192.168.4.5
Connected to 192.168.4.5 (192.168.4.5).
220 (vsFTPd 3.0.2)
Name (192.168.4.5:root): tom       #输入用户名
331 Please specify the password.
Password:                              #输入密码
530 Login incorrect.
Login failed.
ftp>quit                               #退出
```

观察抓包的结果（在kali主机观察tcpdump抓包的结果）：

```shell
[kali@kali ~]$
... …
18:47:27.960530 IP 192.168.2.100.novation > 192.168.4.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER tom
18:47:29.657364 IP 192.168.2.100.novation > 192.168.4.5.ftp: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS 123
```

4)再次使用tcpdump抓包，使用-w选项可以将抓取的数据包另存为文件，方便后期慢慢分析。

```shell
[kali@kali ~]$ sudo tcpdump  -i 网卡名称  -A  -w  ftp.cap  \
host 192.168.4.5  and  tcp  port  21                            #抓包并保存
```

tcpdump命令的-r选项，可以去读之前抓取的历史数据文件

```shell
[kali@kali ~]$ sudo tcpdump  -A  -r  ftp.cap | egrep  '(USER|PASS)'    #分析数据包
.. ..
E..(..@.@.. ...x...d.*..G.\c.1BbP.............
18:47:25.967592 IP 192.168.2.5.ftp > 192.168.2.100.novation: Flags [P.], seq 1:21, ack 1, win 229, length 20
E..<FJ@.@.jE...d...x...*.1BbG.\cP...V...220 (vsFTPd 2.2.2)
… …
18:47:27.960530 IP 192.168.2.100.novation > 192.168.2.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER tom
… …
18:47:27.960783 IP 192.168.2.5.ftp > 192.168.2.100.novation: Flags [P.], seq 21:55, ack 14, win 229, length 34
E..JFL@.@.j5...d...x...*.1BvG.\pP...i~..331 Please specify the password.
… …
18:47:29.657364 IP 192.168.2.5.ftp > 192.168.2.100.novation: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS 123
… …
18:47:29.702671 IP 192.168.2.100.novation > 192.168.2.5.ftp: Flags [P.], seq 55:78, ack 27, win 229, length 23
E..?FN@.@.j>...d...x...*.1B.G.\}P.......230 Login successful.
```

# 2. 加固常见服务的安全

## 2.1 问题

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：

1. 优化Nginx服务的安全配置

## 2.2 方案

Nginx安全优化包括：修改版本信息、限制并发、拒绝非法请求、防止buffer溢出。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：优化Nginx服务的安全配置**

1） 修改版本信息，并隐藏具体的版本号

默认Nginx会显示版本信息以及具体的版本号，这些信息给攻击者带来了便利性，便于他们找到具体版本的漏洞。

如果需要屏蔽版本号信息，执行如下操作，可以隐藏版本号。

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
     server_tokens off;                            #在http下面手动添加这么一行
     … …
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
[root@proxy ~]# curl -I http://192.168.4.5          #查看服务器响应的头部信息
```

2） 限制并发量

DDOS攻击者会发送大量的并发连接，占用服务器资源（包括连接数、带宽等），这样会导致正常用户处于等待或无法访问服务器的状态。

Nginx提供了一个ngx_http_limit_req_module模块，可以有效降低DDOS攻击的风险，操作方法如下：

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        listen 80;
        server_name localhost;
        limit_req zone=one burst=5;
            }
}
#备注说明：
#limit_req_zone语法格式如下：
#limit_req_zone key zone=name:size rate=rate;
#上面案例中是将客户端IP信息存储名称为one的共享内存，内存空间为10M
#1M可以存储8千个IP信息，10M可以存储8万个主机连接的状态，容量可以根据需要任意调整
#每秒中仅接受1个请求，多余的放入漏斗
#漏斗超过5个则报错
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

客户端使用ab测试软件测试效果：

```shell
[root@client ~]# ab -c 100 -n 100  http://192.168.4.5/
```

3） 拒绝非法的请求

网站使用的是HTTP协议，该协议中定义了很多方法，可以让用户连接服务器，获得需要的资源。但实际应用中一般仅需要get和post。

具体HTTP请求方法的含义如表-1所示。

表-1 HTTP请求方法及含义
![在这里插入图片描述](https://img-blog.csdnimg.cn/01c9918361ec4893bf54bb10281d2911.png)
未修改服务器配置前，客户端使用不同请求方法测试：

```shell
[root@client ~]# curl -i -X GET  http://192.168.4.5            #正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            #正常
#curl命令选项说明：
#-i选项：访问服务器页面时，显示HTTP的头部信息
#-X选项：指定请求服务器的方法
```

通过如下设置可以让Nginx拒绝非法的请求方法：

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
       server {
                 listen 80;
#这里，!符号表示对正则取反，~符号是正则匹配符号
#如果用户使用非GET或POST方法访问网站，则retrun返回错误信息
              if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }    
        }
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

修改服务器配置后，客户端使用不同请求方法测试：

```shell
[root@client ~]# curl -i -X GET  http://192.168.4.5            #正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            #报错
```

4） 防止buffer溢出

当客户端连接服务器时，服务器会启用各种缓存，用来存放连接的状态信息。

如果攻击者发送大量的连接请求，而服务器不对缓存做限制的话，内存数据就有可能溢出（空间不足）。

修改Nginx配置文件，调整各种buffer参数，可以有效降低溢出风险。

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
client_body_buffer_size  1k;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;
 … …
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

# 3. Linux基本防护措施

## 3.1 问题

本案例要求练习Linux系统的基本防护措施，完成以下任务：

1. 修改用户zhangsan的账号属性，设置为2019-12-31日失效（禁止登录）
2. 临时锁定用户lisi的账户，使其无法登录，验证效果后解除锁定
3. 修改tty终端提示，使得登录前看到的第一行文本为“Windows Server 2012 Enterprise R2”，第二行文本为“NT 6.2 Hybrid”
4. 锁定文件/etc/resolv.conf、/etc/hosts，以防止其内容被无意中修改
5. 关闭不需要的服务

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改用户zhangsan的账户属性，设置为2019-12-31日失效（禁止登录）**

1）正常情况下，未过期的账号可以正常登录，使用chage可以修改账户有效期。

```shell
chage命令的语法格式：
chage -l    账户名称                #查看账户信息
chage -E 时间 账户名称                #修改账户有效期
```

2）失效的用户将无法登录

使用chage命令将用户zhangsan的账户设为当前已失效（比如已经过去的某个时间）：

```shell
[root@proxy ~]# useradd zhangsan        #创建账户
[root@proxy ~]# passwd zhangsan        #设置密码
[root@proxy ~]# chage -E 2017-12-31 zhangsan    #设置账户过期时间
```

尝试以用户zhangsan重新登录，输入正确的用户名、密码后直接闪退，返回登录页，说明此帐号已失效。

3）重设用户zhangsan的属性，将失效时间设为2019-12-31

```shell
[root@proxy ~]# chage -E 2019-12-31 zhangsan              #修改失效日期
[root@proxy ~]# chage -l zhangsan                        #查看账户年龄信息
Last password change                     : May 15, 2017
Password expires                       : never
Password inactive                       : never
Account expires                          : Dec 31, 2019
Minimum number of days between password change          : 0
Maximum number of days between password change           : 99999
Number of days of warning before password expires         : 7
```

4）重设用户zhangsan的属性，将失效时间设为永不过期

```shell
[root@proxy ~]# chage -E -1 zhangsan               #设置账户永不过期
```

5）定义默认有效期（扩展知识）

/etc/login.defs这个配置文件，决定了账户密码的默认有效期。

```shell
[root@proxy ~]# cat /etc/login.defs
PASS_MAX_DAYS    99999                        #密码最长有效期
PASS_MIN_DAYS    0                            #密码最短有效期
PASS_MIN_LEN    5                            #密码最短长度
PASS_WARN_AGE    7                            #密码过期前几天提示警告信息
UID_MIN                  1000                #UID最小值
UID_MAX                  60000                #UID最大值
```

**步骤二：临时锁定用户zhangsan的账户，使其无法登录，验证效果后解除锁定**

1）锁定用户账号

使用passwd或usermod命令将用户zhangsan的账户锁定。

```shell
[root@proxy ~]# passwd -l zhangsan           #锁定用户账号（lock）
锁定用户 zhangsan 的密码。
passwd: 操作成功
[root@proxy ~]# passwd -S zhangsan          #查看状态（status）
zhangsan LK 2018-02-22 0 99999 7 -1 (密码已被锁定。)
```

2）验证用户zhangsan已无法登录，说明锁定生效

输入正确的用户名、密码，始终提示“Login incorrect”，无法登录。

3）解除对用户zhangsan的锁定

```shell
[root@proxy ~]# passwd -u zhangsan           #解锁用户账号（unlock）
解锁用户 zhangsan 的密码 。
passwd: 操作成功
[root@proxy ~]# passwd -S zhangsan          #查看状态
zhangsan PS 2018-08-14 0 99999 7 -1 (密码已设置，使用 SHA512 加密。)
```

**步骤三：修改tty登录的提示信息，隐藏系统版本**

1）账户在登录Linux系统时，默认会显示登陆信息（包括操作系统内核信息）

/etc/issue这个配置文件里保存的就是这些登陆信息，修改该文件防止内核信息泄露。

```shell
[root@proxy ~]# cat /etc/issue                      #确认原始文件
Red Hat Enterprise Linux Server release 7.5
Kernel \r on an \m
[root@proxy ~]# cp /etc/issue /etc/issue.origin      #备份文件
[root@proxy ~]# vim /etc/issue                      #修改文件内容
Windows Server 2012 Enterprise R2
NT 6.2 Hybrid
```

2）测试版本伪装效果

退出已登录的tty终端，或者重启Linux系统，刷新后的终端提示信息会变成自定义的文本内容，如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/621171ebb7c84fd0a490233b8ab1f531.png)
图-1

**步骤四：锁定文件/etc/resolv.conf、/etc/hosts**

1）语法格式：

```shell
# chattr +i  文件名            #锁定文件（无法修改、删除、追加等）
# chattr -i  文件名            #解锁文件
# chattr +a  文件名            #锁定后文件仅可追加
# chattr -a  文件名            #解锁文件
# lsattr 文件名                #查看文件特殊属性
···
2) 使用+i锁定文件，使用lsattr查看属性
```shell
[root@proxy ~]# chattr +i /etc/resolv.conf 
[root@proxy ~]# lsattr /etc/resolv.conf 
----i---------- /etc/resolv.conf
```

3）使用+a锁定文件(仅可追加)，使用lsattr查看属性

```shell
[root@proxy ~]# chattr +a /etc/hosts
[root@proxy ~]# lsattr /etc/hosts
-----a---------- /etc/hosts
```

4）测试文件锁定效果

```shell
[root@proxy ~]# rm -rf /etc/resolv.conf
rm: 无法删除"/etc/resolv.conf": 不允许的操作
[root@proxy ~]# echo xyz > /etc/resolv.conf
-bash: resolv.conf: 权限不够
[root@proxy ~]# rm -rf  /etc/hosts                         #失败
[root@proxy ~]# echo "192.168.4.1  xyz" > /etc/hosts     #失败
[root@proxy ~]# echo "192.168.4.1  xyz" >> /etc/hosts    #成功
```

5）恢复这两个文件原有的属性（避免对后续实验造成影响）

```shell
[root@proxy ~]# chattr -i /etc/resolv.conf 
[root@proxy ~]# chattr -i /etc/hosts
[root@proxy ~]# lsattr /etc/resolv.conf /etc/hosts
--------------- /etc/resolv.conf
--------------- /etc/hosts
```

附加思维导图，如图-5所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/09fd193b7f484d00943698916c174895.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5


# Exercise

## 1 阅读下列nmap扫描操作，根据注释的功能要求在括号中补全命令选项

> ```shell
> [root@svr7 ~]# nmap  -（  ）  svr7.tarena.com              //扫描开启的UDP服务
> 53/udp   open          domain
> [root@svr7 ~]# nmap  -（  ）  （    ）  192.168.4.0/24      //扫描哪些主机开放FTP、SSH
> [root@svr7 ~]# nmap  -（    ）  192.168.4.110               //扫描操作系统类型
> ```

```shell
[root@svr7 ~]# nmap   -（sU）  svr7.tarena.com              //扫描开启的UDP服务
53/udp   open          domain
[root@svr7 ~]# nmap  -（p）  （21-22）  192.168.4.0/24      //扫描哪些主机开放FTP、SSH
[root@svr7 ~]# nmap  -（A）  192.168.4.110               //扫描操作系统类型
```

## 2 简述ngx_http_limit_req_module模块的用法？

```shell
limit_req_zone $binary_remote_addr  zone=one:10m rate=1r/s;
limit_req zone=one burst=5;
语法：limit_req_zone key zone=name:size rate=rate;
将客户端IP信息存储名称为one的共享内存，空间为10M
1M可以存储8千个IP的信息，10M存8万个主机状态
每秒中仅接受1个请求，多余的放入漏斗
漏斗超过5个则报错
```

## 3 配置新建用户时的属性限制

对于新创建的用户，要求其密码最长使用时间为60天，密码最短使用时间为1天，在密码过期前7天内发出警告。

```shell
[root@svr5 ~]# vim /etc/login.defs
PASS_MAX_DAYS   60
PASS_MIN_DAYS   1
PASS_WARN_AGE   7
```

## 4 如何锁定解锁Linux用户的密码

```shell
[root@svr5 ~]# passwd -l  用户名
[root@svr5 ~]# passwd -u  用户名
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Keepalived highly available & Ceph deployed distributed storage | Cloud computing )

---

# 1. Keepalived高可用

## 1.1 问题

部署两台代理服务器，实现如下效果：

- 利用keepalived实现两台代理服务器的高可用
- 配置VIP为192.168.4.80
- 修改对应的域名解析记录

## 1.2 方案

实验拓扑如图-1所示，做具体实验前请先配置好环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/85b5ce30ee73454686e71f24c0a35270.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-1

备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。

主机配置如表-1所示。

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/f2ae855cc6de41c3ae616a51f9aacf23.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置第二台代理服务器**

1）部署HAProxy

安装软件，手动修改配置文件，添加如下内容。

```shell
[root@proxy2 ~]# yum -y install haproxy 
[root@proxy2 ~]# vim /etc/haproxy/haproxy.cfg
listen wordpress *:80        #监听80端口
  balance roundrobin        #轮询算法
  server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
  server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
  server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
[root@proxy2 ~]# systemctl start haproxy
[root@proxy2 ~]# systemctl enable haproxy
[root@proxy2 ~]# firewall-cmd --set-default-zone=trusted
[root@proxy2 ~]# setenforce  0
[root@proxy2 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

**步骤二：为两台代理服务器配置keepalived**

1）配置第一台代理服务器proxy（192.168.4.5）。

```shell
[root@proxy ~]# yum install -y keepalived
[root@proxy ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  proxy1                #设置路由ID号
  vrrp_iptables                    #设置防火墙规则（手动添加该行）
}
vrrp_instance VI_1 {
  state MASTER                         #主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    #网卡名称（不能照抄网卡名）
  virtual_router_id 51                
  priority 100                     #服务器优先级,优先级高优先获取VIP（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                #主备服务器密码必须一致
  }
  virtual_ipaddress {                #谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80 
}    
}
[root@proxy ~]# systemctl start keepalived
[root@proxy ~]# systemctl enable keepalived
```

2）配置第二台代理服务器proxy（192.168.4.6）。

```shell
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  proxy2                        #设置路由ID号
vrrp_iptables                               #设置防火墙规则（手动添加该行）
}
vrrp_instance VI_1 {
  state BACKUP                         #主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    #网卡名称（不能照抄网卡名）
  virtual_router_id 51                
  priority 50                         #服务器优先级,优先级高优先获取VIP
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       #主备服务器密码必须一致
  }
  virtual_ipaddress {                   #谁是主服务器谁获得该VIP
192.168.4.80 
}    
}
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# systemctl enable keepalived
```

**步骤三：修改DNS服务器**

1）修改网站域名对应的解析记录，解析到新的VIP地址。

192.168.4.5为DNS服务器，DNS配置文件相关知识请参考第一阶段课程。

```shell
[root@proxy ~]# vim /var/named/lab.com.zone
$TTL 1D
@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns.lab.com.
dns     A       192.168.4.5
www     A       192.168.4.80
```

2）重启DNS服务

```shell
[root@proxy ~]# systemctl restart named
```

# 2. 部署Ceph分布式存储

## 2.1 问题

部署Ceph分布式存储，实现如下效果：

- 使用三台服务器部署Ceph分布式存储
- 实现Ceph文件系统共享
- 将网站数据从NFS迁移到Ceph存储

## 2.2 方案

实验拓扑如图-2所示，做具体实验前请先配置好环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7235f82ba38a4f33aef22add7d07b6a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2
![在这里插入图片描述](https://img-blog.csdnimg.cn/db5af21690a64063a17558c315ada996.png)

备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。

主机配置如表-2所示。

表-2
![在这里插入图片描述](https://img-blog.csdnimg.cn/608b230403d2429984b458a09e7067f3.png)

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备实验环境**

1）把3台虚拟机全部关机,添加光盘和磁盘:

每台虚拟机都添加一个光驱；

做如下相同操作:

右击虚拟机,选【设置】---【添加】---【CD|DVD驱动器】--【完成】；

点击刚刚新建的光盘[CD|DVD],勾选使用ISO映像文件--[浏览]；

找到自己真机的ceph10.iso加载即可。

添加磁盘：所有3台ceph服务器都添加2块20G磁盘。

启动所有虚拟机后，查看磁盘情况:

```shell
    [root@node1 ~]# lsblk
    [root@node2 ~]# lsblk
    [root@node3 ~]# lsblk
```

所有主机设置防火墙和SELinux

```shell
[root@node1 ~]# firewall-cmd --set-default-zone=trusted
[root@node1 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node1 ~]# setenforce 0
[root@node2 ~]# firewall-cmd --set-default-zone=trusted
[root@node2 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node2 ~]# setenforce 0
[root@node3 ~]# firewall-cmd --set-default-zone=trusted
[root@node3 ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@node3 ~]# setenforce 0
```

2）所有主机挂载ceph光盘和系统光盘（根据实际情况挂载，不能照抄）

```shell
[root@node1 ~]# umount /dev/sr0
[root@node1 ~]# umount /dev/sr1
[root@node1 ~]# mkdir /ceph
[root@node1 ~]# vim /etc/fstab
    /dev/sr0    /ceph     iso9660   defaults   0  0
    /dev/sr1    /media    iso9660   defaults   0  0
[root@node1 ~]# mount -a
[root@node2 ~]# umount /dev/sr0
[root@node2 ~]# umount /dev/sr1
[root@node2 ~]# mkdir /ceph
[root@node2 ~]# vim /etc/fstab
    /dev/sr0    /ceph     iso9660   defaults   0  0
    /dev/sr1    /media    iso9660   defaults   0  0
[root@node2 ~]# mount -a
[root@node3 ~]# umount /dev/sr0
[root@node3 ~]# umount /dev/sr1
[root@node3 ~]# mkdir /ceph
[root@node3 ~]# vim /etc/fstab
    /dev/sr0    /ceph     iso9660   defaults   0  0
    /dev/sr1    /media    iso9660   defaults   0  0
[root@node3 ~]# mount -a
```

3）在node1配置SSH密钥，让node1可用无密码连接node1,node2,node3

```shell
[root@node1 ~]# ssh-keygen  -f /root/.ssh/id_rsa  -N  ''
#-f后面跟密钥文件的名称（创建密钥到哪个文件）
#-N  ''设置密钥的密码为空（不要给密钥配置密码）
[root@node1 ~]# for i in   41  42  43
do
ssh-copy-id  192.168.2.$i
done
#通过ssh-copy-id将密钥传递给node1，node2，node3
```

4)修改/etc/hosts域名解析记录（不要删除原文件的数据），同步给所有ceph节点。

```shell
[root@node1 ~]# vim /etc/hosts      #修改文件，手动添加如下内容（不要删除原文件的数据）
192.168.2.41    node1
192.168.2.42     node2
192.168.2.43    node3
[root@node1 ~]# for i in 41 42 43
do
     scp /etc/hosts 192.168.2.$i:/etc
done
```

5）为所有ceph节点配置yum源，并将配置同步给所有节点

提示：前面已经将ceph的光盘挂载到/ceph目录。

```shell
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=file:///ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=file:///ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=file:///ceph/Tools
gpgcheck=0
[root@node1 ~]# yum repolist                #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in 41 42 43
do
     scp /etc/yum.repos.d/ceph.repo 192.168.2.$i:/etc/yum.repos.d/
done
```

6）配置NTP服务器同步时间。

node1做服务器。

```shell
[root@node1 ~]# vim /etc/chrony.conf
allow 192.168.2.0/24        #修改26行
local stratum 10            #修改29行(去注释即可)
[root@node1 ~]# systemctl restart chronyd
```

node2和node3做客户端

```shell
[root@node2 ~]# vim /etc/chrony.conf
server 192.168.2.41   iburst              #配置文件第二行，手动加入该行内容
[root@node2 ~]# systemctl restart chronyd
[root@node2 ~]# chronyc sources -v
[root@node3 ~]# vim /etc/chrony.conf
server 192.168.2.41   iburst              #配置文件第二行，手动加入该行内容
[root@node3 ~]# systemctl restart chronyd
[root@node3 ~]# chronyc sources -v
```

**步骤二：部署ceph集群**

1）给node1主机安装ceph-deploy，创建工作目录，初始化配置文件。

```shell
[root@node1 ~]# yum -y install ceph-deploy
[root@node1 ~]# mkdir ceph-cluster
[root@node1 ~]# cd ceph-cluster
```

2）给所有ceph节点安装ceph相关软件包

```shell
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
     ssh $i "yum -y install ceph-mon ceph-osd ceph-mds"
done
```

3）初始化mon服务

```shell
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
#生成ceph配置文件
[root@node1 ceph-cluster]# ceph-deploy mon create-initial
#拷贝ceph配置文件给node1,node2,node3，启动所有主机的mon服务
[root@node1 ceph-cluster]# ceph -s                    #查看状态（此时失败是正常的）
    cluster 9f3e04b8-7dbb-43da-abe6-b9e3f5e46d2e
     health HEALTH_ERR
     monmap e2: 3 mons at
 {node1=192.168.2.41:6789/0,node2=192.168.2.42:6789/0,node3=192.168.2.43:6789/0}
     
osdmap e45: 0 osds: 0 up, 0 in
```

4）使用ceph-deploy工具初始化数据磁盘（仅node1操作），硬盘名称根据实际情况填写，不能照抄。

```shell
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:sdb  node1:sdc    
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:sdb  node2:sdc
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:sdb  node3:sdc
```

5）初始化OSD集群，磁盘名称根据实际情况填写。

```shell
[root@node1 ceph-cluster]# ceph-deploy osd create  node1:sdb  node1:sdc  
#每个磁盘都会被自动分成两个分区；一个固定5G大小；一个为剩余所有容量
#5G分区为Journal缓存；剩余所有空间为数据盘。
[root@node1 ceph-cluster]# ceph-deploy osd create  node2:sdb  node2:sdc
[root@node1 ceph-cluster]# ceph-deploy osd create  node3:sdb  node3:sdc 
[root@node1 ceph-cluster]# ceph -s                 #查看集群状态，状态为OK
```

**步骤三：部署ceph文件系统**

1）启动mds服务（可以在node1或node2或node3启动，也可以在多台主机启动mds）

```shell
[root@node1 ceph-cluster]# ceph-deploy mds create node3
```

2）创建存储池（文件系统由inode和block组成）

```shell
[root@node1 ceph-cluster]# ceph osd pool create cephfs_data 64
[root@node1 ceph-cluster]# ceph osd pool create cephfs_metadata 64
[root@node1 ceph-cluster]# ceph osd lspools      #查看共享池
0 rbd,1 cephfs_data,2 cephfs_metadata
```

3）创建文件系统

```shell
[root@node1 ceph-cluster]# ceph fs new myfs1 cephfs_metadata cephfs_data
[root@node1 ceph-cluster]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
```

**步骤四：迁移网站数据到ceph集群**

1）卸载web1，web2，web3的NFS共享。

暂停服务防止有人实时读写文件。

```shell
[root@web1 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web2 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web3 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web1 ~]# umount /usr/local/nginx/html
[root@web2 ~]# umount /usr/local/nginx/html
[root@web3 ~]# umount /usr/local/nginx/html
[root@web1 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
[root@web2 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
[root@web3 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
```

2）web服务器永久挂载Ceph文件系统（web1、web2、web3都需要操作）。

在任意ceph节点，如node1查看ceph账户与密码。

```shell
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring 
[client.admin]
    key = AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
```

/etc/rc.local是开机启动脚本，任何命令放在该文件中都是开机自启。

ceph-common是ceph的客户端软件。

```shell
[root@web1 ~]# yum -y install ceph-common
[root@web2 ~]# yum -y install ceph-common
[root@web3 ~]# yum -y install ceph-common
[root@web1 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web1 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web1 ~]# chmod +x /etc/rc.local
[root@web2 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web2 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web2 ~]# chmod +x /etc/rc.local
[root@web3 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web3 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web3 ~]# chmod +x /etc/rc.local
```

另一种解决方案，还可以通过fstab实现永久挂载。

提示：如果希望使用fstab实现永久挂载，客户端需要额外安装libcephfs1软件包。

```shell
[root@web1 ~]# yum -y install libcephfs1
[root@web1 ~]# vim /etc/fstab
… …
192.168.2.41:6789:/ /usr/local/nginx/html/    ceph   defaults,_netdev,name=admin,secret=AQCVcu9cWXkgKhAAWSa7qCFnFVbNCTB2DwGIOA== 0 0
```

第三种挂载方案：对于高可用的问题，可以在mount时同时写入多个IP。

```shell
临时命令：
[root@web1 ~]# mount -t ceph  \
192.168.2.41:6789,192.168.2.42:6789,192.168.2.43:6789:/ /usr/local/nginx/html  \
-o name=admin,secret=密钥
永久修改：
[root@web1 ~]# vim /etc/fstab
192.168.2.41:6789,192.168.2.42:6789,192.168.2.43:6789:/ /usr/local/nginx/html/ \
ceph defaults,_netdev,name=admin,secret=密钥 0 0
```

3)迁移NFS服务器中的数据到Ceph存储

登陆NFS服务器备份数据，将备份数据拷贝给web1或web2或web3，tar备份数据时注意使用-p选项保留文件权限。

```shell
[root@nfs ~]# cd /web_share/html/
[root@nfs html]# tar -czpf /root/html.tar.gz ./*
[root@nfs html]# scp /root/html.tar.gz 192.168.2.11:/usr/local/nginx/html/
```

登陆web1将数据恢复到Ceph共享目录

```shell
[root@web1 html]# tar -xf html.tar.gz
[root@web1 html]# rm -rf html.tar.gz
```

4）恢复web服务

```shell
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web3 ~]# /usr/local/nginx/sbin/nginx
```

附加知识（常见面试题）

1) 如何使用awk查看TCP连接状态？

答：ss -ant |awk '{print $1}'
netstat -ant |awk '{print $6}'

2) 有个txt文件内容如下：
   http://a.domain.com/l.html
   http://b.domain.com/l.html
   http://c.domain.com/l.html
   http://a.domain.com/2.html
   http://b.domain.com/2.html
   http://a.domain.com/3.html

要求：编写脚本获取主机名、域名，并统计每个域名出现的次数，并排序。

答：

```shell
#！/bin/bash
awk -F"[/.]" '{print $3}' txt    #单独获取主机名
awk -F"[/]" '{print $3}'  txt    #获取完整域名
awk -F"[/]" '{IP[$3]++} END{for(i in IP){print IP[i],i}}' txt | sort -n
```

3) 至少说出一种linux下实现高可用的方案名称？

答：keepalived，HeartBeat

4) 简述下负载均衡与高可用的概念？

答：
LB（Load_balancing）: 多台服务器平均响应客户端的多次连接请求。
HA（High Availability）: 主备模式，主服务器宕机后，备用服务器才接替工作。

5) 列举几种你知道的LVS调度算法？

答：
轮询（Round Robin）
加权轮询（Weighted Round Robin）
最少连接（Least Connections）
加权最少连接（ Weighted Least Connections ）
源地址哈希值（source hash）

6) 如果你们公司的网站访问很慢，你会如何排查？

答：
查看流量(Zabbix,ifconfig,sar,ping延迟… …)
系统负载(Zabbix,uptime,sar,top,ps,free查看CPU和内存)
日志（数据库日志-慢查询日志、web服务器日志、ELK）
DNS解析；ss端口状态、并发量；本机时间（时间错误会导致服务器故障）
浏览器F12（开发者工具）

7) 你会用什么方法来查看某个应用服务的流量使用情况?

答：
ifconfig eth0（查看网卡整体流量）
iftop（需要安装iftop软件包，实时查看具体IP、端口的流量，iftop -P）
iptraf-ng (需要安装iptraf-ng软件包，实时查看IP、端口的流量)
sar -n DEV（需要安装sysstat软件包，查看历史网卡流量，或者实时查看流量）
nethogs eth0（需要安装nethogs软件包，实时查看进程流量）

查看网站的访问日志（利用awk统计资源的大小并求和）
通过zabbix查看软件流量

> 如有侵权，请联系作者删除



﻿@[TOC]( Keepalived Hot standby & Keepalived+LVS & HAProxy server | Cloud computing )

---

# 1. Keepalived高可用服务器

## 1.1 问题

准备三台Linux服务器，两台做Web服务器，并部署Keepalived高可用软件，一台作为客户端主机，实现如下功能：

- 使用Keepalived实现web服务器的高可用
- Web服务器IP地址分别为192.168.4.100和192.168.4.200
- Web服务器的浮动VIP地址为192.168.4.80
- 客户端通过访问VIP地址访问Web页面

## 1.2 方案

使用3台虚拟机，2台作为Web服务器，并部署Keepalived、1台作为客户端，拓扑结构如图-1所示，主机配置如表-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/dc43a3650363491eaaef135f6f7f8c1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-1

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/c811c889d2624de8967b523d2a2b400d.png)


## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）**

1）设置Web1服务器网络参数、配置Web服务（不能照抄网卡名称）

```shell
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
[root@web1 ~]# yum -y install httpd        #安装软件
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html    #创建网页文件
[root@web1 ~]# systemctl restart httpd        #启动服务器
```

2）设置Web2服务器网络参数、配置Web服务（不能照抄网卡名称）

```shell
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
[root@web2 ~]# yum -y install httpd        #安装软件
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html    #创建网页文件
[root@web2 ~]# systemctl restart httpd        #启动服务器
```

3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）

备注：这个实验，我们使用proxy当作客户端主机，网卡名称不能照抄。

```shell
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
```

**步骤二：安装Keepalived软件**

注意：两台Web服务器做相同的操作。

```shell
[root@web1 ~]# yum install -y keepalived
[root@web2 ~]# yum install -y keepalived 
```

**步骤三：部署Keepalived服务**

1）修改web1服务器Keepalived配置文件

```shell
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  web1        #12行，设置路由ID号（实验需要修改）
    vrrp_iptables            #13行，清除防火墙的拦截规则（实验需要修改，手动添加该行）
}
vrrp_instance VI_1 {
  state MASTER            #21行，主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0            #22行，VIP配在哪个网卡（实验需要修改，不能照抄网卡名）
  virtual_router_id 51        #23行，主备服务器VRID号必须一致
  priority 100            #24行，服务器优先级,优先级高优先获取VIP
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       
  }
  virtual_ipaddress {        #30~32行，谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80/24
}    
}
```

2）修改web2服务器Keepalived配置文件

```shell
[root@web2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  web2        #12行，设置路由ID号（实验需要修改）
  vrrp_iptables            #13行，清除防火墙的拦截规则（实验需要修改，手动添加该行） 
}
vrrp_instance VI_1 {
  state BACKUP            #21行，备服务器为BACKUP（实验需要修改）
  interface eth0            #22行，VIP配在哪个网卡（实验需要修改，不能照抄网卡名）
  virtual_router_id 51        #23行，主辅VRID号必须一致
  priority 50                #24行，服务器优先级（实验需要修改）
  advert_int 1
  authentication {
     auth_type pass
     auth_pass 1111                   
  }
  virtual_ipaddress {        #30~32行，谁是主服务器谁配置VIP（实验需要修改）
192.168.4.80/24 
 }   
}
```

3）启动服务

```shell
[root@web1 ~]# systemctl start keepalived
[root@web2 ~]# systemctl start keepalived
```

4）配置防火墙和SELinux

```shell
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# sed -i  '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@web1 ~]# setenforce 0
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# sed -i  '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@web2 ~]# setenforce 0
```

**步骤四：测试**

1）登录两台Web服务器查看VIP信息

```shell
[root@web1 ~]# ip addr show
[root@web2 ~]# ip addr show
```

2) 客户端访问

客户端使用curl命令连接http://192.168.4.80，查看Web页面；给Web1关机，客户端再次访问http://192.168.4.80，验证是否可以正常访问服务。

# 2. Keepalived+LVS服务器

## 2.1 问题

使用Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：

- LVS1调度器真实IP地址为192.168.4.5
- LVS2调度器真实IP地址为192.168.4.6
- 服务器VIP地址设置为192.168.4.15
- 真实Web服务器地址分别为192.168.4.100、192.168.4.200
- 使用加权轮询调度算法，真实web服务器权重不同

## 2.2 方案

使用5台虚拟机，1台作为客户端主机、2台作为LVS调度器、2台作为Real Server，实验拓扑环境结构如图-2所示，基础环境配置如表-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4fcabe596684a63b188887bf55f640e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

表-2
![在这里插入图片描述](https://img-blog.csdnimg.cn/c3e647c01f554a079771a080dc5b5b76.png)


注意：所有主机都需要配置IP地址与有效的YUM源，网卡名称仅供参考。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置网络环境**

1）关闭服务（把案例1中给web1和web2安装的keepalived关闭）

**警告：请先将案例1中web1和web2的keepalived关闭！！！**

```shell
[root@web1 ~]# systemctl  stop   keepalived
[root@web2 ~]# systemctl  stop   keepalived
```

2）设置Web1服务器的网络参数（不能照抄网卡名称）

```shell
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
```

接下来给web1配置VIP地址

注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。

```shell
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo  ifcfg-lo:0
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
#设备名称
IPADDR=192.168.4.15
#IP地址
NETMASK=255.255.255.255
#子网掩码
NETWORK=192.168.4.15
#网络地址
BROADCAST=192.168.4.15
#广播地址
ONBOOT=yes
#开机是否激活该网卡
NAME=lo:0
#网卡名称
```

注意：这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突。

写入下面这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。

```shell
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容，英语词汇：ignore（忽略、忽视），announce（宣告、广播通知）
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#arp_ignore(防止进站冲突)
#arp_announce(防出站冲突)
[root@web1 ~]# sysctl  -p                #刷新，让配置文件立刻生效
```

重启网络服务

```shell
[root@web1 ~]# systemctl restart network        #重启网络服务
[root@web1 ~]# ip  a   s                        #查看IP地址
```

3）设置Web2服务器的网络参数（不能照抄网卡名称）

```shell
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
```

接下来给web2配置VIP地址

注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。

```shell
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo  ifcfg-lo:0
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
```

注意：这里因为web2也配置与代理一样的VIP地址，默认肯定会出现地址冲突。

写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。

```shell
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容，英语词汇：ignore（忽略、忽视），announce（宣告、广播通知）
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#arp_ignore(防止进站冲突)
#arp_announce(防出站冲突)
[root@web2 ~]# sysctl  -p             #刷新，让配置文件立刻生效
```

重启网络服务

```shell
[root@web2 ~]# systemctl restart network        #重启网络服务
[root@web2 ~]# ip a  s                            #查看IP地址
```

4）配置proxy主机的网络参数(不配置VIP，VIP由keepalvied自动配置)

把前面在proxy主机上面创建的VIP网卡的配置文件直接删除。

备注：不能照抄网卡名称。

```shell
[root@proxy ~]# rm -rf /etc/sysconfig/network-scripts/ifcfg-eth0:0
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
```

5）配置proxy2主机的网络参数(不配置VIP，VIP由keepalvied自动配置)

注意：按照前面的课程环境，默认没有该虚拟机，需要重新建一台虚拟机proxy2。

备注：不能照抄网卡名称。

```shell
[root@proxy2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.6/24 connection.autoconnect yes
[root@proxy2 ~]# nmcli connection up eth0
```

**步骤二：配置后台web服务**

1）安装软件，自定义Web页面（web1和web2主机）

```shell
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
```

2）启动Web服务器软件(web1和web2主机)

```shell
[root@web1 ~]# systemctl start httpd ; systemctl enable httpd
[root@web2 ~]# systemctl start httpd ; systemctl enable httpd
```

**步骤三：调度器安装Keepalived与ipvsadm软件**

**注意：两台LVS调度器执行相同的操作（如何已经安装软件，可忽略此步骤）。**

安装软件

```shell
[root@proxy ~]# yum install -y keepalived
[root@proxy ~]# systemctl enable keepalived
[root@proxy ~]# yum install -y ipvsadm
[root@proxy ~]# ipvsadm -C
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# systemctl enable keepalived
[root@proxy2 ~]# yum install -y ipvsadm
[root@proxy2 ~]# ipvsadm -C
```

**步骤四：部署Keepalived实现LVS-DR模式调度器的高可用**

1）LVS1调度器设置Keepalived，并启动服务（在192.168.4.5主机操作）

```shell
[root@proxy ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  lvs1        #12行，设置路由ID号(实验需要修改)
  vrrp_iptables            #13行，清除防火墙的拦截规则（实验需要修改，手动添加）   
}
vrrp_instance VI_1 {
  state MASTER            #21行，主服务器为MASTER
  interface eth0            #22行，定义网络接口（不能照抄网卡名）
  virtual_router_id 51        #23行，主辅VRID号必须一致
  priority 100            #24行，服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       
  }
  virtual_ipaddress {        #30~32行，配置VIP（实验需要修改）
192.168.4.15/24 
 }   
}
virtual_server 192.168.4.15 80 {        #设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6                        #默认健康检查延迟6秒
  lb_algo rr                            #设置LVS调度算法为RR
  lb_kind DR                            #设置LVS的模式为DR（实验需要修改）
  #persistence_timeout 50                #（实验需要删除）
#注意persistence_timeout的作用是保持连接
#开启后，客户端在一定时间内(50秒)始终访问相同服务器
  protocol TCP                        #TCP协议
  real_server 192.168.4.100 80 {        #设置后端web服务器真实IP（实验需要修改）
    weight 1                            #设置权重为1
    TCP_CHECK {                        #对后台real_server做健康检查（实验需要修改）
    connect_timeout 3                #健康检查的超时时间3秒
    nb_get_retry 3                    #健康检查的重试次数3次
        delay_before_retry 3                #健康检查的间隔时间3秒
    }
  }
 real_server 192.168.4.200 80 {        #设置后端web服务器真实IP（实验需要修改）
    weight 2                        #设置权重为2
    TCP_CHECK {                    #对后台real_server做健康检查（实验需要修改）
         connect_timeout 3            #健康检查的超时时间3秒
    nb_get_retry 3                #健康检查的重试次数3次
    delay_before_retry 3            #健康检查的间隔时间3秒
    }
  }
}
[root@proxy1 ~]# systemctl start keepalived
[root@proxy1 ~]# ipvsadm -Ln        #查看LVS规则
[root@proxy1 ~]# ip a  s            #查看VIP配置
```

2）LVS2调度器设置Keepalived（在192.168.4.6主机操作）

```shell
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
   router_id  lvs2                        #12行，设置路由ID号（实验需要修改）
 vrrp_iptables                   #13行，清除防火墙的拦截规则（实验需要修改，手动添加）   
}
vrrp_instance VI_1 {
  state BACKUP                             #21行，从服务器为BACKUP（实验需要修改）
  interface eth0                        #22行，定义网络接口（不能照抄网卡名）
  virtual_router_id 51                    #23行，主辅VRID号必须一致
  priority 50                             #24行，服务器优先级（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111 
  }
  virtual_ipaddress {                   #30~32行，设置VIP（实验需要修改）
192.168.4.15/24  
}  
}
virtual_server 192.168.4.15 80 {          #自动设置LVS规则（实验需要修改）
  delay_loop 6
  lb_algo  rr                              #设置LVS调度算法为RR
  lb_kind DR                               #设置LVS的模式为DR（实验需要修改）
 # persistence_timeout 50               #（实验需要删除该行）
#注意persistence_timeout的作用是保持连接
#开启后，客户端在一定时间内(50秒)始终访问相同服务器
  protocol TCP                        #TCP协议
  real_server 192.168.4.100 80 {        #设置后端web服务器的真实IP（实验需要修改）
    weight 1                              #设置权重为1
    TCP_CHECK {                         #对后台real_server做健康检查（实验需要修改）
      connect_timeout 3               #健康检查的超时时间3秒
    nb_get_retry 3                   #健康检查的重试次数3次
    delay_before_retry 3            #健康检查的间隔时间3秒
    }
  }
 real_server 192.168.4.200 80 {         #设置后端web服务器的真实IP（实验需要修改）
    weight 2                              #设置权重为2，权重可以根据需要修改
    TCP_CHECK {                        #对后台real_server做健康检查（实验需要修改）
      connect_timeout 3               #健康检查的超时时间3秒
    nb_get_retry 3                   #健康检查的重试次数3次
    delay_before_retry 3            #健康检查的间隔时间3秒
    }
  }
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# ipvsadm -Ln                 #查看LVS规则
[root@proxy2 ~]# ip  a   s                    #查看VIP设置
```

**步骤五：客户端测试**

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。

# 3. 配置HAProxy负载平衡集群

## 3.1 问题

准备4台Linux服务器，两台做Web服务器，1台安装HAProxy，1台做客户端，实现如下功能：

- 客户端访问HAProxy，HAProxy分发请求到后端Real Server
- 开启HAProxy监控页面，及时查看调度器状态
- 设置HAProxy为开机启动

## 3.2 方案

使用4台虚拟机，1台作为HAProxy调度器、2台作为Real Server、1台作为客户端，拓扑结构如图-3所示，具体配置如表-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dce7867396a464ab2b44072668a1280.png)
图-3

表-3
![在这里插入图片描述](https://img-blog.csdnimg.cn/b0906c8708a646ecb1eceba294e05999.png)


为什么Haproxy的实验不需要开启路由，不需要给web服务器配置网关？

Hapoxy是代理服务器（帮你干活的人或物就是你的代理），通讯流程如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a58cc75794c247f591f257b88d44ab8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-4

## 3.3 步骤

实现此案例需要按照如下步骤进行。

web1配置本地真实IP地址（不能照抄网卡名）。

```shell
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1
```

Web2配置本地真实IP地址（不能照抄网卡名）。

```shell
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1
proxy关闭keepalived服务，清理LVS规则，不能照抄网卡名。

[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1
```

**步骤一：配置后端Web服务器**

设置两台后端Web服务（如果已经配置完成，可忽略此步骤）

```shell
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
```

**步骤二：部署HAProxy服务器**

1）配置网络，安装软件

```shell
[root@proxy ~]# yum -y install haproxy
```

2）修改配置文件

```shell
[root@proxy ~]# vim /etc/haproxy/haproxy.cfg
global
 log 127.0.0.1 local2   ##[err warning info debug]
 pidfile /var/run/haproxy.pid ##haproxy的pid存放路径
 user haproxy
 group haproxy
 daemon                    ##以后台进程的方式启动服务
defaults
 mode http                ##默认的模式mode { tcp|http|health } 
option dontlognull      ##不记录健康检查的日志信息
 option httpclose        ##每次请求完毕后主动关闭http通道
 option httplog          ##日志类别http日志格式
 option redispatch      ##当某个服务器挂掉后强制定向到其他健康服务器
 timeout client 300000 ##客户端连接超时，默认毫秒，也可以加时间单位
 timeout server 300000 ##服务器连接超时
 maxconn  3000          ##最大连接数
 retries  3             ##3次连接失败就认为服务不可用，也可以通过后面设置
  
listen  websrv-rewrite 0.0.0.0:80          
   balance roundrobin
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5
#定义集群,listen后面的名称任意，端口为80
#balance指定调度算法为轮询（不能用简写的rr）
#server指定后端真实服务器，web1和web2的名称可以任意
#check代表健康检查，inter设定健康检查的时间间隔，rise定义成功次数，fall定义失败次数
listen stats *:1080        #监听端口
    stats refresh 30s             #统计页面自动刷新时间
    stats uri /stats              #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin       #统计页面用户名和密码设置
```

3）启动服务器并设置开机启动

```shell
[root@proxy ~]# systemctl restart haproxy
[root@proxy ~]# systemctl enable haproxy
```

**步骤三：客户端验证**

客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容，参考图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4181fbdbe9bf4639968eb93d19f1fa1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

备注：

- Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
- Session rate每秒会话率（当前值，最大值，限制数量）；
- Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
- Bytes（入站、出站流量）；
- Denied（拒绝请求、拒绝回应）；
- Errors（错误请求、错误连接、错误回应）；
- Warnings（重新尝试警告retry、重新连接redispatches）；
- Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。

附加思维导图，如图-5所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/8a7ecde1441043c6981f94f229f6a32b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5



# Exercise

## 1 HAProxy工作模式有哪些？

- mode http：客户端请求被深度分析后再发往服务器。
- mode tcp：在客户端与服务器这间建立全双工会话，不检查第七层信息。
- mode health：仅做健康状态检查，已经不建议使用。

## 2 HAProxy配置文件有哪些组成部分？

- default：为后续的其他部分设置缺省参数，缺省参数可以被后续部分重置；
- listen：调度服务器监听的IP和端口。
- server：定义后端真实服务器的IP和端口，健康检查的策略。

## 3 简单描述keepalived配置文件字段含义

以下是部分keepalived配置文件的声明，在下面代码的括号处写出关键字段含义：

> ```shell
> vrrp_instance VI_1 {
> state MASTER                         //（     ）
> interface eth0
> virtual_router_id 51
> priority 100                         //（     ）
> advert_int 1
> authentication {
>  auth_type pass
>  auth_pass forlvs                   //（     ）
> }
> ```

建立测试文件：
1）state MASTER：设置主服务器MASTER，辅助为SLAVE；
2）priority 100：设置优先级，主服务器优先级要比辅助的高；
3）auth_pass forlvs：设置密码，主辅服务器密码必须一致。

## 4 使用Keepalived实现LVS功能？

> 要求：虚拟服务器IP地址为192.168.1.1，采用的LVS调度算法为RR，LVS的模式为DR，Real Server的IP地址分别为192.168.1.10和192.168.1.11。只需写出虚拟服务器部分的配置文件。

```shell
virtual_server 192.168.1.1 80 {           //设置虚拟IP为192.168.1.1
  delay_loop 6
  lb_algo rr                              //设置LVS调度算法为RR
  DR                           //设置LVS的模式为DR
  persistence_timeout 50
  protocol TCP
  real_server 192.168.1.10 80 {//设置Real Server192.168.1.10
    weight 3                             //设置权重为3
    TCP_CHECK {
connect_timeout 3
nb_get_retry 3
delay_before_retry 3
    }
  }
 real_server 192.168.1.11 80 {         //设置Real Server192.168.1.10
    weight 1   
    TCP_CHECK {
connect_timeout 3
nb_get_retry 3
delay_before_retry 3
    }
 }
}
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Kubectl explanation & K8S resource object management & K8S cluster management | Cloud computing )

---

# 1. kubectl基本命令

## 1.1 问题

本案例要求学习使用kubectl基本命令来管理kubernetes，具体要求如下：

1. 查询 节点 信息（node）
2. 启动容器（run）
3. 查询资源信息（deployment）
4. 查询容器信息（pod）
5. 进入容器（exec，attach）
6. 删除资源（delete）

## 1.2 方案

Kubectl是用于控制Kubernetes集群的命令行工具。

Kubectl的语法格式如下:

kubectl [command] [TYPE] [NAME] [flags]

command: 子命令，如 create，get，describe，delete

type: 资源类型，可以表示为单数，复数或缩写形式

name: 资源的名称，如果省略，则显示所有资源信息

flags: 指定可选标志，或附加的参数

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：kubectl命令练习（在master主机操作）**

1）run创建容器资源。

语法格式：kubectl run 资源名称 -i -t --image=私有仓库镜像名称:标签

```shell
[root@master ~]# kubectl run haha -i -t --image=192.168.1.100:5000/myos:v1804
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
If you don't see a command prompt, try pressing enter.
[root@haha-8bbd48d7b-wcnkd /]#                           #注意：这里已经进入了容器
[root@haha-8bbd48d7b-wcnkd /]# ifconfig 
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450
        inet 10.244.7.2  netmask 255.255.255.0  broadcast 0.0.0.0
```

2)get查询资源

语法格式：

kubectl get node 查询节点状态

kubectl get deployment 查询资源名称

kubectl get pod 查询pod容器资源

kubectl get pod -o wide 查询主机信息

kubectl get pod -o yaml 显示资源文件Yaml格式

```shell
[root@master ~]# kubectl  get  nodes
NAME             STATUS      ROLES       AGE           VERSION
master              Ready     master       12h       v1.17.6
node-0001           Ready    <none>     16h             v1.17.6
node-0002       Ready      <none>      16h             v1.17.6
node-0003       Ready     <none>       16h             v1.17.6
[root@master ~]# kubectl  get  deployment.apps
NAME           READY       UP-TO-DATE     AVAILABLE    AGE
haha           1/1         1                       1                  10m
[root@master ~]# kubectl get pod
NAME    READY    STATUS    RESTARTS       AGE
haha-xxxx    1/1    Running       1          14m
[root@master ~]# kubectl get pod -o wide
NAME    READY    STATUS    RESTARTS     AGE    IP                NODE           ... ...
haha-xxxx    1/1    Running       1        14m    10.244.7.4       node-0003     ... ...
```

3）exec进入一个正在运行的容器中

语法格式：

kubectl exec -it 容器id 执行的命令

```shell
[root@kube-master ~]# kubectl  get  pod
NAME                        READY       STATUS    RESTARTS        AGE
haha-8bbd48d7b-wcnkd       1/1            Running     0             31m
#查看一个容器资源的名称
[root@kube-master ~]# kubectl exec -it haha-8bbd48d7b-wcnkd /bin/bash
# 进入该容器中
[root@haha-8bbd48d7b-wcnkd /]#
```

4）查看资源的详细信息（主要用于排错）

语法格式：

kubectl describe 资源类型 资源名称

```shell
[root@kube-master ~]# kubectl describe  deployment  haha  
# 查看deployment资源的详细信息
Name:                  haha
Namespace:             default
CreationTimestamp:    Wed, 04 Mar 2020 15:50:24 +0800
... ...
[root@kube-master ~]# kubectl describe  pod  haha-8bbd48d7b-wcnkd 
# 查看容器的详细信息
Name:               haha-8bbd48d7b-wcnkd
Namespace:         default
Node:               kube-node1/192.168.1.11
Start Time:         Wed, 04 Mar 2020 15:50:24 +0800
Labels:             pod-template-hash=466804836
... ... 
```

5）查看 console 终端的输出信息

```shell
[root@kube-master ~]# kubectl attach haha-8bbd48d7b-wcnkd -c haha -i -t
If you don't see a command prompt, try pressing enter.
# 先通过attach进入一个容器
[root@haha-8bbd48d7b-wcnkd /]# echo hello world          #在容器中echo输出信息
hello world
[root@haha-8bbd48d7b-wcnkd /]#  Ctrl-p + Ctrl-q           #按快捷键退出
[root@kube-master ~]# 
[root@kube-master ~]# kubectl logs haha-8bbd48d7b-wcnkd 
[root@haha-8bbd48d7b-wcnkd /]# echo hello world
hello world
```

6）delete删除资源

语法格式：

kubectl delete 资源类型 资源名称

```shell
[root@kube-master ~]# kubectl delete pod haha-xxxxxxxx     
pod "haha-8bbd48d7b-wcnkd" deleted
# 删除pod，注意：这里的pod名称不能照抄！！！！
[root@kube-master ~]# kubectl get pod -o wide             # 容器被删除后会自动重建
NAME            READY    STATUS      RESTARTS   AGE     IP                NODE
haha-xxxxxxxx   1/1     Running     0            3s     10.254.9.2       kube-node2
haha-xxxxxxxx   1/1     Terminating  2             1h     10.254.39.2      kube-node1
[root@kube-master ~]# kubectl get deployment                 #查看deployment资源
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
haha      1         1         1            1           1h
[root@kube-master ~]# kubectl  delete  deployment  haha  
deployment.extensions "haha" deleted
# 删除deployment资源，容器彻底消失
```



# 2 案例2：资源对象文件

## 2.1 问题

本案例要求熟悉资源文件的语法，具体要求如下：

1. 写一个 deployment 的资源文件
2. 启动一个基本系统(myos.yaml)
3. 启动一个 apache 服务(myweb.yaml)
4. 熟悉 kubectl 查询资源信息（deployment）
5. 熟悉 kubectl 查询容器信息（pod）
6. 熟悉 kubectl 进入容器（exec，attach）
7. 熟悉 kubectl 删除资源（delete）

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：查看现有资源的资源对象文件（在master主机操作）**

语法格式：

kubectl get 资源对象 资源名称 -o 格式（json|yaml）

```shell
[root@kube-master ~]# kubectl  get  deployment  apache  -o yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
... ...
# 导出deployment资源的资源对象文件，depoyment资源的名称为apache，导出yaml格式
```

**步骤二：编写资源对象文件（在master主机操作）**

注意：所有资源文件都在云盘第四阶段kubernetes/v1.17.6/config/目录有案例！！！

1）Pod资源文件

```shell
[root@master ~]# vim  mypod.yaml
---
kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
  - name: mylinux
    image: 192.168.1.100:5000/myos:v1804
    stdin: true
    tty: true
         
[root@master ~]# kubectl apply -f mypod.yaml 
pod/mypod created
[root@master ~]# kubectl get pod
NAME    READY   STATUS    RESTARTS   AGE
mypod   1/1     Running   0          13s
[root@master ~]# kubectl delete -f mypod.yaml
pod "mypod" deleted
[root@master ~]#
```

2）Deployment资源文件

```shell
[root@master ~]# vim myapache.yaml 
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: myapache
spec:
  selector:
    matchLabels:
      myapp: httpd
  replicas: 1
  template:
    metadata:
      labels:
        myapp: httpd
    spec:
      containers:
      - name: webcluster
        image: 192.168.1.100:5000/myos:httpd
        stdin: false
        tty: false
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl apply -f myapache.yaml 
deployment.apps/myapache created
[root@master ~]# kubectl get deployments.apps
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
myapache   1/1     1            1           19s
[root@master ~]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
myapache-69b494dc5c-bff95   1/1     Running   0          28s
[root@master ~]#
```

3)备注

为了建立控制器和 pod 间的关联，kubernetes 先给每个 pod 打上一个标签（Label），然后再给相应的位置定义标签选择器（Label Selector），引用这些标签，资源文件的效果如下：

```shell
... ...             
 selector:                #声明标签选择器
    app: nginx         #为服务的后端选择标签 
... ...
  metadata:
      labels:          #声明标签
        app: nginx         #定义标签名字(上下标签必须一致)
... ...
```

4）如何使用资源文件

使用资源文件管理对象，语法格式：kubectl (apply|create|delete) -f 资源文件

- create 创建资源对象
- apply 声明更新资源对象
- delete 删除资源对象



# 3 案例3：集群扩容更新与回滚

## 3.1 问题

本案例主要练习集群扩容更新与回滚，分别实现以下目标：

1. 创建一个 myweb.yml 使用 apache 启动
2. 练习集群扩容
3. 更新：
4. 从 Apache 滚动更新到 nginx服务
5. 回滚 nginx 到 apache 服务
6. 验证

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建一个单节点的Web容器（在master主机操作操作）**

资源文件在云盘的第四阶段kubernetes/v1.17.6/config/目录有案例。

各位同学需要提前下载素材文件并传到master主机。

```shell
[root@master ~]# kubectl get deployments.apps
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
myapache   1/1     1            1           113s
[root@master ~]# kubectl scale deployment myapache --replicas=3
deployment.apps/myapache scaled
[root@master ~]# kubectl get deployments.apps
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
myapache   3/3     3            3           2m12s
[root@master ~]#
```

**步骤二：集群扩容（在master主机操作操作）**

我们可以使用命令行调整容器副本数量，也可以通过修改资源文件、更新资源的方式调整容器副本数量。

```shell
 [root@master ~]# kubectl scale deployment.apps httpd-example --replicas=3
```

**步骤三：集群更新与回滚**

各位同学需要提前下载素材文件并传到master主机。

```shell
[root@master config]# kubectl rollout history deployment myapache 
deployment.apps/myapache 
REVISION  CHANGE-CAUSE
1         <none>
[root@master ~]# curl http://10.244.3.5
this is apache
[root@master ~]# kubectl edit deployments.apps myapache 
deployment.apps/myapache edited
[root@master ~]# curl http://10.244.2.6
this is nginx
[root@master ~]# kubectl rollout history deployment myapache 
deployment.apps/myapache 
REVISION  CHANGE-CAUSE
1         <none>
2         <none>
[root@master ~]# kubectl rollout undo deployment myapache --to-revision=1
deployment.apps/myapache rolled back
[root@master ~]# curl http://10.244.3.6
this is apache
[root@master ~]#
```

**步骤三：节点标签选择器**

```shell
[root@master ~]# vim myapache.yaml 
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: myapache
spec:
  selector:
    matchLabels:
      myapp: httpd
  replicas: 1
  template:
    metadata:
      labels:
        myapp: httpd
    spec:
      nodeName: node-0001  # 新增一行
      containers:
      - name: webcluster
        image: 192.168.1.100:5000/myos:httpd
        stdin: false
        tty: false
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl delete -f myapache.yaml 
deployment.apps "myapache" deleted
[root@master ~]# kubectl apply -f myapache.yaml 
deployment.apps/myapache created
[root@master ~]# kubectl get pods -o wide
NAME               READY   STATUS    RESTARTS   AGE     IP            NODE
myapache-xxx      1/1     Running   0          3m49s   10.244.3.9    node-0001
```



# 4 多标签节点匹配

```shell
[root@master ~]# kubectl delete -f myapache.yaml
deployment.apps "myapache" deleted
[root@master ~]# kubectl get nodes --show-labels 
NAME        STATUS   ROLES    AGE   VERSION   LABELS
master      Ready    master   10h   v1.17.6   kubernetes.io/hostname=master    ... ...
node-0001   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0001 ... ...
node-0002   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0002 ... ...
node-0003   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0003 ... ...
[root@master ~]# kubectl label nodes node-0002 node-0003 disktype=ssd
node/node-0002 labeled
node/node-0003 labeled
[root@master ~]# kubectl get nodes --show-labels 
NAME        STATUS   ROLES    AGE   VERSION   LABELS
master      Ready    master   10h   v1.17.6   kubernetes.io/hostname=master    ... ...
node-0001   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0001 ... ...
node-0002   Ready    <none>   10h   v1.17.6   disktype=ssd ... ...
node-0003   Ready    <none>   10h   v1.17.6   disktype=ssd ... ...
[root@master ~]# vim myapache.yaml
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: myapache
spec:
  selector:
    matchLabels:
      myapp: httpd
  replicas: 1
  template:
    metadata:
      labels:
        myapp: httpd
    spec:
      nodeSelector:        # 新添加
        disktype: ssd   # 新添加
      containers:
      - name: webcluster
        image: 192.168.1.100:5000/myos:httpd
        stdin: false
        tty: false
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl scale deployment myapache --replicas=3
deployment.apps/myapache scaled
[root@master ~]# kubectl get pod -o wide
NAME        READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   
myapache-xxx    1/1     Running   0          9s    10.244.1.7   node-0003   <none>           
myapache-xxx    1/1     Running   0          9s    10.244.2.8   node-0002   <none>           
myapache-xxx    1/1     Running   0          21s   10.244.2.7   node-0002   <none>           
[root@master ~]# kubectl delete -f myapache.yaml
deployment.apps "myapache" deleted
[root@master ~]# kubectl label nodes node-0002 node-0003 disktype-
node/node-0002 labeled
node/node-0003 labeled
[root@master ~]# kubectl get nodes --show-labels 
NAME        STATUS   ROLES    AGE   VERSION   LABELS
master      Ready    master   10h   v1.17.6   kubernetes.io/hostname=master    ... ...
node-0001   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0001 ... ...
node-0002   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0002 ... ...
node-0003   Ready    <none>   10h   v1.17.6   kubernetes.io/hostname=node-0003 ... ...
[root@master ~]#
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Linux Container Basics & Linux Container Management & Podman Command Line & Advanced Container management )

---

# 1. 实验环境准备

## 1.1 问题

1. 配置: 2CPU，2G内存，20G硬盘
2. node-0001 主机 IP:192.168.4.30
3. 在此机器上安装部署podman服务

## 1.2 方案

在虚拟机环境练习装机过程——通过菜单组“应用程序”-->“系统工具”-->“虚拟系统管理器”，打开KVM虚拟化的图形管理程序（如图-1所示），添加一台虚拟机，将LINUX系统的ISO镜像文件作为此虚拟机的安装光盘。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb7744de368e4b7fa4aeee337948e545.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.3 步骤

**步骤一：新建一台LINUX虚拟机**

1）启动“新建虚拟机”向导程序

单击虚拟系统管理器左上方的“新建”按钮，即可打开“新建虚拟机”向导窗口；为新建虚拟机指定名称，安装方式选择从本地ISO镜像安装（如图-2所示），单击“前进“。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6a5436b1aa384fbdbcd680a464219919.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-2

2）指定ISO文件位置、系统版本

通过“浏览”找到正确的LINUX安装镜像文件的路径（如图-3所示），单击“前进“。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c8554958cacd47369c65025b20dafa50.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图－3

3）指定虚拟机内存与CPU核心数

内存建议设为2048MB，CPU默认2个即可（如图-4所示），单击“前进”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ed42d834100543f69fc200e687861c92.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图－4

4）指定虚拟机的磁盘大小

此处建议选择20GB，（如图-5所示），单击“前进”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5887973c332d4198ac4b18fd2eee3ed6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图－5

5）确认并完成创建

查看虚拟机最终配置信息，将虚拟网络选择为“private1”（如图-6所示），单击“完成”后将会自动运行新建的虚拟机。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c3ff7f67178940f4aaf04d183afab237.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图－6

步骤二：启动虚拟机电源，安装Linux系统

1）运行Linux安装程序

点击完成后，会自动从光盘引导主机（因为新磁盘没有引导信息，自动找其他启动设备），进入系统的安装选择界面。按上箭头键选择第一项“Install Red Hat Enterprise Linux 8.2”（如图-7所示），然后按Enter键启动安装程序。

![在这里插入图片描述](https://img-blog.csdnimg.cn/00597795f0054f84a20abed1e35138d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图－7

2）选择语言类型

建议初学者选择“简体中文（中国）”以降低难度（如图-8所示），单击“继续”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1e484405e4bd4943bd3b63c81d7ee643.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－8

3）设置时间

点击“时间与日期”（如图-9所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/49996eb57dfb4a34b2c0c5ffb64506f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－9

选择亚洲的上海 （如图-10所示），单击上方的“完成”按钮。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b51551aa3023478cadc4039077f3bf64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-10

4）分区配置

选择“安装目的地”（如图-11所示）

![在这里插入图片描述](https://img-blog.csdnimg.cn/8d403222f6654ef8a6f9198be5553597.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－11

自动分区选择“完成”即可（如图-12所示）

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb26ca281b05470f93f594381855b690.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-12

点击左下角“开始安装”（如图-13所示）

![在这里插入图片描述](https://img-blog.csdnimg.cn/ef5894a110384259a6fca943c6410a3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-13

5）结束安装过程

设置root用户密码，经过一段时间安装系统，会提示重启主机（如图-14所示），根据提示操作即可。

![在这里插入图片描述](https://img-blog.csdnimg.cn/074a4b8665ab499b9e1ef88ee332c8ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－14

![在这里插入图片描述](https://img-blog.csdnimg.cn/54e330f4327944cb933ec07384d7ca22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－15

**步骤三：初始化配置**

完成LINUX系统的安装过程后，第一次启动时会要求进行初始化设置。

1）确认许可协议,如图-16与图-17所示，点击“完成”

![在这里插入图片描述](https://img-blog.csdnimg.cn/10f1d764eda24af7a7b2f795283692ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-16

![在这里插入图片描述](https://img-blog.csdnimg.cn/98ef996f335f4704bfd0966407343d87.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-17

2）选择“结束配置”（如图-18所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ee6329c1bb704e5dbd33f941fd5f5560.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-18

3）如图-19所示，点击“前进”

![在这里插入图片描述](https://img-blog.csdnimg.cn/e81156bcde6b4d5e95bf28ed90bbd418.png)
图-19

4）关闭“位置服务”点击前进 （如图-20所示）

![在这里插入图片描述](https://img-blog.csdnimg.cn/623f2a49b4414844ad28b2b849c358e6.png)
图-20

5）如图-21所示，点击“跳过”

/

图-21

6）如图-22所示，创建普通用户“niuben”点击前进

/

图-22

7）设置密码如图-23所示，点击前进

/

图-23

8）接下来只要单击“开始使用”即可

![在这里插入图片描述](https://img-blog.csdnimg.cn/c387ba629bab4d4eb16d51902bd70e50.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-24

点击“未列出”利用root用户自动登入（以后登录时需要提供密码）到桌面环境（如图-25所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f2a53e61707f40dab97831737159f045.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-25

至此，整个LINUX虚拟机系统的安装就完成了。

**步骤三：初始化配置**

1）配置Yum仓库

```shell
[root@localhost ~]# mkdir /dvd
[root@localhost ~]# mount /dev/cdrom /dvd
[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo
[AppStream]
name=rhel8.2
baseurl=file:///dvd/AppStream
enabled=1
gpgcheck=0
[BaseOS]
name=rhel8.2
baseurl=file:///dvd/BaseOS
enabled=1
gpgcheck=0
[root@localhost ~]# yum module  install container-tools
```

2）关闭防火墙与SELinux

```shell
[root@localhost ~]# systemctl stop firewalld
[root@localhost ~]# systemctl disable firewalld
[root@localhost ~]# setenforce 0
[root@localhost ~]# getenforce 
Permissive
[root@localhost ~]# vim /etc/selinux/config
……
SELINUX=permissive
……
```

3）配置IP地址与子网掩码

```shell
[root@localhost ~]# vim   /etc/default/grub      #grub内核引导程序
……..此处省略一万字
GRUB_CMDLINE_LINUX="…….. quiet   net.ifnames=0  biosdevname=0"
……..此处省略一万字              
[root@localhost ~]# grub2-mkconfig  -o  /boot/grub2/grub.cfg  #让网卡命名规则生效
[root@localhost ~]# reboot
[root@localhost ~]# ifconfig   |   head   -2
[root@localhost ~]# nmcli connection  add  type  ethernet      ifname eth0   con-name  eth0
[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.30/24 connection.autoconnect yes
[root@localhost ~]# nmcli connection up eth0
```

# 2 案例2：镜像管理命令

## 2.1 问题

本例要求掌握podman命令的基本操作，导入 httpd、myos、nginx 镜像

## 2.2 方案

真机传递数据到node-0001虚拟机操作：

- scp [...] user@host:远程目录 本地目录
- scp [...] 本地目录 user@host:远程目录

利用podman进行导入：

- podman load -i 备份文件

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：rsync同步基本操作**

1）将真机目录/linux-soft/1/podman 上传到虚拟机node-0001到根目录下

```shell
[root@localhost ~]# scp -r /linux-soft/1/podman  root@192.168.4.30:/
```

**步骤二：导入镜像**

```shell
[root@localhost ~]# podman images
REPOSITORY   TAG   IMAGE ID   CREATED   SIZE
[root@localhost ~]# podman load -i /podman/myos.tar.gz
Getting image source signatures
Copying blob 3e66766ae231 done
Copying blob bcc97fbfc9e1 done
Copying config 2f57195050 done
Writing manifest to image destination
Storing signatures
Loaded image(s): localhost/myos:latest
[root@localhost ~]# podman load -i /podman/httpd.tar.gz
Getting image source signatures
Copying blob 3e66766ae231 skipped: already exists
Copying blob bcc97fbfc9e1 skipped: already exists
Copying config 2f2eb9bd13 done
Writing manifest to image destination
Storing signatures
Loaded image(s): localhost/myos:httpd
[root@localhost ~]# podman load -i /podman/nginx.tar/gz
Getting image source signatures
Copying blob 3e66766ae231 skipped: already exists
Copying blob bcc97fbfc9e1 skipped: already exists
Copying config 8a90426645 done
Writing manifest to image destination
Storing signatures
Loaded image(s): localhost/myos:nginx
[root@localhost ~]# podman images
REPOSITORY       TAG      IMAGE ID       CREATED        SIZE
localhost/myos   nginx    8a9042664597   2 weeks ago    392 MB
localhost/myos   httpd    2f2eb9bd1363   2 weeks ago    392 MB
localhost/myos   latest   2f57195050eb   4 months ago   392 MB
```

# 3. 镜像管理命令

## 3.1 问题

本例要求掌握podman运行容器：

3.2 方案
podman run 命令的参数

- 参数 -i，交互式
- 参数 -t，终端
- 参数 -d，后台运行
- 参数 --name 容器名字

启动 centos 容器，并进入容器

- podman run -it myos:latest /bin/bash

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用镜像myos:latest启动容器**

```shell
[root@localhost ~]# podman run -it localhost/myos:latest /bin/bash
[root@881fb555f9d1 /]# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
[root@881fb555f9d1 /]# exit
exit
[root@localhost ~]# podman ps -a
CONTAINER ID  IMAGE                  COMMAND    CREATED             STATUS                     PORTS  NAMES
881fb555f9d1  localhost/myos:latest  /bin/bash  About a minute ago  Exited (0) 11 seconds ago         modest_tesla
[root@localhost ~]# podman rm 881fb555f9d1   #删除停止的容器
881fb555f9d17b278a46355e7f34c819f9c5c47b41029787085301ae5010ce1f
[root@localhost ~]# podman ps -a
CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES
[root@localhost ~]#
```

**步骤二：启动一个myos:httpd服务容器（后台）**

```shell
[root@localhost ~]# podman images
REPOSITORY       TAG      IMAGE ID       CREATED        SIZE
localhost/myos   nginx    8a9042664597   2 weeks ago    392 MB
localhost/myos   httpd    2f2eb9bd1363   2 weeks ago    392 MB
localhost/myos   latest   2f57195050eb   4 months ago   392 MB
[root@localhost ~]# podman run -itd localhost/myos:httpd 
173633de0200b4feba2a1cd1a20f392cf7ca923c7ccb4954bee971bf428d6d75
[root@localhost ~]# podman ps 
CONTAINER ID  IMAGE                 COMMAND               CREATED        STATUS            PORTS  NAMES
173633de0200  localhost/myos:httpd  /usr/sbin/httpd -...  4 seconds ago  Up 3 seconds ago         great_mahavira
[root@localhost ~]# podman exec -it 173633de0200 /bin/bash
[root@173633de0200 html]# ls
index.html  info.html  info.php
[root@173633de0200 html]# pwd
/var/www/html
[root@173633de0200 html]# cat index.html 
this is apache
[root@173633de0200 html]# exit
exit
[root@localhost ~]#
```

# 4. 容器高级使用

## 4.1 问题

- 利用myos:httpd镜像，创建一个名为logserver的容器
- 将/container挂载到容器中/var/www/html
- logserver容器以systemd服务的形式运行
  该服务命名为container-logserver，该服务设置为开机自启动

## 4.2 方案

**发布podman服务**

- 我们使用 -p 参数把容器端口和宿主机端口绑定
- 例如:把宿主机变成 apache
- podman run -d -p 80:80 myos:httpd

**podman可以映射宿主机文件或目录到容器中**

- 目标对象不存在就自动创建
- 目标对象存在就直接覆盖掉
- 多个容器可以映射同一个目标对象来达到数据共享的目的
- 启动容器时，使用 -v 映射参数（可有多个）
- podman run -d -v 宿主机对象:容器内对象 镜像名称:标签

管理员管理容器服务

- 管理员服务文件默认路径
- /usr/lib/systemd/system/
- 生成服务启动配置文件
- --files：生成文件类型
- podman generate systemd --name 容器名 --files
- 重新加载服务启动配置文件
- systemctl daemon-reload

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建/container目录**

1）创建目录

```shell
[root@localhost ~]# mkdir /container
```

2）建立网页文件

```shell
[root@localhost ~]# echo  contaiber test > /container/index.html
[root@localhost ~]# cat /container/index.html
contaiber test
```

**步骤二：运行容器**

1）运行容器，置入后台

```shell
[root@localhost ~]# podman  images
REPOSITORY       TAG      IMAGE ID       CREATED        SIZE
localhost/myos   nginx    8a9042664597   2 weeks ago    392 MB
localhost/myos   httpd    2f2eb9bd1363   2 weeks ago    392 MB
localhost/myos   latest   2f57195050eb   4 months ago   392 MB
[root@localhost ~]# podman run -itd --name=logserver -v /container/:/var/www/html -p 80:80 localhost/myos:httpd
98f582324701460ffd72f0640c13646ecec3669101ac7dc7614c28970a9bf441
[root@localhost ~]# podman ps
CONTAINER ID  IMAGE                 COMMAND               CREATED         STATUS             PORTS               NAMES
98f582324701  localhost/myos:httpd  /usr/sbin/httpd -...  21 seconds ago  Up 20 seconds ago  0.0.0.0:80->80/tcp  logserver
[root@localhost ~]#
```

2）测试访问

```shell
[root@localhost ~]# curl http://127.0.0.1
contaiber test
[root@localhost /]# podman exec -it logserver /bin/bash
[root@98f582324701 html]# ls
index.html
[root@98f582324701 html]# pwd
/var/www/html
[root@98f582324701 html]# cat index.html
contaiber test
[root@98f582324701 html]# exit
exit
[root@localhost /]#
```

**步骤三：将容器配置成systemd管理的服务**

1）建立服务文件

```shell
[root@localhost /]# cd /usr/lib/systemd/system
[root@localhost system]# podman generate systemd --name logserver   --files
/usr/lib/systemd/system/container-logserver.service
[root@localhost system]#
```

2）重新加载服务文件

```shell
[root@localhost system]# systemctl daemon-reload
```

3）设置开机自启动，重启系统测试

```shell
[root@localhost system]# systemctl enable container-logserver
Created symlink /etc/systemd/system/multi-user.target.wants/container-logserver.service → /usr/lib/systemd/system/container-logserver.service.
[root@localhost system]# reboot
```

4）重新进入系统查看

```shell
[root@localhost ~]# podman ps 
CONTAINER ID  IMAGE                 COMMAND               CREATED         STATUS             PORTS               NAMES
98f582324701  localhost/myos:httpd  /usr/sbin/httpd -...  22 minutes ago  Up 11 minutes ago  0.0.0.0:80->80/tcp  logserver
[root@localhost ~]# curl http://127.0.0.1
contaiber test
[root@localhost ~]#
```

# Exercise

## 1 简述podman运行容器时，映射主机端口格式

-p [可选IP]:宿主机端口:容器端口

例如:把宿主机变成 apache

podman run -itd -p 80:80 镜像名称:标签

## 2 简述podman运行容器时，主机卷的映射命令格式

podman run -itd -v 宿主机对象:容器内对象 镜像名称:标签

## 3 利用systemd管理服务时，服务文件默认路径在哪里？

/usr/lib/systemd/system/

## 4 如何生成容器的服务启动配置文件

podman generate systemd --name 容器名 --files




> 如有侵权，请联系作者删除



﻿@[TOC]( Lists and tuples & dictionaries & collections | Cloud computing )

---

# 1. 用列表构建栈结构

## 1.1 问题

创建stack.py脚本，要求如下：

1. 栈是一个后进先出的结构
2. 编写一个程序，用列表实现栈结构
3. 需要支持压栈、出栈、查询功能

## 1.2 方案

创建空列表存储数据，创建4个函数，分别实现压栈、出栈、查询以及判断函数调用的方法。

此程序需要注意的是堆栈的结构特点，先进后出，后进先出：

1. 调用show_menu()函数后，利用while循环交互端输出提示，请用户input0/1/2/3任意数值，如果输入的值不是0/1/2/3，打印输入值无效请重新输入并重新开始循环，如果输入的值是3，停止整个循环，如果输入的值是0/1/2通过字典键值对关联关系，调用相对应函数
2. 如果输入的值是0，字典cmds中0键对应的值是push_it，push_it()调用压栈函数，压栈函数利用stack.append()方法将输入数据追加到列表结尾
3. 如上，如果输入的值是1，调用出栈函数pop_it()，出栈函数如果stack列表中有数据，弹出列表最后一个元素（根据堆栈结构特点stack.pop()中参数为空），如果stack列表没有数据，输出空列表
4. 如果输入的值是2，调用查询函数view_it()，显示当前列表

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

让输出的文字带颜色：\033[31;1m高亮度红色字体、\033[31;1m高亮度绿色字体、\033[0m关闭所有属性

```shell
[root@localhost day04]# vim stack.py
#!/usr/bin/env python3
stack = []
def push_it():
    item = input('item to push: ')
    stack.append(item)
def pop_it():
    if stack:   
        print("\033[31;1mPopped %s\033[0m" % stack.pop())
    else:
        print('\033[31;1mEmpty stack\033[0m')
def view_it():
    print("\033[32;1m%s\033[0m" % stack)
def show_menu():
    prompt = """(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): """
    cmds = {'0': push_it, '1': pop_it, '2': view_it}
    while True:
        # strip() 方法用于移除字符串头尾指定的字符（默认为空格）
        choice = input(prompt).strip()[0]    
        if choice not in '0123':
            print('Invalid input. Try again.')
            continue     #结束本次循环
    
        if choice == '3':
            break       #结束整个循环
   
        cmds[choice]()   # push_it()  pop_it()
        # if choice == '0':
        #     push_it()
        # elif choice == '1':
        #     pop_it()
        # elif choice == '2':
        #     view_it()
if __name__ == '__main__':
    show_menu()
```

**步骤二：测试脚本执行**

```shell
[root@localhost day04]# python3 stack.py
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 6
Invalid input. Try again.
(0) push_it
(1) pop_it
(2) view_it
(3) quit 
Please input your choice(0/1/2/3): 0
item to push: nihao
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 1 
Popped nihao
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 2
[]
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 0
item to push: a         
(0) push_it
(1) pop_it
(2) view_it 
Please input your choice(0/1/2/3): 0
item to push: b
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 0
item to push: c
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 1
Popped c
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 2
['a', 'b']
(0) push_it
(1) pop_it
(2) view_it
(3) quit
Please input your choice(0/1/2/3): 3
(3) quit
```

# 2. 模拟用户登陆信息系统

## 2.1 问题

编写login.py脚本，实现以下目标：

1. 支持新用户注册，新用户名和密码注册到字典中
2. 支持老用户登陆，用户名和密码正确提示登陆成功
3. 主程序通过循环询问进行何种操作，根据用户的选择，执行注册或是登陆操作

## 2.2 方案

创建空字典存储用户名、密码，用三个函数分别实现用户注册、用户登录以及判断调用函数这三个方法，完成模拟用户登录：

1. 调用show_menu()函数后，利用while循环交互端输出提示，请用户input0/1/2任意数值，如果输入的值不是0/1/2，打印选择无效请重新输入并重新开始循环，如果输入的值是2，停止整个循环，如果输入的值是0/1/2通过字典键值对关联关系，调用相对应函数

2. 如果输入的值是0，字典cmds中0键对应的值是register，register ()调用注册函数，函数利用if方法判断输入用户名是否存在，如果用户名在字典中，输出用户名已存在，否则用户输入密码，并将用户名与密码以键值对形式放入字典中

3. 如上，如果输入的值是1，调用登录函数login()，利用if方法判断输入的用户名的对应的密码是否和字典中存储用户对应密码相同，如果不同显示登录失败，否则登录成功，此函数中导入getpass模块使用方法，作用是输入密码不可见。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day05]# vim login.py
#!/usr/bin/env python3
import getpass
userdb = {}
def register():
    username = input('username: ')
    if username in userdb:
        print('\033[31;1m%s already exists.\033[0m' % username)
    else:
        password = input('password: ')
        userdb[username] = password
def login():
    username = input('username: ')
    password = getpass.getpass('password: ')
    # if username not in userdb or userdb['username'] != password:
    if userdb.get(username) != password:
        print('\033[31;1mLogin incorrect\033[0m')
    else:
        print('\033[32;1mLogin successful\033[0m')
def show_menu():
    prompt = """(0) register
(1) login
(2) quit
Please input your choice(0/1/2): """
    cmds = {'0': register, '1': login}
    while True:
        choice = input(prompt).strip()[0]
        if choice not in '012':
            print('Invalid choice. Try again.')
            continue
        if choice == '2':
            break
        cmds[choice]()
if __name__ == '__main__':
    show_menu()
```

**步骤二：测试脚本执行**

```shell
[root@localhost day05]# python3 login.py 
(0) register
(1) login
(2) quit
Please input your choice(0/1/2): 0
username: a
password: 123
(0) register
(1) login
(2) quit
Please input your choice(0/1/2): 1
username: a
password: 
Login successful
(0) register
(1) login
(2) quit
Please input your choice(0/1/2): 1
username: b
password: 
Login incorrect
(0) register
(1) login
(2) quit
Please input your choice(0/1/2): 2
```

# 3. 比较文件内容

## 3.1 问题

编写程序，完成以下要求：

1. 有两个文件：a.log和b.log
2. 两个文件中有大量重复内容
3. 取出只有在b.log中存在的行

## 3.2 方案

使用集合去重效率高，操作简单。只要将两个文件内容转换成列表，再进行差补运算即可得到仅在b.log中存在的行。

**步骤一：准备两个文件**

```shell
[root@localhost day05]# cp /etc/passwd /tmp/a.log
[root@localhost day05]# cp /etc/passwd /tmp/b.log
# 修改b.log，使之与a.log有不同的行
[root@localhost day05]# vim /tmp/b.log
```

**步骤二：编写程序**

```shell
[root@localhost day05]# vim fdiff.py
with open('/tmp/a.log') as f1:
    aset = set(f1)
with open('/tmp/b.log') as f2:
    bset = set(f2)
with open('/tmp/result.txt', 'w') as f3:
     f3.writelines(bset - aset)
```

**步骤三：验证**

```shell
[root@localhost day05]# cat /tmp/result.txt
```

查看结果，result.txt中将是只有b.log中有，而a.log没有的行。

# Exercise

## 1 获取字典adict['name']的值，如果没有找到，则返回'Not Found'

```shell
>>> adict.get('name', 'Not Found')
```

## 2 遍历字典adict，通过两种方法取出字典的key和value。

```shell
>>> for key in adict:
...   print('%s: %s' % (key, adict[key]))
>>> for key, val in adict.items():
...   print('%s: %s' % (key, val))
## 3 aset和bset是两个可变集合，举例说明什么是交集、并集和差补。
- 交集：aset & bset，取出两个集合中都包含的元素
- 并集：aset | bset，取出两个集合中所有的元素
- 差补：aset - bset，取出在第一个集合中有，而第二个集合中没有的元素

## 4 ('hello')是哪种数据类型
('hello')是元组。单元素元组需要注意，元素后面必须有个逗号，否则构不成元组。

## 5 列表根据不同的分类方式，都属于哪些类型？
列表按存储模型来分，属于容器类型；按更新模型来分，属于可变型；按访问模型来分，属于序列类型。

> 如有侵权，请联系作者删除

```



﻿@[TOC]( Log analysis systems ELK & Elasticsearch & Kibana | Cloud computing )

---

# 1. 安装Elasticsearch

## 1.1 问题

本案例要求：

- 创建虚拟机并安装 elasticsearch
- 最低配置： 2cpu，2G内存，20G硬盘
- 虚拟机：192.168.1.41 es-0001

## 1.2 方案

1. ELK是日志分析平台，不是一款软件,而是一整套解决方案,是三个软件产品的首字母缩写，ELK分别代表：

Elasticsearch:负责日志检索和储存

Logstash:负责日志的收集和分析、处理

Kibana:负责日志的可视化

2) ELK组件在海量日志系统的运维中,可用于解决分布式日志数据集中式查询和管理系统监控等，故障排查，安全信息和事件管理，报表功能

部署Elasticsearch分布式集群安装，Kibana作为可视化平台，实时总结流量和数据的图表，Logstash用来收集处理日志

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：先准备一台虚拟机**

1）更改主机名，配置IP，搭建第三方yum源

```shell
# 在跳板机上把 elk 软件加入自定义 yum 仓库
[root@ecs-proxy ~]# cp -a elk /var/ftp/localrepo/elk
[root@ecs-proxy ~]# cd /var/ftp/localrepo/
[root@ecs-proxy localrepo]# createrepo --update .
```

2）安装elasticsearch

```shell
# 配置主机名解析
[root@es-0001 ~]# vim /etc/hosts
192.168.1.41    es-0001
[root@es-0001 ~]# yum makecache
[root@es-0001 ~]# yum install -y java-1.8.0-openjdk elasticsearch
[root@es-0001 ~]# vim /etc/elasticsearch/elasticsearch.yml
55:  network.host: 0.0.0.0
[root@es-0001 ~]# systemctl enable --now elasticsearch
[root@es-0001 ~]# curl http://192.168.1.41:9200/
{
  "name" : "War Eagle",
  "cluster_name" : "elasticsearch",
  "version" : {
    "number" : "2.3.4",
    "build_hash" : "e455fd0c13dceca8dbbdbb1665d068ae55dabe3f",
    "build_timestamp" : "2016-06-30T11:24:31Z",
    "build_snapshot" : false,
    "lucene_version" : "5.5.0"
  },
  "tagline" : "You Know, for Search"
}
```



# 2. 部署Elasticsearch集群

## 2.1 问题

本案例要求：

- 使用5台虚拟机组建 elasticsearch 集群
- 最低配置： 2cpu，2G内存，20G硬盘
- 虚拟机：
- 192.168.1.41 es-0001
- 192.168.1.42 es-0002
- 192.168.1.43 es-0003
- 192.168.1.44 es-0004
- 192.168.1.45 es-0005

### 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：更改hosts文件，更改配置文件**

1）更改hosts文件

```shell
[root@es-0001 ~]# vim  /etc/hosts
192.168.1.41    es-0001
192.168.1.42    es-0002
192.168.1.43    es-0003 
192.168.1.44    es-0004 
192.168.1.45    es-0005
```

2）更改配置文件

```shell
[root@es-0001 ~]# yum install -y java-1.8.0-openjdk elasticsearch
[root@es-0001 ~]# vim /etc/elasticsearch/elasticsearch.yml
17:  cluster.name: my-es
23:  node.name: es-0001 # 本机主机名
55:  network.host: 0.0.0.0
68:  discovery.zen.ping.unicast.hosts: ["es-0001", "es-0002"]
[root@es-0001 ~]# systemctl enable --now elasticsearch
[root@es-0001 ~]# curl http://192.168.1.41:9200/_cluster/health?pretty
{
  "cluster_name" : "my-es",
  "status" : "green",
  "timed_out" : false,
  "number_of_nodes" : 5,
  "number_of_data_nodes" : 5,
   ... ...
}
```

3） 其他机器（1.42-1.45）一样操作，安装elasticsearch和java-1.8.0-openjdk，同步配置文件在步骤一已经安装了一台elasticsearch，这里只需再准备四台即可

4）访问测试，如图-1所示：

可以访问任意一台主机， 集群的节点都是5台，ES 集群验证：返回字段解析：

”status”: ”green“ 集群状态：绿色为正常、黄色表示有问题但不是很严重、红色表示严重故障

”number_of_nodes”： 5, 表示集群中节点的数量

![img](https://img-blog.csdnimg.cn/img_convert/ec5e493e74e39c9e72ad27f6c6be073d.png)

图-1



# 3. 安装Elasticsearch插件

## 3.1 问题

本案例要求：

- 使用 head插件访问集群
- 购买云主机： 1cpu，1G内存，20G硬盘，并安装 apache
- 虚拟机：
- 192.168.1.48 web

实现此案例需要按照如下步骤进行。

**步骤一：部署插件**

安装 apache，并把 apache 和 es-0001 服务发布到互联网上

安装 apache

```shell
[root@web ~]# yum install -y httpd
[root@web ~]# tar zxf head.tar.gz
[root@web ~]# mv elasticsearch-head /var/www/html/head
[root@web ~]# systemctl enable --now httpd
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
[root@web ~]#
```

2）授权访问head插件访问 es-0001，如图-2所示：

```shell
[root@es-0001 ~]# vim /etc/elasticsearch/elasticsearch.yml
# 配置文件最后追加
http.cors.enabled : true
http.cors.allow-origin : "*"
http.cors.allow-methods : OPTIONS, HEAD, GET, POST, PUT, DELETE
http.cors.allow-headers : X-Requested-With,X-Auth-Token,Content-Type,Content-Length
[root@es-0001 ~]# systemctl restart elasticsearch.service
```

![img](https://img-blog.csdnimg.cn/img_convert/21710a5d0dd36c8b9d10e2a28def2c10.png)



# 4. 熟悉Elasticsearch的API调用

## 4.1 问题

本案例要求：

- 熟悉Elasticsearch的Api调用
- 增：PUT
- 删：DELETE
- 改：POST
- 查：GET

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建 tedu 索引使用 PUT 方式**

```shell
[root@es-0005 bin]# curl -XPUT -H "Content-Type: application/json" 'http://es-0001:9200/tedu' -d '{
    "settings":{
        "index":{
            "number_of_shards": 5, 
            "number_of_replicas": 1
        }
    }
}'
{"acknowledged":true}
```

**步骤二：增加数据**

```shell
[root@es-0005 bin]# curl –XPUT -H "Content-Type: application/json" 'http://es-0001:9200/tedu/teacher/1' -d \
> '{
>   "职业": "诗人",
>   "名字": "李白",
>   "称号": "诗仙",
>   "年代": "唐"
> }' 
{"_index":"tedu","_type":"teacher","_id":"1","_version":1,"_shards":{"total":2,"successful":2,"failed":0},"created":true}
```

**步骤三：查询数据**

```shell
[root@es-0005 bin]# curl -XGET http://es-0001:9200/tedu/teacher/1?pretty
{
  "_index" : "tedu",
  "_type" : "teacher",
  "_id" : "1",
  "_version" : 1,
  "found" : true,
  "_source" : {
    "职业" : "诗人",
    "名字" : "李白",
    "称号" : "诗仙",
    "年代" : "唐"
  }
}
```

**步骤四：修改数据**

```shell
[root@es-0005 bin]# curl -XPOST -H "Content-Type: application/json" http://es-0001:9200/tedu/teacher/1/_update -d \
> '{ 
>     "doc": {
>         "年代": "公元701"
>     }
> }'
{"_index":"tedu","_type":"teacher","_id":"1","_version":2,"_shards":{"total":2,"successful":2,"failed":0}}
```

**步骤五：删除数据**

注：删除时候可以是文档，也可以是索引，但不能是类型

```shell
[root@es-0005 bin]# curl –XDELETE -H "Content-Type: application/json" http://es-0001:9200/tedu/teacher/1
{"found":true,"_index":"tedu","_type":"teacher","_id":"1","_version":3,"_shards":{"total":2,"successful":2,"failed":0}}
[root@es-0005 bin]# curl -XDELETE -H "Content-Type: application/json" http://es-0001:9200/tedu
{"acknowledged":true}[root@es-0005 bin]# 
[root@es-0005 bin]# 
```



# 5. 安装Kibana

## 5.1 问题

本案例要求批量导入数据：

- 创建虚拟机并安装 kibana
- 最低配置： 1cpu，1G内存，10G硬盘
- 虚拟机IP： 192.168.1.46 kibana

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装kibana**

1）在另一台主机，配置ip为192.168.1.46，配置yum源，更改主机名

2）安装kibana

```shell
更改hosts文件
[root@kibana ~]# vim /etc/hosts
192.168.1.41    es-0001
192.168.1.42    es-0002
192.168.1.43    es-0003
192.168.1.44    es-0004
192.168.1.45    es-0005
192.168.1.46    kibana
[root@kibana ~]# yum -y install kibana
```

3）更改配置文件

```shell
[root@kibana ~]# yum install -y kibana
[root@kibana ~]# vim /etc/kibana/kibana.yml
02  server.port: 5601
07  server.host: "0.0.0.0"
28  elasticsearch.hosts: ["http://es-0002:9200", "http://es-0003:9200"]
37  kibana.index: ".kibana"
40  kibana.defaultAppId: "home"
113 i18n.locale: "zh-CN"
[root@kibana ~]# systemctl enable --now kibana
```

**步骤二：web 页面访问，如图-5所示：**

```shell
Firefox  http://192.168.1.46:5601
```

![img](https://img-blog.csdnimg.cn/img_convert/75b2cd612cfae9755ddc302a54e49416.png)

图-5



# 6. 导入日志并绘制图表

## 6.1 问题

本案例要求批量导入数据：

- 导入日志，并绘制图表
- 导入 logs 日志
- 绘制流量图和饼图

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：导入数据**

```shell
[root@localhost ~]# scp  /var/ftp/localrepo/elk/*.gz root@192.168.1.46:/root/
[root@kibana ~]# gzip  -d logs.jsonl.gz 
[root@kibana ~]# curl -XPOST -H "Content-Type: application/json" http://es-0001:9200/_bulk --data-binary @logs.jsonl
```

![img](https://img-blog.csdnimg.cn/img_convert/ae8179792d0011e77bfc25362406fa46.png)

图-6

3）kibana导入数据，如图-7所示：

```shell
firefox  http://192.168.1.46:5601
```

3）成功创建会有logstash-*，如图-7所示：

![img](https://img-blog.csdnimg.cn/img_convert/7529bfc8a844ff64138d0b551dc359f8.png)

图-7

注意： 这里没有数据的原因是导入日志的时间段不对，默认配置是最近15分钟，在这可以修改一下时间来显示

5）kibana修改时间，选择Lsat 15 miuntes

![img](https://img-blog.csdnimg.cn/img_convert/a1612ce9c8936b585f1710f3387c41e4.png)

图-8

7）选择时间2015-5-15到2015-5-22，如图-12所示：

8）查看结果，如图-9所示：

![img](https://img-blog.csdnimg.cn/img_convert/8aa86ffa411b181053f944f729aeff65.png)

图-9

9）除了柱状图，Kibana还支持很多种展示方式 ，如图-10所示：

![img](https://img-blog.csdnimg.cn/img_convert/001362a6c412d9377d665af4e42dc62f.png)

图-10

10）做一个饼图，选择Pie chart，如图-11所示：

11）结果，如图-11所示：

![img](https://img-blog.csdnimg.cn/img_convert/9d9b5566926440c95670aaaa6dff7259.png)

图-11



# Exercise

## 1 简述什么是ELK

ELK是一整套解决方案，是三个软件产品的首字母缩写，很多公司都在使用，如：Sina、携程、华为、美团等

ELK分别代表的意思

Elasticsearch：负责日志检索和储存

Logstash：负责日志的收集和分析、处理

Kibana：负责日志的可视化

这三款软件都是开源软件，通常是配合使用，而且又先后归于Elastic.co公司名下，故被简称为ELK

## 2 ELK可以实现什么功能

在海量日志系统的运维中，可用于解决分布式日志数据集中式查询和管理、系统监控，包含系统硬件和应用各个组件的监控、故障排查、安全信息和事件管理、报表功能

## 3 Elasticsearch主要特点

1. 实时分析

2. 分布式实时文件存储，并将每一个字段都编入索引

3. 文档导向，所有的对象全部是文档

4. 高可用性，易扩展，支持集群（Cluster） 、 分片和复制（Shards 和 Replicas）

5. 接口友好，支持JSON



> 如有侵权，请联系作者删除



﻿@[TOC]( Logical volume management & VDO & RAID array & process management | Cloud computing )

---

# 1. 新建一个逻辑卷

## 1.1 问题

本例要求沿用前一天案例，使用分区 /dev/sdb1 构建 LVM 存储，相关要求如下：

1. 新建一个名为 systemvg 的卷组
2. 在此卷组中创建一个名为 vo 的逻辑卷，大小为180MiB
3. 将逻辑卷 vo 格式化为 EXT4 文件系统
4. 将逻辑卷 vo 挂载到 /vo 目录，并在此目录下建立一个测试文件 votest.txt，内容为“I AM KING.”

## 1.2 方案

LVM创建工具的基本用法：

```shell
vgcreate  卷组名  物理设备.. ..
lvcreate  -L  大小  -n  逻辑卷名  卷组名
```

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建卷组**

1）新建名为systemvg的卷组

```shell
[root@server0 ~]# vgcreate  systemvg  /dev/sdb1
  Physical volume "/dev/sdb1" successfully created
  Volume group "systemvg" successfully created
```

2）确认结果

```shell
[root@server0 ~]# vgscan
  Reading all physical volumes.  This may take a while...
  Found volume group "systemvg" using metadata type lvm2
```

**步骤二：创建逻辑卷**

1）新建名为vo的逻辑卷

```shell
[root@server0 ~]# lvcreate  -L  180MiB  -n  vo  systemvg 
  Logical volume "vo" created
```

2）确认结果

```shell
[root@server0 ~]# lvscan
  ACTIVE            '/dev/systemvg/vo' [180.00 MiB] inherit
```

**步骤三：格式化及挂载使用**

1）格式化逻辑卷/dev/systemvg/vo

```shell
[root@server0 ~]# mkfs.ext4  /dev/systemvg/vo
.. ..
Allocating group tables: done 
Writing inode tables: done 
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done
```

2）挂载逻辑卷/dev/systemvg/vo

```shell
[root@server0 ~]# mkdir  /vo                              //创建挂载点
[root@server0 ~]# mount  /dev/systemvg/vo  /vo             //挂载
[root@server0 ~]# df  -hT  /vo/                         //检查结果
Filesystem              Type  Size  Used Avail Use% Mounted on
/dev/mapper/systemvg-vo ext4  171M  1.6M  157M   1% /vo
```

3）访问逻辑卷/dev/systemvg/vo

```shell
[root@server0 ~]# cat  /vo/votest.txt
I AM KING.
```

# 2. 扩展逻辑卷的大小

## 2.1 问题

本例要求沿用练习一，将逻辑卷 vo 的大小调整为 300MiB，要求如下：

1. 原文件系统中的内容必须保持完整
2. 必要时可使用之前准备的分区 /dev/sdb5 来补充空间
3. 注意：分区大小很少能完全符合要求的大小，所以大小在270MiB和300MiB之间都是可以接受的

## 2.2 方案

对于已经格式化好的逻辑卷，在扩展大小以后，必须通知内核新大小。

如果此逻辑卷上的文件系统是EXT3/EXT4类型，需要使用resize2fs工具；

如果此逻辑卷上的文件系统是XFS类型，需要使用xfs_growfs。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：确认逻辑卷vo的信息**

1）找出逻辑卷所在卷组

```shell
[root@server0 ~]# lvscan
  ACTIVE            '/dev/systemvg/vo' [180.00 MiB] inherit
  ACTIVE            '/dev/datastore/database' [800.00 MiB] inherit
```

2）查看该卷组的剩余空间是否可满足扩展需要

```shell
[root@server0 ~]# vgdisplay  systemvg
  --- Volume group ---
  VG Name               systemvg
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  2
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               196.00 MiB                          //卷组总大小
  PE Size               4.00 MiB
  Total PE              49
  Alloc PE / Size       45 / 180.00 MiB
  Free  PE / Size       4 / 16.00 MiB                      //剩余空间大小
  VG UUID               czp8IJ-jihS-Ddoh-ny38-j521-5X8J-gqQfUN
```

此例中卷组systemvg的总大小都不够300MiB、剩余空间才16MiB，因此必须先扩展卷组。只有剩余空间足够，才可以直接扩展逻辑卷大小。

**步骤二：扩展卷组**

1）将提前准备的分区/dev/sdb5添加到卷组systemvg

```shell
[root@server0 ~]# vgextend  systemvg  /dev/sdb5
  Physical volume "/dev/sdb5" successfully created
  Volume group "systemvg" successfully extended
```

2）确认卷组新的大小

```shell
[root@server0 ~]# vgdisplay  systemvg
  --- Volume group ---
  VG Name               systemvg
  .. ..
  VG Size               692.00 MiB                          //总大小已变大
  PE Size               4.00 MiB
  Total PE              173
  Alloc PE / Size       45 / 180.00 MiB
  Free  PE / Size       128 / 512.00 MiB                  //剩余空间已达512MiB
  VG UUID               czp8IJ-jihS-Ddoh-ny38-j521-5X8J-gqQfUN
```

**步骤三：扩展逻辑卷大小**

1）将逻辑卷/dev/systemvg/vo的大小调整为300MiB

```shell
[root@server0 ~]# lvextend  -L 300MiB  /dev/systemvg/vo 
  Extending logical volume vo to 300.00 MiB
  Logical volume vo successfully resized
```

2）确认调整结果

```shell
[root@server0 ~]# lvscan
  ACTIVE            '/dev/systemvg/vo' [300.00 MiB] inherit
  ACTIVE            '/dev/datastore/database' [800.00 MiB] inherit
```

3）刷新文件系统大小

确认逻辑卷vo上的文件系统类型：

```shell
[root@server0 ~]# blkid  /dev/systemvg/vo
/dev/systemvg/vo: UUID="d4038749-74c3-4963-a267-94675082a48a" TYPE="ext4"
```

选择合适的工具刷新大小：

```shell
[root@server0 ~]# resize2fs  /dev/systemvg/vo 
resize2fs 1.42.9 (28-Dec-2013)
Resizing the filesystem on /dev/systemvg/vo to 307200 (1k) blocks.
The filesystem on /dev/systemvg/vo is now 307200 blocks long.
```

确认新大小（约等于300MiB）：

```shell
[root@server0 ~]# mount  /dev/systemvg/vo  /vo/
[root@server0 ~]# df  -hT  /vo
Filesystem              Type  Size  Used Avail Use% Mounted on
/dev/mapper/systemvg-vo ext4  287M  2.1M  266M   1% /vo
```

# 3. 查看进程信息

## 3.1 问题

本例要求掌握查看进程信息的操作，使用必要的命令工具完成下列任务：

1. 找出进程 gdm 的 PID 编号值
2. 列出由进程 gdm 开始的子进程树结构信息
3. 找出进程 sshd 的父进程的 PID 编号/进程名称
4. 查看当前系统的CPU负载/进程总量信息

## 3.2 方案

查看进程的主要命令工具：

- ps aux、ps –elf：查看进程静态快照
- top：查看进程动态排名
- pstree：查看进程与进程之间的树型关系结构
- pgrep：根据指定的名称或条件检索进程

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：找出进程 gdm 的 PID 编号值**

使用pgrep命令查询指定名称的进程，选项-l显示PID号、-x精确匹配进程名：

```shell
[root@svr7 ~]# pgrep  -lx gdm
1584 gdm  
```

**步骤二：列出由进程 gdm 开始的子进程树结构信息**

使用pstree命令，可以提供用户名或PID值作为参数。通过前一步已知进程gdm的PID为1584，因此以下操作可列出进程gdm的进程树结构：

```shell
[root@svr7 ~]# pstree  -p  1584
gdm(1584)-+-Xorg(1703)
          |-gdm-session-wor(2670)-+-gnome-session(2779)-+-gnom+
          |                       |                     |-gnom+
          |                       |                     |-{gno+
          |                       |                     |-{gno+
          |                       |                     `-{gno+
          |                       |-{gdm-session-wor}(2678)
          |                       `-{gdm-session-wor}(2682)
          |-{gdm}(1668)
          |-{gdm}(1671)
          `-{gdm}(1702)
```

**步骤三：找出进程 sshd 的父进程的 PID 编号/进程名称**

要查看进程的父进程PID，可以使用ps –elf命令，简单grep过滤即可。找到进程sshd所在行对应到的PPID值即为其父进程的PID编号。为了方便直观查看，建议先列出ps表头行，以分号隔开再执行过滤操作。

```shell
[root@svr7 ~]# ps  -elf  |  head  -1 ; ps  -elf  |  grep  sshd
F S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root       1362      1  0  80   0 - 20636 poll_s Jan05 ?        00:00:00 /usr/sbin/sshd –D
.. ..                                 //可获知进程sshd的父进程PID为1
```

然后再根据pstree –p的结果过滤，可获知PID为1的进程名称为systemd：

```shell
[root@svr7 ~]# pstree  -p  |  grep  '(1)'
systemd(1)-+-ModemManager(995)-+-{ModemManager}(1018)
```

**步骤四：查看当前系统的CPU负载/进程总量信息**

使用top命令，直接看开头部分即可；或者 top -n 次数：

```shell
[root@svr7 ~]# top
top - 15:45:25 up 23:55,  2 users,  load average: 0.02, 0.03, 0.05
Tasks: 485 total,   2 running, 483 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.7 us,  1.0 sy,  0.0 ni, 97.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  1001332 total,    76120 free,   419028 used,   506184 buff/cache
KiB Swap:  2097148 total,  2096012 free,     1136 used.   372288 avail Mem
.. ..
```

观察Tasks: 485 total部分，表示进程总量信息。

观察load average: 0.02, 0.03, 0.05 部分，表示CPU处理器在最近1分钟、5分钟、15分钟内的平均处理请求数（对于多核CPU，此数量应除以核心数）。

对于多核CPU主机，如果要分别显示每颗CPU核心的占用情况，可以在top界面按数字键1进行切换：

```shell
[root@svr7 ~]# top
top - 15:47:45 up 23:57,  2 users,  load average: 0.02, 0.03, 0.05
Tasks: 485 total,   2 running, 269 sleeping,   0 stopped,   1 zombie
Cpu0  :  0.6%us,  7.8%sy,  0.0%ni, 91.6%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu1  :  0.7%us,  3.7%sy,  0.0%ni, 95.6%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu2  :  0.7%us,  1.7%sy,  0.0%ni, 97.6%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu3  :  0.3%us,  1.0%sy,  0.0%ni, 98.3%id,  0.3%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  16230564k total, 15716576k used,   513988k free,   326124k buffers
Swap:  8388604k total,   220656k used,  8167948k free, 11275304k cached
.. ..
```

# 4. 进程调度及终止

## 4.1 问题

本例要求掌握调度及终止进程的操作，使用必要的工具完成下列任务：

1. 运行“sleep 600”命令，再另开一个终端，查出sleep程序的PID并杀死
2. 运行多个vim程序并都放入后台，然后杀死所有vim进程
3. su切换为zhsan用户，再另开一个终端，强制踢出zhsan用户

## 4.2 方案

进程调度及终止的主要命令工具：

- 命令行 &：将命令行在后台运行
- Ctrl + z 组合键：挂起当前进程（暂停并转入后台）
- jobs：列出当前用户当前终端的后台任务
- bg 编号：启动指定编号的后台任务
- fg 编号：将指定编号的后台任务调入前台运行
- kill [-9] PID...：杀死指定PID值的进程
- kill [-9] %n：杀死第n个后台任务
- killall [-9] 进程名...：杀死指定名称的所有进程
- pkill：根据指定的名称或条件杀死进程
- 

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：根据PID杀死进程**

1）开启sleep测试进程

```shell
[root@svr7 ~]# sleep 600
//.. .. 进入600秒等待状态
```

2）找出进程sleep的PID

另开一个终端，ps aux并过滤进程信息（第2列为PID值）：

```shell
[root@svr7 ~]# ps  aux  |  grep  sleep
root      32929  0.0  0.0   4312   360 pts/1    S+   17:25   0:00 sleep 600
```

3）杀死指定PID的进程

```shell
[root@svr7 ~]# kill  -9  32929
```

返回原终端会发现sleep进程已经被杀死：

```shell
[root@svr7 ~]# sleep 600
Killed
```

**步骤二：根据进程名杀死多个进程**

1）在后台开启多个vim进程

```shell
[root@svr7 ~]# vim  a.txt &
[1] 33152
[root@svr7 ~]# vim  b.txt &
[2] 33154
[1]+  已停止               vim a.txt
[root@svr7 ~]# vim  c.txt &
[3] 33155
[2]+  已停止               vim b.txt
```

2）确认vim进程信息

```shell
[root@svr7 ~]# jobs  -l
[1]  33152 停止 (tty 输出)     vim a.txt
[2]- 33154 停止 (tty 输出)     vim b.txt
[3]+ 33155 停止 (tty 输出)     vim c.txt
```

3）强制杀死所有名为vim的进程

```shell
[root@svr7 ~]# killall  -9  vim
[1]   已杀死               vim a.txt
[2]-  已杀死               vim b.txt
[3]+  已杀死               vim c.txt
```

4）确认杀进程结果

```shell
[root@svr7 ~]# jobs  -l 
[root@svr7 ~]#
```

**步骤三：杀死属于指定用户的所有进程**

1）登入测试用户zhsan

```shell
[root@svr7 ~]# useradd  zhsan
[root@svr7 ~]# su  -  zhsan
[zhsan@svr7 ~]$
```

2）另开一个终端，以root用户登入，查找属于用户zhsan的进程

```shell
[root@svr7 ~]# pgrep  -u  zhsan
33219
[root@svr7 ~]# pstree  -up  33219                              //检查进程树
bash(33219,zhsan)
```

3）强制杀死属于用户zhsan的进程

```shell
[root@svr7 ~]# pkill  -9  -u  zhsan
[root@svr7 ~]#
```

4）返回原来用户zhsan登录的终端，确认已经被终止

```shell
[zhsan@svr7 ~]$ 已杀死
[root@svr7 ~]#
```

# Exercise

## 1 LVM基本概念。

关于LVM逻辑卷的管理，基本概念及应用如下，请补充完整：

1）PV表示（ ），VG表示（ ），LV表示（ ）

2）创建及使用逻辑卷的主要过程：（ ） 。

> 物理卷、卷组、逻辑卷
> PV物理卷-->VG卷组-->LV逻辑卷-->格式化-->挂载使用

## 2 LVM常用命令。

关于LVM逻辑卷的管理，最常用的一些操作如下，请写出各自的命令字：

> 1）扫描物理卷 （ ），创建物理卷 （ ）。
> 2）扫描卷组（ ），创建卷组（ ），删除卷组（ ）。
> 3）创建逻辑卷（ ），查看逻辑卷（ ）。
> 4）扩展逻辑卷（ ），扩展卷组（ ）。

1）pvscan、pvcreate
2）vgscan、vgcreate、vgremove
3）lvcreate、lvdisplay
4）lvextend、vgextend

## 3 LVM磁盘应用实战。

> 为一台RHEL6虚拟机添加2块20G的SCSI磁盘，相关要求如下：
> 1）将两块磁盘组合成名为data_vg的卷组。
> 2）从卷组data_vg中建立一个名为data_lv的逻辑卷，大小为16G。
> 3）确保开机后能自动将逻辑卷data_lv挂载为/mbox。
> 4）完成上述操作后，将data_lv的容量扩展为24G。

1）准备实验环境

```shell
[root@svr5 ~]# ls /dev/sdb1 /dev/sdc1
/dev/sdb1      /dev/sdc1  
.. ..
```

2）创建VG、验证VG

```shell
[root@svr5 ~]# vgcreate data_vg /dev/sd{b,c}1
  Volume group "data_vg" successfully created
[root@svr5 ~]# vgscan 
  Reading all physical volumes.  This may take a while...
  Found volume group "data_vg" using metadata type lvm2
[root@svr5 ~]# vgdisplay 
.. ..
```

3）创建LV、验证LV

```shell
[root@svr5 ~]# lvcreate -L 16G -n data_lv data_vg
  Logical volume "data_lv" created
[root@svr5 ~]# lvscan 
  ACTIVE            '/dev/data_vg/data_lv' [16.00 GB] inherit
```

4）格式化LV、挂载文件系统

```shell
[root@svr5 ~]# mkfs.ext4 /dev/data_vg/data_lv 
[root@svr5 ~]# mkdir /mbox
[root@svr5 ~]# mount /dev/data_vg/data_lv /mbox/
[root@svr5 ~]# mount | grep mbox
/dev/mapper/data_vg-data_lv on /mbox type ext4 (rw)
```

5）访问逻辑卷，测试写入、读取操作

```shell
[root@svr5 ~]# ls > /mbox/file.txt
[root@svr5 ~]# tail -n 1 /mbox/file.txt 
install.log.syslog
```

6）在线扩展逻辑卷

```shell
[root@svr5 ~]# lvextend -L 24G /dev/data_vg/data_lv 
  Extending logical volume data_lv to 24.00 GB
  Logical volume data_lv successfully resized
[root@svr5 ~]# lvdisplay /dev/data_vg/data_lv | grep Size 
  LV Size                24.00 GB
[root@svr5 ~]# resize2fs /dev/data_vg/data_lv 
resize2fs 1.39 (29-May-2006)
Filesystem at /dev/data_vg/data_lv is mounted on /mbox; on-line resizing required
Performing an on-line resize of /dev/data_vg/data_lv to 6291456 (4k) blocks.
The filesystem on /dev/data_vg/data_lv is now 6291456 blocks long.
[root@svr5 ~]# df -h
文件系统              容量  已用 可用 已用% 挂载点
/dev/sda2              19G  2.7G   16G  15% /
/dev/sda1              99M   12M   82M  13% /boot
tmpfs                 500M     0  500M   0% /dev/shm
/dev/mapper/data_vg-data_lv
                       24G  173M   23G   1% /mbox
[root@svr5 ~]# tail -n 1 /mbox/file.txt 
install.log.syslog
```

## 4 简述RAID的含义及特点。

> RAID的含义及优势？RAID0、RAID1、RAID5分别指什么、各自的特点？

1）RAID：廉价冗余磁盘阵列，指通过硬件/软件技术将多个较小/低速的磁盘整合成一个大磁盘使用的一种存储技术，其不仅可存储数据，还可以实现一定程度的冗余保障，具有“速度快、安全性高”的优势。

2）RAID0、RAID1、RAID5的含义及特点如下：

- RAID0：条带模式，由两个或两个以上的磁盘组成，同一份文档分散在不同的磁盘中，并行写入，提高写效率。
- RAID1：镜像模式，由至少两个磁盘组成，同一份文件被分别写入到不同的磁盘中，每份磁盘数据一样，实现容错，提高读效率。
- RAID5：分布式奇偶校验的独立磁盘模式，结合RAID0和RAID1的好处，同时避免它们的缺点。由至少3块以上大小相同的磁盘组成，实现冗余。

## 5 使用top命令监控进程

> 执行“dd if=/dev/sda of=/dev/null &”命令，然后查找出系统中CPU占用最高的进程，并杀死此该进程。

1）启用后台任务

```shell
[root@svr7 ~]# dd  if=/dev/zero  of=/dev/null  &
[1] 27691
```

2）通过top命令对进程排名，默认情况下排第1位的进程CPU占用最高

查看进程排名：

```shell
[root@svr7 ~]# top
top - 11:07:18 up 3 days, 14:44,  4 users,  load average: 0.23, 0.21, 0.09
Tasks: 150 total,   3 running, 146 sleeping,   0 stopped,   1 zombie
Cpu(s):  3.0%us, 16.2%sy,  0.0%ni,  0.0%id, 76.4%wa,  3.7%hi,  0.7%si,  0.0%st
Mem:   1023848k total,  1015420k used,     8428k free,   532008k buffers
Swap:  4056360k total,      200k used,  4056160k free,    82580k cached
  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
27691 root      18   0 63204  600  504 R 19.7  0.1   0:04.38 dd
  265 root      10  -5     0    0    0 S  0.7  0.0   0:02.42 kswapd0
27694 root      15   0 12764 1140  836 R  0.3  0.1   0:00.01 top
    1 root      15   0 10372  696  588 S  0.0  0.1   0:01.31 init
    2 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 migration/0
    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0
    4 root      10  -5     0    0    0 S  0.0  0.0   2:33.94 events/0
    5 root      10  -5     0    0    0 S  0.0  0.0   0:00.00 khelper
   14 root      16  -5     0    0    0 S  0.0  0.0   0:00.00 kthread
   18 root      10  -5     0    0    0 S  0.0  0.0   0:01.46 kblockd/0
   19 root      20  -5     0    0    0 S  0.0  0.0   0:00.00 kacpid
  187 root      19  -5     0    0    0 S  0.0  0.0   0:00.00 cqueue/0
  190 root      10  -5     0    0    0 S  0.0  0.0   0:00.22 khubd
  192 root      10  -5     0    0    0 S  0.0  0.0   0:00.00 kseriod
  262 root      15   0     0    0    0 S  0.0  0.0   0:00.01 khungtaskd
  263 root      25   0     0    0    0 S  0.0  0.0   0:00.00 pdflush
  264 root      15   0     0    0    0 S  0.0  0.0   0:10.22 pdflush
```

按k键输入要结束的进程id，等待杀死对应的进程：

```shell
.. ..
PID to kill: 27691
Kill PID 27691 with signal [15]:
```

## 6 杀死名称以rh开头的所有进程

1）找出目标进程

```shell
[root@svr7 ~]# pgrep -l ^rh
790 rhsmcertd
1308 rhnsd
```

2）杀死这些进程

```shell
[root@svr7 ~]# pkill ^rh
```

3）确认结果

```shell
[root@svr7 ~]# pgrep -l ^rh
[root@svr7 ~]#
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Logstash & Real-time analysis of Web logs | Cloud computing )

---

# 1. 安装Logstash

## 1.1 问题

本案例要求：

- 创建虚拟机并安装 logstash
- 最低配置： 2cpu，2G内存，10G硬盘
- 虚拟机IP： 192.168.1.47 logstash

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装logstash**

1）配置主机名，ip和yum源，配置/etc/hosts

```shell
[root@logstash ~]# vim /etc/hosts
192.168.1.41    es-0001
192.168.1.42    es-0002
192.168.1.43    es-0003
192.168.1.44    es-0004
192.168.1.45    es-0005
192.168.1.46    kibana
192.168.1.47    logstash
```

2）安装java-1.8.0-openjdk和logstash

```shell
[root@logstash ~]# yum -y install java-1.8.0-openjdk logstash
[root@logstash ~]# java -version
openjdk version "1.8.0_161"
OpenJDK Runtime Environment (build 1.8.0_161-b14)
OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode)
[root@logstash ~]# ln -s /etc/logstash /usr/share/logstash/config 
[root@logstash ~]# vim /etc/logstash/conf.d/my.conf
input { 
  stdin {}
}
filter{ }
output{ 
  stdout{}
}
[root@logstash ~]# /usr/share/logstash/bin/logstash
```



# 2. 编写logstash配置文件

## 2.1 问题

本案例要求：

- 编写 logstash 配置文件
- 标准输入采用 json 编码格式
- 标准输出采用 rubydebug 编码格式
- 启动 logstash 验证

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：codec类插件**

1）codec类插件

```shell
[root@logstash ~]# vim /etc/logstash/conf.d/my.conf
input { 
  stdin { codec => "json" }
}
filter{ }
output{ 
  stdout{ codec => "rubydebug" }
}
[root@logstash ~]# /usr/share/logstash/bin/logstash
Settings: Default pipeline workers: 2
Pipeline main started
a
{
       "message" => "a",
           "tags" => [
          [0] "_jsonparsefailure"
],
      "@version" => "1",
    "@timestamp" => "2020-05-23T12:34:51.250Z",
          "host" => "logstash"
}
```



# 3. Logstash input插件

## 3.1 问题

本案例要求：

- 编写 logstash 配置文件
- 从文件中读取数据，并在屏幕显示
- 启动 logstash 验证

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：file模块插件**

1）file模块插件

```shell
[root@logstash ~]# vim /etc/logstash/conf.d/my.conf
input { 
  file {
    path => ["/tmp/c.log"]
    type => "test"
    start_position => "beginning"
    sincedb_path => "/var/lib/logstash/sincedb"
  }
}
filter{ }
output{ 
  stdout{ codec => "rubydebug" }
}
[root@logstash ~]# rm -rf /var/lib/logstash/plugins/inputs/file/.sincedb_*
[root@logstash ~]# touch /tmp/a.log /tmp/b.log
[root@logstash ~]# /usr/share/logstash/bin/logstash
```

另开一个终端：写入数据

```shell
[root@logstash ~]#  echo a1 >> /tmp/a.log 
[root@logstash ~]#  echo b1 >> /var/tmp/b.log
```

之前终端查看：

```shell
[root@logstash ~]# /usr/share/logstash/bin/logstash
Settings: Default pipeline workers: 2
Pipeline main started
{
       "message" => "a1",
      "@version" => "1",
    "@timestamp" => "2019-03-12T03:40:24.111Z",
          "path" => "/tmp/a.log",
          "host" => "logstash",
          "type" => "testlog"
}
{
       "message" => "b1",
      "@version" => "1",
    "@timestamp" => "2019-03-12T03:40:49.167Z",
          "path" => "/tmp/b.log",
          "host" => "logstash",
          "type" => "testlog"
}
```



# 4. Web日志解析实验

## 4.1 问题

本案例要求：

- Web日志解析实验
- 复制一条 web 日志添加到文件中
- 使用 grok 匹配出日志的各个字段含义转化成 json 格式

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：filter grok模块插件**

grok插件：

解析各种非结构化的日志数据插件

grok使用正则表达式把飞结构化的数据结构化

在分组匹配，正则表达式需要根据具体数据结构编写

虽然编写困难，但适用性极广

解析Apache的日志，之前已经安装过的可以不用安装

浏览器访问网页，在/var/log/httpd/access_log有日志出现

```shell
[root@es-0005 ~]# cat /var/log/httpd/access_log
192.168.1.254 - - [12/Mar/2019:11:51:31 +0800] "GET /favicon.ico HTTP/1.1" 404 209 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
[root@logstash ~]#  vim /etc/logstash/logstash.conf
input{
    file {
      path           => [ "/tmp/a.log", "/tmp/b.log" ]
      sincedb_path   => "/var/lib/logstash/sincedb"
      start_position => "beginning"
      type           => "testlog"
   }
}
filter{
    grok{
       match => [ "message",  "(?<key>reg)" ]
    }
}
output{
    stdout{ codec => "rubydebug" }
}
```

复制/var/log/httpd/access_log的日志到logstash下的/tmp/c.log

```shell
[root@logstash ~]# echo '192.168.1.252 - - [29/Jul/2020:14:06:57 +0800] "GET /info.html HTTP/1.1" 200 119 "-" "curl/7.29.0"' >/tmp/c.log
[root@logstash ~]# vim /etc/logstash/conf.d/my.conf
input { 
  file {
    path => ["/tmp/c.log"]
    type => "test"
    start_position => "beginning"
    sincedb_path => "/dev/null"
  }
}
filter{ 
  grok {
    match => { "message" => "%{HTTPD_COMBINEDLOG}" }
  }
}
output{ 
  stdout{ codec => "rubydebug" }
}
[root@logstash ~]# /usr/share/logstash/bin/logstash
```

查找正则宏路径

```shell
[root@logstash ~]# cd 
/usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/logstash-patterns-core-4.1.2/patterns
[root@logstash ~]# cat httpd  //查找COMBINEDAPACHELOG
COMBINEDAPACHELOG %{COMMONAPACHELOG} %{QS:referrer} %{QS:agent}
[root@logstash ~]#  vim /etc/logstash/logstash.conf
...
filter{
   grok{
        match => ["message", "%{ HTTPD_COMBINEDLOG }"]
  }
}
...
```

解析出的结果

```shell
 [root@logstash ~]#  /opt/logstash/bin/logstash -f  /etc/logstash/logstash.conf  
Settings: Default pipeline workers: 2
Pipeline main started
{
        "message" => "192.168.1.254 - - [15/Sep/2018:18:25:46 +0800] \"GET /noindex/css/open-sans.css HTTP/1.1\" 200 5081 \"http://192.168.1.65/\" \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0\"",
       "@version" => "1",
     "@timestamp" => "2018-09-15T10:55:57.743Z",
           "path" => "/tmp/a.log",
ZZ           "host" => "logstash",
           "type" => "testlog",
       "clientip" => "192.168.1.254",
          "ident" => "-",
           "auth" => "-",
      "timestamp" => "15/Sep/2019:18:25:46 +0800",
           "verb" => "GET",
        "request" => "/noindex/css/open-sans.css",
    "httpversion" => "1.1",
       "response" => "200",
          "bytes" => "5081",
       "referrer" => "\"http://192.168.1.65/\"",
          "agent" => "\"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0\""
}
...
```



# 5. 部署beats与filebeat

## 5.1 问题

本案例要求：

- 打通ELK全流程
- 在 logstash 上安装配置 beats 插件
- web 服务器上安装 filebeat
- 使用 filebeat 收集 web 日志，并发送给 logstash
- 将日志转化为json格式存入elasticsearch

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：filter grok模块插件**

```shell
[root@logstash ~]# vim /etc/logstash/conf.d/my.conf
input { 
  stdin { codec => "json" }
  file{
    path => ["/tmp/c.log"]
    type => "test"
    start_position => "beginning"
    sincedb_path => "/var/lib/logstash/sincedb"
  }
  beats {
    port => 5044
  }
} 
filter{ 
  grok {
    match => { "message" => "%{HTTPD_COMBINEDLOG}" }
  }
} 
output{ 
  stdout{ codec => "rubydebug" }
  elasticsearch {
    hosts => ["es-0004:9200", "es-0005:9200"]
    index => "weblog-%{+YYYY.MM.dd}"
  }
}
[root@logstash ~]# /usr/share/logstash/bin/logstash
```

2）在之前安装了Apache的主机上面安装filebeat

```shell
[root@web ~]# yum install -y filebeat
[root@web ~]# vim /etc/filebeat/filebeat.yml
24:  enabled: true
28:  - /var/log/httpd/access_log
45:    fields: 
46:       my_type: apache
148, 150 注释掉
161: output.logstash:
163:   hosts: ["192.168.1.47:5044"]
180, 181, 182 注释掉
[root@web ~]# grep -Pv "^\s*(#|$)" /etc/filebeat/filebeat.yml
[root@web ~]# systemctl enable --now filebeat
```



# Exercise

## 1 什么是kibana

数据可视化平台工具

## 2 Logstash插件有哪些

codec类插件、file插件、tcp和udp插件、syslog插件、filter grok插件



> 如有侵权，请联系作者删除



﻿@[TOC]( Mail and JSON & Requests module & API interface calls | Cloud computing )

---

# 1. 通过本机发送邮件

## 1.1 问题

编写一个send_mail.py脚本，实现以下功能：

1. 创建bob和alice帐户
2. 编写发送邮件件程序，发件人为root，收件人是本机的bob和alice帐户

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建bob和alice帐户**

```shell
[root@ localhost day12]# ls /home/
Student  zabbix  zhangsan
[root@localhost day12]# useradd bob
[root@localhost day12]# useradd alice
[root@localhost day12]# ls /home/
alice  bob  Student  zabbix  zhangsan
```

**步骤二：编写发送邮件件程序，发件人为root，收件人是本机的bob和alice帐户**

```shell
[root@ localhost day12]# vim send_mail.py
import smtplib
from email.mime.text import MIMEText
from email.header import Header
#邮件正文有三个参数：第一个为文本内容，第二个设置文本格式plain，第三个utf-8设置编码保证多语言兼容性
message = MIMEText('Python邮件发送测试\n', 'plain', 'utf8')    
标准邮件需要三个头部信息： From, To, 和 Subject
#发送者信息
message['From'] = Header('root@localhost', 'utf8')    
#接收者信息
message['To'] = Header('bob@localhost', 'utf8')
#主题信息
message['Subject'] = Header('mail test', 'utf8')
sender = 'root@redhat.com'        #发送方
receivers = ['bob@localhost', 'alice@126.com']    #收件方
smtp_obj = smtplib.SMTP('localhost')    #用localhost发邮件
# smtplib负责发送邮件
smtp_obj.sendmail(sender, receivers, message.as_string())
```

SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。

Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。

Python SMTP 对象使用 sendmail 方法发送邮件：

```shell
smtp_obj.sendmail(sender, receivers, message.as_string())
```

参数说明：
sender: 邮件发送者地址。
receivers: 字符串列表，邮件发送地址。
message.as_string(): 发送消息 ，str模式

由于可以一次发给多个人，所以recives传入一个列表，邮件正文是一个str，as_string()把MIMEText对象变成str。

**步骤三：测试脚本执行**

```shell
[root@ localhost day12]# python3 send_mail.py
[root@ localhost day12]# mail –u bob
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
“/var/mail/bob”: 1 message 1 new
>N  1 =?utf8?q?root=4Oloca  Mon Jul 30 09:36  18?663  “”
& 1
From root@redhat.com Mon Jul 30 09:36:44 2018
Return- Path: <root@redhat.com>
X- Original- To: bob@localhost.tedu.cn
Content- Type: text/plain; charset=“utf8”
From: root@localhost@room8pc16.tedu.cn
To: bob@localhost@room8pc16.tedu.cn
Subject: mail test
Date: Mon, 30 Jul 2018 09:36:44 +0800 (CST)
Status: R
Python邮件发送测试
&
```

# 2. 通过互联网服务器发送邮件

## 2.1 问题

编写一个mail_client.py脚本，实现以下功能：

1. 通过自己互联网注册的邮箱，为其他同学互联网邮箱发邮件

## 2.2 方案

导入sys模块，用sys.argv方法获取get_web函数实参，让用户在命令行上提供http://www.tedu.cn和/tmp/tedu.html两个参数，调用get_web函数实现如下功能：

1) 导入urllib模块，使用urllib模块的urlopen函数打开url（即网址），赋值给html
2) 以写方式打开/tmp/tedu.html文件
3) 以循环方式：
   读html获取的数据，保存到data
   将data写入/tmp/tedu.html
4) 关闭html

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备**

使用SMTP协议发送的邮件，需要先查看您的发件人邮箱是否有开启SMTP协议，如没有需要开启，测试使用的是126.com的邮箱作为发信人邮箱，开启SMTP协议如下

1. 先登录到126.com邮箱，如图-1所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/61935878136a41479f7f40a7d3ce1021.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

2. 看到邮箱上面的功能栏中有一个“设置”的选项，单击该选项，然后选择下拉菜单的“POP3/SMTP/IMAP”，如图-2所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5022edfc0bad4744985e33f135492442.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

3. 如图-3所示，上面红框的两个必须勾选上，如没有勾选，要选择开启就可以勾选上了：

![在这里插入图片描述](https://img-blog.csdnimg.cn/187aa3023a57494ea0e49a5852a5416b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

4. 页面向下可以可以看到下图-4红框里是：SMTP服务器是:smtp.126.com：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1374e0da612348928bc4991b7f9e7b09.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

**步骤二：编写脚本**

```shell
[root@ localhost day12]# vim mail_client.py
#!/usr/bin/env python3
import smtplib
from getpass import getpass
from email.mime.text import MIMEText
from email.header import Header
mail_host = 'smtp.126.com'        #发件人邮箱账号
mail_user = 'zhangzhigang79@126.com'        #收件人邮箱账号
mail_pwd = getpass()        #获取密码
#邮件正文有三个参数：第一个为文本内容，第二个设置文本格式plain，第三个utf-8设置编码保证多语言兼容性
message = MIMEText('Python邮件发送测试\n', 'plain', 'utf8')
#发送者信息
message['From'] = Header('zhangzhigang79@126.com', 'utf8')
#接收者信息
message['To'] = Header('zhangzhigang79@126.com', 'utf8')
#主题信息
message['Subject'] = Header('python 1802 mail test', 'utf8')
sender = 'zhangzhigang79@126.com'        #发送方
receivers = ['zhangzhigang79@126.com']        #接收方
smtp_obj = smtplib.SMTP()        #创建SMTP对象
smtp_obj.connect(mail_host)    #将SMTP对象与发送人邮件简历连接建立连接
smtp_obj.login(mail_user, mail_pwd)        #登录用户名密码
# SMTP 对象使用 sendmail 方法发送邮件
smtp_obj.sendmail(sender, receivers, message.as_string())
```

**步骤三：测试脚本执行**

```shell
[root@ localhost day12]# python3 mail_client.py
Password：
```

如果发送成功，结果显示如图-5所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/bf3656e71afd493fa542ff3d019ad147.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

# 3. 天气预报查询

## 3.1 问题

编写一个display_weather.py脚本，实现以下功能：

1. 运行程序时，屏幕将出现你所在城市各区县名字
2. 用户指定查询某区县，屏幕上将出现该区县当前的气温、湿度、风向、风速等

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：找到天气信息规律**

1. 首先我们想要实现的功能是天气预报，从哪获取天气这是一个问题，在这里可以使用http://www.weather.com.cn/data/sk/101051301.html这个应用程序编程接口，101051301是城市的ID，可以到http://www.weather.com.cn/查看，替换后浏览器打开，如图-6所示，图示为json格式：

![在这里插入图片描述](https://img-blog.csdnimg.cn/4321f04761634ef2a56b4c8417794588.png)
图-6

注意：图中看不懂的文字是编码问题

2. 从图-1中可以看出cityid就是城市ID，temp是温度，SD是湿度，我们编写代码可以直接获取到网站相应信息，编写脚本wather.py：

```shell
[root@ localhost day12]# vim weather.py
#!/usr/bin/python     #这里是python的目录
from urllib.request import urlopen
import json
#打开网页，使用urllib模块的urlopen函数打开url，赋值给html
html = urlopen('http://www.weather.com.cn/data/sk/101010100.html')
#读html获取的数据，保存到data
data = html.read()
#从data中获取我们想要的信息，json.loads()是将json格式数据转换为字典
#（可以理解为json.loads()函数是将字符串转化为字典）
print(json.loads(data))
#关闭html
html.close()
```

3.执行脚本结果如下：

```shell
[root@ localhost day12]# python3 weather.py
{‘weatherinfo’:{‘city’:‘北京’,‘cityid’:‘101010100’,‘temp’:‘27.9’,‘WD’:‘南风’,‘WS’:‘小于3级’,‘SD’:‘28%’,‘AP’:‘1002hPa’,‘njd’:‘暂无实况’,‘WSE’:‘<3’,‘time’:‘17:55’,‘sm’:‘2.1’,‘isRadar’:‘1’,‘Radar’:‘JC_RADAR_AZ9010_JB’}}
```

从以上脚本执行结果中我们可以看到，从网站中获取到的数据是以字典形式显示，显示信息有城市、城市id，温度、风向等等，根据这种规律，编写下面代码

**步骤二：编写代码实现如下功能**

1. 定义一个字典，该字典中键‘0’和‘1’对应的值为天气网址中城市对应的id，城市不同id则不同
2. 运行程序时，屏幕将出现你所在城市名字
3. 当用户指定查询某城市（即输入0或1时）
4. 调用get_weather函数，函数的实际参数为city_codes字典对应值（即对应的城市id）
5. 打开天气网页，使用urllib模块的urlopen函数打开url，赋值给html
6. 读html获取的数据，用json.loads()获取天气信息，获取到的信息为字典形式
7. 从获取到的字典数据中提取气温、湿度、风向、风速等信息，保存在output变量中
8. 将output变量作为get_weather函数的返回值，打印在屏幕上

```shell
[root@ localhost day12]# vim display_weather.py
#!/usr/bin/python
from urllib.request import urlopen
import json
def get_weather(city_code):        #定义一个输入城市id的函数
5. 打开天气网页，使用urllib模块的urlopen函数打开url，赋值给html
    url = 'http://www.weather.com.cn/data/sk/%s.html' % city_code
    html = urlopen(url)
6.读html获取的数据，用json.loads()获取我们想要的信息
#json.loads()是将json格式数据转换为字典
#（可以理解为json.loads()函数是将字符串转化为字典）
    data = json.loads(html.read())
7.output为返回值，即最终屏幕显示的信息
    output = '风向：%s, 风力: %s， 温度：%s, 湿度：%s' % (
#data获取到的天气信息为字典，该字典中weatherinfo键对应的值还是一个字典，这个字典中‘WD’键对应的值是风向，‘WS’键对应的值是风力，'temp'键对应的值是温度，'SD'键对应的值是湿度，利用键值对关系将相应数据显示出来即可
        data['weatherinfo']['WD'],
        data['weatherinfo']['WS'],
        data['weatherinfo']['temp'],
        data['weatherinfo']['SD']
    )
    return output
if __name__ == '__main__':
1.定义字典：键对应的值为天气网站网址接口中城市ID
    city_codes = { '0': '101010100', '1': '101121404'}
2．代码执行后，屏幕给出的提示信息
    prompt = """(0) 北京
(1) 台儿庄
请选择(0/1): """
3．根据提示信息，输入0或1
    choice = input(prompt)
4.调用get_weather函数，其实际参数为city_codes字典对应值
8.打印调用get_weather函数返回值
    print(get_weather(city_codes[choice]))
```

**步骤三：测试脚本执行**

```shell
[root@ localhost day12]# python3 display_weather.py
(0) 北京
(1) 台儿庄
请选择(0/1): 0
 风向：南风， 风力： 小于3级， 温度：27.9， 湿度：28%
[root@ localhost day12]# python3 display_weather.py
(0) 北京
(1) 台儿庄
请选择(0/1): 1
 风向：东北风， 风力： 小于3级， 温度：22.3， 湿度：64%
```

# 4. 钉钉机器人

## 4.1 问题

通过钉钉软件创建一个群聊机器人，要求：

1. 编写代码，通过python脚本实现钉钉机器人在群中发送消息
2. 使用json和requests模块

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在钉钉中创建群聊机器人**

/

图-7

/

图-8

/

图-9

/

图-10

/

图-11

**步骤二：编写代码**

```shell
[root@ localhost day12]# vim dingtalk.py
import json
import requests
import sys
def send_msg(url, reminders, msg):
    headers = {'Content-Type': 'application/json;charset=utf-8'}
    data = {
        "msgtype": "text",  # 发送消息类型为文本
        "at": {
            "atMobiles": reminders,
            "isAtAll": False,   # 不@所有人
        },
        "text": {
            "content": msg,   # 消息正文
        }
    }
    r = requests.post(url, data=json.dumps(data), headers=headers)
    return r.text
if __name__ == '__main__':
    msg = sys.argv[1]
    reminders = ['15055667788']  # 特殊提醒要查看的人,就是@某人一下
    url = 此处填写上面webhook的内容
    print(send_msg(url, reminders, msg))
```

**步骤三：测试脚本执行**

```shell
[root@ localhost day12]# python3 dingtalk.py "这只是一个测试而已"
```

/
图-12

# 5. 通过阿里云api查询天气

## 5.1 问题

通过阿里云开发者平台查询天气，要求：

1. 在阿里云开发者平台0元购买api产品
2. 使用json和requests模块

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：登陆阿里云平台**

1. 在浏览器中打开http://www.aliyun.com
2. 使用阿里系账户登陆

**步骤二：购买产品**

1. 登陆后在搜索框中搜索“天气”
2. 找到“杭州网尚科技”
3. 点击0元购买
4. 点击“管理控制台”，在后台找到查询所需的APPCODE

**三：编写代码**

```shell
>>> url = 'http://jisutqybmf.market.alicloudapi.com/weather/query'
>>> headers = {'Content-Type': 'application/json; charset=UTF-8', 'Authorization': 'APPCODE 你管理后台中查询到的appcode'}
>>> params = {'citycode': '101010100'}
>>> r = requests.get(url, headers=headers, params=params)
>>> data = r.json()
>>> import pprint
>>> pprint.pprint(data)
# 取出后天最高、最低温度
>>> pprint.pprint(data['result']['daily'][2]['day']['temphigh'])
'8'
>>> pprint.pprint(data['result']['daily'][2]['night']['templow'])
'-2'
```

# Exercise

## 1 smtplib和email模块的作用是什么？

- smtplib模块定义了一个SMTP客户端会话对象，可用于发送邮件。
- email模块是用于管理电子邮件的库。它不是用来发送邮件的，而是用来生成发送的邮件对象的。如，email对象可以设置email的头部结构以及正文。

## 2 什么是JSON？它的主要作用是什么？

- JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于程序语言的文本格式。易读，也方便机器进行解析和生成。
- 它的主要作用是将各种数据结构转换成字符串，然后在函数之间传递字符串，或者将字符串从Web客户机传递给服务器端程序。接收端接收到字符串后，还能再转换成相应的数据类型。

## 3 如下代码所示，requests模块发送请求后，返回的数据可以用哪些方式进行读取？

> ```shell
> import requests
> r = requests.get('http://www.tedu.cn/')
> ```

- r.text：返回字符串形式的数据
- r.content：返回二进制形式的数据
- r.json()：用于读取json格式的数据

## 4 HTTP的方法用哪些？

- GET：请求获取Request-URI所标识的资源
- POST：在Request-URI所标识的资源后附加新的数据
- OPTIONS：请求与给定路径匹配的HTTP头的值
- HEAD：请求服务器做好一切发送资源的准备，但是只发送头信息
- DELETE：请求服务器删除Request-URI所标识的资源
- PUT：请求服务器存储一个资源，并用Request-URI作为其标识
- TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT：保留将来使用

> 如有侵权，请联系作者删除



﻿@[TOC]( Master-slave replication & persistence, data types | Cloud computing )

---

# 1. redis主从复制

## 1.1 问题

具体要求如下：

- 将主机192.168.4.51配置为主服务器
- 将主机192.168.4.52配置为192.168.4.51的从服务器
- 测试配置

## 1.2 方案

部署redis一主一从复制结构，主机角色，如图-1所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2af8c6ce9dcf40b49ae84fca275a86c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图－1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：将主机192.168.4.51配置为主服务器**

1） 每台redis服务器，默认都是主服务器;所以主服务器不需要配置。

```shell
[root@redisA ~]# redis-cli -h 192.168.4.51 –p 6351 
192.168.4.51:6351> info replication        //查看复制信息
# Replication
role:master            //是master 服务器  
connected_slaves:0    //从服务器个数零台
master_replid:eaa14478158a71c41f947eaea036658c2087e8f2
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
192.168.4.51:6351>
```

**步骤二：将主机192.168.4.52配置为192.168.4.51的从服务器**

1）命令行配置（马上生效）

```shell
[root@redisB ~]# redis-cli -h 192.168.4.52 –p 6352    
192.168.4.52:6352> slaveof  192.168.4.51  6351  //指定主服务器ip地址与端口
OK
192.168.4.52:6352> info replication   //查看复制信息
# Replication
role:slave  //从服务器
master_host:192.168.4.51        //主服务器ip地址
master_port:6351 //主服务器端口
master_link_status:up //连接状态开启
master_last_io_seconds_ago:3
master_sync_in_progress:0
```

2）永久配置（重新redis服务后，依然有效）

```shell
[root@redisB ~]# vim /etc/redis/6379.conf    
slaveof  192.168.4.51  6351    //在文件末尾添加或在原有配置项上修改都可以
:wq
```

3）在主服务器查看复制信息

```shell
[root@redisA ~]# redis-cli -h 192.168.4.51 –p 6351
192.168.4.51:6351> info replication  //查看复制信息
# Replication
role:master
connected_slaves:1 //从服务器个数 1台
slave0:ip=192.168.4.52,port=6352,state=online,offset=14,lag=1    //从服务器信息
master_replid:db7932eb0ea4302bddbebd395efa174fb079319f
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14
192.168.4.51:6351>
```

**步骤三：测试配置**

1）客户端连接主服务器存储数据

```shell
[root@client50 ~]# redis-cli -h 192.168.4.51 –p 6351    
192.168.4.51:6351> set x  9
OK
192.168.4.51:6351> set y  8
OK
192.168.4.51:6351> set z  7
OK
192.168.4.51:6351>
```

2）在从服务器本机登录，查看数据（与主服务器数据一致）

```shell
[root@redisB ~]#     redis-cli -h 192.168.4.52 –p 6352
192.168.4.52:6352> keys  *
1）“x”
2）“y”
3）“z”
192.168.4.52:6352>
```

# 2. 配置带验证的主从复制

## 2.1 问题

- 具体要求如下：
- 基于案例1的配置
- 设置主服务器192.168.4.51 设置连接密码123456
- 配置从服务器192.168.4.52

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：设置主服务器192.168.4.51 设置连接密码123456**

1） 修改主服务器的配置文件，设置密码。

```shell
[root@redisA ~]# vim +501 /etc/redis/6379.conf 
requirepass  123456   //设置密码
:wq
[root@redisA ~]# vim +43  /etc/init.d/redis_6379  //修改脚本
$CLIEXEC -h 192.168.4.51 -p 6351 -a 123456  shutdown //添加密码
:wq
[root@redisA ~]# /etc/init.d/redis_6379 stop //停止服务
[root@redisA ~]# /etc/init.d/redis_6379  start //启动服务
Starting Redis server...
[root@redisA ~]# 
[root@redisA ~]# netstat -utnlp  | grep  :6351  //查看端口
tcp        0      0 192.168.4.51:6351       0.0.0.0:*               LISTEN      11523/redis-server
```

**步骤二：配置从服务器192.168.4.52**

1） 修改配置文件，设置主服务器连接密码。

```shell
[root@redisB ~]# /etc/init.d/redis_6379 stop //停止服务
[root@redisB ~]# vim +289 /etc/redis/6379.conf 
masterauth  123456   //设置密码
:wq
[root@redisA ~]# /etc/init.d/redis_6379  start //启动服务
Starting Redis server...
[root@redisA ~]# 
[root@redisA ~]# netstat -utnlp  | grep  :6351  //查看端口
tcp        0      0 192.168.4.51:6351       0.0.0.0:*               LISTEN      11523/redis-server
```

2） 在从服务器本机连接服务，查看复制信息

```shell
[root@redisB ~]# redis-cli -h 192.168.4.52 –p 6352    
192.168.4.52:6352> info replication   //查看复制信息
# Replication
role:slave  //从服务器
master_host:192.168.4.51        //主服务器ip地址
master_port:6351 //主服务器端口
master_link_status:up //连接状态开启
master_last_io_seconds_ago:3
master_sync_in_progress:0
……
……
192.168.4.52:6352>
```

# 3. 哨兵服务

## 3.1 问题

- 具体要求如下：
- 基于案例2配置
- 配置哨兵服务
- 测试配置

## 3.2 方案

角色规划如图-1所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/198c6fa7a7524d95ba7d531735279250.png)
图－1

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置哨兵服务（192.168.4.57）**

1） 安装源码软件redis ，无需做初始化配置。

```shell
[root@redis57 redis]# yum -y install gcc 
[root@redis57 redis]# tar -zxf redis-4.0.8.tar.gz
[root@redis57 redis]# cd redis-4.0.8/
[root@redis1 redis-4.0.8]# make
[root@redis1 redis-4.0.8]# make install
```

2）编辑主配置文件

```shell
[root@redis57 redis]# vim  /etc/sentinel.conf  //创建主配置文件
sentinel   monitor   server51   192.168.4.51   6351   1 //监视主服务器
bind  0.0.0.0    //哨兵服务地址（表示本机所有网络接口）
sentinel auth-pass  server51   123456   //主服务器密码
:wq
```

3）启动哨兵服务

```shell
[root@redis57 redis]# redis-sentinel /etc/sentinel.conf    //启动哨兵服务
25371:X 28 Sep 11:16:54.993 # +sdown master redis51 192.168.4.51 6351
25371:X 28 Sep 11:16:54.993 # +odown master redis51 192.168.4.51 6351 #quorum 1/1
25371:X 28 Sep 11:16:54.993 # +new-epoch 3
25371:X 28 Sep 11:16:54.993 # +try-failover master redis51 192.168.4.51 6351
25371:X 28 Sep 11:16:54.994 # +vote-for-leader be035801d4d48eb63d8420a72796f52fc5cec047 3
...
25371:X 28 Sep 11:16:55.287 * +slave slave 192.168.4.51:6351 192.168.4.51 6351 @ redis51 192.168.4.52 6351
25371:X 28 Sep 11:17:25.316 # +sdown slave 192.168.4.51:6379 192.168.4.51 6379 @ redis51 192.168.4.52 6352
```

**步骤二：测试配置**

1）停止主服务器51的redis服务

```shell
[root@redisA ~]#     /etc/init.d/redis_6379 stop
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisA ~]#
```

2）在服务器52主机，查看复制信息

```shell
 [root@redisB ~]# redis-cli -h 192.168.4.52 -p 6352
192.168.4.52:6352> info replication
# Replication
role:master  //角色是master
connected_slaves:0
……
……
```

# 4. 使用RDB文件恢复数据

## 4.1 问题

- 要求如下：
- 启用RDB
- 设置存盘间隔为120秒且10个key改变数据自动存盘
- 备份RDB文件
- 删除数据
- 使用RDB文件恢复数据

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用RDB文件恢复数据**

RDB介绍：
Redis数据库文件，全称Reids DataBase
数据持久化方式之一
在指定时间间隔内，将内存中的数据集快照写入硬盘
术语叫Snapshot快照
恢复时，将快照文件直接读到内存里

相关配置参数
文件名
dbfilename “dump.rdb” 文件名

数据从内存保存到硬盘的频率
save 900 1 900秒内且有1个key改变
save 300 10 300秒内且有10个key改变
save 60 10000 60秒内且有10000个key改变

```shell
[root@redisA ~]# vim /etc/redis/6379.conf
dbfilename dump.rdb
save 900 1        
#save 300 10 //注释原有设置
save 120 10 //时间修改为 120秒
save 60 10000
：wq
[root@redisA ~]#     /etc/init.d/redis_6379 stop  //停止服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redisA ~]#
[root@redisA ~]# rm –rf  /var/lib/redis/6379/* //清空数据库目录
[root@redisA ~]# /etc/init.d/redis_6379 start //启动服务
Starting Redis server...
[root@redisA ~]#
[root@redisA ~]# ls /var/lib/redis/6379  //此时，查看数据库目录下没有dump.rdb文件
[root@redisA ~]# 
[root@redisA ~]# redis-cli -h 192.168.4.51  -p 6351  -a 123456  //连接服务，在200秒内存储10个变量，就会自动在数据库目录下创建dump.rdb 文件
192.168.4.51:6351> set v1 k1
OK
192.168.4.51:6351> set v2 k1
OK
192.168.4.51:6351> set v3 k1
OK
192.168.4.51:6351> set v4 k1
OK
192.168.4.51:6351> set v45 k1
OK
192.168.4.51:6351> set v46 k1
OK
192.168.4.51:6351> set v7 k1
OK
192.168.4.51:6351> set v8 k1
OK
192.168.4.51:6351> set v9 k1
OK
192.168.4.51:6351> set v10 k1
OK
192.168.4.51:6351> keys *
 1) "v2"
 2) "v9"
 3) "v10"
 4) "v45"
 5) "v4"
 6) "v1"
 7) "v46"
 8) "v8"
 9) "v7"
10) "v3"
192.168.4.51:6351>exit
[root@redisA ~]# ls /var/lib/redis/6379  //此时，查看数据库目录下有dump.rdb文件
dump.rdb
[root@redisA ~]#
```

备份数据

```shell
[root@redisA ~]# cd /var/lib/redis/6379/
[root@redisA 6379]# ls
dump.rdb  
[root@redisA 6379]# cp dump.rdb  /tmp/dump.rdb    //备份dump.rdb文件
[root@redisA 6379]# scp  /tmp/dump.rdb  root@192.168.4.56:/root/ //传递备份文件给目标主机
```

删除数据 （56主机模拟误删除数据）

```shell
[root@redis56 ~]# redis-cli -h 192.168.4.56 –p 6356        //连接服务
192.168.4.56:6356> flushall
OK
192.168.4.51:6379> keys *        //已经没有数据
(empty list or set)
192.168.4.56:6356> exit
[root@redis56 ~]#
```

恢复数据(56主机使用备份文件恢复数据)

```shell
[root@redis56 ~]# /etc/init.d/redis_6379 stop  //停止服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redis56 ~]# 
[root@redis56 ~]# rm  -rf  /var/lib/redis/6379/*  //清空数据库目录
[root@redis56 ~]# cp  /tmp/dump.rdb   /var/lib/redis/6379/ //拷贝备份文件到数据库目录下
[root@redis56 ~]# /etc/init.d/redis_6379  start  //    启动服务
Starting Redis server...
[root@redis56 ~]# redis-cli -h 192.168.4.56 –p 6356 //访问服务
192.168.4.56:6356> keys *  //查看数据
 1) "v7"
 2) "v46"
 3) "v45"
 4) "v8"
 5) "v4"
 6) "v2"
 7) "v1"
 8) "v3"
 9) "v9"
10) "v10"
192.168.4.56:6356>
```

# 5. 使用AOF文件恢复数据

## 5.1 问题

- 具体要求如下：
- 启用AOF
- 备份AOF文件
- 删除数据
- 使用AOF文件恢复数据

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用AOF文件恢复数据**

1）修改配置文件

```shell
[root@redisA ~]# redis-cli -h 192.168.4.51 –p 6351 -a 123456 //连接服务
192.168.4.51:6351>config  set   appendonly yes     //启用aof，默认no
192.168.4.51:6351> config  rewrite //写进配置文件
192.168.4.51:6351> save
192.168.4.51:6351> exit
[root@redisA ~]# ls  /var/lib/redis/6379/   //会出现appendonly.aof文件
appendonly.aof  dump.rdb  
[root@redisA ~ ]# 
```

2）备份AOF文件

```shell
[root@redisA ~]# cd /var/lib/redis/6379/
[root@redisA 6379]# cp appendonly.aof /tmp/appendonly.aof
[root@redisA 6379]# scp /tmp/appendonly.aof  root@192.168.4.57:/root/  //传递备份文件给目标主机
```

3）删除数据（在57主机 默认数据误删除）

```shell
[root@redis57 ~]# redis-cli -h 192.168.4.57 -p 6357  //连接服务
192.168.4.57:6357> flushall  //清除数据
OK
192.168.4.57:6357> keys * //查看数据
(empty list or set)
192.168.4.57:6357> exit
[root@redis57  ~ ]# 
```

4) 使用AOF文件恢复数据

```shell
[root@redis57 ~]# vim +673 /etc/redis/6379.conf
appendonly  yes  //启用AOF
:wq
[root@redis57 ~]#
[root@redis57 ~]# /etc/init.d/redis_6379 stop  //停止服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@redis57 ~]# 
[root@redis57 ~]#  /etc/init.d/redis_6379  start //启动服务
Starting Redis server...
[root@redis57 ~]# 
[root@redis57 ~]# rm  -rf  /var/lib/redis/6379/* //删除没有数据的文件
[root@redis57 ~]# cp  /root/appendolny.aof /var/lib/redis/6379/  //拷贝文件
[root@redis57 ~]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redis57 ~]# redis-cli -h 192.168.4.57 -p 6357 //连接服务
192.168.4.57:6357> keys *  //查看数据
 1) "v9"
 2) "v5"
 3) "v8"
 4) "v2"
 5) "v1"
 6) "v4"
 7) "v10"
 8) "v6"
 9) "v7"
10) "v3"
192.168.4.57:6357>
```

# 6. 字符类型

## 6.1 问题

1. 练习命令的使用，具体命令如下：
   set getrange strlen append setbit bitcount
   decr decrby incr incrby incrbyfloat

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：string 字符串**

设置key及值，过期时间可以使用秒或毫秒为单位

setrange key offset value

```shell
192.168.4.56:6356> set  x 9 ex 10 //单位秒
OK
192.168.4.56:6356> 
192.168.4.56:6356> set  y 29 px 10 //单位毫秒
OK
192.168.4.56:6356> 
192.168.4.56:6356> set  y 39 NX //不存在赋值
OK
192.168.4.56:6356> get y //变量值没变
"39"
192.168.4.56:6356> 
192.168.4.56:6356> set  y 49 xx //变量存在赋值
OK
192.168.4.56:6356> get y //变量变了
"49"
192.168.4.56:6356>
```

2) 从偏移量开始复写key的特定位的值

```shell
192.168.4.51:6351> set  first  "hello world"
OK
192.168.4.51:6351> setrange  first  6  "Redis"     //改写为hello Redis
(integer) 11
192.168.4.51:6351> get first
"hello Redis"
```

3) strlen key，统计字串长度

```shell
192.168.4.51:6379> strlen first
(integer) 11
```

4) append key value 存在则追加，不存在则创建key及value，返回key长度

```shell
192.168.4.51:6379> append myname jacob
(integer) 5
```

5) setbit key offset value 对key所存储字串，设置或清除特定偏移量上的位(bit)，value值可以为1或0，offset为0~2^32之间，key不存在，则创建新key

```shell
192.168.4.51:6379> setbit  bit  0  1          //设置bit第0位为1
(integer) 0
192.168.4.51:6379> setbit  bit  1  0          //设置bit第1位为0 
(integer) 0
```

6) bitcount key 统计字串中被设置为1的比特位数量

```shell
192.168.4.51:6379> setbit  bits 0 1        //0001
(integer) 0
192.168.4.51:6379> setbit  bits 3 1        //1001
(integer) 0
192.168.4.51:6379> bitcount  bits            //结果为2
(integer) 2
```

记录网站用户上线频率，如用户A上线了多少天等类似的数据，如用户在某天上线，则使用setbit，以用户名为key，将网站上线日为offset，并在该offset上设置1，最后计算用户总上线次数时，使用bitcount用户名即可，这样即使网站运行10年，每个用户仅占用10*365比特位即456字节

```shell
192.168.4.51:6379> setbit  peter  100  1        //网站上线100天用户登录了一次
(integer) 0
192.168.4.51:6379> setbit  peter  105  1        //网站上线105天用户登录了一次
(integer) 0
192.168.4.51:6379> bitcount  peter
(integer) 2
```

7) decr key 将key中的值减1，key不存在则先初始化为0，再减1

```shell
192.168.4.51:6379> set z 10
OK
192.168.4.51:6379> decr z
(integer) 9
192.168.4.51:6379> decr z
(integer) 8
192.168.4.51:6379> decr bb
(integer) -1
192.168.4.51:6379> decr bb
(integer) -2
```

8) decrby key decrement 将key中的值，减去decrement

```shell
192.168.4.51:6379> set count 100
OK
192.168.4.51:6379> DECRBY cc 20    //定义每次减少20（步长）
(integer) -20
192.168.4.51:6379> DECRBY cc 20
(integer) -40
```

9) getrange key start end 返回字串值中的子字串，截取范围为start和end，负数偏移量表示从末尾开始计数，-1表示最后一个字符，-2表示倒数第二个字符

```shell
192.168.4.51:6379> set x 123456789
OK
192.168.4.51:6379> getrange x -5 -1
"56789"
192.168.4.51:6379> getrange x 0 4
"12345"
```

10) incr key 将key的值加1，如果key不存在，则初始为0后再加1，主要应用为计数器

```shell
192.168.4.51:6379> set page 20
OK
192.168.4.51:6379> incr page
(integer) 21
```

11) incrby key increment 将key的值增加increment

```shell
192.168.4.51:6379> set x 10
OK
192.168.4.51:6379> incr x
(integer) 11
192.168.4.51:6379> incr x
(integer) 12
```

12) incrbyfloat key increment 为key中所储存的值加上浮点数增量 increment

```shell
192.168.4.51:6379> set num 16.1
OK
192.168.4.51:6379> incrbyfloat num 1.1
"17.2"
```

13）字符类型实践

Redis 对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象ID:对象属性”来命名一个键，如使用键【user:1:friends】来存储ID为1的用户的好友列表。

例：如果你正在编写一个博客网站，博客的一个常见的功能是统计文章的访问量，我们可以为每篇文章使用一个名为【post:文章ID:page.view】的键来记录文章的访问量，每次访问文章的时候使用INCR命令使相应的键值递增。

```shell
# 有用户访问文章ID号为42的博文，则将其访问计数加1
127.0.0.1:6379> INCR post:42:page.view
(integer) 1
127.0.0.1:6379> GET post:42:page.view
"1"
127.0.0.1:6379> INCR post:42:page.view
(integer) 2
127.0.0.1:6379> GET post:42:page.view
"2"
```

# 7. list 列表

## 7.1 问题

练习命令使用，具体如下：
lpush llen lrange lpop
lindex lset rpush rpop

## 7.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：list 列表**

1) lpush key value [value…] 将一个或多个值value插入到列表key的表头，Key不存在，则创建key

```shell
192.168.4.51:6379> lpush list a b c        //list值依次为c b a
(integer) 3
```

2) lrange key start stop 从开始位置读取key的值到stop结束

```shell
192.168.4.51:6379> lrange list 0 2        //从0位开始，读到2位为止
1) "c"
2) "b"
3) "a"
192.168.4.51:6379> lrange list 0 -1    //从开始读到结束为止
1) "c"
2) "b"
3) "a"
192.168.4.51:6379> lrange list 0 -2        //从开始读到倒数第2位值
1) "c"
2) "b"
```

3) lpop key 移除并返回列表头元素数据，key不存在则返回nil

```shell
192.168.4.51:6379> lpop list        //删除表头元素，可以多次执行
"c"
192.168.4.51:6379>  LPOP list
"b"
```

4) llen key 返回列表key的长度

```shell
192.168.4.51:6379>  llen list
(integer) 1
```

5) lindex key index 返回列表中第index个值

```shell
192.168.4.51:6379> lindex  list  1
"c"
```

6) lset key index value 将key中index位置的值修改为value

```shell
192.168.4.51:6379> lpush list a b c d 
(integer) 5
192.168.4.51:6379> lset list 3 test        //将list中第3个值修改为test
OK
```

7) rpush key value [value…] 将value插入到key的末尾

```shell
192.168.4.51:6379> rpush list3  a b c    //list3值为a b c
(integer) 3
192.168.4.51:6379> rpush list3 d    //末尾插入d
(integer) 4
```

8) rpop key 删除并返回key末尾的值

```shell
192.168.4.51:6379> RPOP list3 
"d"
```

9）列表类型实践 记录最新的10篇博文

```shell
127.0.0.1:6379> LPUSH posts:list 11 12 13
(integer) 3
127.0.0.1:6379> LRANGE posts:list 0 -1
1) "13"
2) "12"
3) "11"
```

# 8. 散列类型

## 8.1 问题

练习命令使用，具体如下：
hset hmset hgetall hkeys hvals
hget hmget hdel

## 8.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：hash表**

1）hset key field value 将hash表中field值设置为value

```shell
192.168.4.51:6379> hset site google 'www.g.cn'
(integer) 1
192.168.4.51:6379> hset site baidu 'www.baidu.com'
(integer) 1
```

2) hget key filed 获取hash表中field的值

```shell
192.168.4.51:6379> hget site google
"www.g.cn"
```

3) hmset key field value [field value…] 同时给hash表中的多个field赋值

```shell
192.168.4.51:6379> hmset site google www.g.cn  baidu www.baidu.com
OK
```

4) hmget key field [field…] 返回hash表中多个field的值

```shell
192.168.4.51:6379> hmget site google baidu
1) "www.g.cn"
2) "www.baidu.com"
```

5) hkeys key 返回hash表中所有field名称

```shell
192.168.4.51:6379> hmset site google www.g.cn baidu www.baidu.com
OK
192.168.4.51:6379> hkeys  site
1) "google"
2) "baidu"
```

6) hgetall key 返回hash表中所有key名和对应的值列表

```shell
192.168.4.51:6379> hgetall site
1) "google"
2) "www.g.cn"
3) "baidu"
4) "www.baidu.com"
```

7) hvals key 返回hash表中所有key的值

```shell
192.168.4.51:6379> hvals site
1) "www.g.cn"
2) "www.baidu.com"
```

8) hdel key field [field…] 删除hash表中多个field的值，不存在则忽略

```shell
192.168.4.51:6379> hdel  site  google  baidu
(integer) 2
```

9）散列类型实践

将文章ID号为10的文章以散列类型存储在Redis中

```shell
127.0.0.1:6379> HSET post:10 title 例解Python
(integer) 1
127.0.0.1:6379> HGETALL post:10
1) "title"
2) "\xe4\xbe\x8b\xe8\xa7\xa3Python"
127.0.0.1:6379> HSET post:10 author ZhangZhiGang
(integer) 1
127.0.0.1:6379> HMSET post:10 date 2021-05-01 summary 'Python Programming'
OK
127.0.0.1:6379> HGETALL post:10
1) "title"
2) "\xe4\xbe\x8b\xe8\xa7\xa3Python"
3) "author"
4) "ZhangZhiGang"
5) "date"
6) "2021-05-01"
7) "summary"
```

# 9. 集合类型

## 9.1 问题

## 9.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：练习无序集合类型命令**

```shell
127.0.0.1:6379> SADD letters a b c(integer) 3​127.0.0.1:6379> SADD letters b c d(integer) 1​127.0.0.1:6379> SMEMBERS letters1) "d"2) "b"3) "a"4) "c"​127.0.0.1:6379> SREM letters a c(integer) 2​127.0.0.1:6379> SMEMBERS letters1) "d"2) "b"
127.0.0.1:6379> SISMEMBER letters a(integer) 0​127.0.0.1:6379> SISMEMBER letters b(integer) 1
127.0.0.1:6379> SADD s1 a b c(integer) 3​127.0.0.1:6379> SADD s2 b c d(integer) 3​127.0.0.1:6379> SINTER s1 s21) "b"2) "c"​127.0.0.1:6379> SUNION s1 s21) "a"2) "c"3) "b"4) "d"​127.0.0.1:6379> SDIFF s1 s21) "a"
127.0.0.1:6379> SCARD letters(integer) 2
# 在集合s1中随机取出两个不同元素。127.0.0.1:6379> SRANDMEMBER s1 21) "b"2) "c"​# 在集合s1中随机取出两个有可能相同元素。127.0.0.1:6379> SRANDMEMBER s1 -21) "c"2) "c"​127.0.0.1:6379> SRANDMEMBER s1 -21) "a"2) "b"
127.0.0.1:6379> SPOP s1"a"​127.0.0.1:6379> SMEMBERS s11) "b"2) "c"
127.0.0.1:6379> SADD post:10:tags python redis nginx(integer) 3​127.0.0.1:6379> SMEMBERS post:10:tags1) "python"2) "nginx"3) "redis"
···
**步骤二：练习有序集合类型命令**

说明:
```shell
127.0.0.1:6379> ZADD scores 88 tom 90 jerry 75 bob 92 alice(integer) 4​127.0.0.1:6379> ZRANGE scores 0 -11) "bob"2) "tom"3) "jerry"4) "alice"​127.0.0.1:6379> ZRANGE scores 0 -1 WITHSCORES1) "bob"2) "75"3) "tom"4) "88"5) "jerry"6) "90"7) "alice"8) "92"​127.0.0.1:6379> ZADD scores 85 jerry(integer) 0​127.0.0.1:6379> ZRANGE scores 0 -1 WITHSCORES1) "bob"2) "75"3) "jerry"4) "85"5) "tom"6) "88"7) "alice"8) "92"
127.0.0.1:6379> ZSCORE scores tom"88"
127.0.0.1:6379> ZRANGEBYSCORE scores 80 90 WITHSCORES1) "jerry"2) "85"3) "tom"4) "88"
127.0.0.1:6379> ZINCRBY scores 3 bob"78"​127.0.0.1:6379> ZSCORE scores bob"78"
127.0.0.1:6379> ZCARD scores(integer) 4
127.0.0.1:6379> ZCOUNT scores 80 90(integer) 2
127.0.0.1:6379> ZREM scores bob(integer) 1
127.0.0.1:6379> ZRANK scores tom   # 获取tom的排名(integer) 1   # 升序排列，从0开始计数​127.0.0.1:6379> ZREVRANK scores alice   # 获取alice的排名(integer) 0   # 降序排列，从0开始计数
127.0.0.1:6379> ZADD posts:page.view 0 post:10:page.view(integer) 1​127.0.0.1:6379> ZINCRBY posts:page.view 1 post:10:page.view"1"​127.0.0.1:6379> ZRANGE posts:page.view 0 -1 WITHSCORES1) "post:10:page.view"2) "1"
···

# Exercise
## 1 简述redis主从复制工作原理
1）slave向master发送sync命令
2）master启动后台存盘进程，并收集所有修改数据命令
3）master完成后台存盘后，传送整个数据文件到slave
4）slave接收数据文件，加载到内存中完成首次完全同步
5） 后续有新数据产生时，master继续将新的数据收集到的修改命令依次传给slave，完成同步

## 2 简述redis支持的持久化方式
1）RDB（默认）
2）AOF

RDB介绍:
Redis数据库文件，全称 Redis DataBase
数据持久化方式之一
按照指定时间间隔，将内存中的数据集快照写入硬盘

AOF介绍：
Append Only File
记录redis服务所有写操作
不断的将新的写操作，追加到文件的末尾
使用cat命令可以查看文件内容

## 3 简述RDB持久化的默认存盘设置
save 900 1 //15分钟内且有1个key改变自动存盘
save 300 10 //5分钟内且有10个key改变自动存盘
save 60 10000 //1分钟内且有10000个key改变自动存盘

## 4 简述AOF文件记录写操作的方式
appendfsync always //时时记录，并完成磁盘同步
appendfsync everysec //每秒记录一次，并完成磁盘同步
appendfsync no //写入aof ，不执行磁盘同步

## 5 简述redis的数据类型。
Redis常用数据类型：
string字符
list列表
hash表

> 如有侵权，请联系作者删除

```



﻿@[TOC]( MHA Cluster Overview & deployment of an MHA cluster | Cloud computing )

---

# 1. 准备MHA集群环境

## 1.1 问题

- 公共配置
- 配置SSH免密登录
- 安装依赖包
- 配置MySQL一主多从结构

## 1.2 方案

准备5台虚拟机，角色规划如图-1所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1e9724cf70a74a1c975e1dc641533617.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-1

IP规划，如图-2所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2581695fb0ad4e14b1c3a517b910d48c.png)
图-2

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一： 公共配置**

1）配置数据库服务器192.168.4.51

```shell
[root@host51 ~]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
relay_log_purge=0
server_id=51
log_bin=master51
:wq
[root@host51 ~]# systemctl restart mysqld
[root@host51 ~]# mysql -uroot -p123qqq…A
Mysql> grant replication slave on *.* to repluser@”%”
Identified by “123qqq…A”;
Mysql>
```

2）配置数据库服务器192.168.4.52

```shell
[root@host52 ~]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
relay_log_purge=0
server_id=52
log_bin=master52
:wq
[root@host52 ~]# systemctl restart mysqld
[root@host52 ~]# mysql -uroot -p123qqq…A
Mysql> grant replication slave on *.* to repluser@”%”
Identified by “123qqq…A”;
Mysql>
```

3）配置数据库服务器192.168.4.53

```shell
[root@host53 ~]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
relay_log_purge=0
server_id=53
log_bin=master53
:wq
[root@host53 ~]# systemctl restart mysqld
[root@host53 ~]# mysql -uroot -p123qqq…A
Mysql> grant replication slave on *.* to repluser@”%”
Identified by “123qqq…A”;
Mysql>
```

**步骤二： 配置ssh免密登录**

1）配置数据库服务器192.168.4.51

```shell
[root@host51 ~]# ssh-keygen //创建秘钥对
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): //回车
Enter passphrase (empty for no passphrase): //回车
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qb7EZByHad3Jadr+zkiEbo7ZKGmCNlctgp+Wfp3Yad0 root@pxcnode71
The key's randomart image is:
+---[RSA 2048]----+
| |
| + o o |
| = o * |
| o o * |
| . = S o |
| . . * + o |
| .. =.O * + |
|.o.*+= & o E |
|. =+..B.o ..+ |
+----[SHA256]-----+
[root@host51 ~]#
[root@host51 ~]# ssh-copy-id root@192.168.4.52 //传递公钥给host52主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.71's password: //输入host52主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.52'"
and check to make sure that only the key(s) you wanted were added.
[root@host51 ~]#
[root@host51 ~]# ssh-copy-id root@192.168.4.53 //传递公钥给host53主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.71's password: //输入host53主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.53'"
and check to make sure that only the key(s) you wanted were added.
[root@host51 ~]#
[root@host51 ~]# ssh root@192.168.4.52 //可以无密码连接52主机
Last login: Fri Jun 21 13:21:39 2019 from 192.168.4.254
[root@host52 ~]#
[root@host52 ~]# exit //断开连接
登出
Connection to 192.168.4.52 closed.
[root@host51 ~]#
[root@host51 ~]# ssh root@192.168.4.53 //可以无密码连接52主机
Last login: Fri Jun 21 09:01:15 2019 from 192.168.4.254
[root@host53 ~]# exit//断开连接
登出
Connection to 192.168.4.53 closed.
[root@host51 ~]#
```

2）配置数据库服务器192.168.4.52

```shell
[root@host52 ~]# ssh-keygen //创建秘钥对
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): //回车
Enter passphrase (empty for no passphrase): //回车
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qb7EZByHad3Jadr+zkiEbo7ZKGmCNlctgp+Wfp3Yad0 root@pxcnode71
The key's randomart image is:
+---[RSA 2048]----+
| |
| + o o |
| = o * |
| o o * |
| . = S o |
| . . * + o |
| .. =.O * + |
|.o.*+= & o E |
|. =+..B.o ..+ |
+----[SHA256]-----+
[root@host52 ~]#
[root@host52 ~]# ssh-copy-id root@192.168.4.51 //传递公钥给host51主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.51's password: //输入host51主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.51'"
and check to make sure that only the key(s) you wanted were added.
[root@host52 ~]#
[root@host52 ~]# ssh-copy-id root@192.168.4.53 //传递公钥给host53主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.53's password: //输入host53主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.53'"
and check to make sure that only the key(s) you wanted were added.
[root@host52 ~]#
[root@host52 ~]# ssh root@192.168.4.51 //可以无密码连接51主机
Last login: Fri Jun 21 13:21:39 2019 from 192.168.4.254
[root@host51 ~]# exit //断开连接
登出
Connection to 192.168.4.52 closed.
[root@host52 ~]#
[root@host52 ~]# ssh root@192.168.4.53 //可以无密码连接53主机
Last login: Fri Jun 21 09:01:15 2019 from 192.168.4.254
[root@host53 ~]# exit//断开连接
登出
Connection to 192.168.4.53 closed.
[root@host52 ~]#
```

3）配置数据库服务器192.168.4.53

```shell
[root@host53 ~]# ssh-keygen //创建秘钥对
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): //回车
Enter passphrase (empty for no passphrase): //回车
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qb7EZByHad3Jadr+zkiEbo7ZKGmCNlctgp+Wfp3Yad0 root@pxcnode71
The key's randomart image is:
+---[RSA 2048]----+
| |
| + o o |
| = o * |
| o o * |
| . = S o |
| . . * + o |
| .. =.O * + |
|.o.*+= & o E |
|. =+..B.o ..+ |
+----[SHA256]-----+
[root@host53 ~]#
[root@host53 ~]# ssh-copy-id root@192.168.4.51 //传递公钥给host51主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.51's password: //输入host51主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.51'"
and check to make sure that only the key(s) you wanted were added.
[root@host53 ~]#
[root@host53 ~]# ssh-copy-id root@192.168.4.52 //传递公钥给host52主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.52's password: //输入host52主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.52'"
and check to make sure that only the key(s) you wanted were added.
[root@host53 ~]#
[root@host53 ~]# ssh root@192.168.4.51 //可以无密码连接51主机
Last login: Fri Jun 21 13:21:39 2019 from 192.168.4.254
[root@host51 ~]#
[root@host51 ~]# exit //断开连接
登出
Connection to 192.168.4.51 closed.
[root@host53 ~]#
[root@host53 ~]# ssh root@192.168.4.52 //可以无密码连接52主机
Last login: Fri Jun 21 09:01:15 2019 from 192.168.4.254
[root@host52 ~]# exit//断开连接
登出
Connection to 192.168.4.52 closed.
[root@host53 ~]#
```

4）配置管理服务器192.168.4.57

```shell
[root@mgm57 ~]# ssh-keygen //创建秘钥对
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): //回车
Enter passphrase (empty for no passphrase): //回车
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:qb7EZByHad3Jadr+zkiEbo7ZKGmCNlctgp+Wfp3Yad0 root@pxcnode71
The key's randomart image is:
+---[RSA 2048]----+
| |
| + o o |
| = o * |
| o o * |
| . = S o |
| . . * + o |
| .. =.O * + |
|.o.*+= & o E |
|. =+..B.o ..+ |
+----[SHA256]-----+
[root@mgm57 ~]#
[root@mgm57 ~]# ssh-copy-id root@192.168.4.51 //传递公钥给host51主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.51's password: //输入host51主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.51'"
and check to make sure that only the key(s) you wanted were added.
[root@mgm57 ~]#
[root@mgm57 ~]# ssh-copy-id root@192.168.4.52 //传递公钥给host52主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.52's password: //输入host52主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.52'"
and check to make sure that only the key(s) you wanted were added.
[root@mgm57 ~]#
[root@mgm57 ~]# ssh-copy-id root@192.168.4.53 //传递公钥给host52主机
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.53's password: //输入host53主机系统管理员root用户密码
Number of key(s) added: 1
Now try logging into the machine, with: "ssh 'root@192.168.4.53'"
and check to make sure that only the key(s) you wanted were added.
[root@mgm57 ~]
[root@mgm57 ~]# ssh root@192.168.4.51 //可以无密码连接51主机
Last login: Fri Jun 21 13:21:39 2019 from 192.168.4.254
[root@host51 ~]#
[root@host51 ~]# exit //断开连接
登出
Connection to 192.168.4.51 closed.
[root@mgm57 ~]#
[root@mgm57 ~]# ssh root@192.168.4.52 //可以无密码连接52主机
Last login: Fri Jun 21 09:01:15 2019 from 192.168.4.254
[root@host52 ~]# exit//断开连接
登出
Connection to 192.168.4.52 closed.
[root@mgm57 ~]# ssh root@192.168.4.53 //可以无密码连接53主机
Last login: Fri Jun 21 09:01:15 2019 from 192.168.4.254
[root@host53 ~]# exit//断开连接
登出
Connection to 192.168.4.53 closed.
[root@mgm57 ~]#
```

**步骤三： 安装依赖包**

1）配置数据库服务器192.168.4.51

```shell
[root@host51 ~]# yum -y install perl-ExtUtils-* perl-CPAN* //安装系统自带的perl软件包
[root@host51 ~]# cd mha
[root@host51 ~]# yum –y install perl-*.rpm //安装共享的perl软件包
```

2）配置数据库服务器192.168.4.52

```shell
[root@host52 ~]# yum  -y  install  perl-ExtUtils-*  perl-CPAN*  //安装系统自带的perl软件包
[root@host52 ~]#  cd  mha      
[root@host52 ~]#  yum  –y  install  perl-*.rpm  //安装共享的perl软件包[root@localhost 
```

3）配置数据库服务器192.168.4.53

```shell
[root@host53 ~]# yum -y install perl-ExtUtils-* perl-CPAN* //安装系统自带的perl软件包
[root@host53 ~]# cd mha
[root@host53 ~]# yum –y install perl-*.rpm //安装共享的perl软件包
```

4）配置管理服务器192.168.4.57

```shell
[root@mgm57 ~]# yum -y install perl-ExtUtils-* perl-CPAN* //安装系统自带的perl软件包
[root@mgm57 ~]# cd mha
[root@mgm57 ~]# yum –y install perl-*.rpm //安装共享的perl软件包
```

**步骤四： 配置MySQL一主多从结构**

1）配置主服务器192.168.4.51

```shell
[root@host51 ~]# mysql  -uroot  -p123qqq…A
mysql> show master status; //查看日志信息
mysql: [Warning] Using a password on the command line interface can be insecure.
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master51.000001 |     720 |              |                  |                   |
+-----------------+----------+--------------+------------------+-------------------+
[root@host51 ~]#
```

2）配置从服务器192.168.4.52

```shell
[root@host52 ~]# mysql -uroot –p123qqq…A //数据库管理员登录
mysql> change master to //指定主服务器信息
master_host="192.168.4.51", //IP地址
master_user="repluser", //授权用户
master_password="123qqq...A", //授权用户密码
master_log_file="master51.000001", //binlog日志
master_log_pos=720; //偏移量
mysql> start slave; //启动slave进程
mysql> exit ; //断开连接
[root@host52 ~]# mysql -uroot –p123qqq…A –e “show slave status\G” | grep 192.168.4.51
Master_Host: 192.168.4.51 //主服务器Ip地址
[root@host52 ~]# mysql -uroot –p123qqq…A –e “show slave status\G” | grep –i yes
Slave_IO_Running: Yes //I0线程正常
Slave_SQL_Running: Yes //SQL线程正常
```

3）配置从服务器192.168.4.53

```shell
[root@host53 ~]# mysql -uroot –p123qqq…A //数据库管理员登录
mysql> change master to //指定主服务器信息
master_host="192.168.4.51", //IP地址
master_user="repluser", //授权用户
master_password="123qqq...A", //授权用户密码
master_log_file="master51.000001", //binlog日志
master_log_pos=720; //偏移量
mysql> start slave; //启动slave进程
mysql> exit ; //断开连接
[root@host53 ~]# mysql -uroot –p123qqq…A –e “show slave status\G” | grep 192.168.4.51
Master_Host: 192.168.4.51 //主服务器Ip地址
[root@host53 ~]# mysql -uroot –p123qqq…A –e “show slave status\G” | grep –i yes
Slave_IO_Running: Yes //I0线程正常
Slave_SQL_Running: Yes //SQL线程正常
```

# 2. 部署MHA集群

## 2.1 问题

- 配置管理节点
- 配置数据节点

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置管理节点**

1）安装软件

```shell
[root@mgm57 ~]# cd mha
[root@mgm57 mha]#
[root@mgm57 mha]# yum –y install  mha4mysql-node-0.56-0.el6.noarch.rpm//安装mha-node软件包
准备中...                          ################################# [100%]
正在升级/安装...
   1:mha4mysql-node-0.56-0.el6        ################################# [100%]
[root@mgm57 mha]#
[root@mgm57 mha-soft-student]# rpm -qa | grep  mha //查看是否安装成功
mha4mysql-node-0.56-0.el6.noarch
[root@mgm57 mha-soft-student]#
[root@mgm57 mha]# tar -zxvf mha4mysql-manager-0.56.tar.gz //解压mha-manager软件包
mha4mysql-manager-0.56/
mha4mysql-manager-0.56/debian/
mha4mysql-manager-0.56/debian/control
mha4mysql-manager-0.56/debian/copyright
……
……
[root@mgm57 mha]# ls  
app1.cnf            mha4mysql-manager-0.56        
mha4mysql-node-0.56-0.el6.noarch.rpm
master_ip_failover  mha4mysql-manager-0.56.tar.gz
[root@mgm57 mha ]# cd mha4mysql-manager-0.56  //进入源码目录
[root@mgm57 mha4mysql-manager-0.56]# ls //查看文件列表
AUTHORS  COPYING  inc  Makefile.PL  META.yml  rpm      t
bin      debian   lib  MANIFEST     README    samples  tests
[root@mgm57 mha4mysql-manager-0.56]#
[root@mgm57 mha4mysql-manager-0.56]# perl Makefile.PL //配置
*** Module::AutoInstall version 1.03
*** Checking for Perl dependencies...
[Core Features]
- DBI                   ...loaded. (1.627)
- DBD::mysql            ...loaded. (4.023)
- Time::HiRes           ...loaded. (1.9725)
- Config::Tiny          ...loaded. (2.14)
- Log::Dispatch         ...loaded. (2.41)
- Parallel::ForkManager ...loaded. (1.18)
- MHA::NodeConst        ...loaded. (0.56)
*** Module::AutoInstall configuration finished.
Checking if your kit is complete...
Looks good
Writing Makefile for mha4mysql::manager
Writing MYMETA.yml and MYMETA.json
[root@mgm57 mha4mysql-manager-0.56]#  make //编译
[root@mgm57 mha4mysql-manager-0.56]#  make install //安装
[root@mgm57 mha4mysql-manager-0.56]# materha_    //tab键 显示安装命令
masterha_check_repl    masterha_conf_host       masterha_master_switch
masterha_check_ssh     masterha_manager         masterha_secondary_check
masterha_check_status  masterha_master_monitor  masterha_stop
```

2）编辑主配置文件

```shell
[root@mgm57 ~ ]#  mkdir  /etc/mha  //创建工作目录
[root@mgm57 ~ ]#  cp mha4mysql-manager-0.56/sample/conf/app1.cnf /etc/mha/ //拷贝模板文件
[root@mgm57 ~ ]#  vim /etc/mha/app1.cnf   //编辑主配置文件
     [server default]     //管理服务默认配置
                manager_workdir=/etc/mha    //工作目录
                manager_log=/etc/mha/manager.log   //日志文件
                master_ip_failover_script=/etc/mha/master_ip_failover //故障切换脚本
                 ssh_user=root  //访问ssh服务用户
                 ssh_port=22    //ssh服务端口
                 repl_user=repluser           //主服务器数据同步授权用户
                 repl_password=123qqq…A    //密码
                 user=plj                   //监控用户
                 password=123qqq…A               //密码
        [server1]   //指定第1台数据库服务器
hostname=192.168.4.51    //服务器ip地址
port=3306                //服务端口
candidate_master=1               //竞选主服务器
[server2]  //指定第2台数据库服务器
hostname=192.168.4.52
port=3306
candidate_master=1  
            
[server3]  //指定第3台数据库服务器
hostname=192.168.4.53
port=3306
candidate_master=1
:wq
```

3）创建故障切换脚本

```shell
[root@mgm57 ~]# cp mha-soft-student/master_ip_failover /etc/mha/
[root@mgm57 ~]# vim +35 /etc/mha/master_ip_failover
my $vip = '192.168.4.100/24';  # Virtual IP  //定义VIP地址
my $key = "1"; //定义变量$key
my $ssh_start_vip = "/sbin/ifconfig ens33:$key $vip"; //部署vip地址命令
my $ssh_stop_vip = "/sbin/ifconfig ens33:$key down"; //释放vip地址命令
:wq
[root@mgm57 ~]# chmod +x  /etc/mha/master_ip_failover //给脚本加执行权限
```

4）在当前主服务器部署vip地址

```shell
[root@host51 ~]# ifconfig  ens33:1  //部署之前查看 
ens33:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 52:54:00:d8:10:d7  txqueuelen 1000  (Ethernet)
[root@host51 ~]# ifconfig  ens33:1  192.168.4.100  //部署vip地址
[root@host51 ~]# ifconfig  ens33:1 //部署后查看
Ens33:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:d8:10:d7  txqueuelen 1000  (Ethernet)
```

**步骤二：配置数据节点**

1）在所有数据库服务器上，安装mha-node软件包

```shell
]# cd mha
]#  rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm
准备中...                          ################################# [100%]
正在升级/安装...
   1:mha4mysql-node-0.56-0.el6        ################################# [100%]
```

2）在所有数据服务器上添加监控用户

可以只在host51主机执行授权命令，host52和host53 会自动同步授权

```shell
]# mysql –uroot –p密码
mysql> grant all on  *.*  to plj@"%" identified by "123qqq...A";
mysql> exit;
```

3）在从服务器查看

```shell
[root@host52 ~]# mysql -uroot -p123qqq...A -e 'show grants for plj@"%"'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------------------------------------------------+
| Grants for plj@%                                     |
+------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'plj'@'%'             |
+------------------------------------------------------+
[root@host52 ~]#
[root@host53 mha]# mysql -uroot -p123qqq...A -e 'show grants for plj@"%"'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------------------------------------+
| Grants for plj@%                         |
+------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'plj'@'%' |
+------------------------------------------+
[root@host53 mha]#
```

# 3. 测试配置

## 3.1 问题

- 测试集群环境
- 访问集群
- 测试高可用
- 修复故障服务器

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：测试集群环境**

1）在管理主机，测试ssh配置

```shell
 [root@mgm57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf //执行测试命令
Thu Jun 20 15:33:48 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 15:33:48 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:33:49 2019 - [debug]
Thu Jun 20 15:33:48 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.51(192.168.4.51:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]  Connecting via SSH from root@192.168.4.53(192.168.4.53:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:51 2019 - [info] All SSH connection tests passed successfully.//测试成功提示
```

2）在管理主机，测试主从同步

```shell
 [root@host57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf //执行测试命令
Thu Jun 20 15:37:46 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:37:46 2019 - [info] MHA::MasterMonitor version 0.56.
Thu Jun 20 15:37:47 2019 - [info] GTID failover mode = 0
Thu Jun 20 15:37:47 2019 - [info] Dead Servers: //没有停止的mysql服务器
Thu Jun 20 15:37:47 2019 - [info] Alive Servers://运行mysql服务主机列表
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.52(192.168.4.52:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)
Thu Jun 20 15:37:47 2019 - [info] Alive Slaves:
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)  Version=5.7.17-log (oldest major version between slaves) log-bin:enabled
Thu Jun 20 15:37:47 2019 - [info]     Replicating from 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info] Current Alive Master: 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info] Checking slave configurations..
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.52(192.168.4.52:3306).
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.53(192.168.4.53:3306).
Thu Jun 20 15:37:47 2019 - [info] Checking replication filtering settings..
Thu Jun 20 15:37:47 2019 - [info]  binlog_do_db= , binlog_ignore_db=
Thu Jun 20 15:37:47 2019 - [info]  Replication filtering check ok.
Thu Jun 20 15:37:47 2019 - [info] GTID (with auto-pos) is not supported
Thu Jun 20 15:37:47 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:37:49 2019 - [info] All SSH connection tests passed successfully.
Thu Jun 20 15:37:49 2019 - [info] Checking MHA Node version..
Thu Jun 20 15:37:50 2019 - [info]  Version check ok.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication settings on the current master..
Thu Jun 20 15:37:50 2019 - [info] HealthCheck: SSH to 192.168.4.51 is reachable.
Thu Jun 20 15:37:50 2019 - [info] Master MHA Node version is 0.56.
Thu Jun 20 15:37:50 2019 - [info] Checking recovery script configurations on 192.168.4.51(192.168.4.51:3306)..
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.51(192.168.4.51:22)..
  Creating /var/tmp if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to master51.000002
Thu Jun 20 15:37:50 2019 - [info] Binlog setting check done.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.52(192.168.4.52:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host52-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host52-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:51 2019 - [info]   Executing command : apply_diff_relay_logs --command=test --slave_user='root' --slave_host=192.168.4.53 --slave_ip=192.168.4.53 --slave_port=3306 --workdir=/var/tmp --target_version=5.7.17-log --manager_version=0.56 --relay_log_info=/var/lib/mysql/relay-log.info  --relay_dir=/var/lib/mysql/  --slave_pass=xxx
Thu Jun 20 15:37:51 2019 - [info]   Connecting to root@192.168.4.53(192.168.4.53:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host53-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host53-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:52 2019 - [info] Slaves settings check done.
Thu Jun 20 15:37:52 2019 - [info]
192.168.4.51(192.168.4.51:3306) (current master)
 +--192.168.4.52(192.168.4.52:3306)
 +--192.168.4.53(192.168.4.53:3306)
Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.52..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.53..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking master_ip_failover_script status:
Thu Jun 20 15:37:52 2019 - [info]   /etc/mha/master_ip_failover --command=status --ssh_user=root --orig_master_host=192.168.4.51 --orig_master_ip=192.168.4.51 --orig_master_port=3306
Thu Jun 20 15:37:52 2019 - [info]  OK.
Thu Jun 20 15:37:52 2019 - [warning] shutdown_script is not defined.
Thu Jun 20 15:37:52 2019 - [info] Got exit code 0 (Not master dead).
MySQL Replication Health is OK.//测试成功提示信息
```

3）启动管理服务

```shell
[root@mgm57 ~]# masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf \
--ignore_last_failover //执行启动命令
Thu Jun 20 17:05:58 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:05:58 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:05:58 2019 - [info] Reading server configuration from /etc/mha/app1.cnf.. 
```

4）查看服务状态

```shell
[root@mgm57 ~]#  masterha_check_status  --conf=/etc/mha/app1.cnf//执行命令
app1 (pid:15806) is running(0:PING_OK), master:192.168.4.51 //服务运行，监视主服务器192.168.4.51
[root@mgm57 ~]# ls /etc/mha/   //查看工作目录文件列表
app1.cnf  app1.master_status.health  manager.log  master_ip_failover
```

**步骤二：访问集群**

1）在主服务器51 添加访问数据的连接用户

```shell
]# mysql  -uroot -p123qqq...A
mysql> create database db9;
Query OK, 1 row affected (0.05 sec)
mysql> create table db9.a (id int);
Query OK, 0 rows affected (0.63 sec)
mysql> grant select,insert on db9.* to yaya55@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.08 sec)
mysql>exit
```

2）客户端50 连接vip地址访问集群

```shell
host50~]# mysql -h192.168.4.100  -uyaya55  -p123qqq...A
mysql> select  * from  db9.a;
mysql> insert into db9.a values(100);
mysql> select  * from db9.a;
+------+
| id   |
+------+
|  100 |
+------+
1 row in set (0.00 sec)
mysql>exit
```

3）在从服务器host52 查看数据

```shell
 [root@host52 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
+------+
```

4）在从服务器host53 查看数据

```shell
[root@host53 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
+------+
```

**步骤三：测试高可用**

1）停止主服务器51的mysql服务

```shell
host51~]# systemctl  stop  mysqld
```

2）查看管理服务 ，输出的监控信息

```shell
 [root@mgm57~]#masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf \
> --ignore_last_failover
Thu Jun 20 17:05:58 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:05:58 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:05:58 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
  Creating /var/tmp if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to master51.000002
Thu Jun 20 17:35:59 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:35:59 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:35:59 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
[root@host57 ~]#
[root@mgm57 ~]# masterha_check_status  --conf=/etc/mha/app1.cnf
app1 is stopped(2:NOT_RUNNING).  //监控到主服务器宕机 管理服务自动停止
[root@mgm57 ~]#
```

3）客户端依然连接vip地址，可以访问到数据

```shell
client50]# ping -c 2 192.168.4.100  //能够ping通vip地址
PING 192.168.4.100 (192.168.4.100) 56(84) bytes of data.
64 bytes from 192.168.4.100: icmp_seq=1 ttl=255 time=0.222 ms
64 bytes from 192.168.4.100: icmp_seq=2 ttl=255 time=0.121 ms
--- 192.168.4.71 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.121/0.171/0.222/0.052 ms
client50]# mysql -h192.168.4.100 -uyaya55 -p123qqq...A //连接vip地址
mysql> insert into db9.a values(200); //插入记录
mysql> select  * from db9.a;//查询记录
+------+
| id   |
+------+
|  100 |
|  200 |
+------+
```

4）查看vip地址

在host52主机查看到vip地址，说明host52 主机被选举为主服务器

```shell
 [root@host52 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:f5:c4:6a  txqueuelen 1000  (Ethernet)
```

在host53主机未查看到vip地址，说明host53主机是当前host52的从服务器

```shell
 [root@host53 ~]# ifconfig  eth0:1 //未查到vip地址
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 52:54:00:28:22:2e  txqueuelen 1000  (Ethernet)
[root@host53 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i 192
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.52  //主服务器Ip地址
[root@host53 ~]#
[root@host53 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes  //IO线程正常
            Slave_SQL_Running: Yes  //SQL线程正常
 [root@host53 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a" //自动同步数据
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
|  200 |
+------+
```

**步骤四：修复故障服务器**

1）配置数据库服务器

启动host51主机的数据库服务

```shell
host51~]# systemctl  start  mysqld
```

与主服务器数据一致

```shell
[root@host52 ~]#  mysqldump -uroot -p123qqq...A  --master-data  db9 > db9.sql //在主服务器host52 做完全备份
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host52 ~]#
[root@host52 ~]# scp db9.sql  root@192.168.4.51:/root/  //拷贝备份文件给host51主机
db9.sql  100% 1918     3.1MB/s   00:00
[root@host52 ~]#
host51 ~]# mysql -uroot -p123qqq...A db9 < /root/db9.sql//host51 主机使用备份文件恢复数据
mysql: [Warning] Using a password on the command line interface can be insecure.
```

指定主服务器信息

```shell
 [root@host51 ~]# grep master52 /root/db9.sql  //查看日志名及偏移量
CHANGE MASTER TO MASTER_LOG_FILE='master52.000001', MASTER_LOG_POS=895;
[root@host51 ~]# mysql -uroot -p123qqq...A
mysql>change master to master_host="192.168.4.52",master_user="repluser",master_password="123qqq...A",master_log_file="master52.000001",master_log_pos=895;
Query OK, 0 rows affected, 2 warnings (0.14 sec)
```

启动slave进程

```shell
mysql> start slave;
Query OK, 0 rows affected (0.01 sec)
Mysql> exit ;
```

查看状态信息

```shell
 [root@host51 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep 192.168.4.52
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.52 //主服务器ip地址
[root@host51 ~]#
[root@host51 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes //IO线程状态正常
            Slave_SQL_Running: Yes //SQL线程状态正常
[root@host51 ~]#
```

2）配置管理服务器

修改配置文件，添加数据库服务器host51

```shell
]# vim /etc/mha/app1.cnf
 [server1 ]
hostname=192.168.4.51
port=3306
candidate_master=1
:wq
```

测试集群环境

```shell
[root@mgm57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf //测试SSH
Thu Jun 20 15:33:48 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 15:33:48 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:33:49 2019 - [debug]
Thu Jun 20 15:33:48 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.51(192.168.4.51:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]  Connecting via SSH from root@192.168.4.53(192.168.4.53:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:51 2019 - [info] All SSH connection tests passed successfully.//成功
 [root@mgm57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf//测试主从同步
Thu Jun 20 15:37:46 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:37:46 2019 - [info] MHA::MasterMonitor version 0.56.
Thu Jun 20 15:37:47 2019 - [info] GTID failover mode = 0
Thu Jun 20 15:37:47 2019 - [info] Dead Servers:
Thu Jun 20 15:37:47 2019 - [info] Alive Servers:
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.52(192.168.4.52:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)
Thu Jun 20 15:37:47 2019 - [info] Alive Slaves:
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)  Version=5.7.17-log (oldest major version between slaves) log-bin:enabled
Thu Jun 20 15:37:47 2019 - [info]     Replicating from 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info] Current Alive Master: 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info] Checking slave configurations..
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.52(192.168.4.52:3306).
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.53(192.168.4.53:3306).
Thu Jun 20 15:37:47 2019 - [info] Checking replication filtering settings..
Thu Jun 20 15:37:47 2019 - [info]  binlog_do_db= , binlog_ignore_db=
Thu Jun 20 15:37:47 2019 - [info]  Replication filtering check ok.
Thu Jun 20 15:37:47 2019 - [info] GTID (with auto-pos) is not supported
Thu Jun 20 15:37:47 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:37:49 2019 - [info] All SSH connection tests passed successfully.
Thu Jun 20 15:37:49 2019 - [info] Checking MHA Node version..
Thu Jun 20 15:37:50 2019 - [info]  Version check ok.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication settings on the current master..
Thu Jun 20 15:37:50 2019 - [info] HealthCheck: SSH to 192.168.4.51 is reachable.
Thu Jun 20 15:37:50 2019 - [info] Master MHA Node version is 0.56.
Thu Jun 20 15:37:50 2019 - [info] Checking recovery script configurations on 192.168.4.51(192.168.4.51:3306)..
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.51(192.168.4.51:22)..
  Creating /var/tmp if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to master51.000002
Thu Jun 20 15:37:50 2019 - [info] Binlog setting check done.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.52(192.168.4.52:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host52-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host52-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:51 2019 - [info]   Connecting to root@192.168.4.53(192.168.4.53:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host53-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host53-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:52 2019 - [info] Slaves settings check done.
Thu Jun 20 15:37:52 2019 - [info]
192.168.4.51(192.168.4.51:3306) (current master)
 +--192.168.4.52(192.168.4.52:3306)
 +--192.168.4.53(192.168.4.53:3306)
Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.52..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.53..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking master_ip_failover_script status:
Thu Jun 20 15:37:52 2019 - [info]   /etc/mha/master_ip_failover --command=status --ssh_user=root --orig_master_host=192.168.4.51 --orig_master_ip=192.168.4.51 --orig_master_port=3306
Thu Jun 20 15:37:52 2019 - [info]  OK.
Thu Jun 20 15:37:52 2019 - [warning] shutdown_script is not defined.
Thu Jun 20 15:37:52 2019 - [info] Got exit code 0 (Not master dead).
MySQL Replication Health is OK. //成功
```

重启管理服务

```shell
]# masterha_stop  --conf=/etc/mha/app1.cnf //停止管理服务
Stopped app1 successfully.
]# masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf \
--ignore_last_failover //启动管理服务
Thu Jun 20 17:05:58 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:05:58 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:05:58 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
```

查看状态

```shell
mgm57 ~]# masterha_check_status  --conf=/etc/mha/app1.cnf
app1 (pid:15806) is running(0:PING_OK), master:192.168.4.52 //服务运行，监视服务器52
[root@mgm57 ~]#
```


# Exercise

## 1 简述什么是MHA。

MHA全称Master High Availability
由日本DeNA公司youshimaton开发
是一套优秀的实现MySQL高可用的解决方案
数据库的自动故障切换操作能做到在0~30秒之内
MHA能确保在故障切换过程中最大程度保证数据的一致性，以达到真正意义上的高可用。

## 2 简述MHA组成。

该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上。

## 3 简述MHA工作原理。

MHA Manager定时探测集群中的master节点，当master出现故障时，自动将拥有最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。


## 4 简述MHA集群常用管理命令。

masterha_check_ssh 检查MHA的SSH配置状况 
masterha_check_repl 检查MySQL复制状况 
masterha_manger 启动管理服务
masterha_check_status 检测当前MHA运行状态 
masterha_master_monitor 检测master是否宕机 
masterha_master_switch 控制故障转移（自动或者手动） 
masterha_conf_host 添加或删除配置的server信息

> 如有侵权，请联系作者删除



﻿@[TOC]( Monitor resource usage & manage storage volumes | Cloud computing )

---

# 1. 安装部署metrics-server

## 1.1 问题

本案例要求安装部署metrics-server，具体要求如下：

1. 修改 apiserver 的启动参数，添加聚合API
2. 配置文件路径 /etc/kubernetes/manifests/kube-apiserver.yaml
3. \- --enable-aggregator-routing=true
4. 重启 kubelet 服务
5. 导入镜像，部署metrics-server
6. pdb.yaml, rbac.yaml
7. deployment.yaml, service.yaml,apiservice.yaml
8. 验证 kubectl top node

## 1.2 方案

metrics是一个监控系统资源使用的插件，可以监控node节点上的cpu、内存的使用率，或pod对资源的占用率，通过对资源占用的了解，可以更加合理的部署容器应用

## 1.3 步骤

实现此案例需要按照如下步骤进行。

没有安装部署metrics之前查看node节点信息会失败。

```shell
[root@master ~]# kubectl  top  node
Error from server (NotFound): the server could not find the requested resource (get services http:heapster:)
```

**步骤一：修改kube-apiserver配置文件（在master主机操作）**

1）开启聚合服务

默认K8S不支持聚合服务就没法用metrics，这里首先需要修改配置文件开启该功能。

```shell
[root@master ~]# vim /etc/kubernetes/manifests/kube-apiserver.yaml
#在该文件中找spec.containers.command ，在它的最下面手动添加如下一行内容：
- --enable-aggregator-routing=true
[root@master ~]# systemctl  restart  kubelet             #重启服务
[root@master ~]# kubectl -n kube-system get pod \
kube-apiserver-master -o yaml |grep enable-aggregator-routing
#修改完成后，将kube-apiserver的配置导出查看是否有刚刚添加的参数，有就代表成功了
#这一步是验证的操作
```

2）设置kubelet证书

```shell
[root@master ~]# vim /var/lib/kubelet/config.yaml    #在文件末尾手动添加如下一行
serverTLSBootstrap: true
[root@master ~]# systemctl  restart  kubelet             #重启服务
# 等待几分钟后就能看到了
[root@master ~]# kubectl get certificatesigningrequests
NAME        AGE    REQUESTOR        CONDITION
csr-nvd65        8m          system:node:master            Pending
csr-6qz7b        4m34s       system:node:node-0003        Pending
csr-rft2l        4m46s       system:node:node-0002     Pending
csr-t5fvc        5m2s        system:node:node-0001     Pending
#这里查看到所有的主机都在等待证书的签发
#master主机的证书目前状态为Pending，代表正在等待证书的签发
#node-0003主机的证书目前状态为Pending，代表正在等待证书的签发
#node-0002主机的证书目前状态为Pending，代表正在等待证书的签发
#node-0001主机的证书目前状态为Pending，代表正在等待证书的签发
```

重要：修改配置文件开启证书后，所有主机的证书都没有签发，下面需要给所有主机都签发证书（等于是给证书签个名才能用）

注意：是所有主机的证书都需要签发，如何签发呢？具体语法格式如下：

kubectl certificate approve 名称

这里最后的名称就是上面kubectl get certificatesigningrequests命令查看到的名称

```shell
[root@master ~]# kubectl certificate approve csr-nvd65    # 签发证书
[root@master ~]# kubectl certificate approve csr-6qz7b    # 签发证书
[root@master ~]# kubectl certificate approve csr-rft2l    # 签发证书
[root@master ~]# kubectl certificate approve csr-t5fvc    # 签发证书
#注意：最后的名称不能照抄，一定要自己通过kubectl get certificatesigningrequests查看
```

再次查看证书状态

```shell
[root@master ~]# kubectl get certificatesigningrequests
NAME        AGE    REQUESTOR        CONDITION
csr-nvd65        16m       system:node:master            Approved,Issued
csr-t5fvc        13m       system:node:node-0001     Approved,Issued
csr-rft2l        13m       system:node:node-0002     Approved,Issued
csr-6qz7b        13m       system:node:node-0003     Approved,Issued
#所有证书状态都是Approved（已经被签发了）
```

**步骤二：安装metrics-server（在master主机操作）**

1）导入镜像到私有镜像仓库（192.168.1.100服务器）

镜像及资源文件在云盘第四阶段kubernetes/v1.17.6/metrics/目录下，各位同学需要提前下载。

```shell
[root@master ~]# docker load -i metrics-server.tar.gz
[root@master ~]# docker images            #查看metrics-server镜像的名称
[root@master ~]# docker tag  旧名称   192.168.1.100:5000/metrics-server:master
[root@master ~]# docker push  192.168.1.100:5000/metrics-server:master
```

2）修改资源文件

所有资源文件在云盘第四阶段kubernetes/v1.17.6/metrics/目录下，各位同学需要提前下载。

```shell
[root@master metrics]# vim deployment.yaml           
29： image: 192.168.1.100:5000/metrics-server:master
# 该行原文指向官网地址，我们需要修改为自己的私有镜像仓库
# 启动metrics-server容器时就从私有仓库下载镜像然后再启动容器，否则默认是连接官网找镜像
```

3）依次创建所有资源

```shell
[root@master metrics]# kubectl apply -f rbac.yaml 
[root@master metrics]# kubectl apply -f pdb.yaml 
[root@master metrics]# kubectl create -f deployment.yaml 
[root@master metrics]# kubectl apply -f service.yaml 
[root@master metrics]# kubectl apply -f apiservice.yaml 
```

4）验证

```shell
[root@master metrics]# kubectl -n kube-system get pod           # 验证POD
NAME                     READY       STATUS        RESTARTS   AGE
metrics-server-xxx     1/1      Running          0          9m15s
... ...
[root@master metrics]# kubectl -n kube-system get apiservices     # 验证API
NAME                         SERVICE                          AVAILABLE    AGE
v1beta1.metrics.k8s.io        kube-system/metrics-server     True           15m
[root@master metrics]# kubectl  top  node
error: metrics not available yet    # 你需要等几分钟，还没有收集数据
[root@master metrics]# kubectl  top  node
NAME         CPU(cores)    CPU%       MEMORY(bytes)      MEMORY%   
master        73m             3%       1196Mi             68%       
node-0001       20m              1%     729Mi              41%  
... ...     
```



# 2. 容器资源利用率监控

```shell
[root@master ~]# kubectl apply -f myapache.yaml 
deployment.apps/myapache created
[root@master ~]# kubectl top pod
error: metrics not available yet
# 等待大约 30 秒
[root@master ~]# kubectl top pod
NAME                       CPU(cores)   MEMORY(bytes)   
myapache-7d689bf8f-lfr5h   0m           0Mi   
[root@master ~]# curl http://10.244.2.17/info.php?id=5000000
<pre>
Array
(
    [REMOTE_ADDR] => 10.244.0.0
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /info.php?id=5000000
    [id] => 5000000
)
php_host:     myapache-7d689bf8f-lfr5h
[root@master ~]# kubectl top pod
NAME                       CPU(cores)   MEMORY(bytes)   
myapache-7d689bf8f-w4rtt   1000m        8Mi  
[root@master ~]#
```



# 3. configMap练习

## 3.1 问题

本案例主要做configMap练习，具体要求如下：

1. 通过configMap修改nginx的配置文件
2. 让nginx支持php

## 3.2 方案

ConfigMap是在Pod中映射(文件/目录)的一种方式，允许你将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性。

通过ConfigMap我们可以把真机的目录或文件映射到容器中。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建configMap资源（在master主机操作）**

1）准备一个nginx的配置文件。

启动一个容器，从容器中将nginx.conf文件拷贝到真机。

```shell
[root@master ~]# mkdir /var/webconf
[root@master ~]# docker run -itd --name mynginx 192.168.1.100:5000/myos:nginx
9f719d0e797f81887b21985a31f426c1f2c48efd24a2c6666ecf41396fb99e93
[root@master ~]# docker cp mynginx:/usr/local/nginx/conf/nginx.conf /var/webconf/
[root@master ~]# docker rm -f mynginx
mynginx
[root@master ~]# ls -l /var/webconf/
total 4
-rw-r--r-- 1 root root 2656 Jul 25  2020 nginx.conf
[root@master ~]# vim /var/webconf/nginx.conf 
... ...
        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
... ...
[root@master ~]# kubectl create configmap nginx-conf --from-file=/var/webconf/nginx.conf 
configmap/nginx-conf created
[root@master ~]# kubectl get configmaps 
NAME         DATA   AGE
nginx-conf   1      8s
[root@master ~]#
```

2）定义configMap

configMap可以映射单一文件，也可以映射一个目录。

语法格式：kubectl create configmap 名称 --from-file=文件路径

```shell
[root@master ~]# kubectl create configmap nginx-conf --from-file=nginx.conf 
configmap "nginx-conf" created
# 创建一个名称为nginx-conf的configMap，对应的是真机的nginx.conf文件
[root@master ~]# kubectl get configmap nginx-conf       #查看configMap
NAME          DATA          AGE
nginx-conf       1             10s
```

3）使用资源文件启动容器调用前面定义的configMap

资源文件已经工作在云盘第四阶段kubernetes/v1.17.6/config/目录下。

```shell
[root@master ~]# vim webnginx.yaml
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: webnginx
spec:
  selector:
    matchLabels:
      myapp: nginx
  replicas: 1
  template:
    metadata:
      labels:
        myapp: nginx
    spec:
      volumes:                      # 新添加
      - name: nginx-php             # 新添加（标记1）
        configMap:                  # 新添加
          name: nginx-conf          # 新添加，必须与 configmap 命令创建的名称相同
      containers:
      - name: nginx
        image: 192.168.1.100:5000/myos:nginx
        volumeMounts:               # 新添加
        - name: nginx-php           # 新添加，必须与（标记1）名称相同
          subPath: nginx.conf       # 新添加
          mountPath: /usr/local/nginx/conf/nginx.conf     # 新添加
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl apply -f webnginx.yaml 
deployment.apps/webnginx created
[root@master ~]# kubectl get pod 
NAME                        READY   STATUS    RESTARTS   AGE
webnginx-844859695b-5s7m7   1/1     Running   0          10s
[root@master ~]# kubectl exec -it webnginx-844859695b-5s7m7 -- /bin/bash
[root@webnginx-844859695b-5s7m7 html]# cat /usr/local/nginx/conf/nginx.conf
# 查看配置文件是否改变了
[root@webnginx-844859695b-kmwwh html]# ss -ltun
Netid  State      Recv-Q Send-Q      Local Address:Port      Peer Address:Port            
tcp    LISTEN     0      128                     *:80                   *:*                                
[root@webnginx-844859695b-kmwwh html]# exit
[root@master ~]# kubectl delete -f webnginx.yaml 
deployment.apps "webnginx" deleted
[root@master ~]#
```

4）添加PHP容器，测试网页

```shell
[root@master ~]# vim webnginx.yaml
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: webnginx
spec:
  selector:
    matchLabels:
      myapp: nginx
  replicas: 1
  template:
    metadata:
      labels:
        myapp: nginx
    spec:
      volumes:
      - name: nginx-php
        configMap: 
          name: nginx-conf
      containers:
      - name: nginx
        image: 192.168.1.100:5000/myos:nginx
        volumeMounts:
        - name: nginx-php
          subPath: nginx.conf
          mountPath: /usr/local/nginx/conf/nginx.conf
        ports:
        - protocol: TCP
          containerPort: 80
      - name: php-backend                       # 新添加
        image: 192.168.1.100:5000/myos:php-fpm  # 新添加
      restartPolicy: Always
[root@master ~]# kubectl apply -f config/webnginx.yaml 
deployment.apps/webnginx created
[root@master ~]# kubectl get pod -o wide
NAME                        READY   STATUS    RESTARTS   AGE    IP            NODE      
webnginx-6c9f6fd675-7rmzk   2/2     Running   0          5s        10.244.2.25   node-0002
[root@master ~]# kubectl exec -it webnginx-6c9f6fd675-7rmzk -c nginx -- /bin/bash
[root@webnginx-6c9f6fd675-7rmzk html]# ss -ltun
Netid  State      Recv-Q Send-Q      Local Address:Port      Peer Address:Port              
tcp    LISTEN     0      128                     *:80                   *:*                  
tcp    LISTEN     0      128                     *:9000                 *:*
[root@webnginx-6c9f6fd675-7rmzk html]# exit
[root@master ~]# curl http://10.244.2.25/info.php
<pre>
Array
(
    [REMOTE_ADDR] => 10.244.0.0
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /info.php
)
php_host:     webnginx-6c9f6fd675-7rmzk
1229
[root@master ~]#
```



# 4. 网络存储卷应用案例



# 5 emptydir案例

```shell
[root@master ~]# vim webcache.yaml 
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: webcache
spec:
  selector:
    matchLabels:
      myapp: cache
  replicas: 1
  template:
    metadata:
      labels:
        myapp: cache
    spec:
      volumes:                       # 新添加
      - name: empty-data             # 新添加
        emptyDir: {}                 # 新添加
      containers:
      - name: apache
        image: 192.168.1.100:5000/myos:httpd
        stdin: false
        tty: false
        volumeMounts:                # 新添加
        - name: empty-data           # 新添加
          mountPath: /var/cache      # 新添加
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl apply -f webcache.yaml 
deployment.apps/webcache created
[root@master ~]# kubectl exec -it webcache-c58847c54-qw9lh -- /bin/bash
[root@webcache-c58847c54-qw9lh html]# df -h
Filesystem       Size   Used       Avail        Use%       Mounted on
/dev/vda1        40G    2.9G       35G          8%         /var/cache
... ...
[root@webcache-c58847c54-qw9lh html]# exit
[root@master ~]#
```



# 6 hostpath案例

```shell
[root@master ~]# cat webcache.yaml 
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: webcache
spec:
  selector:
    matchLabels:
      myapp: cache
  replicas: 1
  template:
    metadata:
      labels:
        myapp: cache
    spec:
      volumes:
      - name: empty-data
        emptyDir: {}
      - name: log-data                # 新添加
        hostPath:                     # 新添加
          path: /var/weblog           # 新添加
          type: DirectoryOrCreate     # 新添加
      containers:
      - name: apache
        image: 192.168.1.100:5000/myos:httpd
        stdin: false
        tty: false
        volumeMounts:
        - name: empty-data
          mountPath: /var/cache
        - name: log-data             # 新添加
          mountPath: /var/log/httpd  # 新添加
        ports:
        - protocol: TCP
          containerPort: 80
      restartPolicy: Always
[root@master ~]# kubectl apply -f webcache.yaml 
deployment.apps/webcache created
[root@master ~]# kubectl get pod -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE
webcache-75588b9cc5-xzkvc   1/1     Running   0          4s    10.244.2.30   node-0002
[root@master ~]# curl http://10.244.2.30/
this is apache
[root@master ~]# ssh 192.168.1.32
root@192.168.1.32's password: 
Last login: Mon Apr 26 10:41:58 2021 from 192.168.1.252
Welcome to Huawei Cloud Service
[root@node-0002 ~]# ls -l /var/weblog/
total 16
-rw-r--r--   1 root root   86 Apr 26 13:12 access_log
-rw-r--r--   1 root root  489 Apr 26 13:12 error_log
[root@node-0002 ~]# cat /var/weblog/access_log 
10.244.0.0 - - [26/Apr/2021:05:12:59 +0000] "GET / HTTP/1.1" 200 15 "-" "curl/7.29.0"
[root@node-0002 ~]#
```



# 7 pv/pvc案例

## 7.1 问题

本案例练习练习使用网络存储卷，具体要求如下。

1. 安装 NFS服务
2. 定义 PV，PVC
3. 在K8S集群中挂载NFS存储卷

## 7.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署NFS服务器（在192.168.1.100主机操作）**

1）部署服务器

```shell
[root@registry ~]# yum install -y nfs-utils
[root@registry ~]# mkdir -m 777 /var/webroot
[root@registry ~]# vim  /etc/exports
/var/webroot    *(rw)
[root@registry ~]# systemctl enable --now nfs
```

2）任意其他主机做客户端测试

```shell
[root@localhost ~]# yum install -y nfs-utils
[root@localhost ~]# showmount -e 192.168.1.100
Export list for 192.168.1.100:
/var/webroot *
```

**步骤二：创建PV/PVC资源（在master主机操作）**

对应的资源文件在云盘第四阶段kubernetes/v1.17.6/config/目录。

1）创建PV资源

```shell
[root@master ~]# vim mypv.yaml 
---
kind: PersistentVolume
apiVersion: v1
metadata:
  name: pv-nfs
spec:
  volumeMode: Filesystem
  capacity:
    storage: 30Gi
  accessModes:
  - ReadWriteOnce
  - ReadOnlyMany
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    server: 192.168.1.100
    path: /var/webroot
[root@master ~]# kubectl apply -f mypv.yaml 
persistentvolume/pv-nfs created
[root@master ~]# kubectl get pv
NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS          AGE
pv-nfs   30Gi       RWO,ROX,RWX    Retain           Available       3s
```

2）创建PVC资源（默认情况下PVC与PV会自动匹配容量大小、自动映射）

```shell
[root@master configmap]# vim mypvc.yaml 
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pvc-nfs
spec:
  volumeMode: Filesystem
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 25Gi
[root@master configmap]# kubectl apply -f mypvc.yaml
[root@master configmap]# kubectl get pv
NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM
pv-nfs   30Gi       RWX            Retain           Bound    default/pvc-nfs
[root@master configmap]# kubectl get pvc
NAME      STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
pvc-nfs   Bound    pv-nfs   30Gi       RWO,ROX,RWX                   27s
```

3）创建容器资源，调用PVC

```shell
[root@master ~]# cat webnginx.yaml 
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: webnginx
spec:
  selector:
    matchLabels:
      myapp: nginx
  replicas: 1
  template:
    metadata:
      labels:
        myapp: nginx
    spec:
      volumes:
      - name: nginx-php
        configMap: 
          name: nginx-conf
      - name: website                     # 新添加
        persistentVolumeClaim:            # 新添加
          claimName: pvc-nfs              # 新添加
      containers:
      - name: nginx
        image: 192.168.1.100:5000/myos:nginx
        volumeMounts:
        - name: nginx-php
          subPath: nginx.conf
          mountPath: /usr/local/nginx/conf/nginx.conf
        - name: website                     # 新添加
          mountPath: /usr/local/nginx/html  # 新添加
        ports:
        - protocol: TCP
          containerPort: 80
      - name: php-backend
        image: 192.168.1.100:5000/myos:php-fpm
        volumeMounts:                       # 新添加
        - name: website                     # 新添加
          mountPath: /usr/local/nginx/html  # 新添加
      restartPolicy: Always
[root@master ~]# kubectl delete -f webnginx.yaml 
deployment.apps "webnginx" deleted
[root@master ~]# kubectl apply -f webnginx.yaml 
deployment.apps/webnginx created
[root@master ~]# kubectl get pod -o wide
NAME                       READY   STATUS    RESTARTS   AGE   IP            NODE
webnginx-d488b9447-t62cl   2/2     Running   0          7s    10.244.2.32   node-0002
[root@master ~]# curl http://10.244.2.32/
# 在 nfs 上创建修改页面，然后在容器端访问测试
```



# 8. 微服务web集群实战

## 8.1 问题

本案例结合前面的实验步骤做一个综合的微服务课外练习，具体要求如下。

1. 使用myos:php-fpm 创建后端应用php-app
2. 创建php-service，为后端应用提供内部clusterIP和负载均衡
3. 使用myos:nginx创建应用，并使用php-service解析php文件
4. 创建web-service，发布nginx应用到nodePort
5. 使用Ingress对外发布服务nginx应用

## 8.2 步骤

实现此案例需要参考前面的案例1至案例5的内容自行完成。

> 如有侵权，请联系作者删除



﻿@[TOC]( Monitoring Overview & Zabbix foundation & Zabbix monitoring service | Cloud computing )

---

# 1. 常用系统监控命令

## 1.1 问题

本案例要求熟悉查看Linux系统状态的常用命令，为进一步执行具体的监控任务做准备：

- 查看内存信息
- 查看交换分区信息
- 查看磁盘信息
- 查看CPU信息
- 查看网卡信息
- 查看端口信息
- 查看网络连接信息

## 1.2 方案

一般企业做监控的目的：实时报告系统状态，提前发现系统的问题。

监控的资源可以分为：共有数据（HTTP、FTP等）和私有数据（CPU、内存、进程数等）。

监控软件可以使用：系统自带的命令、Cacti监控系统、Nagios监控系统、Zabbix监控系统。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：使用命令查看计算机状态数据**

1）查看内存与交换分区信息

```shell
[root@proxy ~]# free                                     #查看内存信息
              total        used        free      shared  buff/cache   available
Mem:       16166888     8017696      720016      106504     7429176     7731740
Swap:       4194300      218268     3976032
[root@proxy ~]# free | awk '/Mem/{print $4}'                #查看剩余内存容量
720928
[root@proxy ~]# swapon -s                                #查看交换分区信息
文件名                类型            大小        已用        权限
/dev/sda3             partition        4194300    218268    -1
```

**步骤二：查看磁盘与CPU利用率**

1）查看磁盘信息

```shell
[root@proxy ~]# df                                     #查看所有磁盘的使用率
文件系统           1K-块      已用      可用         已用% 挂载点
/dev/sda2        476254208    116879624    335159084    26%        /
/dev/sda1        198174        133897        49737        73%        /boot
[root@proxy ~]# df | awk '/\/$/{print $5}'            #查看根分区的利用率
```

2）查看CPU平均负载

```shell
[root@proxy ~]# uptime                             #查看CPU负载（1，5，15分钟）
 23:54:12 up 38 days, 14:54,  9 users,  load average: 0.00, 0.04, 0.05
[root@proxy ~]# uptime |awk '{print $NF}'            #仅查看CPU的15分钟平均负载
0.05
```

**步骤二：查看网卡信息、端口信息、网络连接信息**

1）查看网卡信息（网卡名称仅供参考），如果没有ifconfig命令则需要安装net-tools软件包。

```shell
[root@proxy ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.5  netmask 255.255.255.0  broadcast 172.25.0.255
        inet6 fe80::5054:ff:fe00:b  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:00:00:0b  txqueuelen 1000  (Ethernet)
        RX packets 62429  bytes 10612049 (10.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5674  bytes 4121143 (3.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@proxy ~]# ifconfig eth0 |awk '/inet /{print $2}'        #查看IP地址信息
192.168.4.5
[root@proxy ~]# ifconfig eth0 |awk '/RX p/{print $5}'        #网卡接受数据包流量
10625295
[root@proxy ~]# ifconfig eth0 |awk '/TX p/{print $5}'        #网卡发送数据包流量
4130821
```

2）查看端口信息

```shell
[root@proxy ~]# ss -ntulp                                #查看本机监听的所有端口
#-n以数字显示端口号
#-t显示tcp连接
#-u显示udp连接
#-p显示监听端口对应的程序名称
```

3）查看网络连接信息

```shell
[root@proxy ~]# ss -antup                                #查看所有的网络连接信息
#-a查看所有连接状态信息
```

# 2. 部署Zabbix监控平台

## 2.1 问题

本案例要求部署一台Zabbix监控服务器，一台被监控主机，为进一步执行具体的监控任务做准备：

1. 安装LNMP环境
2. 源码安装Zabbix
3. 安装监控端主机，修改基本配置
4. 初始化Zabbix监控Web页面
5. 修改PHP配置文件，满足Zabbix需求
6. 安装被监控端主机，修改基本配置

## 2.2 方案

使用1台Linux虚拟机，安装部署LNMP环境、Zabbix及相关的依赖包，配置数据库并对Zabbix监控平台进行初始化操作。使用2台Linux被监控端，源码安装Zabbix Agent。完成Zabbix实验需要我们搭建一个实验环境，拓扑结构如表-1所示。

表-1 实验拓扑结构（网卡名称仅供参考，不能照抄）
![在这里插入图片描述](https://img-blog.csdnimg.cn/1b07e3df4ab9428dbb5d78d606df1592.png)

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署监控服务器**

1）安装LNMP环境

Zabbix监控管理控制台需要通过Web页面展示出来，并且还需要使用MySQL来存储数据，因此需要先为Zabbix准备基础LNMP环境。

```shell
[root@zabbixserver ~]# yum -y install gcc pcre-devel  openssl-devel
[root@zabbixserver ~]# tar -xf nginx-1.12.2.tar.gz
[root@zabbixserver ~]# cd nginx-1.12.2
[root@zabbixserver nginx-1.12.2]# ./configure --with-http_ssl_module
[root@zabbixserver nginx-1.12.2]# make && make install
[root@zabbixserver ~]# yum -y  install  php  php-mysql  php-fpm
[root@zabbixserver ~]# yum -y  install  mariadb  mariadb-devel  mariadb-server
```

2）修改Nginx配置文件

配置Nginx支持PHP动态网站，因为有大量PHP脚本需要执行，因此还需要开启Nginx的各种fastcgi缓存，加速PHP脚本的执行速度。

```shell
[root@zabbixserver ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
    fastcgi_buffers 8 16k;              #缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;              #缓存php生产的头部信息，32k
    fastcgi_connect_timeout 300;         #连接PHP的超时时间，300秒
    fastcgi_send_timeout 300;             #发送请求的超时时间，300秒
    fastcgi_read_timeout 300;            #读取请求的超时时间，300秒
location ~ \.php$ {
                root           html;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
                include        fastcgi.conf;   #[注意这里别出错]
        }
… …
```

3）启动服务

启动Nginx、PHP-FPM、MariaDB服务，关闭SELinux与防火墙。

```shell
[root@zabbixserver ~]# systemctl start  mariadb        #启动服务
[root@zabbixserver ~]# systemctl start  php-fpm        #启动服务
[root@zabbixserver ~]# systemctl enable  mariadb        #设置开机自启
[root@zabbixserver ~]# systemctl enable  php-fpm        #设置开机自启
[root@zabbixserver ~]# /usr/local/nginx/sbin/nginx        #启动服务
[root@zabbixserver ~]# echo /usr/local/nginx/sbin/nginx  >> /etc/rc.local
[root@zabbixserver ~]# chmod +x /etc/rc.local
#通过rc.local设置开机自启
[root@zabbixserver ~]# firewall-cmd --set-default-zone=trusted
[root@zabbixserver ~]# setenforce 0
[root@zabbixserver ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

**步骤二：部署监控服务器Zabbix Server**

1）源码安装Zabbix Server

多数源码包都是需要依赖包的，zabbix也一样，源码编译前需要先安装相关依赖包。

```shell
[root@zabbixserver lnmp_soft]# yum -y install  net-snmp-devel \
curl-devel autoconf libevent-devel
#安装相关依赖包
[root@zabbixserver lnmp_soft]# tar -xf zabbix-3.4.4.tar.gz
[root@zabbixserver lnmp_soft]# cd zabbix-3.4.4/
[root@zabbixserver zabbix-3.4.4]# ./configure  --enable-server \
 --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config \
 --with-net-snmp --with-libcurl
# --enable-server安装部署zabbix服务器端软件
# --enable-agent安装部署zabbix被监控端软件
# --enable-proxy安装部署zabbix代理相关软件
# --with-mysql指定mysql_config路径
# --with-net-snmp允许zabbix通过snmp协议监控其他设备（如交换机、路由器等）
# --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
[root@zabbixserver zabbix-3.4.4]# make && make install
```

2）创建并初始化数据库（root用户默认没有密码）

```shell
[root@zabbixserver ~]# mysql
mysql> create database zabbix character set utf8;
#创建数据库，数据库名称为zabbix，character set utf8是支持中文字符集
mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';
#创建可以访问数据库的账户与密码，用户名是zabbix，密码是zabbix
mysql> exit
#退出数据库
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/database/mysql/
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < schema.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < images.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < data.sql
#刚刚创建是空数据库，zabbix源码包目录下，有提前准备好的数据
#使用mysql导入这些数据即可（注意导入顺序）
#-u指定数据库用户名，-p指定数据库密码
如何测试？
[root@zabbixserver ~]# mysql -uzabbix -pzabbix -h localhost zabbix
#-u指定用户名，-p指定密码，-h指定服务器IP，最后的zabbix是数据库名称
#使用zabbix账户（密码为zabbix）连接localhost服务器上面的zabbix数据库
mysql> show tables;
#查看有没有数据表
mysql> exit
#退出数据库
```

3）修改zabbix_server配置并启动监控服务

修改Zabbix_server配置文件，设置数据库相关参数，启动Zabbix_server服务

```shell
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_server.conf
DBHost=localhost
# 85行，定义哪台主机为数据库主机，localhost为本机
DBName=zabbix
#95行，设置数据库名称
DBUser=zabbix
#111行，设置数据库账户
DBPassword=zabbix
#119行，设置数据库密码
LogFile=/tmp/zabbix_server.log    
#38行，日志的位置，排错使用，该行仅查看即可
[root@zabbixserver ~]# useradd -s /sbin/nologin zabbix
#服务不允许以root身份启动，不创建用户无法启动服务（用户不需要登录系统）
#创建zabbix用户才可以以zabbix用户的身份启动服务
#启动服务后可以通过ps aux查看进程是以什么用户的身份启动的
```

通过创建service文件管理zabbix服务。

```shell
[root@zabbixserver ~]# vim /usr/lib/systemd/system/zabbix_server.service 
[Unit]
Description=zabbix server
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_server.pid
ExecStart=/usr/local/sbin/zabbix_server
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
[root@zabbixserver ~]# systemctl  enable  zabbix_server  --now
[root@zabbixserver ~]# ss -ntulp |grep zabbix_server     #确认连接状态，端口10051
tcp LISTEN 0 128 *:10051 *:* users:(("zabbix_server",pid=23275,fd=4),("zabbix_server",pid=23274,fd=4)
```

4) 修改Zabbix_agent配置文件，启动Zabbix_agent服务

```shell
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5            #93行，允许哪些主机监控本机
ServerActive=127.0.0.1,192.168.2.5        #134行，允许哪些主机通过主动模式监控本机
Hostname=zabbix_server                #145行，设置本机主机名（名称可以任意）
LogFile=/tmp/zabbix_agentd.log            #设置日志文件（不需要修改）
UnsafeUserParameters=1                #280行，是否允许自定义监控传参
```

编写zabbix_agentd的service文件，通过systemd管理服务。

[root@zabbixserver ~]#  vim /usr/lib/systemd/system/zabbix_agentd.service
[Unit]
Description=zabbix agent
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_agentd.pid
ExecStart=/usr/local/sbin/zabbix_agentd
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
[root@zabbixserver ~]# systemctl enable  zabbix_agentd   --now
[root@zabbixserver ~]# ss -ntulp |grep zabbix_agentd   #查看端口信息为10050
tcp    LISTEN     0      128       *:10050                 *:*                   users:(("zabbix_agentd",pid=23505,fd=4),("zabbix_agentd",pid=23504,fd=4)

```
5)上线Zabbix的Web页面
```shell
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/frontends/php/
[root@zabbixserver php]# cp -r * /usr/local/nginx/html/
[root@zabbixserver php]# chown -R  apache.apache /usr/local/nginx/html/
#这里修改所有者使用:或者.都可以。
#修改权限的原因如下：
#php-fpm的账户是apache，后面我们需要让php-fpm对网站目录具有读写操作，
#而/usr/local/nginx/html默认是root所有，仅root具有写权限，php-fpm无写权限
```

浏览器访问Zabbix_server服务器的Web页面

```shell
火狐浏览器访问【 firefox http://192.168.2.5/index.php 】
#第一次访问，初始化PHP页面会检查计算机环境是否满足要求，如果不满足会给出修改建议
#默认会提示PHP的配置不满足环境要求，需要修改PHP配置文件
```

根据错误提示，安装依赖、修改PHP配置文件，满足Zabbix_server的环境要求。

```shell
[root@zabbixserver ~]# yum -y install  php-gd  php-xml
[root@zabbixserver ~]# yum -y install  php-bcmath  php-mbstring 
[root@zabbixserver ~]# vim /etc/php.ini
date.timezone = Asia/Shanghai                #878行，设置时区
max_execution_time = 300                    #384行，最大执行时间，秒
post_max_size = 32M                        #672行，POST数据最大容量
max_input_time = 300                        #394行，服务器接收数据的时间限制
[root@zabbixserver ~]# systemctl restart php-fpm
```

修改完PHP配置文件后，再次使用浏览器访问服务器，则会提示如图-1和图-2所示的提示信息。

![在这里插入图片描述](https://img-blog.csdnimg.cn/125e4e6df151497ea2aa6c8a0baf872f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-1

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f958a768a0a4f818a750d97e0ebce0d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-2

注意：这里有一个PHP LDAP是warning状态是没有问题的！

在初始化数据库页面，填写数据库相关参数，如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/678112b74b25452ab5e0def3832087bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

在登陆页面，使用用户(admin)和密码(zabbix)登陆，登陆后设置语言环境为中文，如图-4和图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/316edf73598b46ffa3186206cb312658.png)
图-4

![在这里插入图片描述](https://img-blog.csdnimg.cn/f69700914f85469089a781ca352435b0.png)
图-5

**步骤三：部署被监控主机Zabbix Agent**

1）源码安装Zabbix agent软件

在2.100和2.200做相同操作（以web1为例）。

```shell
[root@web1 ~]# useradd -s /sbin/nologin  zabbix
[root@web1 ~]# yum -y install gcc pcre-devel autoconf
[root@web1 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@web1 ~]# cd zabbix-3.4.4/
[root@web1 zabbix-3.4.4]# ./configure --enable-agent
[root@web1 zabbix-3.4.4]# make && make install 
```

2）修改agent配置文件，启动Agent

```shell
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5                #93行，谁可以监控本机（被动监控模式）
ServerActive=127.0.0.1,192.168.2.5            #134行，谁可以监控本机（主动监控模式）
Hostname=web1                                    #145行，被监控端自己的主机名
EnableRemoteCommands=1    
#69行，监控异常后，是否允许服务器远程过来执行命令，如重启某个服务
UnsafeUserParameters=1                    #280行，是否允许自定义key传参
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# sed -i  '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
[root@web1 ~]# setenforce 0
[root@web1 ~]# vim /usr/lib/systemd/system/zabbix_agentd.service
[Unit]
Description=zabbix agent
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_agentd.pid
ExecStart=/usr/local/sbin/zabbix_agentd
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
[root@web1 ~]# systemctl enable  zabbix_agentd   --now
#启动服务器并设置开机自启动
```

# 3. 配置及使用Zabbix监控系统

## 3.1 问题

沿用练习一，使用Zabbix监控平台监控Linux服务器，实现以下目标：

- 监控CPU
- 监控内存
- 监控进程
- 监控网络流量
- 监控硬盘

## 3.2 方案

通过Zabbix监控平台，添加被监控web1主机（192.168.2.100）并链接监控模板即可，Zabbix默认模板就可以监控CPU、内存、进程、网络、磁盘等项目。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：添加监控主机**

主机是Zabbix监控的基础，Zabbix所有监控都是基于Host主机。

使用火狐浏览器登录http://192.168.2.5/index.php，通过Configuration（配置）-->Hosts（主机）-->Create Host（创建主机）添加被监控Linux主机，如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fc753a2755c2428c86c7d704d1c33632.png)
图-7

添加被监控主机时，需要根据提示输入被监控Linux主机的主机名称（最好与电脑的主机名一致，但也允许不一致）、主机组、IP地址等参数，具体参考图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/039d435cca1a44c1b4ece6afc8f81f25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

**步骤二：为被监控主机添加监控模板**

点击<模板>,Zabbix通过监控模板来对监控对象实施具体的监控功能，根据模板来定义需要监控哪些数据，对于Linux服务器的监控，Zabbix已经内置了相关的模板（Template OS Linux），选择模板并链接到主机即可，如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e8bf9deb6e4843028a030db0ee2d4748.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-9

**步骤三：查看监控数据**

查看监控数据，登录Zabbix Web控制台，点击Monitoring(监控中)—> Latest data(最新数据)，正过滤器中填写过滤条件，根据监控组和监控主机选择需要查看哪些监控数据，如图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/deef37b2701649368fe8be9bc9fbbecb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-10

找到需要监控的数据后，可以点击后面的Graph（图形）查看监控图形，如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/895abe470fbd4cdabed2856759f4d9fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-11

# 4. 自定义Zabbix监控项目

## 4.1 问题

沿用练习二，使用Zabbix实现自定义监控，实现以下目标：

1. 监控Linux服务器系统账户的数量

## 4.2 方案

需要使用Zabbix自定义key的方式实现自定义监控，参考如下操作步骤：

1. 创建自定义key
2. 创建监控项目
3. 创建监控图形
4. 将监控模板关联到主机

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：被监控主机创建自定义key（在192.168.2.100操作）**

1）创建自定义key

自定义key语法格式为：UserParameter=自定义key名称,命令。

自定义的key文件一般存储在/usr/local/etc/zabbix_agentd.conf.d/目录，这里还需要修改zabbix_agentd.conf文件，允许自定义监控key，来读取该目录下的所有文件 。

```shell
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Include=/usr/local/etc/zabbix_agentd.conf.d/             #264行，加载配置文件目录
[root@web1 ~]# cd /usr/local/etc/zabbix_agentd.conf.d/
[root@web1 zabbix_agentd.conf.d]# vim count.line.passwd
UserParameter=count.line.passwd,sed -n '$=' /etc/passwd
#自定义key语法格式:
#UserParameter=自定义key名称,命令
```

2）测试自定义key是否正常工作

```shell
[root@web1 ~]# systemctl restart  zabbix_agentd                #重启agent服务
[root@web1 ~]# zabbix_get -s 127.0.0.1 -k count.line.passwd
21
```

注意：如zabbix_get命令执行错误，提示Check access restrictions in Zabbix agent configuration，则需要检查agent配置文件是否正确：

```shell
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5
ServerActive=127.0.0.1,192.168.2.5
```

**步骤二：创建监控模板**

模板、应用集与监控项目的关系图，参考图-12所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/2417ff82c4a64d399129d85a796a54d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-12

1）添加监控模板

登录Zabbix Web监控控制台，通过Configuration(配置)-->Template(模板)-->Create template(创建模板)，填写模板名称，新建模板群组，如图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eb4a0bf0ae914153ba46f14867b994ad.png)
图-13

创建模板后，默认模板中没有任何应用集、监控项、触发器、图形等，如图-14所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7c685df2adf741c1ae50d85eeec32110.png)
图-14

2）创建应用集

创建完成模板后，默认模板中没有任何应用集、监控项、触发器、图形等资源。这里需要点击模板后面的Application（应用集）链接打开创建应用集的页面，如图-15所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/dee21603ab9d411eb71a9b249ceb53b4.png)
图-15

点击Application（应用集）后，会刷新出图-16所示页面，在该页面中点击Create application（创建应用集）按钮。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dda7a4b98014f6cbe3ac6ea2cbdda68.png)
图-16

设置应用集名称，名称可以任意，如图-17所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1398dc1b53b94beb8e2185021356c891.png)
图-17

3）创建监控项目item（监控项）

与创建应用集一样，在模板中还需要创建监控项目，如图-18所示，点击items（监控项），并在刷新出的新页面中选择Create items（创建监控项）创建项目，如图-19所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e6cd87e14c174adcaecc1c082e0ef5aa.png)
图-18

![在这里插入图片描述](https://img-blog.csdnimg.cn/6223b667eb294daaa97222acfb5afd4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-19

接下来，还需要给项目设置名称（名称可以任意）及对应的自定义key（必须与前面自定义的监控key名称一致），如图-20所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c981fd678ac4443b9438e467c6885e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-20

4）将模板链接到被监控主机

将完整的监控模板制作完成后，就可以将模板链接到主机实现监控功能了。首先找到被监控主机Configuration（配置）-->Hosts（主机），如图-21所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7b2bb71510de4007adade06b673826e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-21

点击需要的被监控主机链接，打开监控主机设置页面，在Template（模板）页面中选择需要链接到该主机的模板，在此选择刚刚创建的模板count_line.passwd添加即可，如图-22所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8eff95de3c66468188f49a17d76c5262.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-22

6）查看监控数据图形

点击Monitoring(监控中)—> Latest data(最新数据)，根据需要选择条件，查看监控图形，如图-23和图-24所示。


![在这里插入图片描述](https://img-blog.csdnimg.cn/81205e437569412ebed868a0aa31a0a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/7e118a747cb343668fb25910b3f9f3fe.png)
图-24

附加思维导图，如图-25所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1908d8e8abfb4b5999c22a301a997d36.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-25


# Exercise

## 1 简单描述Zabbix具有哪些监控功能

- 具备常见的商业监控软件所具备的功能
- 主机性能监控、网络设备监控、数据库监控等
- 支持多种报警机制
- 支持自动发现网络设备和服务器
- 可以通过配置自动发现服务器规则来实现
- 支持分布式，能集中展示、管理分布式的监控点
- 编写插件容易，可以自定义监控项
- 具有实时绘图功能

## 2 简述源码编译安装Zabbix平台的操作步骤

```shell
[root@zabbixserver ~]# tar  zabbix-2.2.1.tar.gz -C /usr/src
[root@zabbixserver ~]# cd /usr/src/zabbix-2.2.1/
[root@zabbixserver zabbix-2.2.1]# ./configure \
>--prefix=/usr/local/zabbix --enable-server --enable-proxy \
>--enable-agent --with-mysql=/usr/bin/mysql_config \
> --with-net-snmp --with-libcurl
[root@zabbixserver zabbix-2.2.1]# make && make install
```

## 3 使用Template OS Linux模板可以监控哪些项目

- 监控CPU
- 监控内存
- 监控进程
- 监控网络流量
- 监控硬盘

## 4 Zabbix_agent配置文件的名称是什么

zabbix_agentd.conf。

> 如有侵权，请联系作者删除



﻿@[TOC]( MySQL primary/secondary synchronization & Primary/secondary synchronization modes | Cloud computing )

---

# 1. MySQL一主一从

## 1.1 问题

- 数据库服务器192.168.4.51配置为主数据库服务器
- 数据库服务器192.168.4.52配置为从数据库服务器
- 客户端192.168.4.50测试配置

## 1.2 方案

使用2台虚拟机，如图-1所示。其中192.168.4.51是主服务器,另一台192.168.4.52作为从服务器，通过调取主服务器上的binlog日志，在本地重做对应的库、表，实现与主服务器的数据同步。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5ce8077dfc0e48158f3d24dbd5014b9e.png)
图-1

主机51和主机52分别运行MySQL数据库服务，且管理员root用户可以本机登录；主机50作为客户机 只需有命令行连接命令mysql即可。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置主服务器192.168.4.51**

1）启用binlog日志

```shell
]# vim /etc/my.cnf
 [mysqld]
  server_id=51            //server_id
log-bin=master51        //日志名
:wq
]# systemctl  restart mysqld
```

2）用户授权

用户名自定义、客户端地址使用% 或 只指定 从服务器的地址 都可以、只给复制数据的权限即可。

```shell
]# mysql -uroot -p密碼
mysql> grant  replication slave on *.*  to repluser@"%" identified  by "123qqq...A";
mysql>quit;
```

3）查看binlog日志信息

查看日志文件名 和 偏移量位置。

```shell
mysql> show master status\G;
*************************** 1. row ***************************
File: master51.000001 //日志名
Position: 441 //偏移量
Binlog_Do_DB:
Binlog_Ignore_DB:
Executed_Gtid_Set:
1 row in set (0.00 sec)
```

**步骤二：配置从服务器192.168.4.52**

1）指定server_id

Server_id值可以自定义，但不可以与主服务器相同。

```shell
]# vim /etc/my.cnf
                        [mysqld]
                        server_id=52   //server_id值
                        :wq
                        ]# systemctl  restart mysqld  //重启服务
```

2）确保与主服务器数据一致（如果是使用2台新部署的数据库服务器配置主从同步，此操作可以忽略）

```shell
]# mysqldump  -uroot  –p密码   --master-data   数据库名   > /allbak.sql  //在主服务器上备份数据
]# scp  /allbak.sql    root@192.168.4.52:/root/   //将备份文件拷贝给从服务器
mysql> create database 数据库名 ;  //在从服务器上创建与主服务器同名的数据库
]# mysql  -uroot –p密码  数据库名  <  /root/allbak.sql //从服务器使用备份文件恢复数据
]# vim /root/allbak.sql //在从服务器查看备份文件中的binlog日志信息
......
......
CHANGE MASTER TO MASTER_LOG_FILE='master51.000001', MASTER_LOG_POS=441; //日志名与偏移量
```

3）指定主服务器信息

数据库管理员root本机登录，指定主服务器信息，其中日志文件名和偏移量 写allbak.sql文件记录的。

```shell
]# mysql -uroot –p密码     //管理员root 本机登录
mysql> show slave status;  //查看状态信息，还不是从服务器
Empty set (0.00 sec)
mysql> change   master  to //指定主服务器
    -> master_host=“192.168.4.51”,                 //主服务器ip地址
    -> master_user=“repluser”,                        //主服务器授权用户
    -> master_password=“123qqq…A”,            //主服务器授权用户密码
    -> master_log_file=“master51-bin.000001”,//主服务器日志文件
    -> master_log_pos=441;                  //主服务器日志偏移量
mysql> start  slave;
mysql> show slave status\G; //查看状态信息
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.4.51  //主服务器ip地址
                  Master_User: repluser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: master51.000001
          Read_Master_Log_Pos: 437
               Relay_Log_File: host52relay-bin.000002
                Relay_Log_Pos: 604
        Relay_Master_Log_File: master51.000001
             Slave_IO_Running: Yes        //IO线程yes状态
            Slave_SQL_Running: Yes        //SQL线程yes状态
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 437
              Relay_Log_Space: 812
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 50
                  Master_UUID: 4881ee4b-8800-11e9-830a-525400001e32
             Master_Info_File: /var/lib/mysql/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400
                  Master_Bind: 
      Last_IO_Error_Timestamp: 
     Last_SQL_Error_Timestamp: 
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
           Retrieved_Gtid_Set: 
            Executed_Gtid_Set: 
                Auto_Position: 0
         Replicate_Rewrite_DB: 
                 Channel_Name: 
           Master_TLS_Version: 
1 row in set (0.00 sec)
```

**步骤三：客户端测试配置**

1）在主服务器添加访问数据的连接用户

授权用户对所有数据有增删改查的权限即可

```shell
]# mysql –uroot –p密码
mysql> grant select,insert,update,delete on  *.* to  admin@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.03 sec)
mysql> quit
```

2）客户端连接主服务器访问数据

在50主机 使用主服务器51的授权用户连接

```shell
]# mysql -h192.168.4.51-uadmin -p123qqq...A
mysql> show grants;
+------------------------------------------------------------+
| Grants for admin@%                                         |
+------------------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE, DELETE ON *.* TO 'admin'@'%' |
+------------------------------------------------------------+
1 row in set (0.00 sec)
mysql> insert into db3.user(name,uid) values("lili",288); //db3库和user表是主从同步之前主服务器已有的。
Query OK, 1 row affected (0.05 sec)
mysql> insert into db3.user(name,uid) values("lili",288);
Query OK, 1 row affected (0.28 sec)
mysql> insert into db3.user(name,uid) values("lili",288);
Query OK, 1 row affected (0.05 sec)
mysql> select name,uid from db3.user where name="lili";
+------+------+
| name | uid  |
+------+------+
| lili |  288 |
| lili |  288 |
| lili |  288 |
+------+------+
3 rows in set (0.00 sec)
```

3) 客户端连接从服务器访问数据

客户端50主机使用授权用户连接从服务器可以看到和主服务器同样的数据

```shell
]# mysql -h192.168.4.52 –uadmin  -p123qqq…A
mysql> select name,uid from db3.user where name="lili";
+------+------+
| name | uid  |
+------+------+
| lili |  288 |
| lili |  288 |
| lili |  288 |
+------+------+
3 rows in set (0.00 sec)
```

# 2. 配置一主多从结构

## 2.1 问题

- 配置192.168.4.53数据库服务器为主机192.168.4.51的从服务器
- 客户端测试配置。

## 2.2 方案

创建1台新虚拟机，配置ip地址为192.168.4.53、运行数据库服务，且数据库管理员root用户可以本机登录。具体结构，如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c4d202aae80c4c2daee93bfcec79435e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

## 2.3 步骤

实现此案例需要按照如下步骤进行。
**步骤一：配置从服务器192.168.4.53**

1）启用binlog日志

```shell
]# vim /etc/my.cnf
 [mysqld]
  server_id=53        //server_id
:wq
]# systemctl  restart mysqld
```

2）确保与主服务器数据一致

在主服务器51 备份所有数据 并把备份文件拷贝给53服务器。

```shell
]# mysqldump -uroot –p123qqq…A –-master-data –B db4 db3 >  /root/twodb.sql
]# scp /root/twodb.sql  root@192.168.4.53:/root/
```

在53主机使用备份文件恢复数据，并查看备份文件记录的日志名和偏移量

```shell
]# mysql -uroot –p123qqq…A  < /root/twodb.sql
]# grep  mater51  /root/twodb.sql
CHANGE MASTER TO MASTER_LOG_FILE='master51.000001', MASTER_LOG_POS=1098; //日志名与偏移量
```

3）指定主服务器信息

填写备份文件里显示的日志文件名 和 偏移量位置。

```shell
mysql> change   master  to //指定主服务器
    -> master_host=“192.168.4.51”,                 //主服务器ip地址
    -> master_user=“repluser”,                        //主服务器授权用户
    -> master_password=“123qqq…A”,            //主服务器授权用户密码
    -> master_log_file=“master51.000001”,//主服务器日志文件
    -> master_log_pos=1098;                  //主服务器日志偏移量
mysql> start slave;
```

查看状态信息

```shell
]# mysql –uroot –p123qqq…A –e “show slave status\G” | grep –i  yes
            Slave_IO_Running: Yes        //IO线程yes状态
            Slave_SQL_Running: Yes        //SQL线程yes状态
]# mysql –uroot –p123qqq…A –e “show slave status\G” | grep –i  “master_host”
Master_Host: 192.168.4.51  //主服务器ip地址
```

**步骤二：客户端测试（192.168.4.50）**

1）连接主服务器插入新记录

```shell
]# mysql -h192.168.4.51-uadmin -p123qqq...A
mysql> insert into db3.user(name,uid) values("lucy",888); //db3库和user表是主从同步之前主服务器已有的。
Query OK, 1 row affected (0.05 sec)
```

2）在从服务器本机53 可以查询到新插入的数据

```shell
]# mysql  -uroot  –p123qqq…A
mysql> select name,uid from db3.user;
+------+------+
| name | uid  |
+------+------+
| lili |  288 |
| lucy |  888 |
+------+------+
2 rows in set (0.00 sec)
```

# 3. 配置主从从结构

## 3.1 问题

- 配置主机192.168.4.53为主服务器
- 配置主机192.168.4.54为53主机的从服务器
- 配置主机192.168.4.55为54主机的从服务器
- 客户端测试配置。

## 3.2 方案

使用3台虚拟机，分别运行mysql数据库服务，且管理员root可以本机登录；主机192.168.4.53为主服务器;主机192.168.4.54为从服务器；主机192.168.4.55为从服务器。如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/32807a40789b45d88290fe218fd6439b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备**

为了在启用binlog日志及同步之前保持主、从库的一致性，主从同步未配置之前，要保证从库上要有主库上的数据，禁用selinux，关闭防火墙服务，保证物理连接正常

1）关闭防火墙，禁用selinux，已关可忽略：

```shell
]# systemctl  stop firewalld
]# setenforce  0 
```

**步骤二：配置主服务器192.168.4.53**

2）用户授权

```shell
]# mysql -uroot -p123456
mysql> grant   replication  slave   on  *.*  to  yaya@"%"   identified    by  "123qqq…A“；
Query OK, 0 rows affected, 1 warning (0.03 sec)
```

3）启用binlog日志，修改/etc/my.cnf配置，重新启动MySQL服务程序

指定服务器ID号、允许日志同步：

```shell
]# vim /etc/my.cnf
[mysqld]
log_bin=db53                     //启用binlog日志，并指定文件名前缀
server_id=53                    //指定服务器ID号
```

4）重启mysql服务：

```shell
]# systemctl  restart   mysqld
```

5）确保/var/lib/mysql下面有两个文件：

```shell
]#  ls  /var/lib/mysql/db51.*
/var/lib/mysql/db53.000001  /var/lib/mysql/db53.index
```

6）查看主服务正在使用的日志信息

查看主服务器状态，记录下当前的日志文件名、偏移的位置（下面SLAVE发起复制时需要用到）：

```shell
    mysql> show  master  status;
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db53.000001 |437       |      |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

**步骤三：配置从服务器192.168.4.54**

1）在服务器192.168.4.53上做用户授权（数据同步使用的连接用户）

```shell
]# mysql -uroot -p123456
mysql> grant  replication slave on *.*  to  user55@”%” identified by  “654321” ;
```

2）修改/etc/my.cnf配置，启用binlog日志，指定server_id 和 允许级联复制

```shell
]# vim /etc/my.cnf 
[mysqld]
server_id=54                  
log-bin=db54
log_slave_updates                          //允许级联复制
```

3）配置完成后，重启mysql服务：

```shell
]# systemctl restart mysqld
```

4）确保/var/lib/mysql下面有两个文件：

```shell
]# ls /var/lib/mysql/db52.*
/var/lib/mysql/db54.000001   /var/lib/mysql/db54.index
```

5）查看正在使用的日志信息

```shell
]# mysql -uroot -p123456
mysql>  show  master  status;
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
|db54.000001  |      154 |                                                          
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)    //查看日志文件名、偏移的位置
```

6）验证主服务器的的授权用户

```shell
]# mysql -h192.168.4.53 -uyaya -p123456
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>                                //验证成功
```

7）通过change master语句指定master服务器的IP地址、同步用户名/密码、起始日志文件、偏移位置（参考master上的状态输出）：

```shell
]# mysql -uroot -p123456
mysql> change master to
-> master_host="192.168.4.53”;
-> master_user="yaya",
-> master_password="123456",
-> master_log_file="db53.000001”;
-> master_log_pos=437;
Query OK, 0 rows affected, 2 warnings (0.43 sec)
```

8）启动slave进程

```shell
mysql> start slave;
Query OK, 0 rows affected (0.03 sec)
```

9）查看进程状态信息，通过show slave status语句可查看从服务器状态，确认其中的IO线程、SQL线程正常运行，才能成功同步,IO线程和SQL线程必须是Yes

```shell
mysql> show slave status \G;
*************************** 1. row ***************************
Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.4.53 //主服务器IP地址
Master_User: yaya
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: db53.000001
Read_Master_Log_Pos: 437
Relay_Log_File: db54-relay-bin.000001
Relay_Log_Pos: 315
Relay_Master_Log_File: db54.000001
             Slave_IO_Running: Yes    //IO线程状态YES
            Slave_SQL_Running: Yes  //SQL线程状态YES
Replicate_Do_DB:
Replicate_Ignore_DB:
Replicate_Do_Table:
Replicate_Ignore_Table:
Replicate_Wild_Do_Table:
Replicate_Wild_Ignore_Table:
Last_Errno: 0
Last_Error:
Skip_Counter: 0
Exec_Master_Log_Pos: 437
Relay_Log_Space: 521
Until_Condition: None
Until_Log_File:
Until_Log_Pos: 0
Master_SSL_Allowed: No
Master_SSL_CA_File:
Master_SSL_CA_Path:
Master_SSL_Cert:
Master_SSL_Cipher:
Master_SSL_Key:
Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
Last_IO_Errno: 0
Last_IO_Error:
Last_SQL_Errno: 0
Last_SQL_Error:
Replicate_Ignore_Server_Ids:
Master_Server_Id: 51
Master_UUID: 81a13101-aa66-11e8-ad11-525400019e62
Master_Info_File: /var/lib/mysql/master.info
SQL_Delay: 0
SQL_Remaining_Delay: NULL
Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
Master_Retry_Count: 86400
Master_Bind:
Last_IO_Error_Timestamp:
Last_SQL_Error_Timestamp:
Master_SSL_Crl:
Master_SSL_Crlpath:
Retrieved_Gtid_Set:
Executed_Gtid_Set:
Auto_Position: 0
Replicate_Rewrite_DB:
Channel_Name:
Master_TLS_Version:
1 row in set (0.00 sec)
```

**步骤四：配置从服务器192.168.4.55**

1）验证主库的授权用户

```shell
]# mysql  -h192.168.4.54  -uuser54 -p654321
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>                  //验证成功
```

2）指定server_id

```shell
]# vim /etc/my.cnf
[mysqld]
server_id=55
:wq
```

3）重新启动服务

```shell
]# systemctl restart mysqld
```

4）管理员登录指定主库信息

```shell
]# mysql -uroot -p123456
mysql> change  master  to 
    -> master_host="192.168.4.54”;
    -> master_user="user55”;
    -> master_password="654321",
    -> master_log_file=" db54.000001”;
    -> master_log_pos=154;
Query OK, 0 rows affected, 2 warnings (0.37 sec)
```

5）启动slave进程

```shell
mysql>  start  slave;
Query OK, 0 rows affected (0.04 sec)
```

6）查看进程状态信息

```shell
mysql> show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.4.54
                  Master_User: user55
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: db54.000001
          Read_Master_Log_Pos: 154
               Relay_Log_File: db55-relay-bin.000001
                Relay_Log_Pos: 315
        Relay_Master_Log_File: db54.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
```

**步骤五：客户端验证配置**

在主库授权访问数据的连接用户;户端连接主库执行与权限匹配的sql操作;

授权用户连接第1台从库，可以看到主库的数据;权用户连接第2台从库，可以看到主库的数据

1）在主服务器上在主库上授权访问gamedb库的用户

```shell
]# mysql -uroot  -p123456
mysql> grant  all  on  gamedb.*   to   dada@"%"  identified by  "123456";
Query OK, 0 rows affected, 1 warning (0.03 sec)
```

2）客户端使用授权用户连接主库，建库、表、插入记录

```shell
]# mysql  -h192.168.4.53    -udada  -p123456
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MySQL [(none)]>   //验证成功
MySQL [(none)]> create  database  gamedb;   //创建测试库
Query OK, 1 row affected (0.04 sec)
MySQL [(none)]> create  table  gamedb.t1(id int);   //在gamedb下创建t1表
Query OK, 0 rows affected (0.17 sec)
MySQL [(none)]> insert into  gamedb.t1 values(8888);   //在t1表中插入数值
Query OK, 1 row affected (0.22 sec)
```

3）客户端使用授权用户连接2台从库时，也可以看到主库上新的库表记录

```shell
]# mysql  -h192.168.4.54    -udada  -p123456  //验证54主机的状态
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 10
Server version: 5.7.17-log MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MySQL [(none)]> select  * from gamedb.t1;         //查询插入的表格
+------+
| id   |
+------+ 
| 8888 |
+------+
1 row in set (0.00 sec)
MySQL [(none)]> exit
[root@room9pc01 ~]# mysql  -h192.168.4.55   -udada  -p123456 //验证55主机的状态
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 6
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MySQL [(none)]> select  * from gamedb.t1;
+------+
| id   |
+------+
| 8888 |
+------+
1 row in set (0.00 sec)
```

# 4. 配置半同步复制模式

## 4.1 问题

- 开启案例2 从服务器192.168.4.54 半同步复制模式
- 查看半同步复制模式是否开启

## 4.2 方案

以案例2从服务器192.168.4.54 为例演示配置，54主机既做主服务器又做从服务器，所以两种角色的半同步复制模块和功能都要启用。

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：查看是否允许动态加载模块。**

1）查看是否允许动态加载模块（默认允许）

```shell
mysql> show  variables  like  'have_dynamic_loading';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| have_dynamic_loading | YES   |
+----------------------+-------+
1 row in set (0.01 sec)
```

2）命令行加载插件

```shell
mysql> install  plugin   rpl_semi_sync_master   SONAME   ”semisync_master.so”; //加载master模块
mysql> install  plugin   rpl_semi_sync_slave SONAME  'semisync_slave.so'; //加载slave模块
```

查看模块是否安装成功：

```shell
mysql> select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';  
+----------------------+---------------+
| PLUGIN_NAME          | PLUGIN_STATUS |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE         |        //模块安装成功
| rpl_semi_sync_slave  | ACTIVE         |        
+----------------------+---------------+
2 rows in set (0.00 sec)
```

3）启用半同步复制 （在安装完插件后，半同步复制默认是关闭的）

```shell
mysql> set  global rpl_semi_sync_master_enabled = 1; //启用master半同步复制
Query OK, 0 rows affected (0.00 sec)
mysql> set  global rpl_semi_sync_slave_enabled = 1; //启用slave半同步复制
Query OK, 0 rows affected (0.00 sec)
```

查看半同步复制模式是否启用：

```shell
mysql>  show  variables  like  "rpl_semi_sync_%_enabled";
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | ON    |    //模块已启用
| rpl_semi_sync_slave_enabled  | ON    |
+------------------------------+-------+
2 rows in set (0.00 sec)
```

4）修改配置文件，永久启用半同步复制

```shell
 [root@master51 ~]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1
：wq
```

5）重启数据库服务，并查看状态信息

```shell
]# mystemctl  restart mysqld
]# mysql -uroot -p123qqq...A
mysql> select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';
+----------------------+---------------+
| plugin_name          | plugin_status |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        | //模块已加载
| rpl_semi_sync_slave  | ACTIVE        |
+----------------------+---------------+
2 rows in set (0.00 sec)
mysql>  show  variables  like  "rpl_semi_sync_%_enabled";
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | ON    | //模式已启用
| rpl_semi_sync_slave_enabled  | ON    |
+------------------------------+-------+
2 rows in set (0.00 sec)
```

# Exercise

## 1 简述MySQL 主从同步中，主数据库服务器要做哪些配置？

**第1步：用户授权**

```shell
mysql> grant replication slave on  *.*  to  用户名@”从数据库服务器ip地址”  identified  by  “密码”;
```

**第2步：启用binlog日志并指定server_id**

```shell
[root@server0 ~]#vim /etc/my.cnf
[mysqld]
log-bin=日志文件名
server_id=数字
:wq
[root@server0 ~]# Service  mysql   restart
```

## 2 简述在主从同步结构中，slave服务器IO线程和SQL线程各自的作用。

IO线程的作用：把主数据库服务器binlog日志里的sql命令拷贝到本机的中继日志文件里。

SQL线程的作用： 执行本机中继日志文件中的sql命令，把数据写进本机的数据库里。

## 3 简述MySQL 主从同步结构模式种类。

主从同步结构模式如下：一主一从结构 、一主多从结构 、主从从结构 、主主结构

## 4 简述MySQL 主从同步复制模式。

主从同步复制模式如下：异步复制模式 、全同步复制模式 、半同步复制模式

> 如有侵权，请联系作者删除



﻿@[TOC]( NAT & VRRP | Cloud computing )

---

# 1. 配置静态NAT

## 1.1 问题

按照图-1拓扑图所示，在R1上配置静态NAT使192.168.2.1转换为100.0.0.2,192.168.2.2转换为100.0.0.3，实现外部网络访问

![在这里插入图片描述](https://img-blog.csdnimg.cn/a72d21bf39f24fbaa330e6913d870e5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置静态NAT**
pc3无需配置网关

```shell
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0] ip address  100.0.0.1 8
[Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.2 inside 192.168.2.1
[Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.3 inside 192.168.2.2
```

# 2. Easy IP

## 2.1 问题

按照图-2所示的拓扑结构，在R1上配置Easy IP使企业内网192.168.2.0/24利用g0/0/0端口的ip，实现外部网络的访问

![在这里插入图片描述](https://img-blog.csdnimg.cn/9fbd64d2fc624c86a49724d7b7e8bf61.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-2

## 2.2 步骤

实现此案例需要按照如下步骤进行

**步骤一：配置静态NAT**

注：以下命令需要在路由器配置好ip的基础上完成

```shell
[Huawei]acl 2000    
[Huawei-acl-basic-2000]rule permit source any     //使用acl定义任何内部地址
[Huawei]interface g0/0/0
[Huawei-GigabitEthernet0/0/0]nat outbound 2000    //可以利用g0/0/0的ip访问外网
```

# 3. 三层交换配置VRRP

## 3.1 问题

按照图-3所示拓扑结构，在三层交换机配置热备份路由协议使组内两个出口设备共享一个虚拟ip地址192.168.1.254为内网主机的网关

![在这里插入图片描述](https://img-blog.csdnimg.cn/3f9b2cb8033f4b22be1d5d291d7461bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

## 3.2 步骤

本实验暂不考虑NAT问题

**步骤一：pc配置ip**

pc设备配置ip与网关，192.168.1.1的网关为192.168.1.254
192.168.4.1的网关为192.168.4.254

**步骤二：路由器配置**

路由器配置

```shell
<Huawei>system-view 
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 192.168.2.1 24
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.3.1 24
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]ip address 192.168.4.254 24
[Huawei]ospf    
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255
```

**步骤三：交换机配置**

1）MS1

```shell
<Huawei>system-view
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]ip add 192.168.1.252 24
[Huawei]vlan 2
[Huawei-vlan2]quit
[Huawei]interface Vlanif 2
[Huawei-Vlanif2]ip address 192.168.2.2 24
[Huawei-Vlanif2]quit
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]port link-type access 
[Huawei-GigabitEthernet0/0/2]port default vlan 2
[Huawei]ospf    
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254
```

2）MS2

```shell
<Huawei>system-view
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]ip add 192.168.1.253 24
[Huawei]vlan 3
[Huawei-vlan3]quit
[Huawei]interface Vlanif 3
[Huawei-Vlanif3]ip address 192.168.3.2 24
[Huawei-Vlanif3]quit
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]port link-type access 
[Huawei-GigabitEthernet0/0/2]port default vlan 3
[Huawei]ospf    
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254
```

# 4. 网络负载均衡

## 4.1 问题

按照图-4所示拓扑结构，配置MS1为vlan10的主路由器、vlan20的备份路由器，MS2为vlan10的备份路由器、vlan20的主路由器，实现负载均衡的效果

![在这里插入图片描述](https://img-blog.csdnimg.cn/4e64ddd96fa848c2bcc581acef512f64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

## 4.2 步骤

实现此案例需要按照如下步骤进行

**步骤一：配置交换机**

1）MS1

```shell
[Huawei]interface Vlanif 10
[Huawei-Vlanif10]ip address 192.168.10.252 24
[Huawei-Vlanif10]vrrp vrid 1 virtual-ip 192.168.10.254
[Huawei-Vlanif10]vrrp vrid 1 priority 110
[Huawei]interface Vlanif 20
[Huawei-Vlanif20]ip address 192.168.20.252 24
[Huawei-Vlanif20]vrrp vrid 2 virtual-ip 192.168.20.254
```

1）MS2

```shell
[Huawei]interface Vlanif 10
[Huawei-Vlanif10]ip address 192.168.10.253 24
[Huawei-Vlanif10]vrrp vrid 1 virtual-ip 192.168.10.254
[Huawei]interface Vlanif 20
[Huawei-Vlanif20]ip address 192.168.20.253 24
[Huawei-Vlanif20]vrrp vrid 2 virtual-ip 192.168.20.254
[Huawei-Vlanif20]vrrp vrid 2 priority 110
```

# Exercise

## 1 VRRP的作用是什么？

网关的冗余备份，可以保障网关设备出现故障的情况下不会对网络造成重大影响。

## 2 VRRP中路由器身份有哪些？

主路由器，备份路由器，虚拟路由器

## 3 NAT的作用是什么？

通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址，使内部网络可以连接到互联网等外部网络上。

## 4 私有IP地址分类有哪些？

A类 10.0.0.0~10.255.255.255

B类 172.16.0.0~172.31.255.255

C类 192.168.0.0~192.168.255.255

## 5 NAT常用实现方式有哪些？

静态转换

Easy IP

> 如有侵权，请联系作者删除



﻿@[TOC]( Native cloud K8S decryption & K8S cluster installation and deployment & K8S network plug-in | Cloud computing )

---

# 1. 准备虚拟机环境

## 1.1 问题

本案例要求准备虚拟机环境，具体要求如下：

1. 在跳板机配置YUM源服务器
2. 准备虚拟机master实验环境
3. 最低配置：2cpu，2G内存
4. 卸载防火墙 firewalld-*
5. 禁用 selinux 和 swap
6. 配置yum仓库，安装kubeadm、kubelet、kubectl、docker-ce
7. 配置docker私有镜像仓库和cgroup驱动（daemon.json）
8. 配置内核参数（/etc/sysctl.d/k8s.conf）

## 1.2 方案

完成后续课程的学习需要提前准备实验用的虚拟机，实验虚拟机列表如表-1所示。

所有主机的主机名和IP必须与列表相同!!!

否则后续所有试验都无法顺利完成！！！

表-1

![img](https://img-blog.csdnimg.cn/img_convert/23e1f23bedd7c95516826b2b93f45dd4.png)

## 1.3 步骤

实现此案例需要按照如下步骤进行。

步骤一：在跳板机配置YUM源服务器（在跳板机主机操作）

Kubernetes相关软件已经提前共享到云盘，各位同学需要提前下载，并传到跳板机主机。云盘资料在第四阶段kubernetes/v1.17.6/k8s-install/目录下。

1）将所有软件资料放到跳板机的YUM共享目录。

```shell
[root@localhost ~]# rsync -avXSH --delete \
kubernetes/v1.17.6/k8s-install /var/ftp/localrepo/
```

2)更新YUM共享服务器数据

```shell
[root@server ~]# cd /var/ftp/localrepo
[root@server localrepo]# createrepo --update .
```

步骤二：安装管理节点所需软件包（在master主机操作）

1）设置yum源

```shell
[root@master ~]# vim /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever – Localrepo
baseurl=ftp://192.168.1.252/localrepo
enabled=1
gpgcheck=0
[root@master ~]# yum makecache
```

2）安装软件

```shell
[root@master ~]# yum install -y kubeadm kubelet kubectl docker-ce
```

3）修改docker配置，指定使用私有镜像仓库

私有镜像仓库已经在前面课程搭建完成（在192.168.1.100服务器上）！！！

```shell
[root@master ~]# vim /etc/docker/daemon.json 
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "registry-mirrors": ["https://hub-mirror.c.163.com"],
    "insecure-registries":["192.168.1.100:5000", "registry:5000"]
}
```

4）修改内核参数

```shell
[root@master ~]# vim /etc/sysctl.d/k8s.conf      #没有该文件，需要新建文件
net.bridge.bridge-nf-call-ip6tables = 1          # 开启桥设备内核监控（ipv6）
net.bridge.bridge-nf-call-iptables = 1               # 开启桥设备内核监控（ipv4）
net.ipv4.ip_forward = 1                             # 开启路由转发
[root@master ~]# modprobe br_netfilter             #加载内核模块
[root@master ~]# sysctl --system                    # 加载上面的k8s.conf配置文件
* Applying /etc/sysctl.d/k8s.conf ...
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
... ...
```

5）了解kubeadm命令

```shell
kubeadm 命令
config: 配置管理命令
help:   查看帮助
init:   初始命令
join:   node加入集群的命令
reset:  还原状态命令 
token:  token凭证管理命令
version:查看版本
```



# 2. 配置私有仓库

## 2.1 问题

本案例要求上传镜像到私有仓库（192.168.1.100:5000），具体需要上传的镜像列表如下：

1. 192.168.1.100:5000/kube-apiserver:v1.17.6
2. 192.168.1.100:5000/kube-controller-manager:v1.17.6
3. 192.168.1.100:5000/kube-scheduler:v1.17.6
4. 192.168.1.100:5000/kube-proxy:v1.17.6
5. 192.168.1.100:5000/pause:3.1
6. 192.168.1.100:5000/etcd:3.4.3-0
7. 192.168.1.100:5000/coredns:1.6.5

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：列出部署kubernetes需要哪些镜像（在master主机操作）**

```shell
[root@master ~]# kubeadm config image list           #列出需要的镜像
k8s.gcr.io/kube-apiserver:v1.17.6
k8s.gcr.io/kube-controller-manager:v1.17.6
k8s.gcr.io/kube-scheduler:v1.17.6
k8s.gcr.io/kube-proxy:v1.17.6
k8s.gcr.io/pause:3.1
k8s.gcr.io/etcd:3.4.3-0
k8s.gcr.io/coredns:1.6.5
```

**步骤二：将所有需要的镜像导入私有仓库（在master或者node-0001主机操作）**

所有实验需要的镜像都已经提前共享在云盘，各位同学需要将所有镜像下载并传到master主机。镜像在云盘第四阶段kubernetes/v1.17.6/base-images目录下。

警告：所有镜像禁止修改名称和标签，必须保留原名称！！！

```shell
[root@master ~]# docker load -i kube-apiserver.tar.gz
#加载kube-apiserver镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/kube-apiserver:v1.17.6 192.168.1.100:5000/kube-apiserver:v1.17.6
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/kube-apiserver:v1.17.6
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i pause.tar.gz
#加载pause镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/pause:3.1 192.168.1.100:5000/pause:3.1
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/pause:3.1
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i kube-proxy.tar.gz
#加载kube-proxy镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/kube-proxy:v1.17.6 192.168.1.100:5000/kube-proxy:v1.17.6
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/kube-proxy:v1.17.6
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i kube-controller-manager.tar.gz
#加载kube-controller-manager镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/kube-controller-manager:v1.17.6 192.168.1.100:5000/kube-controller-manager:v1.17.6
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/kube-controller-manager:v1.17.6
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i kube-controller-manager.tar.gz
#加载kube-controller-manager镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/kube-controller-manager:v1.17.6 192.168.1.100:5000/kube-controller-manager:v1.17.6
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/kube-controller-manager:v1.17.6
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i etcd.tar.gz
#加载etcd镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/etcd:3.4.3-0 192.168.1.100:5000/etcd:3.4.3-0
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/etcd:3.4.3-0
#将镜像上传到192.168.1.100私有镜像仓库服务器
[root@master ~]# docker load -i coredns.tar.gz
#加载coredns镜像到本地
[root@master ~]# docker tag \
k8s.gcr.io/coredns:1.6.5 192.168.1.100:5000/coredns:1.6.5
#修改镜像标签（只修改服务器的IP，不要修改镜像名称和后面的版本）
[root@master ~]# docker push 192.168.1.100:5000/coredns:1.6.5
#将镜像上传到192.168.1.100私有镜像仓库服务器
```



# 3. 安装master

## 3.1 问题

本案例要求安装部署master，分别实现以下目标：

1. 设置tab键
2. 安装IPVS模式软件包 ipvsadm、ipset
3. 在master上部署kubernetes

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装部署master管理节点（在master主机操作操作）**

1）设置Tab补齐

kubectl、kubeadm支持自动补全功能，可以节省大量输入，自动补全脚本由 kubectl、kubeadm产生，仅需要在您的 shell 配置文件中调用即可。

```shell
[root@master ~]# kubectl completion bash >/etc/bash_completion.d/kubectl
[root@master ~]# kubeadm completion bash >/etc/bash_completion.d/kubeadm
[root@master ~]# exit
# 注意 ：配置完成以后需要退出，重新登录后才能生效
```

2）安装IPVS代理

```shell
[root@master ~]# yum install -y ipvsadm ipset
```

3）k8s系统初始化

```shell
[root@master ~]# kubeadm init --dry-run
... ...
根据提示信息排错若干
... ...
--------------------------------------------------------------------
[root@master ~]# kubeadm config print init-defaults >kubeadm-init.yaml
```

4）修改配置文件

修改好的配置文件已经共享在云盘，直接使用修改好的配置文件即可。

配置文件在第四阶段kubernetes/v1.17.6/config/kubeadm-init.yaml。

```shell
[root@master ~]# vim  kubeadm-init.yaml
06:    ttl: 24h0m0s                          # token 生命周期
12:    advertiseAddress: 192.168.1.21        # apiserver 的IP地址
32:    imageRepository: 192.168.1.100:5000    # 镜像仓库地址
34:    kubernetesVersion: v1.17.6        # 当前安装的 k8s 版本
36:    dnsDomain: cluster.local        # 默认域名地址
37:    podSubnet: 10.244.0.0/16        # 容器地址cidr，新添加
38:    serviceSubnet: 10.254.0.0/16        # 服务地址cidr
#文件最后手动添加如下4行
---                    
apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: ipvs
```

5）安装master

```shell
[root@master ~]# kubeadm init --config=kubeadm-init.yaml | tee master-init.log
... ...
Your Kubernetes control-plane has initialized successfully!
To start using your cluster, you need to run the following as a regular user:
  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
... ...
[root@master ~]# mkdir -p /root/.kube
[root@master ~]# cp -i /etc/kubernetes/admin.conf /root/.kube/config
```

6）启动服务并验证

```shell
[root@master ~]# kubectl  get  componentstatuses
NAME                               STATUS          MESSAGE                 ERROR
controller-manager           Healthy                ok                  
scheduler                         Healthy           ok                  
etcd-0                         Healthy           {"health":"true"}   
[root@master ~]# kubectl version
Client Version: version.Info{Major:"1", Minor:"17", GitVersion:"v1.17.6", GitCommit:"d32... ...", GitTreeState:"clean", BuildDate:"2020-05-20T13:16:24Z", GoVersion:"go1.13.9", Compiler:"gc", Platform:"linux/amd64"}
Server Version: version.Info{Major:"1", Minor:"17", GitVersion:"v1.17.6", GitCommit:"d32... ...", GitTreeState:"clean", BuildDate:"2020-05-20T13:08:34Z", GoVersion:"go1.13.9", Compiler:"gc", Platform:"linux/amd64"}
```



# 4. 安装node节点并加入master

## 4.1 问题

本案例要求安装node节点并加入master，具体要求如下：

1. node主机最低配置：2cpu，2G内存
2. 初始化系统环境（步骤同 master）
3. 设置主机名/etc/hosts
4. master上创建 token
5. 安装 node 并加入集群

### 4.2 步骤

实现此案例需要按照如下步骤进行。

！！！提醒：本案例的所有操作都已经编写了ansible剧本，下面的所有操作步骤都可以通过ansible自动化完成。

各位同学在【跳板机】主机下载ansible配置以及对应的素材，执行剧本即可完成下面的所有操作！

Ansible素材在云盘共享第四阶段kubernetes/v1.17.6/node-install/目录下。

将整个目录下载拷贝到【跳板机】，然后修改剧本中的Token和对应的Hash值。

如果获取Token和对应的Hash值，可以参考下面的【步骤二】。

```shell
[root@localhost node-install]# vim node_install.yaml           # 执行前需要修改剧本
vars:
    master: '192.168.1.21:6443'
    token: ‘fm6kui.mp8rr3akn74a3nyn’       # 设置获取的 token
    token_hash: ‘sha256:f46dd7ee … …’        # 设置获取的 token hash
[root@localhost node-install]# ansible-playbook  node_install.yaml    # 执行剧本
```

**步骤一：初始化node节点（在node-0001主机操作）**

1）关闭防火墙和SELinux。

```shell
[root@node-0001 ~]# vim /etc/selinux/config
... ...
SELINUX=disabled
[root@node-0001 ~]# yum -y remove firewalld-*
... ...
[root@node-0001 ~]# reboot
... ...
[root@node-0001 ~]# sestatus 
SELinux status:                 disabled
```

2）配置YUM源

```shell
[root@node-0001 ~]# vim  /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever – Localrepo
baseurl=ftp://192.168.1.252/localrepo
enabled=1
gpgcheck=0
```

3）如果系统中有swap交换分区的话，则禁用该分区，可以在/etc/fstab中禁用。

4）安装软件

```shell
[root@node-0001 ~]# yum install -y kubeadm kubelet docker-ce
```

5）安装IPVS代理

```shell
[root@node-0001 ~]# yum install -y ipvsadm ipset
```

6）修改docker配置，指定使用私有镜像仓库

```shell
[root@node-0001 ~]# vim /etc/docker/daemon.json 
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "registry-mirrors": ["https://hub-mirror.c.163.com"],
    "insecure-registries":["192.168.1.100:5000", "registry:5000"]
}
```

7）修改内核参数

```shell
[root@node-0001 ~]# vim /etc/sysctl.d/k8s.conf      #没有该文件，需要新建文件
net.bridge.bridge-nf-call-ip6tables = 1          # 开启桥设备内核监控（ipv6）
net.bridge.bridge-nf-call-iptables = 1               # 开启桥设备内核监控（ipv4）
net.ipv4.ip_forward = 1                             # 开启路由转发
[root@node-0001 ~]# modprobe br_netfilter          #加载内核模块
[root@node-0001 ~]# sysctl --system                # 加载上面的k8s.conf配置文件
* Applying /etc/sysctl.d/k8s.conf ...
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
... ...
```

8）修改/etc/hosts

```shell
[root@node-0001 ~]# vim  /etc/hosts
::1        localhost    localhost.localdomain    localhost6    localhost6.localdomain6
127.0.0.1    localhost    localhost.localdomain    localhost4    localhost4.localdomain4
192.168.1.21    master
192.168.1.31    node-0001
192.168.1.32    node-0002
192.168.1.33    node-0003
192.168.1.34    node-0004
192.168.1.35    node-0005
```

**步骤二：将node加入K8s集群**

1）启动服务器（在node-0001主机操作）

```shell
[root@node-0001 ~]# systemctl enable --now docker kubelet
```

2）查看日志查找下面这一行安装指令的样例（在master主机操作）

```shell
kubeadm join 192.168.1.21:6443 --token <token> \
--discovery-token-ca-cert-hash   sha256: <token ca hash>
```

3）如何获取Token Hash值（在master主机操作）

```shell
[root@master ~]# openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt |  \
openssl rsa -pubin -outform der |openssl dgst -sha256 -hex
writing RSA key
(stdin)= f46dd7ee29faa3c096cad189b0f9aedf59421d8a881f7623a543065fa6b0088c
```

4）如何获取Token（在master主机操作）

```shell
[root@master ~]# kubeadm token list                # 列出 token
[root@master ~]# kubeadm token delete <token>        # 删除 token
[root@master ~]# kubeadm token create                # 创建 token
[root@master ~]# kubeadm token create --ttl=0 --print-join-command 
... ...
kubeadm join 192.168.1.21:6443 --token fm6kui.mp8rr3akn74a3nyn    
 --discovery-token-ca-cert-hash 
sha256:f46dd7ee29faa3c096cad189b0f9aedf59421d8a881f7623a543065fa6b0088c 
```

5）安装node节点（在node-0001主机操作）

使用刚刚生成的token指令完成node节点安装，下面的Toen和Hash值不能照抄。

```shell
[root@node-0001 ~]# kubeadm join 192.168.1.21:6443 --token \
fm6kui.mp8rr3akn74a3nyn --discovery-token-ca-cert-hash sha256:f46dd7ee29faa3c096cad189b0f9aedf59421d8a881f7623a543065fa6b0088c
```



# 5. 配置flannel网络，完成集群

## 5.1 问题

本案例要求配置flannel网络，完成集群，具体要求如下：

1. 导入镜像到私有仓库
2. 修改配置文件
3. 启动网络组件

## 5.2 步骤

实现此案例需要按照如下步骤进行。

注意：本案例需要的软件都已经共享在云盘，在第四阶段kubernetes/v1.17.6/ flannel目录下。各位同学需要提前将该目录下的素材下载到master主机。

**步骤一：导入并将镜像上传至192.168.1.100私有镜像服务器（在master主机操作）**

安装软件并启动服务

```shell
[root@master ~]# docker load -i flannel.tar.gz
# 加载镜像
[root@master ~]# docker tag \
quay.io/coreos/flannel:v0.12.0-amd64 192.168.1.100:5000/flannel:v0.12.0-amd64
# 修改标签
[root@master ~]# docker push 192.168.1.100:5000/flannel:v0.12.0-amd64
# 上传镜像到192.168.1.100服务器
```

**步骤二：配置flannel网络（master主机操作）**

1）修改资源配置文件

资源配置文件已经共享在云盘第四阶段kubernetes/v1.17.6/ flannel目录下。

```shell
[root@master ~]# vim flannel/kube-flannel.yaml
128: "Network": "10.244.0.0/16",        
# 该地址必须与案例3初始化文件 kubeadm-init.yaml 中的 podSubnet 一致
172: image: 192.168.1.100:5000/flannel:v0.12.0-amd64
186: image: 192.168.1.100:5000/flannel:v0.12.0-amd64
227行到结尾的所有内容全部删除
```

2）创建资源

```shell
[root@master ~]# kubectl apply -f kube-flannel.yml 
podsecuritypolicy.policy/psp.flannel.unprivileged created
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds-amd64 created
```

3）验证效果

```shell
[root@master ~]# ifconfig
flannel.1: flags=4163 ... ...
... ...
[root@master ~]# kubectl get nodes
NAME              STATUS    ROLES    AGE    VERSION
master            Ready    master    26h    v1.17.6
node-0001    Ready    <none>    152m    v1.17.6
```



# 6. 配置所有node节点完成集群部署

## 6.1 问题

本案例要求参考案例4将其他所有node节点加入K8s集群，具体要求如下：

1. 将node-0002加入K8S集群
2. 将node-0003加入K8S集群

## 6.2 步骤

实现此案例需要按照如下步骤进行。

具体操作步骤参考【4】，我们可以直接使用提前准备好的ansible剧本自动化完成添加node节点的任务，也可以尝试自己手动操作。

> 如有侵权，请联系作者删除



﻿@[TOC]( Nginx installation & user authentication & Nginx web hosting & HTTPS encrypted web sites | Cloud computing )

---

# 1 案例1：搭建Nginx服务器

## 1.1 问题

在IP地址为192.168.4.5的主机上安装部署Nginx服务，并可以将Nginx服务器，要求编译时启用如下功能：

- 支持SSL加密功能
- 设置Nginx账户及组名称均为nginx
- Nginx服务器升级到更高版本。

然后客户端访问页面验证Nginx Web服务器：

- 使用火狐浏览器访问
- 使用curl访问

## 1.2 方案

提前准备运维课程所需的所有虚拟机，为后续所有实验做准备，克隆4台CentOS虚拟机，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。不需要配置网关与DNS。

表－1 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/50a65e9883b44f49805b151a7ff2fc8e.png)


第一天课程需要使用2台CentOS虚拟机，其中一台作为Nginx服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba66688d827a4c05a9a0c2f1e67930c2.png)
图-1

安装nginx-1.12.2版本时，需要使用如下参数：

- --with-http_ssl_module：提供SSL加密功能
- --user：指定账户
- --group：指定组

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：构建Nginx服务器**

1）使用源码包安装nginx软件包

```shell
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        #安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
--prefix=/usr/local/nginx   \                #指定安装路径
--user=nginx   \                            #指定用户
--group=nginx  \                            #指定组
--with-http_ssl_module                    #开启SSL加密功能
[root@proxy nginx-1.12.2]# make && make install     #编译并安装
```

2）nginx命令的用法

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    #启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            #关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        #重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                #查看软件信息
```

netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：

> -a显示所有端口的信息
> -n以数字格式显示端口号
> -t显示TCP连接的端口
> -u显示UDP连接的端口
> -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
> -p显示监听端口的服务名称是什么（也就是程序名称）

nginx服务默认通过TCP 80端口监听客户端请求：

```shell
root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
```

3）测试首页文件

Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：

```shell
[root@client ~]# curl http://192.168.4.5
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor="white" text="black">
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
```

**步骤二：客户端访问测试**

1）分别使用浏览器和命令行工具curl测试服务器页面

如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。

```shell
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5
```

# 2. 用户认证

## 2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：

1. 访问Web页面需要进行用户认证
2. 用户名为：tom，密码为：123456

## 2.2 方案

通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。效果如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b92c4b140a954245a108f6cefc2c46c8.png)
图-2

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改Nginx配置文件**

1）修改/usr/local/nginx/conf/nginx.conf

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
        auth_basic "Input Password:";                        //认证提示符信息
        auth_basic_user_file  "/usr/local/nginx/pass";        //认证的密码文件
        location / {
            root   html;
            index  index.html index.htm;
        }
  }
```

2）生成密码文件，创建用户及密码

使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。

```shell
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass
```

3）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

**步骤二：客户端测试**

1）登录192.168.4.10客户端主机进行测试

如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。

或者直接使用真实主机的火狐也可以。

```shell
[root@client ~]# firefox http://192.168.4.5                    //输入密码后可以访问
```

# 3. 基于域名的虚拟主机

## 3.1 问题

沿用练习二，配置基于域名的虚拟主机，实现以下目标：

1. 实现两个基于域名的虚拟主机，域名分别为www.a.com和www.b.com
2. 对域名为www.a.com的站点进行用户认证，用户名称为tom，密码为123456

## 3.2 方案

修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。

虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改配置文件**

1）修改Nginx服务配置，添加相关虚拟主机配置如下

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;                                      //端口
        server_name  www.a.com;                                //域名
auth_basic "Input Password:";                        //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                                    //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                        //端口
        server_name  www.b.com;                                //域名
location / { 
root   www;                                 //指定网站根路径
index  index.html index.htm;
}
}
```

2）创建网站根目录及对应首页文件

```shell
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html
```

3）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

**步骤二：客户端测试**

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析

```shell
 [root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com
```

2）登录192.168.4.10客户端主机进行测试

注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。

```shell
[root@client ~]# firefox http://www.a.com            //输入密码后可以访问
[root@client ~]# firefox http://www.b.com            //直接访问
```

提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。

**步骤三：扩展课外实验：其他类型的虚拟主机**

1. 基于端口的虚拟主机（参考模板）

```shell
server {
        listen       8080;                        //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;                         //端口
        server_name  web1.example.com;           //域名
      .......
}
```

2. 基于IP的虚拟主机（参考模板）

```shell
server {
        listen       192.168.0.1:80;              //IP地址与端口
        server_name  web1.example.com;          //域名
  ... ...
}
    server {
        listen       192.168.0.2:80;             //IP地址与端口
        server_name  web1.example.com;
... ...
}
```

# 4. SSL虚拟主机

## 4.1 问题

沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：

1. 域名为www.c.com
2. 该站点通过https访问
3. 通过私钥、证书对该站点所有数据加密

## 4.2 方案

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。

加密算法一般分为对称算法、非对称算法、信息摘要。

对称算法有：AES、DES，主要应用在单机数据加密。

非对称算法有：RSA、DSA，主要应用在网络数据加密。

信息摘要：MD5、sha256，主要应用在数据完整性校验。


## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置SSL虚拟主机**

1）生成私钥与证书

```shell
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书
```

2）修改Nginx配置文件，设置加密网站的虚拟主机

```shell
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
… …    
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
```

3）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

**步骤二：客户端验证**

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析

```shell
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com
```

2）登录192.168.4.10客户端主机进行测试

```shell
[root@client ~]# firefox https://www.c.com            //信任证书后可以访问
```

# Exercise

## 1 简述常见Web服务器软件有哪些

Apache、 Nginx、 Lighttpd 、Tomcat、 IBM WebSphere、IIS。

## 2 使用Nginx部署基于域名的虚拟主机如何修改配置文件

```shell
[root@nginx ~]# vim /usr/local/nginx/nginx.conf
.. ..
server {
        listen       80;                          //端口
        server_name  web1.plj.com;               //域名
        location / {
              root   /web1;                        //网页根路径
              index  index.html;                 //定义首页文档
          }
}
    server {
        listen       80;
        server_name  web2.plj.com;
        location / {
              root   /web2;
              index  index.html; 
          }
}
.. ..
```

## 3 对网站进行SSL加密，如何生成私钥与证书

```shell
[root@nginx ~]# openssl genrsa -out cert.key 2048                    //生成私钥
[root@nginx ~]# openssl req -new -x509 -key test.pem -out cert.pem    //生成证书
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Nginx proxy server & Nginx optimization | Cloud computing )

---

# 1. Nginx反向代理

## 1.1 问题

使用Nginx实现Web反向代理功能，实现如下功能：

- 后端Web服务器两台，可以使用httpd实现
- Nginx采用轮询的方式调用后端Web服务器
- 两台Web服务器的权重要求设置为不同的值
- 最大失败次数为1，失败超时时间为30秒

## 1.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台Web服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f49ff7cf346d43259ba6677fc7258330.png)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署实施后端Web服务器**

1）部署后端Web1服务器

后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。

```shell
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
```

2）部署后端Web2服务器

```shell
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
```

**步骤二：配置Nginx服务器，添加服务器池，实现反向代理功能**

1）修改/usr/local/nginx/conf/nginx.conf配置文件

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
#使用upstream定义后端服务器集群，集群名称任意(如webserver)
#使用server定义集群中的具体服务器和端口
upstream webserver {
                server 192.168.2.100:80;
                server 192.168.2.200:80;
        }
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
#通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;
        }
}
```

2）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端使用浏览器访问代理服务器测试轮询效果

```shell
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
```

**步骤二：配置upstream服务器集群池属性**

1）设置失败次数，超时时间，权重

weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }
#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数，测试服务器几次才确认服务器失败
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}
```

2）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）关闭一台后端服务器（如web1）

```shell
[root@web1 ~]# systemctl stop httpd
```

4）客户端使用浏览器访问代理服务器测试轮询效果

```shell
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
```

5）再次启动后端服务器的httpd（如web1）

```shell
[root@web1 ~]# systemctl start httpd
```

6）客户端再次使用浏览器访问代理服务器测试轮询效果

```shell
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
```

**步骤三：配置upstream服务器集群的调度算法**

1）设置相同客户端访问相同Web服务器

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                 ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}
```

2）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端使用浏览器访问代理服务器测试轮询效果

```shell
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
```

# 2. Nginx的TCP/UDP调度器

## 2.1 问题

使用Nginx实现TCP/UDP调度器功能，实现如下功能：

- 后端SSH服务器两台
- Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
- Nginx采用轮询的方式调用后端SSH服务器

## 2.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8ec188d43c1b40c18dbe7ab1fbd44d65.png)
图-2

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署支持4层TCP/UDP代理的Nginx服务器**

1）部署nginx服务器

编译安装必须要使用--with-stream参数开启4层代理模块。

```shell
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module        \                        //开启SSL加密功能
> --with-stream                                       //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install           //编译并安装
```

**步骤二：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能**

1）修改/usr/local/nginx/conf/nginx.conf配置文件

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
               server 192.168.2.200:22;
}
            server {
                listen 12345;                    //Nginx监听的端口
                 proxy_pass backend;
             }
}
http {
.. ..
}
```

2）重新加载配置

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）客户端使用访问代理服务器测试轮询效果

```shell
[root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果
```

# 3. Nginx常见问题处理

## 3.1 问题

本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：

- 如何自定义返回给客户端的404错误页面
- 如何查看服务器状态信息
- 如果客户端访问服务器提示“Too many open files”如何解决
- 如何解决客户端访问头部信息过长的问题
- 如何让客户端浏览器缓存数据

客户机访问此Web服务器验证效果：

- 使用ab压力测试软件测试并发量
- 编写测试脚本生成长头部信息的访问请求
- 客户端访问不存在的页面，测试404错误页面是否重定向

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：自定义报错页面**

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到

```shell
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
```

2）修改Nginx配置文件，自定义报错页面

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
        charset utf-8;                    //仅在需要中文时修改该选项
error_page   404  /404.html;    //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
Oops,No NO no page …
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面

```shell
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
```

4）常见http状态码

常见http状态码可用参考表-1所示。

表－1 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/e69844b7f5de49b782baf522233d57dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


**步骤二：如何查看服务器状态信息（非常重要的功能）**

1）编译安装时使用--with-http_stub_status_module开启状态页面模块

```shell
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                        //开启SSL加密功能
> --with-stream                                //开启TCP/UDP代理模块
> --with-http_stub_status_module                //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装
```

2）启用Nginx服务并查看监听端口状态

ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx
```

3）修改Nginx配置文件，定义状态页面

```shell
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
                 #allow IP地址;
                 #deny IP地址;
        }
… …
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

4）优化后，查看状态页面信息

```shell
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0
```

Active connections：当前活动的连接数量。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。

**步骤三：优化Nginx并发量**

1）优化前使用ab高并发测试

```shell
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)                //提示打开文件数量过多
```

2）修改Nginx配置文件，增加并发量

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
worker_processes  2;                    //与CPU核心数量一致
events {
worker_connections 65535;        //每个worker最大并发连接数
}
.. ..
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

3）优化Linux内核参数（最大文件数量）

```shell
[root@proxy ~]# ulimit -a                        //查看所有属性值
[root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
[root@proxy ~]# vim /etc/security/limits.conf
    .. ..
*               soft    nofile            100000
*               hard    nofile            100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值
```

4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）

```shell
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
```

**步骤四：优化Nginx数据包头缓存**

1）优化前，使用脚本测试长头部请求是否能获得响应

```shell
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大
```

2）修改Nginx配置文件，增加数据包头部缓存大小

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        //默认请求包头信息的缓存    
large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
.. ..
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
```

3）优化后，使用脚本测试长头部请求是否能获得响应

```shell
[root@proxy ~]# cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh
```

**步骤五：浏览器本地缓存静态数据**

1）使用Firefox浏览器查看缓存

以Firefox浏览器为例，在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息，如图-3所示，点击List Cache Entries可以查看详细信息。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f760db2b68344d3c98caee51a17fe4fa.png)
图-3

2）清空firefox本地缓存数据，如图-4所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2ae9f7a503754f95a66a7b5c4c3d0964.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-4

3）修改Nginx配置文件，定义对静态页面的缓存时间

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}
}
[root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息

```shell
[root@client ~]# firefox http://192.168.4.5/day.jpg
```

在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。


# Exercise

## 1 Nginx反向代理如何设置后端服务器组的状态

> Nginx可以设置后台服务器组主机的状态，在括号内填写下列不同状态的作用
>
> - down （ ）
> - max_fails （ ）
> - fail_timeout （ ）
> - backup （ ）

- down：表示当前server暂时不参与负载
- max_fails：允许请求失败的次数（默认为1）
- fail_timeout ：max_fails次失败后，暂停提供服务的时间
- backup：备份服务器

## 2 Nginx实现TCP/UDP调度需要什么模块


需要ngx_stream_core_module模块，使用--with-stream可以开启该模块。

## 3 如何优化提升Nginx并发数量

```shell
[root@nginx ~]# vim /usr/local/nginx/nginx.conf
.. ..
events {
worker_connections 65535;                //每个worker最大并发连接数
use epoll;
}
[root@nginx ~]# vim /etc/security/limits.conf
.. ..
*             soft    nofile  100000
*             hard    nofile  100000
```

## 4 如何使用ab对Web服务器进行压力测试

> 要求：并发数为1024，总请求数为2048，测试页面为http://www.tarena.com/

```shell
[root@localhost ~]# ab -c 2048 –n 1024 http://www.tarena.com/
```

## 5 使用Nginx如何自定义404错误页面

```shell
[root@nginx ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
fastcgi_intercept_errors on;         //错误页面重定向
server {
error_page   404  /40x.html;        //自定义404错误页面
        location = /40x.html {
            root   html;
        }
error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
}
}
```

> 如有侵权，请联系作者删除



﻿@[TOC]( NoSQL overview & Deploy Redis service & deploy LNMP+Redis | Cloud computing )

---

# 1. 搭建Redis服务器

## 1.1 问题

具体要求如下：

- 在主机 192.168.4.51 上安装并启用 redis 服务
- 设置变量school，值为tarena
- 查看变量school的值

## 1.2 步骤

实现此案例需要按照如下步骤进行。
**步骤一：搭建redis服务器**

1）安装源码redis软件

```shell
 [root@redis1 redis]# yum -y install gcc 
[root@redis1 redis]# tar -zxf redis-4.0.8.tar.gz
[root@redis1 redis]# cd redis-4.0.8/
[root@redis1 redis-4.0.8]# ls
00-RELEASENOTES  CONTRIBUTING  deps     Makefile   README.md   runtest          runtest-sentinel  src    utils
BUGS             COPYING       INSTALL  MANIFESTO  redis.conf  runtest-cluster  sentinel.conf     tests
[root@redis1 redis-4.0.8]# make
[root@redis1 redis-4.0.8]# make install
[root@redis1 redis-4.0.8]# cd utils/
[root@redis1 utils]# ./install_server.sh
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] 
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] 
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] 
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] 
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] 
Selected config:
Port           : 6379                   //端口号
Config file    : /etc/redis/6379.conf         //配置文件目录
Log file       : /var/log/redis_6379.log      //日志目录
Data dir       : /var/lib/redis/6379          //数据库目录
Executable     : /usr/local/bin/redis-server  //启动程序的目录
Cli Executable : /usr/local/bin/redis-cli     //命令行的连接工具
Is this ok? Then press ENTER to go on or Ctrl-C to abort.  //回车完成配置
Copied /tmp/6379.conf => /etc/init.d/redis_6379    //服务启动脚本
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...  //提示服务已经启动
Installation successful!        //提示安装成功
```

2）查看服务状态

```shell
[root@redis1 utils]#  /etc/init.d/redis_6379 status
Redis is running (15203)
```

3）查看监听的端口

```shell
[root@redis1 utils]# netstat -antupl |grep :6379 //查看端口
tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      15203/redis-server
[root@redis1 utils]# ps  -C redis-server  //查看进程
  PID TTY          TIME CMD
15203 ?        00:00:00 redis-server
```

4）停止服务

```shell
[root@redis1 utils]# /etc/init.d/redis_6379 stop
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
```

5）连接redis

```shell
[root@redis1 utils]# /etc/init.d/redis_6379 start 
Starting Redis server...
[root@redis1 utils]# redis-cli  //默认连接127.0.0.1地址的 6379端口
127.0.0.1:6379> ping
PONG            //PONG说明服务正常
6）存储变量school，值为tarena，查看变量school的值
```

常用指令操作：
set keyname keyvalue //存储
get keyname //获取

```shell
127.0.0.1:6379> set school tarena
OK
127.0.0.1:6379> get school
"tarena"
127.0.0.1:6379>
```

# 2. 常用命令

## 2.1 问题

- 练习如下命令的使用：
- set mset get mget keys type
- exists ttl expire move 、select
- del flushdb flushall save shutdown

## 2.2 步骤

实现此案例需要按照如下步骤进行。
**步骤一：命令set 、 mset 、 get 、 mget**

具体操作如下

```shell
192.168.4.50:6350> set name bob
OK
192.168.4.50:6350> 
192.168.4.50:6350> mset age 19   sex  boy
OK
192.168.4.50:6350> 
192.168.4.50:6350> get name
"bob"
192.168.4.50:6350> 
192.168.4.50:6350> mget age sex
1) "19"
2) "boy"
192.168.4.50:6350> 
192.168.4.50:6350>
```

**步骤二：命令keys 、 type 、 exists 、 del**

具体操作如下

```shell
192.168.4.50:6350> keys *
1) "sex"
2) "age"
3) "name"
192.168.4.50:6350> 
192.168.4.50:6350> keys  ???
1) "sex"
2) "age"
192.168.4.50:6350> keys a*
1) "age"
192.168.4.50:6350> 
192.168.4.50:6350> type age //使用set命令存储的变量都是字符类型
string
192.168.4.50:6350> 
192.168.4.50:6350> del age
(integer) 1
192.168.4.50:6350>
192.168.4.50:6350> exists age //变量不存储返回值0
(integer) 0
192.168.4.50:6350> 
192.168.4.50:6350> exists sex  //变量存在 返回值1
(integer) 1
192.168.4.50:6350>
```

**步骤三：命令ttl 、 expire 、 move 、 flushdb 、flushall 、save、shutdown、select**

具体操作如下

```shell
192.168.4.50:6350> keys *
1) "sex"
2) "name"
192.168.4.50:6350> ttl sex  //返回值-1 表示变量永不过期
(integer) -1
192.168.4.50:6350>
192.168.4.50:6350> expire sex 20 //设置变量过期时间为 20 秒
(integer) 1
192.168.4.50:6350> 
192.168.4.50:6350> ttl sex  //还剩14秒过期
(integer) 14
192.168.4.50:6350> 
192.168.4.50:6350> ttl sex //返回值-2 表示已经过期
(integer) -2
192.168.4.50:6350> exists sex //变量已经不存在
(integer) 0
192.168.4.50:6350>
192.168.4.50:6350> move name 1 //把变量name移动到1号库里
(integer) 1
192.168.4.50:6350> 
192.168.4.50:6350> select 1  //切换到1号库
OK
192.168.4.50:6350[1]> keys * //查看
1) "name"
192.168.4.50:6350[1]> select 0 //切换到0号库
OK
192.168.4.50:6350> keys * //查看
(empty list or set)
192.168.4.50:6350>
192.168.4.50:6350> select 1 //切换到1号库
OK
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> keys *
1) "name"
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> flushdb
OK
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> keys *
(empty list or set)
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> flushall
OK
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> save
OK
192.168.4.50:6350[1]> 
192.168.4.50:6350[1]> shutdown
not connected> //提示连接断开
not connected> exit  //退出登录
[root@host50 ~]# 
[root@host50 ~]# netstat -utnlp  | grep  redis-server //没有进程信息
[root@host50 ~]# 
[root@host50 ~]# /etc/init.d/redis_6379  start //启动服务
Starting Redis server...
[root@host50 ~]# 
[root@host50 ~]# netstat -utnlp  | grep  redis-server //查看进程信息
tcp        0      0 192.168.4.50:6350       0.0.0.0:*               LISTEN      11475/redis-server  
[root@host50 ~]#
```

# 3. 修改Redis服务运行参数

## 3.1 问题

- 对Redis服务器192.168.4.50做如下配置：
- 端口号 6350
- IP地址 192.168.4.50
- 连接密码 123456
- 测试配置

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改主配置文件**

1）修改配置文件

```shell
[root@host50 utils]# cp /etc/redis/6379.conf  /root/6379.conf     
//可以先备份一份，防止修改错误没法还原
[root@host50 utils]# /etc/init.d/redis_6379 stop
[root@host50 utils]# vim /etc/redis/6379.conf
...
bind  192.168.4.50                //设置服务使用的ip
port 6350                            //更改端口号
requirepass 123456                //设置密码
：wq
```

2）修改启动脚本

```shell
[root@host50 ~]# vim  +43  /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.50 -p 6350 -a 123456  shutdown
:wq
```

3）启动服务

```shell
[root@host50 ~]# /etc/init.d/redis_6379  start
Starting Redis server...
[root@host50 ~]# 
[root@host50 ~]# netstat -utnlp  | grep redis-server
tcp        0      0 192.168.4.50:6350       0.0.0.0:*               LISTEN      11523/redis-server  
[root@host50 ~]#
```

4）测试配置

访问服务存取数据

```shell
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 //访问服务
192.168.4.50:6350> ping
PONG
192.168.4.50:6350> keys *
(empty list or set)
192.168.4.50:6350> 
192.168.4.50:6350> set x 99
OK
192.168.4.50:6350>
192.168.4.50:6350> exit
[root@host50 ~]#
```

# 4. 部署LNMP+Redis

## 4.1 问题

- 具体要求如下：
- 在主机192.168.4.57部署LNMP 环境
- 配置PHP支持redis
- 编写网站脚本，把数据存储到redis服务器192.168.4.50

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在主机192.168.4.57部署LNMP 环境**

1）安装源码nginx软件及php-fpm

```shell
]#yum  -y  install  gcc    pcre-devel   zlib-devel  //安装依赖
]#tar  -zxvf  nginx-1.12.2.tar.gz  //解压
]#cd nginx-1.12.2  //进源码目录
]#./configure  //配置
……
……
Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + using system zlib library
  nginx path prefix: "/usr/local/nginx"
  nginx binary file: "/usr/local/nginx/sbin/nginx"
  nginx modules path: "/usr/local/nginx/modules"
  nginx configuration prefix: "/usr/local/nginx/conf"
  nginx configuration file: "/usr/local/nginx/conf/nginx.conf"
  nginx pid file: "/usr/local/nginx/logs/nginx.pid"
  nginx error log file: "/usr/local/nginx/logs/error.log"
  nginx http access log file: "/usr/local/nginx/logs/access.log"
  nginx http client request body temporary files: "client_body_temp"
  nginx http proxy temporary files: "proxy_temp"
  nginx http fastcgi temporary files: "fastcgi_temp"
  nginx http uwsgi temporary files: "uwsgi_temp"
  nginx http scgi temporary files: "scgi_temp"
[root@localhost nginx-1.12.2]# make //编译
……
……
objs/src/http/modules/ngx_http_upstream_zone_module.o \
objs/ngx_modules.o \
-ldl -lpthread -lcrypt -lpcre -lz \
-Wl,-E
sed -e "s|%%PREFIX%%|/usr/local/nginx|" \
        -e "s|%%PID_PATH%%|/usr/local/nginx/logs/nginx.pid|" \
        -e "s|%%CONF_PATH%%|/usr/local/nginx/conf/nginx.conf|" \
        -e "s|%%ERROR_LOG_PATH%%|/usr/local/nginx/logs/error.log|" \
        < man/nginx.8 > objs/nginx.8
make[1]: 离开目录“/root/lnmp/nginx-1.12.2”
[root@localhost nginx-1.12.2]#make  install //安装
……
……
test -d '/usr/local/nginx/logs' \
        || mkdir -p '/usr/local/nginx/logs'
test -d '/usr/local/nginx/html' \
        || cp -R html '/usr/local/nginx'
test -d '/usr/local/nginx/logs' \
        || mkdir -p '/usr/local/nginx/logs'
make[1]: 离开目录“/root/lnmp/nginx-1.12.2”
 [root@localhost nginx-1.12.2]# ls /usr/local  //查看安装目录
bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src
[root@localhost nginx-1.12.2]#
 [root@localhost nginx-1.12.2]# ls /usr/local/nginx  //查看目录列表
conf  html  logs  sbin
[root@localhost nginx-1.12.2]#
]#yum   -y     install  php-fpm  //安装php-fpm
……
……
已安装:
  php-fpm.x86_64 0:5.4.16-45.el7
作为依赖被安装:
  libzip.x86_64 0:0.10.1-8.el7              php-common.x86_64 0:5.4.16-45.el7
完毕！
```

2）修改配置nginx.conf

```shell
] # vim   +65  /usr/local/nginx/conf/nginx.conf
      location ~ \.php$ {
              root           html;
              fastcgi_pass   127.0.0.1:9000;
              fastcgi_index  index.php;
              include        fastcgi.conf;
       }
:wq
]#  /usr/local/nginx/sbin/nginx  -t     //测试修改
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
```

3）启动服务

启动php-fpm服务

```shell
]#  systemctl  start php-fpm  //启动服务
]#  netstat  -utnlp  | grep  :9000  //查看端口
```

启动nginx服务

```shell
]# /usr/local/nginx/sbin/nginx
]# netstat  -utnlp  | grep  :80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      23505/nginx: master
```

4）测试配置

```shell
]# vim  /usr/local/nginx/html/test.php  //编写php文件
<?php
        echo  "hello world!!!";
?>
:wq
]# curl  http://localhost/test.php     //访问nginx服务
                hello world!!!
```

**步骤二：配置PHP支持redis**

1）安装php扩展

```shell
 [root@host71 ~]# rpm -q php php-devel
未安装软件包 php
未安装软件包 php-devel
[root@host71 ~]#
[root@host71 ~]# rpm -q automake autoconf
未安装软件包 automack
未安装软件包 autoconf
[root@host71 ~]#
[root@host71 ~]# yum -y  install php php-devel automake autoconf //安装依赖
]# tar -zxf php-redis-2.2.4.tar.gz //安装扩展包
]# cd phpredis-2.2.4/
]# phpize            //生成配置文件php-config及 configure命令
Configuring for:
PHP Api Version:         20100412
Zend Module Api No:      20100525
Zend Extension Api No:   220100525
]# ./configure  --with-php-config=/usr/bin/php-config //配置
]# make //编译
]# make install //安装
```

2）修改php.ini文件

```shell
]#vim /etc/php.ini
728 extension_dir = "/usr/lib64/php/modules/"  //模块文件目录
730 extension = "redis.so"  //模块文件名
:wq
]# systemctl  restart php-fpm //重启php-fpm服务
]# php -m | grep  -i redis     //查看已加载的模块
redis
```

**步骤三：测试配置：编写网站脚本，把数据存储到redis服务器192.168.4.50**

1）查看192.168.4.50主机的redis服务是否运行

```shell
 [root@host50 ~]# netstat -utnlp  | grep redis-server
tcp        0      0 192.168.4.50:6350       0.0.0.0:*               LISTEN      11523/redis-server  
[root@host50 ~]#
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 //访问服务
192.168.4.50:6350> ping
PONG
192.168.4.50:6350> exit 
```

2）编写网站脚本

```shell
]# vim  /usr/local/nginx/html/linkredis.php
<?php
$redis = new redis();
$redis->connect("192.168.4.50","6350");
$redis->auth("123456");
$redis->set("linux","redhat");
echo $redis->get("linux");
?>
:wq 
```

3）访问网站脚本

```shell
]#curl  http://localhost/linkredis.php      //访问nginx服务
   redhat
```

4）在192.168.4.50 服务器，查看数据

```shell
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 //连接redis服务
192.168.4.50:6350> keys *   //查看变量
1) "linux"
192.168.4.50:6350> 
192.168.4.50:6350> get linux //获取值
"redhat"
192.168.4.50:6350> 
```

# Exercise

## 1 什么是RDBMS

RDBMS即关系数据库管理系统（Relational Database Management System），按照预先设置的组织结构，将数据存储在物理介质上，数据之间可以做关联操作

## 2 主流的RDBMS软件有哪些

主流的RDBMS软件有：
Oracle
DB2
MS SQL Server
MySQL、MariaDB

## 3 什么是NOSQL以及软件有哪些

什么是NOSQL？
NoSQL（NoSQL = Not Only SQL），意思是“不仅仅是SQL”，泛指非关系型数据库，不需要预先定义数据存储结构，表的每条记录都可以有不同的类型和结构

NOSQL服务软件：
1）MongoDB
2）Memcached
3）CouchDB
4）Neo4j
5）FlockDB

## 4 redis介绍


> 如有侵权，请联系作者删除



﻿@[TOC]( OOP basics & OOP advanced & RE modules | Cloud computing )

---

# 1. 编写游戏人物

## 1.1 问题

创建程序，要求如下：

1. 创建游戏角色类
2. 游戏人物角色拥有名字、武器等属性
3. 游戏人物具有攻击和行走的方法
4. 武器通过武器类实现

## 1.2 方案

由于游戏角色和武器都由类实现，而这个两个类又完全不同，所以可以通过组合来实现。将武器类的一个实例作为游戏人物的一个属性。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day07]# vim game_role.py
class Weapon:
    def __init__(self, wname, strength):
        self.wname = wname
        self.strength = strength
class Warrior:
    def __init__(self, name, weapon):
        self.name = name
        self.weapon = weapon
    def speak(self, words):
        print("I'm %s, %s" % (self.name, words))
    def show_me(self):
        print("我是%s, 我是一个战士。我用的武器是%s" % (self.name, self.weapon.wname))
if __name__ == '__main__':
    blade = Weapon('青龙偃月刀', 100)
    print(blade.wname, blade.strength)
    gy = Warrior('关羽', blade)
    gy.show_me()
    cz = Weapon('禅杖', 100)
    lzs = Warrior('鲁智深', cz)
    lzs.show_me()
```

**步骤二：测试脚本执行**

```shell
[root@localhost day07]# python3  game_role.py
青龙偃月刀 100
我是关羽, 我是一个战士。我用的武器是青龙偃月刀
我是鲁智深, 我是一个战士。我用的武器是禅杖
```

# 2. 出版商程序

## 2.1 问题

创建books.py文件，实现以下目标：

1. 为出版商编写一个Book类
2. Book类有书名、作者、页数等属性
3. 打印实例时，输出书名
4. 调用实例时，显示该书由哪个作者编写

## 2.2 方案

创建一个类，类中创建3种魔法方法：

1. __init__方法：__init__方法用于初始化实例属性，创建对象后会自动调用__init__方法，属于构造器方法，此处初始化了书名及作者两个属性

2. __str__方法：创建对象后，打印实例对象pybook，返回书名，打印出书名

3. __call__方法：创建对象后，可以像调用函数一样调用该方法，模拟函数的行为，打印出书名及作者

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day07] # vim books.py
#!/usr/bin/env python3
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author
    def __str__(self):
        return '<Book: %s>' % self.title
    def __call__(self):
        print('《%s》 is written by %s.' % (self.title, self.author))
if __name__ == '__main__':
    pybook = Book('Core Python', 'Weysley')
    print(pybook)  # 调用__str__
    pybook()   # 调用__call__
```

**步骤二：测试脚本执行**

```shell
[root@localhost day07]# python3 books.py 
<Book: Core Python>
《Core Python》 is written by Weysley.
```

# 3. 分析apache访问日志

## 3.1 问题

编写count_patt.py脚本，实现一个apche日志分析脚本：

1. 统计每个客户端访问apache服务器的次数
2. 将统计信息通过字典的方式显示出来
3. 分别统计客户端是Firefox和MSIE的访问次数
4. 分别使用函数式编程和面向对象编程的方式实现

## 3.2 方案

collections是python内建的一个集合模块，模块中提供了许多有用的集合类,其中counter类 是一个简单的计数器，以字典的键值对形式储存，其中搜索的元素作为键，出现的次数作为值

实现过程：

1. 实例化一个计数器

2. 实例化正则表达式

3. 将文件以对象形式打开

4. 通过正则表达式查找文件每一行

5. 如果找到结果

6. 将结果添加到计数器，通过update方法更新原有数据

7. 返回计数器

8. 将文件地址和正则表达式作为实参传递给函数

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day08]# vim count_patt.py
#!/usr/bin/env python3
import re
import collections
#fname 文件地址  patt 正则表达式
def count_patt(fname,patt):
    
    counter = collections.Counter()
   
    cpatt = re.compile(patt)
        with open(fname) as fobj:
        for line in fobj:
           
            m = cpatt.search(line)
           
            if m:
              
                counter.update([m.group()])
  
    return counter
if __name__ == "__main__":
    fname = "access_log.txt"
    ip_patt = "^(\d+\.){3}\d+"
    a = count_patt(fname,ip_patt)
    print(a)
    br_patt = "Firefox|MSIE|Chrome"
    b = count_patt(fname,br_patt)
    print(b)
```

实现此案例还可通过面向对象方式实现：

实现过程：

1. 创建类CountPatt

2. 定义构造方法 创建正则对象

3. 定义类方法

4. 创建计数器对象

5. 打开文本文件

6. 通过正则表达式查找文件每一行

7. 如果找到结果

8. 将结果添加到计数器，通过update方法更新原有数据

9. 返回计数器

10. 将文件地址和正则表达式作为实参传递给函数

```shell
[root@localhost day08]# vim count_patt2.py
#!/usr/bin/env python3
import re
import collections
import re
import collections
class CountPatt:
    
    def __init__(self,patt):
        self.cpatt = re.compile(patt)
    
    def count_patt(self,fname):
        
        counter = collections.Counter()
       
        with open(fname) as fobj:
       
            for line in fobj:
       
                m = self.cpatt.search(line)
        
                if m:
        
                    counter.update([m.group()])
    
        return counter
if __name__ == "__main__":
    fname = "access_log.txt"
    ip_patt = "^(\d+\.){3}\d+"
    br_patt = "Firefox|MSIE|Chrome"
    ip = CountPatt(ip_patt)
    print(ip.count_patt(fname))
    br = CountPatt(br_patt)
    print(br.count_patt(fname))
```

步骤二：测试脚本执行

```shell
[root@localhost day08]# python3 count_patt.py 
Counter({‘172.40.0.54’：391，‘172.40.50.116’：244，‘201.1.1.254’：173，‘127.0.0.1’：121，‘201.1.2.254’：119})
Counter({‘Firefox’：870，‘MSIE’：391，‘Chrome’：24})
[root@localhost day08]# python3 count_patt2.py 
Counter({‘172.40.0.54’：391，‘172.40.50.116’：244，‘201.1.1.254’：173，‘127.0.0.1’：121，‘201.1.2.254’：119})
Counter({‘Firefox’：870，‘MSIE’：391，‘Chrome’：24})
```

# Exercise

## 1 在OOP编程时，常用的magic魔法方法有哪些？

- __init__：实例化类实例时默认会调用的方法
- __str__：打印/显示实例时调用方法
- __call__：用于创建可调用的实例

## 2 在OOP编程时，什么时候使用组合，什么时候使用派生？

- 当类之间有显著的不同，并且较小的类是较大的类所需要的组件时组合表现得很好
- 但当设计“相同的类但有一些不同的功能”时，使用派生

## 3 如何用正则表达式匹配全部是数字的字符串？

- '^\d+$'
- '^\[0-9]+$'

## 4 re.match和re.search的区别是什么？

- re.match只能从字符串的开头匹配
- re.search可以在字符串的任意位置匹配

## 5 通过什么方法可以将以下正则表达式匹配到的内容提取出来？

> ```shell
> m = re.search('f..', 'seafood')
> ```

```shell
m.group()
```

## 6 如何通过正则表达式匹配字符串中所有符合条件的子串。

- re.findall方法
- re.finditer方法

## 7 re.compile作用是什么？

- 对正则表达式模式进行编译，返回一个正则表达式对象
- 在大量匹配的情况下，可以提升效率


> 如有侵权，请联系作者删除



﻿@[TOC]( OSPF & transport layer & and ACL | Cloud computing )

---

# 1. 动态路由

## 1.1 问题

通过配置静态路由协议ospf实现全网互通，按照图-1拓扑图所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/7aec552222fb4851885e529fe4b4e314.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置交换机**

1）S3700交换机配置

```shell
[Huawei]vlan batch 2 3            //创建VLAN2、3
[Huawei]interface Ethernet0/0/2
[Huawei-Ethernet0/0/2]port default vlan 2
[Huawei]interface Ethernet0/0/3
[Huawei-Ethernet0/0/3]port default vlan 3
[Huawei]interface Ethernet0/0/4  （该接口连接了三层交换机S5700）
[Huawei-Ethernet0/0/4]port link-type trunk
[Huawei-Ethernet0/0/4]port trunk allow-pass vlan all
```

2）S5700交换机配置

```shell
[Huawei]vlan batch 2 3 4            //创建VLAN2、3、4
[Huawei]interface Vlanif 1
[Huawei-Vlanif4]ip address  192.168.1.254 24
[Huawei]interface Vlanif 2
[Huawei-Vlanif4]ip address  192.168.2.254 24
[Huawei]interface Vlanif 3
[Huawei-Vlanif4]ip address  192.168.3.254 24
[Huawei]interface Vlanif 4
[Huawei-Vlanif4]ip address  192.168.4.1 24
[Huawei]interface GigabitEthernet 0/0/1   （该接口连接了S3700交换机）
[Huawei-GigabitEthernet0/0/1] port link-type trunk
[Huawei-GigabitEthernet0/0/1] port trunk allow-pass vlan all
[Huawei]interface GigabitEthernet 0/0/2   （该接口连接了路由器）
[Huawei-GigabitEthernet0/0/2] port link-type access
[Huawei-GigabitEthernet0/0/2] port default vlan 4
[Huawei]ospf 1
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255
[Huawei]ip route-static 0.0.0.0 0.0.0.0 192.168.4.2
```

**步骤二：配置路由器**

AR2220路由器配置如下

```shell
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0] ip address  192.168.4.2 24
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/0] ip address  192.168.5.254 24
[Huawei]ospf 1
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255
```

# 2. 基本ACL的配置（1）

## 2.1 问题

按照图-2所示拓扑结构，禁止主机pc2与pc1通信，而允许所有其他流量

![在这里插入图片描述](https://img-blog.csdnimg.cn/03809e5a419d4b3e84703b21400812d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置IP**

为路由器g0/0/0接口配置ip 192.168.1.254，为路由器g0/0/1接口配置ip 192.168.2.254

```shell
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0] ip address  192.168.1.254 24
[Huawei]acl 2000
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address  192.168.2.254 24
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000
```

# 3. 基本ACL的配置（2）

## 3.1 问题

按照图-3所示拓扑结构，允许主机pc2与pc1互通，而禁止其他设备访问pc1

![在这里插入图片描述](https://img-blog.csdnimg.cn/89ab9930578e497ab5c33cffa1d84077.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：放行192.168.2.1，拒绝其他设备**

此步骤需要在上一实验基础上进行

```shell
[Huawei]acl 2001
[Huawei-acl-basic-2001]rule permit source 192.168.2.1 0
[Huawei-acl-basic-2001]rule deny source any
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]undo traffic-filter inbound acl 2000
[Huawei-GigabitEthernet0/0/1] traffic-filter inbound acl 2001
```

# 4. 高级ACL

## 4.1 问题

按照图-4所示拓扑结构，禁止pc2访问pc1的ftp服务，禁止pc3访问pc1的www服务，所有主机的其他服务不受限制

![在这里插入图片描述](https://img-blog.csdnimg.cn/2a694fc65e464f9b850dcedbcd6ab365.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：根据协议所用端口进行封堵**

此步骤需要在上一实验基础上进行

```shell
[Huawei]acl 3000
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 
0 destination-port eq 21
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 
0 destination-port eq 80
[Huawei]interface g0/0/1
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 3000      //在接口中应用acl
```

# Exercise

## 1 传输层有哪些协议，各有什么特点？

TCP（Transmission Control Protocol）
传输控制协议
可靠的、面向连接的协议
传输效率低

UDP（User Datagram Protocol）
用户数据报协议
不可靠的、无连接的服务
传输效率高

## 2 描述TCP三次握手以及四次断开的过程

三次握手

/

四次断开

/

## 3 SMTP、DNS、Telnet、TFTP、NTP分别是什么协议，使用了什么端口？

SMTP 简单邮件传输协议 端口号25
DNS 域名系统 端口号53
Telnet 远程登录 端口号23
TFTP 简单文件传输协议 端口号69
NTP 网络时间协议 端口号123

## 4 ACL常见类型有哪些，各有什么区别？

基本ACL
基于源IP地址过滤数据包
基本访问控制列表的列表号是2000~2999

高级ACL
基于源IP地址、目的IP地址、指定协议、端口来过滤数据包
高级访问控制列表的列表号是3000~3999



> 如有侵权，请联系作者删除



﻿@[TOC]( Overview of container technology & images and containers & Docker configuration management | Cloud computing )

---

# 1 案例1：docker安装部署

## 1.1 问题

本案例要求为主机安装docker软件，具体要求如下：

1. 在跳板机192.168.1.252配置Docker的YUM服务器
2. 额外准备2台虚拟机，最低配置: 2CPU，2G内存，10G硬盘
3. docker-0001 主机 IP:192.168.1.31
4. docker-0002 主机 IP:192.168.1.32
5. 推荐CentOS7或RHEL7
6. 关闭防火墙和SELinux
7. 在两台机器上安装部署docker服务

## 1.2 方案

完成后续课程的学习需要提前准备实验用的虚拟机，实验虚拟机列表如表-1所示。

所有主机的主机名和IP必须与列表相同!!!

否则后续所有试验都无法顺利完成！！！

表-1

![img](https://img-blog.csdnimg.cn/img_convert/5ef21579f9575275f7f90b53e6e327ff.png)

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在跳板机（192.168.1.252）配置Docker的YUM服务器**

1）配置YUM服务器。

提示：相关软件已经提前共享到云盘，相关资料在kubernetes/目录下。

拷贝docker相关软件到跳板机，并创建私有YUM仓库服务器。

```shell
[root@localhost ~]# cp -a kubernetes/docker  /var/ftp/localrepo/
[root@localhost ~]# cd /var/ftp/localrepo
[root@localhost ~]# createrepo --update .
```

**步骤二：docker-0001和docker-0002安装Docker软件**

docker-0001和docker-0002做相同操作，下面以一台主机操作为例。

1）关闭防火墙和SELinux。

```shell
[root@docker-0001 ~]# vim /etc/selinux/config
... ...
SELINUX=disabled
[root@docker-0001 ~]# yum -y remove firewalld-*
... ...
[root@docker-0001 ~]# reboot
... ...
[root@docker-0001 ~]# sestatus 
SELinux status:                 disabled
```

2）配置YUM源

```shell
[root@docker-0001 ~]# vim  /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever – Localrepo
baseurl=ftp://192.168.1.252/localrepo
enabled=1
gpgcheck=0
[root@docker-0001 ~]# yum makecache                     #清空缓存
[root@docker-0001 ~]# yum list docker-ce*              #查看软件列表
Loaded plugins: fastestmirror
docker-ce.x86_64    3:18.06.3-3.el7    @local_software
```

3）安装docker软件并启动服务

```shell
[root@localhost ~]# yum install -y docker-ce          #安装软件
[root@localhost ~]# systemctl enable docker
[root@localhost ~]# systemctl start docker
```



# 2 案例2：下载导入镜像

## 2.1 问题

本案例熟悉docker镜像管理的命令，分别实现以下目标：

1. search 查找
2. pull 下载
3. save备份
4. load恢复

## 2.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：查看帮助，熟悉命令格式（可以在docker-0001或者docker-0002操作）

```shell
[root@docker-0001 ~]# docker help search 
[root@docker-0001 ~]# docker help pull
[root@docker-0001 ~]# docker help save 
[root@docker-0001 ~]# docker help load 
```



# 3 案例3：镜像管理命令

## 3.1 问题

本案例练习docker镜像管理的命令，分别实现以下目标：

1. 导入4个镜像（centos，nginx，redis，ubuntu）
2. 使用镜像CentOS启动容器
3. 使用镜像busybox启动容器
4. 使用镜像nginx启动容器

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：导入镜像（可以在docker-0001或者docker-0002操作）**

镜像都已经提前共享到云盘，请提前下载云盘中的镜像，并拷贝到实验虚拟机中。

所有镜像在云盘第四阶段的kubernetes/docker-images/目录下。

```
[root@docker-0001 ~]# docker  load  -i  centos.tar.gz
[root@docker-0001 ~]# docker  load  -i  nginx.tar.gz
[root@docker-0001 ~]# docker  load  -i  redis.tar.gz
[root@docker-0001 ~]# docker  load  -i  ubuntu.tar.gz
```

**步骤二：使用镜像，运行容器**

1）运行容器

可以通过docker help run或者man docker-run查看帮助。

法法格式如下：docker run -参数 镜像名称：镜像标签 启动命令

run命令 = 创建 + 启动 + 进入

docker run 命令的重要参数如下

- 参数 -i，交互式
- 参数 -t，终端
- 参数 -d，后台运行
- 参数 --name 容器名字

启动 centos 容器，并进入容器

```shell
[root@docker-0001 ~]# docker run -it --name myos centos:latest /bin/bash
```

使用docker命令启动容器，可以通过提示符判定自己是否进入容器

```shell
[root@docker-0001 ~]#  docker run -it centos:latest /bin/bash
[root@10d70724abf2 /]# ps –ef                   #可以看到命令提示符已经变了
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 12:52 ?        00:00:00 /bin/bash
root        14     1  0 12:53 ?        00:00:00 ps -ef
```

2）其他镜像的使用

所有其他镜像使用方法类似，下面再看几个例子

```shell
[root@docker-0001 ~]# docker run -it nginx /bin/bash
[root@docker-0001 ~]# docker run -it ubuntu /bin/bash
```



# 4 案例4：镜像管理命令二

## 4.1 问题

本案例要求进一步熟练掌握以下镜像管理命令，主要完成内容：

1. search、images、load、save、pull
2. tag、inspect、history、rmi、push

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：镜像管理命令的使用**

查看镜像

```shell
[root@docker-0001 ~]# docker images
```

搜索镜像（默认需要连接外网才可以）

```shell
[root@docker-0001 ~]# docker search   镜像名称
```

删除镜像

```shell
[root@docker-0001 ~]# docker rmi  镜像名称:镜像标签
```

上传下载镜像（默认需要连接外网才可以）

```shell
[root@docker-0001 ~]# docker pull  镜像名称:镜像标签            #下载镜像
[root@docker-0001 ~]# docker push  要上传的镜像名称:镜像标签    #上传镜像
```

备份镜像

```shell
[root@docker-0001 ~]# docker save 镜像名称:镜像标签 -o  文件名称
# -o选项指定将镜像备份到哪个文件
```

恢复镜像

```shell
[root@docker-0001 ~]# docker load -i 备份文件名称
```

查看镜像的制作历史

```shell
[root@docker-0001 ~]# docker history 镜像名称:镜像标签
```

查看镜像的信息

```shell
[root@docker-0001 ~]# docker inspect 镜像名称:镜像标签
```

镜像的新名称和标签

```shell
[root@docker-0001 ~]# docker tag 镜像名称:镜像标签  新镜像名称:新的标签
```



# 5 案例5：容器管理命令

## 5.1 问题

本案例要求熟练掌握以下容器管理命令，主要练习以下命令：

1. run、stop、start、restart、ps、cp
2. rm、inspect、top、attach、exec

## 5.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：容器管理命令

启动容器

```shell
[root@docker-0001 ~]# docker run -参数 镜像名称:镜像标签 启动命令
```

查看容器

```shell
[root@docker-0001 ~]# docker ps  [ -a ] [ -q ]
#[]代表可选参数，可以使用-a或-q也可以不适用
#-a代表查看所有容器的信息
#-q只显示容器的id号
```

删除容器

```shell
[root@docker-0001 ~]# docker rm  容器id             #根据容器ID，删除某个已启动的容器
[root@docker-0001 ~]# docker rm $(docker ps -aq)   #删除已经启动所有容器
```

启动、停止、重启容器的命令

```shell
[root@docker-0001 ~]# docker start  容器id            #启动容器
[root@docker-0001 ~]# docker stop  容器id             #关闭容器
[root@docker-0001 ~]# docker restart  容器id          #重启容器
```

将真机文件拷贝到容器中

```shell
[root@docker-0001 ~]# docker cp  本机文件路径  容器id:容器内路径
#该命令可以将真机的某个文件上传到容器中的某个路径下
[root@docker-0001 ~]# docker cp 容器id:容器内路径  本机文件路径
#该命令可以将容器中的某个文件下载到真机的某个路径下
```

查看容器信息

```shell
[root@docker-0001 ~]# docker inspect 容器id
```

进入容器(退出会关闭)

```shell
[root@docker-0001 ~]# docker attach 容器id
```

进入容器(退出不关闭)

```shell
[root@docker-0001 ~]# docker exec -it 容器id 启动命令
```



# 6 案例6：练习容器的执行方式

## 6.1 问题

本案例要求理解容器的执行方式：

1. 前台服务
2. 后台服务
3. 创建一个 centos 的容器，并为他设置 yum 源

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：概念**

容器启动服务的方式

前台服务（-it）：一般是能与用户交互的程序，比如 /bin/bash、/bin/sh 等

后台服务（-itd）：一般是一个程序服务，比如 apache、nginx、redis 等

**步骤二：命令练习**

```shell
[root@docker-0001 ~]# docker run -d  centos:latest        # 失败
c2219228afc14e7c87b20280fcb5793f006a24a360433c107a3ab5a9dee34047
[root@docker-0001 ~]# docker ps -a
CONTAINER ID   IMAGE              COMMAND   CREATED             STATUS      NAMES
c2219228afc1    centos:latest   "/bin/bash"   5 seconds ago    Exited (0)      xx
[root@docker-0001 ~]# docker run -itd  centos:latest        # 成功
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Overview of Python & environment preparation & Getting Started with Python & Overview of data types | Cloud computing )

---

# 1. 准备python开发环境

## 1.1 问题

1. 下载最新版本的python3
2. 下载pycharm社区版
3. 安装python3，使其支持Tab键补全
4. 配置pycharm，使其符合自己的习惯

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：下载最新版python3**

首先去python官网下载python3的源码包，网址：https://www.python.org/

进去之后点击导航栏的Downloads，也可以鼠标放到Downloads上弹出菜单选择Source code，表示源码包，这里选择最新版本3.6.4，这里选择第一个下载即可，下载的就是源码包：Python-3.6.4.tar.gz，下载好之后上传到linux系统，准备安装，如图-1所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5e4cf22760394c68ae521917befe21f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

**步骤二：Linux下安装python3**

1)python安装之前需要一些必要的模块，如果没有这些模块后来使用会出现一些问题，输入以下命令提前预装依赖包：

```shell
[root@localhost ~]# yum install -y gcc gcc-c++ zlib-devel openssl-devel readline-devel libffi-devel sqlite-devel tcl-devel tk-devel
```

释放文件：

```shell
[root@localhost python]# tar -xzf Python-3.6.4.tar.gz
```

2)进入Python-3.6.4目录：

```shell
[root@localhost python]# cd Python-3.6.4
[root@localhost Python-3.6.4]#ls        #此时Python-3.6.4文件夹中没有makefile文件
```

3)配置安装目录：

configure是用来进行用户个性配置的工具，--prefix是说软件安装目录设置在哪里， =/usr/local就是你给出的安装目录

```shell
[root@localhost Python-3.6.4]# ./configure --prefix=/usr/local
[root@localhost Python-3.6.4]# ls        #此时Python-3.6.4文件夹中生成了makefile文件
aclocal.m4     Doc              Makefile         PCbuild         python-config.py
build          Grammar          Makefile.pre     Programs        python-gdb.py
config.guess   Include          Makefile.pre.in  pybuilddir.txt  README.rst
config.log     install-sh       Misc             pyconfig.h      setup.py
config.status  Lib              Modules          pyconfig.h.in   Tools
config.sub     libpython3.6m.a  Objects          python
configure      LICENSE          Parser           Python
configure.ac   Mac              PC               python-config
```

4)接下来编译源码：

```shell
[root@localhost Python-3.6.4]# make
```

5)执行安装：

```shell
[root@localhost Python-3.6.4]# make install
```

整个过程大约5-10分钟，安装成功

**步骤三：下载并安装Pycharm社区版**

网址：https://www.jetbrains.com/pycharm/download，这里选择下图红框下载即可，下载好之后上传到linux系统，准备安装，如图-2所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/b1c70601825244a38366f23e5b12cb31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-2

2)释放文件：

```shell
[root@localhost ~]# tar -xzf pycharm-community-2018.1.1.tar.gz
```

3)运行下面的命令进入PyCharm 目录：

```shell
[root@localhost pycharm-community-2018.1.1]# cd pycharm-community-2018.1.1/bin
```

4)通过运行下面的命令来运行PyCharm进入图形化安装界面：

```shell
[root@localhost bin]# sh pycharm.sh &
```

5)Pycharm打开后，如果你需要导入之前安装版本的设置的话，可以选择第一个选项，如果没有的话，选择(Do not import settings)默认不导入设置，点击/同意，就可以进入pycharm进行配置，如图-3所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/539ba04966084e1ba4b4139ded1ab84f.png)
图-3

6)激活Pycharm：在弹出的激活窗口中，选择“License serveer”输入激活服务器地址“http://127.0.0.1:1017”，之后点击‘Activate’，完成pycharm激活，如图-4所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/74a101a97b64439da2e2bc099282049e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-4

7)启动完成进入欢迎界面，如图-5所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d46fe304d9c8497e998ea97efc436ccf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-5

# 2. 模拟用户登陆

## 2.1 问题

编写login.py脚本，实现以下目标：

1. 创建名为login.py的程序文件
2. 程序提示用户输入用户名
3. 用户输入用户名后，打印欢迎用户

## 2.2 方案

编写程序时，很多情况下都需要程序与用户交互。在python3中，主要通过input()获取用户输入信息，使用print()打印信息。

通常当想看变量内容时，会在代码中使用print()语句输出。不过在交互式解释器中，可以用print语句显示变量的字符串表示，或者仅使用变量名查看该变量的原始值。

从用户那里得到数据输入的最容易的方法是使用input()内建函数。它读取标准输入，并将读取到的数据赋值给指定的变量。需要注意的是，input()函数读入的数据全部是以字符串的方式存储的。如果用户输的是数字，那么python也将其保存为字符串，当将字符串与数字做数学运算是将会出现TypeError的错误。

初学者在需要显示信息或得到用户输入时，很容易想到使用print()语句和input()内建函数。不过在此建议函数应该保持其清晰性，也就是它只应该接受参数，返回结果。从用户那里得到需要的数据， 然后调用函数处理， 从函数得到返回值，然后显示结果给用户。这样你就能够在其它地方也可以使用你的函数而不必担心自定义输出的问题。这个规则的一个例外是，如果函数的基本功能就是为了得到用户输出，或者就是为了输出信息，这时在函数体使用print()语句或input()也未尝不可。更重要的，将函数分为两大类，一类只做事，不需要返回值（比如与用户交互或设置变量的值）， 另一类则执行一些运算，最后返回结果。如果输出就是函数的目的，那么在函数体内使用 print()语句也是可以接受的选择。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

本次练习的脚本文件是/root/bin/login.py。

```shell
[root@localhost day01]# vim login.py
#!/usr/bin/env python3
username = input('username: ')       #使用变量username接收用户输入的字符
print('Welcome', username)                 #输出欢迎信息，字符串和变量名之间用逗号
                                            #隔开，两者之间自动会加上空格
```

**步骤二：测试脚本执行**

```shell
[root@localhost day01]# python3 login.py
username: bob                              #输入用户名
Welcome bob
```

# Exercise

## 1 python基本的输入输出语句是什么？

输入语句：input()
输出语句：print()

## 2 变量定义的要求有哪些？

第一个字符只能是大小写字母或下划线
后续字符只能是大小写字母或数字或下划线
区分大小写

## 3 以下代码能不能正确运行？为什么？

> ```shell
> \>>>  n += 1 
> ```
>
> 不能运行。因为n += 1相当于是n = n + 1。赋值自右向左进行，在执行n + 1时，n还没有定义，将会出现NameError。

## 4 Python常用的数据类型有哪些？

数字
字符串
列表
元组
字典

## 5 python的数据类型是怎么分类的？

按存储模型分类：

- 标量：数字、字符串
- 容器：列表、元组、字典

按更新模型分类：

- 可变：列表、字典
- 不可变：数字、字符串、元组

按访问模型分类：

- 直接：数字
- 序列：列表、元组、字符串
- 映射：字典

> 如有侵权，请联系作者删除



﻿@[TOC]( Percona software introduction & Innobackupex backup and recovery | Cloud computing )

---

# 1. 完全备份与恢复

## 1.1 问题

1. 练习物理备份与恢复
2. 练习mysqldump备份与恢复

## 1.2 步骤

在192.168.4.50按照如下步骤完成。

**步骤一：练习物理备份与恢复**

```shell
//创建备份文件存储目录
[root@host50 ~]# mkdir /bakdir
//拷贝数据库目录
[root@host50 ~]# cp -r /var/lib/mysql  /bakdir/mysql.bak
//打包压缩数据库目录
[root@host50 ~]# cd  /var/lib/mysql/
[root@host50 ~]# tar –zcvf /bakdir/mysql.tar.gz  ./*
//查看备份文件
[root@host50 ~]# ls /bakdir/
mysql.bak  mysql.tar.gz
[root@host50 ~]#
```

2)恢复数据

50主机使用备份文件恢复数据

```shell
[root@host50 ~]# systemctl  stop mysqld
[root@host50 ~]# rm  -rf /var/lib/mysql/*
[root@host50 ~]# cp -r /bakdir/mysql.bak/* /var/lib/mysql/
或
[root@host50 ~]# tar -zxvf /bakdir/mysql.tar.gz  -C /var/lib/mysql/
[root@host50 ~]# chown  -R mysql:mysql /var/lib/mysql
[root@host50 ~]# systemctl  start mysqld
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'use tarena; show tables'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| emp_sal_view     |
| employees        |
| salary           |
| t1               |
| t2               |
| t3               |
| t4               |
| t5               |
| user             |
| user3            |
| v1               |
| v2               |
| v4               |
| v6               |
| v7               |
+------------------+
[root@host50 ~]#
```

**步骤二：练习mysqldump备份与恢复**

在50主机做备份和恢复的练习

1）完全备份
Mysql服务的备份文件通常以.sql结尾

```shell
//备份所有数据
[root@host50 ~]# mysqldump -uroot -pNSD123...a  --all-databases > /bakdir/all.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]#
//仅备份mysql库的所有的数据 
[root@host50 ~]# mysqldump -uroot -pNSD123...a  -B mysql > /bakdir/mysql.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
//一起备份tarena库和db1 库的所有数据
[root@host50 ~]# mysqldump -uroot -pNSD123...a  -B tarena db1  > /bakdir/tarna_db1.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
//只备份tarena库里的user表所有数据
[root@host50 ~]# mysqldump -uroot -pNSD123...a  tarena user  > /bakdir/tarna_user.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
//同时备份tarena库下的 employees表和salary表的所有数据
[root@host50 ~]# mysqldump -uroot -pNSD123...a  tarena employees  salary  > /bakdir/tarna_employees_salary.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
//查看备份文件
[root@host50 ~]# ls /bakdir/*.sql
/bakdir/all.sql  /bakdir/mysql.sql  /bakdir/tarna_db1.sql  /bakdir/tarna_employees_salary.sql  /bakdir/tarna_user.sql
[root@host50 ~]#
```

2）完全恢复

```shell
在50主机删除的数据后，使用备份文件恢复

//删除表里的记录
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'delete from tarena.user'
mysql: [Warning] Using a password on the command line interface can be insecure.
//表记录行数为0
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'select count(*) from tarena.user'
mysql: [Warning] Using a password on the command line interface can be insecure.
+----------+
| count(*) |
+----------+
|        0 |
+----------+
[root@host50 ~]#
//使用备份文件恢复数据
[root@host50 ~]# mysql -uroot -pNSD123...a  tarena < /bakdir/tarna_user.sql 
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
//查看表记录
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'select count(*) from tarena.user'
mysql: [Warning] Using a password on the command line interface can be insecure.
+----------+
| count(*) |
+----------+
|       23 |
+----------+
[root@host50 ~]#
//删除工资表salary
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'drop table tarena.salary'
mysql: [Warning] Using a password on the command line interface can be insecure.
//删除员工表employees
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'drop table tarena.employees'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]#
//使用备份文件恢复数据
[root@host50 ~]# mysql -uroot -pNSD123...a  tarena < /bakdir/tarna_employees_salary.sql 
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# 
//查看表记录
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'select count(*) from tarena.salary'
mysql: [Warning] Using a password on the command line interface can be insecure.
+----------+
| count(*) |
+----------+
|     8055 |
+----------+
//查看表记录
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'select count(*) from tarena.employees'
mysql: [Warning] Using a password on the command line interface can be insecure.
+----------+
| count(*) |
+----------+
|      137 |
+----------+
[root@host50 ~]#
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'show databases'
mysql: [Warning] Using a password on the command line interface can be insecure.
+--------------------+
| Database           |
+--------------------+
| information_schema |
| DB1                |
| db1                |
| db2                |
| mydb               |
| mysql              |
| performance_schema |
| sys                |
| tarena             |
+--------------------+
[root@host50 ~]#
```

3）其他主机拷贝50主机的备份文件恢复数据

51主机拷贝50主机的mysql库备份文件，实现与50主机的登录用户一致

```shell
//拷贝50主机的mysql.sql 文件
[root@host51 ~]# scp  192.168.4.50:/bakdir/mysql.sql /root/
Warning: Permanently added '192.168.4.50' (ECDSA) to the list of known hosts.
root@192.168.4.50's password: #50主机的密码 
mysql.sql                                                                                                                          100% 1082KB  45.9MB/s   00:00    
[root@host51 ~]#
#覆盖目标库的同名库数据恢复
[root@host51 ~]# mysql -uroot -pNSD123...a  < /root/mysql.sql 
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host51 ~]# 
[root@host51 ~]# 
//查看授权用户和50主机的用户一样
[root@host51 ~]# mysql -uroot -pNSD123...a  -e 'select user from mysql.user'
mysql: [Warning] Using a password on the command line interface can be insecure.
+-----------+
| user      |
+-----------+
| mysqla    |
| mysqlb    |
| plj       |
| repluser  |
| webuser   |
| yaya      |
| root      |
| mysql.sys |
| root      |
+-----------+
[root@host51 ~]#
```

# 2. binlog日志

## 2.1 问题

## 2.2 步骤

实现此案例需要在192.168.4.50按照如下步骤进行。

**步骤一：启用binlog日志**

1）修改配置文件，并重启服务。

```shell
[root@host50 ~]# vim  /etc/my.cnf
[mysqld]
    server_id=1  //指定server_id
log-bin=/mylog/db50  //指定日志目录及名称                           
:wq
[root@host50 ~]# mkdir  /mylog   //创建目录
[root@host50 ~]# chown  mysql  /mylog   //修改所有者
[root@host50 ~]# setenforce 0 //禁用selinux
[root@host50 ~]# systemctl  restart mysqld.service  //重启服务
```

2）查看日志信息

```shell
[root@host50 ~]# 
[root@localhost ~]# mysql -uroot -p123qqq...A //管理员登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.17-log MySQL Community Server (GPL)
……
……
mysql> show master status; //查看日志信息
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db50.000001 |      154 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
mysql>
```

**步骤二:手动创建新日志**

1）手动创建3个新的日志文件

```shell
mysql>
mysql> flush logs;  //刷新日志
Query OK, 0 rows affected (0.14 sec)
mysql> flush logs; //刷新日志
Query OK, 0 rows affected (0.11 sec)
mysql> flush logs; //刷新日志
Query OK, 0 rows affected (0.12 sec)
mysql> system ls /mylog/  //查看日志文件
db50.000001  db50.000002  db50.000003  db50.000004  db50.index
mysql> 
mysql> show master status; //查看日志信息
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db50.000004 |      154 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
mysql>
```

**步骤三:删除binlog日志文件**

1）删除编号3之前的日志文件

```shell
 mysql>
 mysql> purge  master  logs  to  "db50.000003"; //删除日志
Query OK, 0 rows affected (0.05 sec)
mysql> system ls /mylog/    //查看日志文件
db50.000003  db50.000004  db50.index
mysql> 
mysql> system  cat /mylog/db50.index //查看索引文件
/mylog/db50.000003
/mylog/db50.000004
mysql>
```

# 3. 使用binlog日志恢复数据

## 3.1 问题

1. 修改日志格式 修改为mixed
2. 创建库表并插入记录 创建db4库和tb1表并插入3条记录
3. 记录插入和删除 删除tb1表中刚插入的3条记录
4. 恢复记录 使用binlog日志恢复删除的3条记录

## 3.2 步骤

实现此案例需要在192.168.4.50主机按照如下步骤进行。

**步骤一：修改日志格式**

1）修改格式为 mixed

```shell
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
server_id=50
log_bin=db50
binlog_format="mixed"  #指定日志格式
:wq
[root@host50 ~]# systemctl  restart mysqld
[root@host50 ~]# mysql -uroot -pNSD123...a  #管理员登录
mysql> show variables like "binlog_format"; #查看日志格式
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | MIXED |
+---------------+-------+
1 row in set (0.00 sec)
mysql>
mysql> show master status\G  #查看日志信息
*************************** 1. row ***************************
             File: db50.000001
         Position: 154
     Binlog_Do_DB: 
 Binlog_Ignore_DB: 
Executed_Gtid_Set: 
1 row in set (0.00 sec)
mysql>
```

步骤二：创建库表并插入记录

1）创建db4库

```shell
mysql> create database db4 ;
Query OK, 1 row affected (0.03 sec)
```

2）建表tb1表 表结构自定义即可

```shell
mysql> create table db4.tb1(name char(10));
Query OK, 0 rows affected (0.26 sec)
```

3)插入3条表记录

```shell
mysql> insert into db4.tb1 values("tom");
Query OK, 1 row affected (0.07 sec)
mysql> insert into db4.tb1 values("lucy");
Query OK, 1 row affected (0.06 sec)
mysql> insert into db4.tb1 values("lili");
Query OK, 1 row affected (0.03 sec)
//查看日志信息
mysql> show master status\G
*************************** 1. row ***************************
             File: db50.000001
         Position: 1297
     Binlog_Do_DB: 
 Binlog_Ignore_DB: 
Executed_Gtid_Set: 
1 row in set (0.00 sec)
mysql>
```

**步骤三：删除表记录**

1）删除tb1表中刚插入的3条记录

```shell
mysql> select  * from   db4.tb1;
+------+
| name |
+------+
| tom  |
| lucy |
| lili |
+------+
3 rows in set (0.00 sec)
mysql> delete from  db4.tb1;
Query OK, 3 rows affected (0.05 sec)
mysql>
```

**步骤四：恢复记录**

1）使用binlog日志恢复删除的3条记录

```shell
//通过查看日志内容  获取sql命令的范围
mysql> show binlog events in "db50.000001";
+-------------+------+----------------+-----------+-------------+---------------------------------------+
| Log_name    | Pos  | Event_type     | Server_id | End_log_pos | Info                                  |
+-------------+------+----------------+-----------+-------------+---------------------------------------+
| db50.000001 |    4 | Format_desc    |        50 |         123 | Server ver: 5.7.17-log, Binlog ver: 4 |
| db50.000001 |  123 | Previous_gtids |        50 |         154 |                                       |
| db50.000001 |  154 | Anonymous_Gtid |        50 |         219 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 |  219 | Query          |        50 |         310 | create database db4                   |
| db50.000001 |  310 | Anonymous_Gtid |        50 |         375 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 |  375 | Query          |        50 |         479 | create table db4.tb1(name char(10))   |
| db50.000001 |  479 | Anonymous_Gtid |        50 |         544 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 |  544 | Query          |        50 |         618 | BEGIN                                 |
| db50.000001 |  618 | Query          |        50 |         720 | insert into db4.tb1 values("tom")     |
| db50.000001 |  720 | Xid            |        50 |         751 | COMMIT /* xid=7 */                    |
| db50.000001 |  751 | Anonymous_Gtid |        50 |         816 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 |  816 | Query          |        50 |         890 | BEGIN                                 |
| db50.000001 |  890 | Query          |        50 |         993 | insert into db4.tb1 values("lucy")    |
| db50.000001 |  993 | Xid            |        50 |        1024 | COMMIT /* xid=8 */                    |
| db50.000001 | 1024 | Anonymous_Gtid |        50 |        1089 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 | 1089 | Query          |        50 |        1163 | BEGIN                                 |
| db50.000001 | 1163 | Query          |        50 |        1266 | insert into db4.tb1 values("lili")    |
| db50.000001 | 1266 | Xid            |        50 |        1297 | COMMIT /* xid=9 */                    |
| db50.000001 | 1297 | Anonymous_Gtid |        50 |        1362 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
| db50.000001 | 1362 | Query          |        50 |        1436 | BEGIN                                 |
| db50.000001 | 1436 | Query          |        50 |        1525 | delete from  db4.tb1                  |
| db50.000001 | 1525 | Xid            |        50 |        1556 | COMMIT /* xid=12 */                   |
+-------------+------+----------------+-----------+-------------+---------------------------------------+
22 rows in set (0.00 sec)
mysql> exit
//恢复数据
[root@host50 ~]# mysqlbinlog --start-position=618 --stop-position=1362  /var/lib/mysql/db50.000001   | mysql -uroot -pNSD123...a
//查看数据
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'select  * from db4.tb1'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| name |
+------+
| tom  |
| lucy |
| lili |
+------+
[root@host50 ~]#
```

# 4. innobackupex完全备份与恢复

## 4.1 问题

1. 安装percona软件
2. 备份所有数据到/allbak目录下
3. 使用备份文件恢复数据

## 4.2 步骤

实现此案例需要按照如下步骤进行

在192.168.4.50主机 备份数据,在192.168.4.50主机或52主机练习数据恢复。

**步骤一：安装percona软件**

1) 在50主机安装软件

```shell
[root@host50 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm //安装依赖软件(此软件操作系统光盘没有 需从网上自己下载 安装没有依赖)
[root@host50 ~]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
警告：percona-xtrabackup-24-2.4.6-2.el7.x86_64.rpm: 头V4 DSA/SHA1 Signature, 密钥 ID cd2efd2a: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:percona-xtrabackup-24-2.4.6-2.el7################################# [ 33%]
   2:percona-xtrabackup-test-24-2.4.6-################################# [ 67%]
   3:percona-xtrabackup-24-debuginfo-2################################# [100%]
```

2）查看命令帮助信息

```shell
[root@host50 ~]# innobackupex --help  //查看命令选项
[root@host50 ~]#
[root@host50 ~]# man  innobackupex //查看详细帮助 (按q 退出)
```

**步骤二：备份所有数据到/allbak目录下**

1）备份所有数据

备份50主机的所有数据

```shell
//备份50主机所有数据
[root@host50 ~]# innobackupex -uroot -pNSD123...a  /allbak --no-timestamp 
......
......
170425 11:06:00 [00] Copying ib_buffer_pool to /backup/ib_buffer_pool
170425 11:06:00 [00]        ...done
170425 11:06:00 Backup created in directory '/backup/'
170425 11:06:00 [00] Writing backup-my.cnf
170425 11:06:00 [00]        ...done
170425 11:06:00 [00] Writing xtrabackup_info
170425 11:06:00 [00]        ...done
xtrabackup: Transaction log of lsn (2543884) to (2543893) was copied.
170425 11:06:01 completed OK    //提示OK 表示备份成功
```

2）查看备份文件

备份目录下：有数据 和 记录备份信息的配置文件

```shell
[root@host50 ~]# ls /allbak
backup-my.cnf  ib_buffer_pool  mysql      sys                   xtrabackup_info
db1  ibdata1      performance_schema  xtrabackup_checkpoints  xtrabackup_logfile
//保存备份信息的配置文件
[root@host50 ~]# cat /allbak/xtrabackup_checkpoints 
backup_type = full-backuped   #备份类型
from_lsn = 0  #备份数据的起始范围
to_lsn = 9513407 #备份数据的结束范围
last_lsn = 9513416 #增量备份数据的参考点
compact = 0
recover_binlog_info = 0
[root@host50 ~]# 
```

**步骤三：使用备份文件恢复数据**

1）在50本机使用备份文件恢复数据

```shell
[root@host50 ~]# rm -rf /var/lib/mysql/*     //清空数据库目录   
[root@host50 ~]#
[root@host50 ~]# systemctl  stop mysqld         //停止服务
 
//确保数据库目录为空
[root@host50 ~]# ls /var/lib/mysql
[root@host50 ~]# 
//准备恢复数据
[root@host50 ~]# cat /allbak/xtrabackup_checkpoints   #执行准备恢复数据前的信息
backup_type = full-backuped  #类型
from_lsn = 0
to_lsn = 9513407
last_lsn = 9513416
compact = 0
recover_binlog_info = 0
[root@host50 ~]# 
[root@host50 ~]# innobackupex  --apply-log  /allbak #准备恢复数据
[root@host50 ~]# cat /allbak/xtrabackup_checkpoints   #执行准备恢复后查看
backup_type = full-prepared  #类型
from_lsn = 0
to_lsn = 9513407
last_lsn = 9513416
compact = 0
recover_binlog_info = 0
[root@host50 ~]# 
//拷贝数据
[root@host50 ~]# innobackupex --copy-back /allbak
......
......
210915 14:25:06 [01] Copying ./xtrabackup_master_key_id to /var/lib/mysql/xtrabackup_master_key_id
210915 14:25:06 [01]        ...done
210915 14:25:07 [01] Copying ./ibtmp1 to /var/lib/mysql/ibtmp1
210915 14:25:07 [01]        ...done
210915 14:25:07 completed OK!
[root@host50 ~]# 
//修改所有者和组
[root@host50 ~]# chown -R mysql:mysql /var/lib/mysql
//启动数据库服务
[root@host50 ~]# systemctl  start  mysqld
//连接服务查看数据
[root@host50 ~]# mysql -uroot -pNSD123...a -e 'use tarena;show tables'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| emp_sal_view     |
| employees        |
| salary           |
| t1               |
| t2               |
| t3               |
| t4               |
| t5               |
| user             |
| user3            |
| v1               |
| v2               |
| v4               |
| v6               |
| v7               |
+------------------+
[root@host50 ~]# 
```

2）在51主机使用备份文件恢复数据

```shell
//安装软件提供innobackupex命令
[root@host51 ~]# rpm -ivh  libev-4.15-1.el6.rf.x86_64.rpm
[root@host51 ~]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
    //误删除数据
[root@host51 ~]# systemctl  stop mysqld    #停止服务
[root@host51 ~]# rm -rf /var/lib/mysql/*   #清空数据库
//拷贝50主机的备份目录
[root@host51 ~]# scp -r 192.168.4.51:/allbak  /root/
//使用备份目录恢复数据（因为50主机已经做过准备恢复数据了）
[root@host51 ~]# innobackupex  --copy-back /opt/allbak/
[root@host51 ~]# chown  -R mysql:mysql /var/lib/mysql
//启动服务查看数据
[root@host51 ~]# systemctl  start mysqld 
[root@host51 ~]# mysql -uroot -pNSD123...a -e 'use tarena;show tables'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| emp_sal_view     |
| employees        |
| salary           |
| t1               |
| t2               |
| t3               |
| t4               |
| t5               |
| user             |
| user3            |
| v1               |
| v2               |
| v4               |
| v6               |
| v7               |
+------------------+
[root@host51 ~]# 
```

# 5. 恢复单张表

## 5.1 问题

1. 删除表记录
2. 恢复表记录

## 5.2 步骤

实现此案例需要按照如下步骤进行(在50主机完成实验)。

**步骤一：删除表记录**

```shell
[root@host50 ~]# mysql –uroot  -pNSD123…a
//删除表记录 以user表为例  
mysql> delete from tarena .user;
Query OK, 23 rows affected (0.03 sec)
```

步骤二：恢复表记录

```shell
//删除表空间
mysql> alter table tarena.user discard  tablespace;
Query OK, 0 rows affected (0.06 sec)
mysql> system ls /var/lib/mysql/tarena/user.*  #只剩表结构文件
/var/lib/mysql/tarena/user.frm
mysql>exit;
[root@host50 ~]# ls /allbak/tarena/user.*   #导出表信息前查看user表文件
/allbak/tarena/user.frm  /allbak/tarena/user.ibd
//导出表信息
[root@host50 ~ ]# innobackupex --apply-log --export  /allbak
……
……
InnoDB: FTS optimize thread exiting.
InnoDB: Starting shutdown...
InnoDB: Shutdown completed; log sequence number 9514071
210915 16:51:04 completed OK!
[root@host50 ~]# 
//执行导出信息命令后查看user表文件
[root@host50 ~]# ls -l /allbak/tarena/user.*
-rw-r--r-- 1 root root   737 9月  15 16:51 /allbak/tarena/user.cfg
-rw-r----- 1 root root 16384 9月  15 16:51 /allbak/tarena/user.exp
-rw-r----- 1 root root  8784 9月  15 11:13 /allbak/tarena/user.frm
-rw-r----- 1 root root 98304 9月  15 11:13 /allbak/tarena/user.ibd
[root@host50 ~]#
//拷贝表信息文件到数据库目录下
[root@host50 ~]# cp /allbak/tarena/user.{cfg,exp,ibd} /var/lib/mysql/tarena/
//修改表信息文件的所有者及组用户为mysql
[root@host50 ~]# chown mysql:mysql /var/lib/mysql/tarena/user.*    
//管理员登录
[root@host50 ~]# mysql -uroot -pNSD123...a   
mysql: [Warning] Using a password on the command line interface can be insecure.
//没有表记录
mysql> select  count(*) from tarena.user;
ERROR 1814 (HY000): Tablespace has been discarded for table 'user'
mysql>
//导入表信息
mysql> alter table tarena.user import  tablespace ;
Query OK, 0 rows affected (0.34 sec)
//查看表记录
mysql> select  count(*) from tarena.user;
+----------+
| count(*) |
+----------+
|       23 |
+----------+
1 row in set (0.00 sec)
mysql> exit 
//删除数据库目录下的表信息文件
[root@host50 ~]# rm -rf /var/lib/mysql/tarena/user.cfg 
[root@host50 ~]# rm -rf /var/lib/mysql/tarena/user.exp
# 6. 增量备份与恢复
## 6.1 问题
- 完全备份
- 增量备份
- 删除数据
- 恢复数据

## 6.2 步骤
实现此案例需要在192.168.4.50主机按照如下步骤进行。

**步骤一：完全备份**

1）备份所有数据
```shell
//备份所有数据到 /fullbak目录
[root@host50 ~]# innobackupex  -uroot -pNSD123...a /fullbak  --no-timestamp
……
……
210917 10:42:13 [00] Writing /fullbak/xtrabackup_info
210917 10:42:13 [00]        ...done
xtrabackup: Transaction log of lsn (11194613) to (11194622) was copied.
210917 10:42:13 completed OK!
[root@host50 ~]#
//查看备份目录
[root@host50 ~]# ls /fullbak/
backup-my.cnf  DB1  db4             ibdata1  mysql               sys     xtrabackup_binlog_info  xtrabackup_info
db1            db2  ib_buffer_pool  mydb     performance_schema  tarena  xtrabackup_checkpoints  xtrabackup_logfile
[root@host50 ~]#
//查看备份信息
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = full-backuped  #完全备份
from_lsn = 0  #备份起始位置
to_lsn = 11194613 #备份结束位置
last_lsn = 11194622 #增量备份参考点
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
```

步骤二：增量备份 （每次执行备份，值备份新数据,在50主机执行）

1）第一次增量备份

```shell
//插入新记录(可以插入多行)
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]# mysql -uroot -pNSD123...a  -e  'insert into tarena.user(name,uid)values("a",1001)'
mysql: [Warning] Using a password on the command line interface can be insecure.
[root@host50 ~]#
//增量备份 ，数据存储目录/new1dir
[root@host50 ~]# innobackupex -uroot -pNSD123...a  --incremental /new1dir --incremental-basedir=/fullbak --no-timestamp
……
……
210917 11:01:46 [00] Writing /new1dir/backup-my.cnf
210917 11:01:46 [00]        ...done
210917 11:01:46 [00] Writing /new1dir/xtrabackup_info
210917 11:01:46 [00]        ...done
xtrabackup: Transaction log of lsn (11198109) to (11198118) was copied.
210917 11:01:47 completed OK!
[root@host50 ~]# 
//查看备份目录列表
[root@host50 ~]# ls /new1dir/
backup-my.cnf  DB1  db4             ibdata1.delta  mydb   performance_schema  tarena                  xtrabackup_checkpoints  xtrabackup_logfile
db1            db2  ib_buffer_pool  ibdata1.meta   mysql  sys                 xtrabackup_binlog_info  xtrabackup_info
[root@host50 ~]# 
//查看备份信息
[root@host50 ~]# cat /new1dir/xtrabackup_checkpoints 
backup_type = incremental  #增量备份
from_lsn = 11194613 #备份起始位置
to_lsn = 11198109 #备份结束位置
last_lsn = 11198118 #增量备份参考点
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
```

2) 第二次增量备份

```shell
//增量备份 数据存储在 /new2dir 目录

[root@host50 ~]# innobackupex -uroot -pNSD123...a --incremental /new2dir --incremental-basedir=/new1dir --no-timestamp
……
……
MySQL binlog position: filename 'db50.000001', position '6612'
210917 11:28:12 [00] Writing /new2dir/backup-my.cnf
210917 11:28:12 [00] ...done
210917 11:28:12 [00] Writing /new2dir/xtrabackup_info
210917 11:28:12 [00] ...done
xtrabackup: Transaction log of lsn (11201887) to (11201896) was copied.
210917 11:28:12 completed OK!
[root@host50 ~]#

//查看备份目录
[root@host50 ~]# ls /new2dir/
backup-my.cnf DB1 db4 ibdata1.delta mydb performance_schema tarena xtrabackup_checkpoints xtrabackup_logfile
db1 db2 ib_buffer_pool ibdata1.meta mysql sys xtrabackup_binlog_info xtrabackup_info
[root@host50 ~]#

//查看备份信息
[root@host50 ~]# cat /new2dir/xtrabackup_checkpoints
backup_type = incremental #增量备份
from_lsn = 11198109 #备份起始位置
to_lsn = 11201887 #备份结束位置
last_lsn = 11201896 #增量备份参考点
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
```

**步骤三：删除数据**

1) 停止服务，并清空数据

```shell
[root@host50 ~]# systemctl  stop  mysqld
[root@host50 ~]# rm -rf /var/lib/mysql/*
```

**步骤四：恢复数据**

1）准备恢复数据

```shell
//恢复前查看备份信息文件
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = full-backuped   #类型
from_lsn = 0
to_lsn = 11194613
last_lsn = 11194622    #结束位置
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
//准备恢复数据
[root@host50 ~]# innobackupex  --apply-log --redo-only /fullbak 
……
xtrabackup: starting shutdown with innodb_fast_shutdown = 1
InnoDB: Starting shutdown...
InnoDB: Shutdown completed; log sequence number 11194631
InnoDB: Number of pools: 1
210917 11:59:14 completed OK!
[root@host50 ~]#
//查看备份信息文件
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = log-applied   #类型
from_lsn = 0
to_lsn = 11194613
last_lsn = 11194622   #结束位置
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
```

2）合并数据

```shell
//合并第1次增量备份数据
[root@host50 ~]# innobackupex  --apply-log --redo-only /fullbak  --incremental-dir=/new1dir
……
……
210917 12:08:16 [01]        ...done
210917 12:08:16 [00] Copying /new1dir//xtrabackup_binlog_info to ./xtrabackup_binlog_info
210917 12:08:16 [00]        ...done
210917 12:08:16 [00] Copying /new1dir//xtrabackup_info to ./xtrabackup_info
210917 12:08:16 [00]        ...done
210917 12:08:16 completed OK!
[root@host50 ~]# 
//查看合并后的备份信息
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = log-applied
from_lsn = 0
to_lsn = 11198109
last_lsn = 11198118 # 变成和第1次增量备份位置一样
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
//查看第1次增量备份结束的位置
[root@host50 ~]# cat /new1dir/xtrabackup_checkpoints 
backup_type = incremental
from_lsn = 11194613
to_lsn = 11198109
last_lsn = 11198118 #结束位置
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
//合并第2次增量备份数据
[root@host50 ~]# innobackupex  --apply-log --redo-only /fullbak  --incremental-dir=/new2dir
……
……
210917 12:13:39 [01]        ...done
210917 12:13:40 [00] Copying /new2dir//xtrabackup_binlog_info to ./xtrabackup_binlog_info
210917 12:13:40 [00]        ...done
210917 12:13:40 [00] Copying /new2dir//xtrabackup_info to ./xtrabackup_info
210917 12:13:40 [00]        ...done
210917 12:13:40 completed OK!
[root@host50 ~]# 
//查看备份信息
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = log-applied
from_lsn = 0
to_lsn = 11201887  #结束位置是第2次增量备份的位置
last_lsn = 11201896  
compact = 0
recover_binlog_info = 0
[root@host50 ~]# 
//查看第2次增量备份的位置
[root@host50 ~]# cat /new2dir/xtrabackup_checkpoints 
backup_type = incremental
from_lsn = 11198109
to_lsn = 11201887 #增量备份结束位置
last_lsn = 11201896
compact = 0
recover_binlog_info = 0
[root@host50 ~]#
//删除合并数据后的增量备份目录
[root@host50 ~]# 
[root@host50 ~]# rm -rf /new1dir/
[root@host50 ~]# rm -rf /new2dir/
[root@host50 ~]#
```

3）恢复数据

```shell
//拷贝数据
[root@host50 ~]# innobackupex  --copy-back /fullbak/
……
……
210917 12:22:54 [01]        ...done
210917 12:22:54 [01] Copying ./xtrabackup_master_key_id to /var/lib/mysql/xtrabackup_master_key_id
210917 12:22:54 [01]        ...done
210917 12:22:54 [01] Copying ./xtrabackup_info to /var/lib/mysql/xtrabackup_info
210917 12:22:54 [01]        ...done
210917 12:22:54 completed OK!
[root@host50 ~]#
//修改所有者和组
[root@host50 ~]# chown  -R mysql:mysql /var/lib/mysql
//查看修改
[root@host50 ~]# ls -l /var/lib/mysql
总用量 77872
drwxr-x--- 2 mysql mysql       76 9月  17 12:22 db1
drwxr-x--- 2 mysql mysql      142 9月  17 12:22 DB1
drwxr-x--- 2 mysql mysql      164 9月  17 12:22 db2
drwxr-x--- 2 mysql mysql       50 9月  17 12:22 db4
-rw-r----- 1 mysql mysql     1065 9月  17 12:22 ib_buffer_pool
-rw-r----- 1 mysql mysql 79691776 9月  17 12:22 ibdata1
drwxr-x--- 2 mysql mysql       66 9月  17 12:22 mydb
drwxr-x--- 2 mysql mysql     4096 9月  17 12:22 mysql
drwxr-x--- 2 mysql mysql     8192 9月  17 12:22 performance_schema
drwxr-x--- 2 mysql mysql     8192 9月  17 12:22 sys
drwxr-x--- 2 mysql mysql     4096 9月  17 12:22 tarena
-rw-r----- 1 mysql mysql       17 9月  17 12:22 xtrabackup_binlog_pos_innodb
-rw-r----- 1 mysql mysql      523 9月  17 12:22 xtrabackup_info
-rw-r----- 1 mysql mysql        1 9月  17 12:22 xtrabackup_master_key_id
[root@host50 ~]#
//启动服务
[root@host50 ~]# systemctl  start mysqld
//查看数据
[root@host50 ~]# mysql -uroot -pNSD123...a -e ' show databases'
mysql: [Warning] Using a password on the command line interface can be insecure.
+--------------------+
| Database           |
+--------------------+
| information_schema |
| DB1                |
| db1                |
| db2                |
| db4                |
| mydb               |
| mysql              |
| performance_schema |
| sys                |
| tarena             |
+--------------------+
[root@host50 ~]#
```

# Exercise

## 1 阐述innobackupex完全备份与恢复操作命令。

备份数据

```shell
[root@dbsvr1 ~]# innobackupex  -u root -p 123456  /backup  --no-timestamp              
```

恢复数据

```shell
[root@dbsvr1 ~]# systemctl stop  mysqld
[root@dbsvr1 ~]# rm -rf  /var/lib/mysql/*
[root@dbsvr1 ~]# innobackupex –-apply-log  /backup
[root@dbsvr1 ~]# innobackupex --copy-back  /backup  
[root@dbsvr1 ~]# chown  -R  mysql:mysql  /var/lib/mysql
[root@dbsvr1 ~]# systemctl start  mysqld
```

## 2 阐述innobackupex恢复单张表数据的步骤。

删除表空间
导出表信息
拷贝表信息文件到数据库目录下
修改表信息文件的所有者及组用户为mysql
导入表空间
删除数据库目录下的表信息文件
查看表记录

## 3 阐述innobackupex增量恢复数据的步骤与命令。

准备恢复数据

```shell    
innobackupex --apply-log --redo-only   完全备份目录 
```

合并日志

```shell
innobackupex --apply-log --redo-only  完全备份目录 --incremental-dir=增量备份目录 
```

拷贝文件

```shell
innobackupex --copy-back  完全备份文件目录   
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Private cloud Overview & private cloud configuration management & cloud host management | Cloud computing )

---

# 1. 登录Openstack

## 1.1 问题

本案例要求启动Openstack集群环境，具体要求如下：

- 导入教学环境，并启动Openstack集群
- 通过浏览器访问 192.168.1.10
- 登录 Openstack

## 1.2 方案

openstack 实验架构图例拓扑如图-1所示。

![img](https://img-blog.csdnimg.cn/img_convert/1f08c7aac8ae2b68f797a4b0c49036c0.png)

图-1

openstack初始化环境要求如表-1所示：

表-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：导入系统**

1）如果是windows系统

导入教学环境镜像到 E:\下

配置网卡连接 vmnet8、配置系统光盘路径

启动三台虚拟机 openstack、nova01、nova02

2）如果是linux系统

**步骤二：登录 openstack**

1）Web页面登录：

浏览器访问 http://192.168.1.10/

2）命令行登录：

3）总结：



# 2. 配置云主机类型并上传镜像

## 2.1 问题

本案例要求配置云主机类型，上传镜像：

- 创建一个项目 tedu
- 分配一个用户管理该项目 uu
- 自定义云主机类型 （ 2cpu， 512m 内存）
- 上传课件里面的镜像 small.img

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建项目**

1）创建tedu项目，如图-2所示：

![img](https://img-blog.csdnimg.cn/img_convert/10e3a443f1dab1cb775fc1fd0d427f44.png)

图-2

2）创建uu用户，如图-3所示：

![img](https://img-blog.csdnimg.cn/img_convert/5e52a9c6c0f673cbbbe132896f14aafa.png)

图-3

**步骤二：新建云主机类型**

1）通过Horizon创建云主机类型，如图-4所示：

![img](https://img-blog.csdnimg.cn/img_convert/ebb4a52b385f5f7e72f0faa56d3d1c45.png)

图-4

2）上传镜像，效果如图-5所示。

![img](https://img-blog.csdnimg.cn/img_convert/59a5c84a32f7fe19416207996f204788.png)

图-5



# 3. 配置公有网络

## 3.1 问题

本案例要求：

- 创建一个外部网络，分配给项目
- 创建一个内部网络
- 创建一个路由，把内部网络和外部网络连接起来

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建网络**

1）登陆admin用户，创建外网public，如图-6所示：

![img](https://img-blog.csdnimg.cn/img_convert/b4b4551dc9d232507609fa350a95273e.png)

图-6

2）退出admin用户 ，登陆uu用户，创建public的子网wan，如图-7所示：

![img](https://img-blog.csdnimg.cn/img_convert/6697a4a6783b36e20047e207ee55202b.png)

图-7

3）public外网不需要激活DHCP，如图-8所示：

![img](https://img-blog.csdnimg.cn/img_convert/1039a0af47af9739768b1ab3337a2abb.png)

图-8

4）创建内网lan，如图-9所示：

![img](https://img-blog.csdnimg.cn/img_convert/93b13d3931d1ab2bfc52ce94c0f8ae7c.png)

图-9

5）创建lan的子网，如图-10所示：

![img](https://img-blog.csdnimg.cn/img_convert/f035689e31cf0106e3fd4d11018ebd33.png)

图-10

7）给内网分配地址池，如图-11所示：

![img](https://img-blog.csdnimg.cn/img_convert/7e540a3a1d78ba55a537aa4d86ff75d2.png)

图-11

8）新建路由，如图-12所示：

![img](https://img-blog.csdnimg.cn/img_convert/7eb5537f8cfe2772f68fa1075fabb84a.png)

图-12

9）选择路由子网，如图-13所示：

![img](https://img-blog.csdnimg.cn/img_convert/870406713430646b2f4bf383b0c24da5.png)

图-13



# 4. 配置私有网络及路由

## 4.1 问题

本案例要求：

- 为项目 tedu 设置一个私有网络
- 网络名称 tedu_lan
- 定义子网 tedu_lan_subnet
- 子网IP范围: 10.10.10.101,10.10.10.200
- 启用DHCP
- 设置DNS：192.168.1.254
- 设置路由 tedu_route
- 路由要求联通内网和外网
- 路由私有网络地址为 10.10.10.254

### 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建私有网络**

创建私有网络如图-14所示。

![img](https://img-blog.csdnimg.cn/img_convert/824f703b79f5862101546d2708edc234.png)

图-14

创建子网如图-15和图-16所示。

![img](https://img-blog.csdnimg.cn/img_convert/68ce4c2b51946cf7367517c554bae0e4.png)

图-15

![img](https://img-blog.csdnimg.cn/img_convert/220c2f68aba35229332e716d5f2f5bf0.png)

图-16

**步骤二：创建路由**

创建路由如图-17所示。

![img](https://img-blog.csdnimg.cn/img_convert/4bbc29715ff1f3cecb4e76b2f8a2cf2e.png)

图-17

添加路由接口如图-18所示。

![img](https://img-blog.csdnimg.cn/img_convert/cfec83a31bc9f011ca6ae3a850bbfb45.png)

图18



# 5. 创建云主机

## 5.1 问题

本案例要求：

- 通过 web 页面创建云主机
- 并通过 web console 登录云主机

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建云主机**

1）创建云主机，如图-19所示：

![img](https://img-blog.csdnimg.cn/img_convert/a79e13e8d446340d294463f9c0e89e96.png)

图-19

![img](https://img-blog.csdnimg.cn/img_convert/ba94cff9c27ed5d33b457e25936e2258.png)

图-20

4）云主机类型，如图-21所示：

![img](https://img-blog.csdnimg.cn/img_convert/962e1432ea54dd95c099dd5d24bd4c74.png)

图-21

5）云主机网络，如图-22所示：

![img](https://img-blog.csdnimg.cn/img_convert/cacec3f4bc907732cef23e5b5f24cb02.png)

图-22

5）web页面访问云主机，如图-23所示：

![img](https://img-blog.csdnimg.cn/img_convert/516c6db6a164f7064edf44dc03d794b6.png)

图-23



# 6. 配置浮动IP与安全组

## 6.1 问题

本案例要求：

- 为刚刚创建的云主机设置外部访问
- 设置浮动 ip
- 配置安全组，允许外部主机 ping 云主机
- 配置安全组，允许外部主机通过 ssh 管理云主机

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建浮动IP**

![img](https://img-blog.csdnimg.cn/img_convert/c3cc078a488fd0a137172802e44d5a42.png)

图-24

![img](https://img-blog.csdnimg.cn/img_convert/95afc044ce87f8089beddb3d6d9a976a.png)

图-25

**步骤二：建立安全组**

1）新建一个安全组，允许SSH访问，如图-26：

![img](https://img-blog.csdnimg.cn/img_convert/35650e49f7fa0240e2c72e9dcb1c7be7.png)

图26

2）允许ssh访问，如图-27

![img](https://img-blog.csdnimg.cn/img_convert/7769fc8b23f7c63d00302c041694b00f.png)

图-27

3）允许HTTPS访问，如图-28所示：

![img](https://img-blog.csdnimg.cn/img_convert/6d76f8e3335c5900a716e3b2ca61381f.png)

图-28

**步骤三：设置安全组规则，允许外界ping通云主机**

1）添加规则，如图-29所示：

![img](https://img-blog.csdnimg.cn/img_convert/10c97cdaf775afec04ad6246bd1fa869.png)

图-29

2）增加ping规则，如图-30所示

![img](https://img-blog.csdnimg.cn/img_convert/2649f18ddfe3d3ca77cc6ddf7c567f0a.png)

图-30

7）进入控制台，配置dns的ip为192.168.1.254，这里不再重复，通过浮动ip可以ssh连接，如图-31所示：

![img](https://img-blog.csdnimg.cn/img_convert/6604634908ed725a7b880d426cd0a798.png)

图-31



# 7. 练习

## 7.1 问题

本案例要求增加一个nova计算节点：

- 把nova02虚拟机加入openstack集群
- 创建云主机，实现自动调度分配

## 7.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装计算节点**

1）更改answer.ini文件

```shell
[root@openstack ~]# vim answer.ini        //在openstack上面操作
98 CONFIG_COMPUTE_HOSTS=192.168.1.11,192.168.1.12    
102 CONFIG_NETWORK_HOSTS=192.168.1.10,192.168.1.11,192.168.1.12 
[root@openstack ~]# packstack --answer-file answer.ini
**** Installation completed successfully ******
```

2）这时浏览器访问时不出现页面，15-horizon_vhost.conf文件被还原，需要重新修改这个文件

```shell
[root@openstack ~]# cd /etc/httpd/conf.d/
[root@openstack conf.d]# vi 15-horizon_vhost.conf
     35   WSGIProcessGroup apache
     36   WSGIApplicationGroup %{GLOBAL}     //添加这一行
[root@openstack conf.d]# apachectl  graceful  //重新载入配置文件
```

3）浏览器访问，出现页面

```shell
[root@openstack conf.d]# firefox 192.168.1.10
[root@localhost conf.d]# cd
[root@localhost ~]# ls
answer.ini   keystonerc_admin   
[root@openstack ~]# cat keystonerc_admin   
unset OS_SERVICE_TOKEN
    export OS_USERNAME=admin
    export OS_PASSWORD=1bb4c987345c45ba
```

4）安装后的节点状态，如图-32所示：

![img](https://img-blog.csdnimg.cn/img_convert/bd8830a704faf2d434a330c7c410bfba.png)

图-32

openstack错误分析：

1）进入控制台不显示内容，如图-33所示：

![img](https://img-blog.csdnimg.cn/img_convert/08dd8283dddf1f94a9825c4dba8ff48a.png)

图-33

解决办法：可以重新启动一下openstack-nova-console

2）若出现云主机处于错误状态，如图-34所示：

![img](https://img-blog.csdnimg.cn/img_convert/eb8a449ec309386b66535ec90625d427.png)

图-34

解决办法：

可能是主机down掉

可能是内存不足

可能是内网出现了问题，检查内网，或者把内网删除（不会建立的可以参考案例4），重新建立，之后重新启动openstack

```shell
[root@openstack ~]# systemctl restart openstack-nova-compute
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Prometheus server & Prometheus monitored end & Grafana & and monitoring database | Cloud computing )

---

# 1. Prometheus监控服务器

## 1.1 问题

本案例要求部署prometheus监控服务器，完成以下任务：

1. 安装监控服务器
2. 修改配置文件
3. 编写service文件，管理服务
4. 查看监控数据

## 1.2 方案

实验需要2台虚拟机，主机信息如表-1所示。

所有主机系统均为CentOS7，提前配置IP、主机名、系统YUM源。

表-1 实验拓扑结构（网卡名称仅供参考，不能照抄）
![在这里插入图片描述](https://img-blog.csdnimg.cn/a8267e5dabbe4e369f7b0e29221e4a94.png)


实验拓扑如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec49d87cb5d74b0a9334b71c9abd3134.png)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装监控软件（192.168.4.10主机操作）**

1）安装软件（软件包在第二阶段素材prometheus_soft.tar.gz中有提供）。

需要提前将软件拷贝到虚拟机。解压即可使用。

```shell
[root@prometheus ~]# tar -xf prometheus_soft.tar.gz
[root@prometheus ~]# cd prometheus_soft
[root@prometheus prometheus_soft]# tar -xf prometheus-2.17.2.linux-386.tar.gz
[root@prometheus prometheus_soft]# ls
[root@prometheus prometheus_soft]# mv prometheus-2.17.2.linux-386 /usr/local/prometheus
[root@prometheus prometheus_soft]# ls /usr/local/prometheus/
```

2）修改prometheus配置文件。

```shell
[root@prometheus ~]# vim /usr/local/prometheus/prometheus.yml
static_configs:
    - targets: ['192.168.4.10:9090']      
#修改最后一行，将IP地址改为本机IP
[root@prometheus ~]# /usr/local/prometheus/promtool check config \
/usr/local/prometheus/prometheus.yml
#检查配置配置文件是否有语法错误
```

3）编写服务service文件，使用systemd管理服务。

```shell
[root@prometheus ~]# vim /usr/lib/systemd/system/prometheus.service
[Unit]
Description=Prometheus Monitoring System
After=network.target
[Service]
ExecStart=/usr/local/prometheus/prometheus \
  --config.file=/usr/local/prometheus/prometheus.yml \
  --storage.tsdb.path=/usr/local/prometheus/data/
[Install]
WantedBy=multi-user.target
#备注：
#--config.file和--storage.tsdb.path都是prometheus这个程序的参数
#可以通过prometheus -h查看这个程序支持哪些参数
#--config.file参数后面指定该程序使用哪个配置文件启动服务
#--storage.tsdb.path参数后面指定该程序将数据存储在哪个目录下
[root@prometheus ~]# systemctl  enable prometheus.service --now
#设置服务器开机自启动服务，并立刻启动该服务
```

3）设置防火墙、SELinux（如果已经关闭则可以忽略此步骤）。

```shell
[root@prometheus ~]#firewall-cmd --set-default-zone=trusted
[root@prometheus ~]#setenforce 0
[root@prometheus ~]#sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

**步骤二：查看监控控制台**

1）查看监控主机、监控数据。

使用浏览器firefox或者google-chrome访问http://192.168.4.10:9090。

查看监控主机，点击《Status》--《Targets》查看主机，效果如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b615ced0be44e5686e440d1a4463610.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

查看具体监控数据，点击《Graph》，选择监控数据，如go_memstats_alloc_bytes，点击《Execute》效果如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ede14f17ca9647bf8863a92d54f4d954.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-3

查看监控数据对应的监控图形，效果如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3e2b700afc724c96a6671e1421140cb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

# 2. Prometheus被监控端

## 2.1 问题

本案例要求配置Prometheus被监控端主机，主要完成以下任务：

1. 安装被监控端软件
2. 编写service文件
3. 修改监控服务器配置文件
4. 查看监控数据

## 2.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：部署被控制端export

1）安装软件（192.168.4.11主机操作）。

安装软件，软件在第二阶段素材prometheus_soft.tar.gz中有提供。

提前将软件拷贝到虚拟机中。

```shell
[root@node1 ~]# tar -xf prometheus_soft.tar.gz
[root@node1 ~]# cd prometheus_soft
[root@node1 prometheus_soft]# tar -xf node_exporter-1.0.0-rc.0.linux-amd64.tar.gz
[root@node1 prometheus_soft]# ls
[root@node1 prometheus_soft]# mv node_exporter-1.0.0-rc.0.linux-amd64 /usr/local/node_exporter
[root@node1 prometheus_soft]# ls /usr/local/node_exporter  
```

2) 编写服务service文件（192.168.4.11主机操作）。

```shell
[root@node1 ~]# vim /usr/lib/systemd/system/node_exporter.service
[Unit]
Description=node_exporter
After=network.target
[Service]
Type=simple
ExecStart=/usr/local/node_exporter/node_exporter
[Install]
WantedBy=multi-user.target
[root@node1 ~]# systemctl  enable node_exporter --now
```

3）设置防火墙、SELinux（如果已经关闭则可以忽略此步骤）。

```shell
[root@node1 ~]#firewall-cmd --set-default-zone=trusted
[root@node1 ~]#setenforce 0
[root@node1 ~]#sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

4) 修改监控服务器配置文件（192.168.4.10主机操作）。

参考配置文件最后的模板，在文件末尾添加3行新内容，具体内容如下：

```shell
[root@prometheus ~]# vim /usr/local/prometheus/prometheus.yml
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
    - targets: ['192.168.4.10:9090']
  - job_name: 'node1'                    #监控任务取任意名称
    static_configs:
    - targets: ['192.168.4.11:9100']    #被监控端主机和端口
[root@prometheus ~]# systemctl  restart prometheus.service
```

5) 查看监控主机、监控数据。

使用浏览器访问http://192.168.4.10:9090。

查看监控主机列表，如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/397dccf9ab274c88888757ce815480b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

查看主机CPU监控数据，如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/12a38b9e7d634fec961dab569595834a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

# 3. grafana可视化监控数据

## 3.1 问题

本案例要求配置grafana实现数据可视化效果，完成以下任务：

1. 安装Grafana
2. 修改grafana配置
3. 导入可视化模板
4. 查看监控图表

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装部署grafana（192.168.4.10主机操作）**

1）安装软件（软件在第二阶段素材prometheus_soft.tar.gz中有提供）

```shell
[root@prometheus ~]# cd prometheus_soft/
[root@prometheus prometheus_soft]# yum -y install grafana-6.7.3-1.x86_64.rpm
[root@prometheus prometheus_soft]# systemctl enable grafana-server.service --now
#设置grafana服务为开机自启动服务，并立刻启动该服务
```

提示：grafana默认启动的是3000端口。

2）重置登录密码

浏览器访问Grafana控制台，http://192.168.4.10:3000

默认用户名和密码都是：admin。

重置密码效果如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/859e61dd4b6a44d9a2bbaabbdc0a26aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-7

附加知识：

有些浏览器问题，可能无法重置密码，如果无法重置密码，则可以设置grafana允许匿名登录，具体操作如下（非必要，不要执行如下操作）：

```shell
[root@prometheus ~]# vim /etc/grafana/grafana.ini
[auth.anonymous]
enabled = true
org_role = Admin
[root@prometheus ~]# systemctl restart grafana-server.service
```

**步骤二：配置Grafana**

浏览器访问Grafana控制台，http://192.168.4.10:3000

1）添加数据源

Grafana可以将数据图形化，那么数据从哪里来呢？

点击《Add data source》，选择从Prometheus获取数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/abef82552b4a45b8a76473705d522ce4.png)
图-8

填写Prometheus基本信息，效果如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/71488ae4c5604650a9e0616018fe6379.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-9

2）导入可视化模板

使用不同的可视化模板就可以将不同的数据进行图形化展示，下面导入prometheus图形化模板，效果如图-10、图-11所示，选择《Prometheus 2.0 Stats》。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cf023eafd0ee4eff82e377d5e0bf9736.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-10

![在这里插入图片描述](https://img-blog.csdnimg.cn/3a4a74cfa47745dbb83eb3e28d815fc5.png)
图-11

查看监控效果如图-12所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/65d26f0d33f0431481900f07c33c6e41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-12

**步骤二：查看被监控主机的系统信息**

1）导入主机监控的可视化模板（node_exporter模板）

模板文件在在第二阶段素材prometheus_soft.tar.gz中有提供。添加效果如图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/702c1b5f08d5413188728f7c77bf9822.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-13

2）选择数据源

导入监控主机的可视化模板后，我们就可以查看主机的监控图形了，但是这个图形的数据从哪里获取呢，需要设置prometheus为数据源，效果如图-14所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c12cbc9fe4bf4a1ba1c31ce2c4ea0659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-14

返回Grafana首页，查看监控图形，效果如图-15、图-16所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3803bac8ceb5444c9c233d37006c8d3e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-15

![在这里插入图片描述](https://img-blog.csdnimg.cn/fa20a080d595492fa57c7833345723c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-16

# 4. 监控数据库

## 4.1 问题

本案例要求使用prometheus监控MariaDB数据库，完成以下任务：

1. 安装数据库
2. 安装数据库exporter
3. 配置数据库账户和密码
4. 导入监控模板

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装MariaDB（被监控主机192.168.4.11操作）**

1）安装软件,启动服务

```shell
[root@node1~]# yum -y install mariadb-server
[root@node1~]# systemctl enable  mariadb --now
```

2）创建数据库账户，配置密码

监控数据库，需要创建一个对数据库有权限的账户并配置密码。

```shell
[root@node1~]# mysql
> grant all on *.* to 'jerry'@'127.0.0.1' identified by '123';
> exit
```

备注：创建用户jerry，该用户可以从本机127.0.0.1登录服务器，该用户的密码为123。

**步骤二：安装配置导出器(exporter)**

（软件在第二阶段素材prometheus_soft.tar.gz中有提供）

1）安装mysqld_exporter导出器（被监控主机192.168.4.11操作）。

```shell
[root@node1 prometheus_soft]# tar -xf mysqld_exporter-0.12.1.linux-amd64.tar.gz
[root@node1 prometheus_soft]# mv mysqld_exporter-0.12.1.linux-amd64 /usr/local/mysqld_exporter
[root@node1 prometheus_soft]# vim /usr/local/mysqld_exporter/.my.cnf
[client]
host=127.0.0.1
port=3306
user=jerry
password=123
```

备注：创建数据库配置文件.my.cnf，到时mysqld_exporter自动读取配置文件，使用配置文件用的账户和密码信息访问数据库，获取数据库监控信息。

2）编写服务service文件，默认端口为9104（被监控主机192.168.4.11操作）。

```shell
[root@node1~]# vim /usr/lib/systemd/system/mysqld_exporter.service
[Unit]
Description=node_exporter
After=network.target
[Service]
ExecStart=/usr/local/mysqld_exporter/mysqld_exporter \
--config.my-cnf=/usr/local/mysqld_exporter/.my.cnf
[Install]
WantedBy=multi-user.target
#备注：
#--config.my-cnf是mysqld_exporter程序的参数，该参数后面指定数据库的配置文件
#可以使用mysqld_exporter -h查看该程序支持哪些参数
[root@node1~]# systemctl enable mysqld_exporter --now 
```

3)修改监控服务器配置文件（192.168.4.10主机操作）。

参考原文的配置模板，最文件最后手动添加如下3行内容，修改后重启服务。

```shell
[root@prometheus ~]# vim /usr/local/prometheus/prometheus.yml
scrape_configs:
… …
  - job_name: 'mysql'                    #监控任务的名称
    static_configs:
    - targets: ['192.168.4.11:9104']    #被监控主机IP和端口
[root@prometheus ~]# systemctl restart prometheus.service
```

**步骤三：配置Grafana可视化**

1）查看监控主机（浏览器访问http://192.168.4.10:9090）。

查看prometheus是否已经识别到MariaDB数据库主机，效果如图-17所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9f3e7b925550490f966523d10811bb51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-17

2）访问Grafana导入数据库可视化模板（浏览器访问http://192.168.4.10:3000）。

导入数据库可视化模板，效果如图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7a823c45427840e290f9d4b42be0d4d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-18

设置数据源，数据来源于Prometheus，效果如图-19所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a589c169527f4726ad77a444eb3d9ad8.png)
图-19

如果离开监控图形时提示保存监控图形，可以任意输入名称即可，如图-20所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ff1f2d4ca080404ea78a8ae4f9d67c66.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-20


# Exercise

## 1 Prometheus默认的数据库是什么类型的数据库

时序数据库（带时间标记的数据库）

## 2 Prometheus默认端口是多少？

9090端口。

## 3 Grafana支持哪些数据源？

Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等。

## 4 MySQL默认的配置文件名？

my.cnf

> 如有侵权，请联系作者删除



﻿@[TOC]( PXC & MySQL storage engine | Cloud computing )

---

# 1 案例1：安装软件

## 1.1 问题

- 环境准备
- 安装软件包

## 1.2 方案

准备3台虚拟主机，配置ip地址和主机名。具体如图-1所示：（不需要安装任何MySQL服务软件）
![在这里插入图片描述](https://img-blog.csdnimg.cn/c9bbd9491c7b40668d227d702e7e7677.png)
图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：环境准备**

配置主机名与ip地址绑定

配置服务器192.168.4.71

```shell
]#  vim /etc/hosts
192.168.4.71     pxcnode71
192.168.4.72     pxcnode72
192.168.4.73     pxcnode73 
:wq
]#hostname  pxcnode71
```

配置服务器192.168.4.72

```shell
]#  vim /etc/hosts
192.168.4.71     pxcnode71
192.168.4.72     pxcnode72
192.168.4.73     pxcnode73 
:wq
]#hostname  pxcnode72
```

配置服务器192.168.4.73

```shell
]#  vim /etc/hosts
192.168.4.71     pxcnode71
192.168.4.72     pxcnode72
192.168.4.73     pxcnode73 
:wq
]#hostname  pxcnode73
```

在任意一台服务器上ping 对方的主机名，ping通为配置成功。

```shell
[root@host71 ~]# ping -c 2  pxcnode71  //成功
PING pxcnode71 (192.168.4.71) 56(84) bytes of data.
64 bytes from pxcnode71 (192.168.4.71): icmp_seq=1 ttl=255 time=0.011 ms
64 bytes from pxcnode71 (192.168.4.71): icmp_seq=2 ttl=255 time=0.020 ms
--- pxcnode71 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.011/0.015/0.020/0.006 ms
[root@host71 ~]# 
[root@host71 ~]# 
[root@host71 ~]# ping -c 2  pxcnode72 //成功
PING pxcnode72 (192.168.4.72) 56(84) bytes of data.
64 bytes from pxcnode72 (192.168.4.72): icmp_seq=1 ttl=255 time=0.113 ms
64 bytes from pxcnode72 (192.168.4.72): icmp_seq=2 ttl=255 time=0.170 ms
--- pxcnode72 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.113/0.141/0.170/0.030 ms
[root@host71 ~]# 
[root@host71 ~]# 
[root@host71 ~]# ping -c 2  pxcnode73 //成功
PING pxcnode73 (192.168.4.73) 56(84) bytes of data.
64 bytes from pxcnode73 (192.168.4.73): icmp_seq=1 ttl=255 time=0.198 ms
64 bytes from pxcnode73 (192.168.4.73): icmp_seq=2 ttl=255 time=0.155 ms
--- pxcnode73 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.155/0.176/0.198/0.025 ms
[root@host71 ~]#
```

步骤二：安装软件包

1）在192.168.4.71 服务器安装软件包

软件包之间有依赖注意软件包安装顺序

```shell
]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm    //安装依赖
]# yum  -y  install  percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
 ]# rpm -ivh qpress-1.1-14.11.x86_64.rpm     //安装依赖
 ]# tar -xvf  Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
 ]# yum -y  install  Percona-XtraDB-Cluster-*.rpm
```

2）在192.168.4.72 服务器安装软件包

```shell
]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm    //安装依赖
]# yum  -y  install  percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
]# rpm -ivh qpress-1.1-14.11.x86_64.rpm     //安装依赖
]# tar -xvf  Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
]# yum -y  install  Percona-XtraDB-Cluster-*.rpm
```

3）在192.168.4.73 服务器安装软件包

```shell
]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm    //安装依赖
]# yum  -y  install  percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
]# rpm -ivh qpress-1.1-14.11.x86_64.rpm     //安装依赖
]# tar -xvf  Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
]# yum -y  install  Percona-XtraDB-Cluster-*.rpm
```

# 2. 配置服务

## 2.1 问题

- 修改mysqld.cnf文件
- 修改mysqld_safe.cnf文件
- 修改wsrap.cnf文件
- 启动服务

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：修改mysqld.cnf文件**

1）分别修改3台服务器的mysqld.cnf文件

```shell
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
[mysqld]
server-id=71                      //server-id 不允许重复
datadir=/var/lib/mysql                  //数据库目录
socket=/var/lib/mysql/mysql.sock         //socket文件
log-error=/var/log/mysqld.log        //日志文件
pid-file=/var/run/mysqld/mysqld.pid    //pid文件
log-bin                    //启用binlog日志
log_slave_updates            //启用链式复制
expire_logs_days=7            //日志文件保留天数
:wq
```

修改服务器192.168.4.72

```shell
[root@pxcnode72 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
[mysqld]
server-id=72                      //server-id 不允许重复
datadir=/var/lib/mysql                  //数据库目录
socket=/var/lib/mysql/mysql.sock         //socket文件
log-error=/var/log/mysqld.log        //日志文件
pid-file=/var/run/mysqld/mysqld.pid    //pid文件
log-bin                    //启用binlog日志
log_slave_updates            //启用链式复制
expire_logs_days=7            //日志文件保留天数
:wq
```

修改服务器192.168.4.73

```shell
[root@pxcnode73 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
[mysqld]
server-id=73                      //server-id 不允许重复
datadir=/var/lib/mysql                  //数据库目录
socket=/var/lib/mysql/mysql.sock         //socket文件
log-error=/var/log/mysqld.log        //日志文件
pid-file=/var/run/mysqld/mysqld.pid    //pid文件
log-bin                    //启用binlog日志
log_slave_updates            //启用链式复制
expire_logs_days=7            //日志文件保留天数
:wq
```

**步骤二：修改mysqld_safe.cnf文件**

1）分别修改3台服务器的mysqld_safe.cnf （使用默认配置即可）

```shell
//修改服务器192.168.4.71
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf
[mysqld_safe]
pid-file = /var/run/mysqld/mysqld.pid
socket   = /var/lib/mysql/mysql.sock
nice     = 0
:wq
//修改服务器192.168.4.72
[root@pxcnode72 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf
[mysqld_safe]
pid-file = /var/run/mysqld/mysqld.pid
socket   = /var/lib/mysql/mysql.sock
nice     = 0
:wq
//修改服务器192.168.4.73
[root@pxcnode73 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf
[mysqld_safe]
pid-file = /var/run/mysqld/mysqld.pid
socket   = /var/lib/mysql/mysql.sock
nice     = 0
:wq
```

**步骤三：修改wsrep.cnf文件**

分别修改3台服务器的wsrep.cnf,其中成员列表、集群名、SST用户和密码必须相同

```shell
//修改服务器192.168.4.71
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73//成员列表
wsrep_node_address=192.168.4.71 //本机ip
wsrep_cluster_name=pxc-cluster //集群名
wsrep_node_name=pxcnode71 //本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //SST数据同步授权用户及密码
:wq
//修改服务器192.168.4.72
[root@pxcnode72 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73//成员列表
wsrep_node_address=192.168.4.72 //本机ip
wsrep_cluster_name=pxc-cluster //集群名
wsrep_node_name=pxcnode72 //本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //SST数据同步授权用户及密码
:wq
//修改服务器192.168.4.73
[root@pxcnode73 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73//成员列表
wsrep_node_address=192.168.4.73 //本机ip
wsrep_cluster_name=pxc-cluster //集群名
wsrep_node_name=pxcnode73 //本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //SST数据同步授权用户及密码
:wq
```

**步骤四：启动服务**

1）集群初始化

注意：在任意一台服务器上执行即可且只能执行一遍，首次启动服务时间比较长

```shell
[root@pxcnode71 ~]# ]# systemctl  start mysql@bootstrap.service  //启动集群服务
[root@pxcnode71 ~]# grep pass /var/log/mysqld.log     //查看数据库管理员初始登录密码
2019-06-20T12:29:42.489377Z 1 [Note] A temporary password is generated for root@localhost: W.HiOb8(ok)_
[root@pxcnode71 ~]#mysql –uroot –p’ W.HiOb8(ok)_’ //使用初始密码登录
Mysql> alter user  root@”localhost” identified by “123456”;//修改登录密码
MySQL> exit; //断开连接
[root@pxcnode71 ~]#mysql –uroot –p123456 //使用修改后的密码登录
Mysql> garnt reload, lock tables,replication client,process on *.*  to
sstuser@"localhost” identified by  “123qqq…A”; //添加SST用户
MySQL> exit;
[root@pxcnode71 ~]#
```

2）启动数据库服务

启动主机pxcnode72的数据库服务，会自动同步pxcnode71主机的root初始密码和授权用户sstuser

```shell
[root@pxcnode72 ~]# systemctl  start mysql  //启动数据库服务
[root@pxcnode72 ~]#
[root@pxcnode72 ~]# netstat -utnlp  | grep :3306
tcp6       0      0 :::3306                 :::*                    LISTEN      12794/mysqld        
[root@pxcnode72 ~]# netstat -utnlp  | grep :4567 //查看集群端口
tcp        0      0 0.0.0.0:4567            0.0.0.0:*               LISTEN      12794/mysqld        
[root@host72 ~]#
```

启动主机pxcnode73的数据库服务，会自动同步pxcnode71主机的root初始密码和授权用户sstuser

```shell
[root@pxcnode73 ~]# systemctl  start mysql  //启动数据库服务
[root@pxcnode73 ~]#
[root@pxcnode73 ~]# netstat -utnlp  | grep :3306
tcp6       0      0 :::3306                 :::*                    LISTEN      12794/mysqld        
[root@pxcnode73 ~]# netstat -utnlp  | grep :4567 //查看集群端口
tcp        0      0 0.0.0.0:4567            0.0.0.0:*               LISTEN      12794/mysqld        
[root@host73 ~]#
```

# 3. 测试配置

## 3.1 问题

1. 查看集群信息
2. 访问集群，存取数据
3. 测试故障自动恢复

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：查看集群信息**

1）启动数据库服务

在任意一台数据查看都可以。

```shell
[root@pxcnode71 ~]# mysql -uroot -p123456
wsrep_incoming_addresses 192.168.4.71:3306,192.168.4.72:3306,192.168.4.73:3306 //集群成员列表 
wsrep_cluster_size       3 //集群服务器台数
wsrep_cluster_status   Primary     //主机状态                           
wsrep_connected        ON            //连接状态
wsrep_ready             ON           //服务状态
```

**步骤二：访问集群，存取数据**

1）添加访问数据的连接用户 （在任意一台服务器上添加都可以，另外的2台服务器会自动同步授权用户）

```shell
[root@pxcnode72 ~]# mysql  -uroot  -p123456
mysql> grant all on  gamedb.*  to yaya@"%" identified by "123456"; //添加授权用户
Query OK, 0 rows affected, 1 warning (0.18 sec)
[root@pxcnode71 ~]# mysql -uroot -p123456 -e  'show grants for yaya@"%" ' //查看
mysql: [Warning] Using a password on the command line interface can be insecure.
+--------------------------------------------------+
| Grants for yaya@%                                |
+--------------------------------------------------+
| GRANT USAGE ON *.* TO 'yaya'@'%'                 |
| GRANT ALL PRIVILEGES ON `gamedb`.* TO 'yaya'@'%' |
+--------------------------------------------------+
[root@pxcnode71 ~]#
[root@pxcnode73 ~]# mysql -uroot -p123456 -e  'show grants for yaya@"%" ' //查看
mysql: [Warning] Using a password on the command line interface can be insecure.
+--------------------------------------------------+
| Grants for yaya@%                                |
+--------------------------------------------------+
| GRANT USAGE ON *.* TO 'yaya'@'%'                 |
| GRANT ALL PRIVILEGES ON `gamedb`.* TO 'yaya'@'%' |
+--------------------------------------------------+
[root@pxcnode73 ~]#
```

2）客户端连接集群存取数据 （连接任意一台数据库服务器的ip地址都可以）

连接数据服务器主机73

```shell
client50 ~]# mysql -h192.168.4.73 -uyaya -p123456 //连接服务器73
mysql>
mysql> create database gamedb; //建库
Query OK, 1 row affected (0.19 sec)
mysql>  create table  gamedb.a(id int primary key auto_increment,name char(10));//建表
Query OK, 0 rows affected (1.02 sec)
mysql> insert into gamedb.a(name)values("bob"),("tom"); //插入记录
Query OK, 2 rows affected (0.20 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

3）在另外2台数据库服务器查看数据，客户端连接数据库服务器71主机查看数据。

```shell
client50 ~]# mysql -h192.168.4.71 -uyaya -p123456 //连接服务器71
mysql> select  * from  gamedb.a; //查看记录
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
```

4）客户端连接数据库服务器73主机查看数据

```shell
client50 ~]# mysql -h192.168.4.73 -uyaya -p123456 //连接服务器73
mysql> select  * from  gamedb.a; //查看记录
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
```

**步骤三：测试故障自动恢复**

1）停止数据库服务

停止三台服务器的任意一台主机的数据库服务都不会影响数据的存取。

```shell
[root@pxcnode71 ~]# systemctl  stop  mysql  //停止71主机的数据库服务
```

2）在客户端连接剩下两台服务器，任意一台都可以访问数据

```shell
Client50 ~]# client50 ~]# mysql -h192.168.4.72 -uyaya -p123456 //连接服务器72
mysql> insert into gamedb.a(name)values("bob2"),("tom2");
mysql> insert into gamedb.a(name)values("jerry"),("jack");
Query OK, 2 rows affected (0.20 sec)
Records: 2  Duplicates: 0  Warnings: 0 
```

客户端50，连接数据库主机73，查看数据

```shell
client50 ~]# mysql -h192.168.4.73 -uyaya -p123456 //连接服务器73
mysql> select  * from  gamedb.a;
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
|  7 | bob2  |
|  9 | tom2  |
| 11 | jerry |
| 13 | jack  |
+----+-------+
6 rows in set (0.00 sec)
```

3）启动71主机的数据库服务

数据库服务运行后，会自动同步宕机期间的数据。

```shell
client50 ~]# mysql -h192.168.4.71 -uyaya -p123456 //连接服务器71
mysql> select  * from  gamedb.a;
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
|  7 | bob2  |
|  9 | tom2  |
| 11 | jerry |
| 13 | jack  |
+----+-------+
rows in set (0.00 sec)
```

# 4. MySQL存储引擎

## 4.1 问题

具体如下：

1. MySQL服务存储引擎管理
2. 表存储引擎管理

## 4.2 步骤

实现此案例需要在192.168.4.50主机按照如下步骤进行。

**步骤一：MySQL服务存储引擎管理**

1）查看存储引擎

执行SHOW ENGINES\G指令可列表查看，MySQL 5.6可用的存储引擎有9种（除最后的FEDERATED以外，其他8种都支持），其中默认采用的存储引擎为InnoDB

```shell
//管理员登录
[root@host50 ~]# mysql -uroot -pNSD123...a 
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.17-log MySQL Community Server (GPL)
……
……
mysql> 
//查看存储引擎
mysql> SHOW ENGINES\G
*************************** 1. row ***************************
      Engine: InnoDB //默认存储引擎
     Support: DEFAULT                              
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: FEDERATED
     Support: NO                             
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
9 rows in set (0.01 sec)
```

2）修改服务默认使用的存储引擎

在 mysql> 环境中，可以直接通过SET指令更改默认的存储引擎（只在本次连接会话过程中有效，退出重进即失效） 。比如临时修改为MyISAM，可执行下列操作：

```shell
mysql> SET default_storage_engine=MyISAM;              //改用MyISAM引擎
Query OK, 0 rows affected (0.00 sec)
mysql> SHOW VARIABLES LIKE 'default_storage_engine';          //确认结果
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)
```

若希望直接修改MySQL服务程序所采用的默认存储引擎，应将相关设置写入配置文件/etc/my.cnf，并重启服务后生效。比如：

```shell
[root@dbsvr1 ~]# vim /etc/my.cnf
[mysqld]
.. ..
default_storage_engine=myisam                              //改用myisam引擎
[root@dbsvr1 ~]# systemctl  restart mysqld.service           //重启服务
```

重新登入确认修改结果：

```shell
[root@dbsvr1 ~]# mysql -uroot –Pnsd123…a
……
……
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MYISAM |                  //默认引擎已修改
+------------------------+--------+
1 row in set (0.00 sec)
mysql> exit
Bye
```

**步骤二：表存储引擎管理**

1）查看表使用的存储引擎

通过查看建表命令，显示表使用的存储引擎

```shell
mysql> show create table user \G  //查看建表命令
*************************** 1. row ***************************
       Table: user
Create Table: CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` char(50) DEFAULT NULL,
  `age` tinyint(3) unsigned DEFAULT '19',
  `password` char(1) DEFAULT NULL,
  `uid` int(11) DEFAULT NULL,
  `gid` int(11) DEFAULT NULL,
  `comment` char(150) DEFAULT NULL,
  `homedir` char(50) DEFAULT NULL,
  `shell` char(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=latin1  //存储引擎是InnoDB
1 row in set (0.00 sec)
mysql>
```

2）设置表使用的存储引擎

```shell
//建表时，指定表使用的存储引擎
mysql> create table tarena.stuinfo( name char(10) , age int ) engine=memory;
Query OK, 0 rows affected (0.06 sec)
//查看表文件
mysql> system ls /var/lib/mysql/tarena/stuinfo.*
/var/lib/mysql/tarena/stuinfo.frm
mysql> 
//修改表使用的存储引擎
mysql> alter table tarena.stuinfo engine=innodb;
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
//查看表文件
mysql> system ls /var/lib/mysql/tarena/stuinfo.*
/var/lib/mysql/tarena/stuinfo.frm
/var/lib/mysql/tarena/stuinfo.ibd  
mysql> 
//不指定存储引擎，使用服务默认存储引擎
mysql> create table tarena.stuinfo2( name char(10) , age int );
Query OK, 0 rows affected (0.20 sec)
//查看表文件
mysql> system ls /var/lib/mysql/tarena/stuinfo2.*
/var/lib/mysql/tarena/stuinfo2.frm  
/var/lib/mysql/tarena/stuinfo2.MYD
/var/lib/mysql/tarena/stuinfo2.MYI
mysql> 
```

# 5. 事务特性

## 5.1 问题

具体操作如下：

1. 练习事务回滚
2. 练习事务隔离级别

## 5.2 步骤

实现此案例需要在192.168.4.50主机按照如下步骤进行。

**步骤一：练习事务回滚**

1）事务的创建

```shell
[root@host50 ~]# mysql -uroot –Pnsd123…a  //管理员登录
mysql> 
//查看自动提交状态
mysql> show variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)
```

显示事务：

```shell
mysql> set autocommit=0;  //只对当前会话生效
Query OK, 0 rows affected (0.00 sec)
mysql> show variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)
```

2）事务执行步骤

第一步：开启事务

```shell
set aotocommit=0;
start transaction;    # 可选
```

第二步:编写事务语句

```shell
INSERT、UPDATE、DELETE  语句
```

第三步:结束事务

```shell
commit | rollback;
```

3）事务示例

```shell
//创建银行表
mysql> create table tarena.bank(
    ->   id int primary key,
    ->   name varchar(20),
    ->   balance int
    -> )engine=innodb;
//插入记录
mysql> insert into tarena.bank values(1,"jim",10000),(2,"tom",20000);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
//查看记录
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10000 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
//验证事务
Mysql> set autocommit=0; #关闭自动提交
//修改字段值
mysql> update tarena.bank set balance=balance-800 where id = 1; #减800
Query OK, 1 row affected (0.05 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> update tarena.bank set balance=balance+800 where id = 2; #加800
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//查看修改
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |    9200 |
|  2 | tom  |   20800 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
//打开新终端，连接数据库服务，查看记录
mysql> select  * from tarena.bank;#发现记录没改，因为对方没有提交
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10000 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
//回到 set autocommit = 0 的 终端
mysql> rollback ; #执行回滚命令，因为没有提交可以回滚
Query OK, 0 rows affected (0.26 sec)
mysql> select  * from  tarena.bank;#数据被回滚到没有修改前。
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10000 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
```

4）SAVEPOINT应用
使用mysql中的savepoint保存点来实现事务的部分回滚

语法:

```shell
SAVEPOINT identifier
ROLLBACK [WORK] TO [SAVEPOINT] identifier
RELEASE SAVEPOINT identifier
```

说明:
使用 SAVEPOINT identifier 来创建一个名为identifier的回滚点
ROLLBACK TO identifier，回滚到指定名称的SAVEPOINT，这里是identifier
使用 RELEASE SAVEPOINT identifier 来释放删除保存点identifier
如果当前事务具有相同名称的保存点，则将删除旧的保存点并设置一个新的保存点。
如果执行START TRANSACTION，COMMIT和ROLLBACK语句，则将删除当前事务的所有保存点。

SAVEPOINT示例:

```shell
//关闭自动提交
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)
//修改记录
mysql>  update tarena.bank set balance=balance+500 where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//修改前定义保存点名称为a
mysql> savepoint a;
Query OK, 0 rows affected (0.00 sec)
//执行修改
mysql>  update tarena.bank set balance=balance+400 where id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//查看记录
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20400 |
+----+------+---------+
2 rows in set (0.00 sec)
//回滚到保存点a
mysql> rollback to a;
Query OK, 0 rows affected (0.00 sec)
//查看数据
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20000 |   #数据还原了
+----+------+---------+
2 rows in set (0.00 sec)
```

**步骤二：练习事务隔离级别**
1）查看当前事务隔离级别

```shell
mysql> select @@tx_isolation;  #可重复读
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ | 
+-----------------+
1 row in set (0.00 sec)
mysql> mysql>
```

2）修改事务隔离级别

```shell
//设置事务隔离级别 读未提交
mysql> set session transaction isolation level read uncommitted ;
Query OK, 0 rows affected (0.00 sec)
mysql> select @@tx_isolation; 
+------------------+
| @@tx_isolation   |
+------------------+
| READ-UNCOMMITTED |
+------------------+
1 row in set (0.00 sec)
mysql>
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
mysql> set autocommit=0;
mysql> update tarena.bank set balance=balance+100 where id =1 ;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10600 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
//没有查看到改变数据
mysql> select  * from tarena.bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
//设置事务隔离级别 读未提交
mysql> set session transaction isolation level read uncommitted;
Query OK, 0 rows affected (0.00 sec)
//可以查看到数据了 ，此时id 值 1 的用户已经增加了
mysql> select  * from tarena.bank;  
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10600 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql> 
mysql> rollback;  #执行回滚
Query OK, 0 rows affected (0.00 sec)
mysql> select  * from tarena.bank; #查看数据
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
mysql>
mysql> select  * from tarena.bank; #id值1 的 数据又减少了
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | jim  |   10500 |
|  2 | tom  |   20000 |
+----+------+---------+
2 rows in set (0.00 sec)
```

# Exercise

## 1 简述MySQL体系结构的组成，并描述每个组成部分的作用。

mysql体系结构包括如下组成部分：

## 2 简述innodb存储引擎和myisam存储引擎的特点。

innodb的特点：支持行级锁、支持外键 、 支持事务 、支持事务回滚。
myisam的特点：支持表级锁、不支持外键 、不支持事务 、不支持事务回滚

## 3 简述PXC集群相关端口号及作用。

> 如有侵权，请联系作者删除



﻿@[TOC]( PyMySQL module & multithreaded programming & Paramiko module | Cloud computing )

---

# 1. 向表中添加数据

## 1.1 问题

1. 向employees表插入数据
2. 向salary表插入数据
3. 插入的数据需要commit到数据库中

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：PyMySQL安装**

1) 安装gcc，有些软件包是C的源码

```shell
[root@localhost ~]# yum install -y gcc
已加载插件：fastestmirror, langpacks
dvd                                                      | 3.6 kB     00:00     
Loading mirror speeds from cached hostfile
匹配 gcc-4.8.5-16.el7.x86_64 的软件包已经安装。正在检查更新。
无须任何处理
```

2)为了加速下载，可以使用国内开源镜像站点

```shell
[root@localhost ~]# mkdir ~/.pip
[root@localhost ~]# vim ~/.pip/pip.conf
[global]
index-url = http://pypi.douban.com/simple/
[install]
trusted-host=pypi.douban.com
```

3)安装pymysql

```shell
[root@localhost ~]# pip3 install pymysql
```

**步骤二：安装mariadb-server**

```shell
[root@localhost ~]# yum install –y mariadb-server
....
已安装：
        mariadb-server.x86_64 1:5.5.56-2.el7
作为依赖被安装：
        mariadb.x86_64 1:5.5.56-2.el7
        perl-DBD-MySQL. x86_64 0:4.023-5.el7
完毕！
[root@localhost ~]# systemctl start mariadb
[root@localhost ~]# systemctl enable mariadb
[root@localhost ~]# mysqladmin password tedu.cn
```

**步骤三：创建数据库**

1)创建数据库

```shell
[root@localhost ~]# mysql -uroot -ptedu.cn    
MariaDB [(none)]> CREATE DATABASE tedu DEFAULT CHARSET 'utf8';
Query OK, 1 row affected (0.00 sec)
```

2)创建部门表

部门表字段：部门ID、部门名称

```shell
MariaDB [(none)]> USE tedu;
Database changed
MariaDB [tedu]> CREATE TABLE departments(dep_id INT PRIMARY KEY, dep_name VARCHAR(20));
Query OK, 0 rows affected (0.04 sec)
```

3)创建员工表

员工表字段：员工编号、姓名、出生日期、部门ID、电话号码、email、引用外键id

```shell
MariaDB [tedu]> CREATE TABLE employees (emp_id INT PRIMARY KEY, emp_name VARCHAR(20) NOT NULL, birth_date DATE, phone CHAR(11), email VARCHAR(50), dep_id INT, FOREIGN KEY(dep_id) REFERENCES departments(dep_id));
Query OK, 0 rows affected (0.05 sec)
````

4)创建工资表

工资表字段：auto_id、员工编号、日期、基本工资、奖金、工资总和

```shell
MariaDB [tedu]> CREATE TABLE salary(auto_id INT AUTO_INCREMENT PRIMARY KEY, date DATE, emp_id INT, basic INT, awards INT, FOREIGN KEY(emp_id) REFERENCES employees(emp_id));
Query OK, 0 rows affected (0.05 sec)
```

**步骤四：向departments表插入数据**

1)新建insert_data.py文件，编写代码如下：

```shell
[root@localhost day10]# vim insert_data.py
import pymysql
1)连接数据库
conn = pymysql.connect(
    host='127.0.0.1',        #连接ip
    port=3306,            #端口号
    user='root',            #数据库用户名
    passwd='tedu.cn',        #数据库密码
    db='tedu',            #数据库名
    charset='utf8'        #设置了数据库的字符集
)
2)创建游标
cursor = conn.cursor()
3)向部门表departments中插入数据
insert1 = "INSERT INTO departments(dep_id, dep_name) VALUES(%s, %s)"
result = cursor.execute(insert1, (1, '人事部'))        # execute执行insert语句
4)将更新提交到数据库
conn.commit()    
5)关闭游标
cursor.close()
6)关闭数据库连接
conn.close()
```

2)执行insert_data.py文件：

```shell
[root@localhost day10]# python3 insert_data.py
```

3)登录mariadb查看结果：

```shell
MariaDB [tedu]>> select * from departments;
+--------+-----------+
| dep_id | dep_name  |
+--------+-----------+
|      1  |  人事部    |
+--------+-----------+
1 row in set (0.00 sec) 
```

4) 向部门表departments中插入数据还可以用如下方法：

```shell
#以上insert_data.py文件第3步可用如下代码替换：
insert1 = "INSERT INTO departments(dep_id, dep_name) VALUES(%s, %s)"
data = [(2, '运维部'), (3, '开发部')]
cursor.executemany(insert1, data)
```

mariadb查看结果如下：

```shell
MariaDB [tedu]>> select * from departments;
+--------+-----------+
| dep_id | dep_name  |
+--------+-----------+
|      1  |  人事部    |
|      2  |  运维部    |
|      3  |  开发部    |
+--------+-----------+
3 rows in set (0.01 sec)
```

**步骤五：向employees表插入数据**

1)新建insert_emp.py文件，编写代码如下：

```shell
[root@localhost day10]# vim insert_emp.py
import pymysql
1)连接数据库
conn = pymysql.connect(
    host='127.0.0.1',        #连接ip
    port=3306,            #端口号
    user='root',            #数据库用户名
    passwd='tedu.cn',        #数据库密码
    db='tedu',            #数据库名
    charset='utf8'        #设置了数据库的字符集
)
2)创建游标
cursor = conn.cursor()
3)向部门表employees中插入数据
insert1 = "INSERT INTO employees(emp_id, emp_name, birth_date,phone, email, dep_id) VALUES(%s, %s, %s, %s, %s, %s)"
result = cursor.execute(insert1, (1, '王君', '2018-9-30',\
 '15678789090', 'wj@163.com', 3))        # execute执行insert语句
4)将更新提交到数据库
conn.commit()    
5)关闭游标
cursor.close()
6)关闭数据库连接
conn.close()
```

2)执行insert_emp.py文件：

```shell
[root@localhost day10]# python3 insert_emp.py
```

3)登录mariadb查看结果：

```shell
MariaDB [tedu]>> select * from employees;
+--------+----------+------------+-------------+------------+--------+
| emp_id | emp_name | birth_date |  phone       | email      | dep_id |
+--------+----------+------------+-------------+------------+--------+
|      1  |    王君   | 2018-09-30 | 15678789090 | wj@163.com |      3 |
+--------+----------+------------+-------------+------------+--------+
 1 row in set (0.00 sec) 
```

4) 向部门表employees中插入数据还可以用如下方法：

```shell
#以上insert_emp.py文件第3步可用如下代码替换：
insert1 = "INSERT INTO employees (dep_id, dep_name) VALUES(%s, %s)"
data = [(2, '运维部'), (3, '开发部')]
cursor.executemany(insert1, data)
```

mariadb查看结果如下：

```shell
MariaDB [tedu]>> select * from departments;
+--------+----------+------------+-------------+------------+--------+
| emp_id | emp_name | birth_date |  phone       | email      | dep_id |
+--------+----------+------------+-------------+------------+--------+
|      1  |   王君    | 2018-09-30 | 15678789090 | wj@163.com |      3 |
|      2  |   李雷    | 2018-09-30 | 15678789090 | wj@163.com |      2 |
|      3  |   张美    | 2018-09-30 | 15678789090 | zm@163.com |      1 |
+--------+----------+------------+-------------+------------+--------+
3 rows in set (0.00 sec)
```

**步骤六：向salary表插入数据**

1)新建insert_sal.py文件，编写代码如下：

```shell
[root@localhost day10]# vim insert_sal.py
import pymysql
1)连接数据库
conn = pymysql.connect(
    host='127.0.0.1',        #连接ip
    port=3306,            #端口号
    user='root',            #数据库用户名
    passwd='tedu.cn',        #数据库密码
    db='tedu',            #数据库名
    charset='utf8'        #设置了数据库的字符集
)
2)创建游标
cursor = conn.cursor()
3)向部门表salary中插入数据
insert2 = "INSERT INTO salary(date, emp_id,basic, awards) VALUES(%s, %s, %s, %s)"
data = [('2018-9-30', 2, 1000, 2000), ('2018-9-30', 3, 3000, 6000),('2018-9-30', 1, 8000, 9000)]
cursor.executemany(insert2, data)
4)将更新提交到数据库
conn.commit()    
5)关闭游标
cursor.close()
6)关闭数据库连接
conn.close()
```

2)执行insert_sal.py文件：

```shell
[root@localhost day10]# python3 insert_sal.py
```

3)登录mariadb查看结果：

```shell
MariaDB [tedu]>> select * from salary;
+---------+------------+--------+-------+--------+
| auto_id | date       | emp_id | basic | awards |
+---------+------------+--------+-------+--------+
|       1 | 2018-09-30 |      2  |  1000 |   2000 |
|       2 | 2018-09-30 |      3  |  3000 |   6000 |
|       3 | 2018-09-30 |      1  |  8000 |   9000 |
+---------+------------+--------+-------+--------+
3 rows in set (0.01 sec) 
```

# 2. 扫描存活主机

## 2.1 问题

创建mtping.py脚本，实现以下功能：

1. 通过ping测试主机是否可达
2. 如果ping不通，不管什么原因都认为主机不可用
3. 通过多线程方式实现并发扫描

## 2.2 方案

subprocess.call ()方法可以调用系统命令，其返回值是系统命令退出码，也就是如果系统命令成功执行，返回0，如果没有成功执行，返回非零值。

调用Ping对象，可以调用系统的ping命令，通过退出码来判断是否ping通了该主机。如果顺序执行，每个ping操作需要消耗数秒钟，全部的254个地址需要10分钟以上。而采用多线程，可以实现对这254个地址同时执行ping操作，并发的结果就是将执行时间缩短到了10秒钟左右。

##  2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day09]# vim mtping.py
#!/usr/bin/env python3
import subprocess
import threading
def ping(host):
    rc = subprocess.call(
        'ping -c2 %s &> /dev/null' % host,
        shell=True
    )
    if rc:
        print('%s: down' % host)
    else:
        print('%s: up' % host)
if __name__ == '__main__':
    ips = ['172.40.58.%s' % i for i in range(1, 255)]
    for ip in ips:
        # 创建线程，ping是上面定义的函数, args是传给ping函数的参数
        t = threading.Thread(target=ping, args=(ip,))
        t.start()  # 执行ping(ip)
```

面向对象代码编写方式如下：

定义Ping类，该类可实现允许ping通任何主机功能：

1. 利用__init__方法初始化参数，当调用Ping类实例时，该方法自动调用

2. 利用__call__()方法让Ping类实例变成一个可调用对象调用，调用t.start()时， 引用subprocess模块执行shell命令ping所有主机，将执行结果返回给rc变量，此时，如果ping不通返回结果为1，如果能ping通返回结果为0

3. 如果rc变量值不为0，表示ping不通，输出down

4. 否则，表示可以ping通，输出up

利用列表推导式生成整个网段的IP地址列表[172.40.58.1,172.40.58.2....]

循环遍历整个网段列表，直接利用 Thread 类来创建线程对象，执行Ping(ip)。

```shell
[root@localhost day09]# vim mtping2.py
#!/usr/bin/env python3
import threading
import subprocess
class Ping:
    def __init__(self, host):
        self.host = host
    def __call__(self):
        rc = subprocess.call(
            'ping -c2 %s &> /dev/null' % self.host,
            shell=True
        )
        if rc:
            print('%s: down' % self.host)
        else:
            print('%s: up' % self.host)
if __name__ == '__main__':
    ips = ('172.40.58.%s' % i for i in range(1, 255))  # 创建生成器
    for ip in ips:
        # 创建线程，Ping是上面定义的函数
        t = threading.Thread(target=Ping(ip))  # 创建Ping的实例
        t.start()   #执行Ping(ip)
```

**步骤二：测试脚本执行**

```shell
[root@localhost day09]# python3 udp_time_serv.py 
172.40.58.1: up
172.40.58.69: up
172.40.58.87: up
172.40.58.90: up
172.40.58.102: up
172.40.58.101: up
172.40.58.105: up
172.40.58.106: up
172.40.58.108: up
172.40.58.110: up
172.40.58.109: up
...
...
...
...
172.40.58.241: down
172.40.58.242: down
172.40.58.243: down
172.40.58.245: down
172.40.58.246: down
172.40.58.248: down
172.40.58.247: down
172.40.58.250: down
172.40.58.249: down
172.40.58.251: down
172.40.58.252: down
172.40.58.253: down
172.40.58.254: down
```

# 3. 利用多线程实现ssh并发访问

## 3.1 问题

编写一个remote_comm.py脚本，实现以下功能：

1. 在文件中取出所有远程主机IP地址
2. 在shell命令行中接受远程服务器IP地址文件、远程服务器密码以及在远程主机上执行的命令
3. 通过多线程实现在所有的远程服务器上并发执行命令

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装paramiko**

paramiko 遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接，可以实现远程文件的上传，下载或通过ssh远程执行命令。

```shell
[root@localhost ~]# pip3 install paramiko
...
...
Successfully installed bcrypt-3.1.4 paramiko-2.4.1 pyasn1-0.4.4 pynacl-1.2.1
You are using pip version 9.0.1, however version 18.0 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
```

测试是否安装成功

```shell
>>> import paramiko
>>>
```

**步骤二：编写脚本**

```shell
[root@localhost day11]# vim remote_comm.py
#!/usr/bin/env python3
import sys
import getpass
import paramiko
import threading
import os
#创建函数实现远程连接主机、服务器密码以及在远程主机上执行的命令的功能
def remote_comm(host, pwd, command):
#创建用于连接ssh服务器的实例
    ssh = paramiko.SSHClient()
#设置自动添加主机密钥
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
#连接ssh服务器，添加连接的主机、用户名、密码填好
    ssh.connect(hostname=host, username='root', password=pwd)
#在ssh服务器上执行指定命令，返回3项类文件对象，分别是，输入、输出、错误
    stdin, stdout, stderr = ssh.exec_command(command)
#读取输出
    out = stdout.read()
#读取错误
    error = stderr.read()
#如果有输出
    if out:
#打印主机输出内容
        print('[%s] OUT:\n%s' % (host, out.decode('utf8')))
#如果有错误
    if error:
#打印主机错误信息
        print('[%s] ERROR:\n%s' % (host, error.decode('utf8')))
#程序结束
    ssh.close()
if __name__ == '__main__':
#设定sys.argv长度，确保remote_comm函数中参数数量
    if len(sys.argv) != 3:
        print('Usage: %s ipaddr_file "command"' % sys.argv[0])
        exit(1)
#判断命令行上输入如果不是文件，确保输入的是文件  
    if not os.path.isfile(sys.argv[1]):
        print('No such file:', sys.argv[1])
        exit(2)
#fname为存储远程主机ip的文件，用sys.argv方法，可以在执行脚本时再输入文件名，更为灵活
    fname = sys.argv[1]
#command为在远程主机上执行的命令，用sys.argv方法，可以在执行脚本时再输入相应命令，command为remote_comm函数第三个参数
    command = sys.argv[2]
#通过getpass输入远程服务器密码，pwd为remote_comm函数第二个参数
    pwd = getpass.getpass()
#打开存有远程主机ip的文件
    with open(fname) as fobj:
#将遍历文件将ip以列表形式存入ips，line.strip()可以去掉每行ip后\n
        ips = [line.strip() for line in fobj]
#循环遍历列表，获取ip地址，ip为remote_comm函数第一个参数
    for ip in ips:
#将读取到的ip地址作为remote_comm函数实际参数传递给函数，ips中有几个ip地址循环几次
#创建多线程
        t = threading.Thread(target=remote_comm, args=(ip, pwd, command))
#启用多线程
        t.start()
```

**步骤三：测试脚本执行**

```shell
#参数给少了效果如下：
[root@localhost day11]# python3 remote_comm.py server_addr.txt
Usage: remote_comm.py ipaddr_file “command”
#参数给多了效果如下：
[root@localhost day11]# python3 remote_comm.py server_addr.txt id zhangsan
Usage: remote_comm.py ipaddr_file “command”
#正常显示如下：
[root@localhost day11]# python3 remote_comm.py server_addr.txt “id zhangsan”
Password:
[192.168.4.2] OUT:
uid=1001(zhangsan) gid=1001(zhangsan) 组=1001(zhangsan)
[192.168.4.3] OUT:
uid=1001(zhangsan) gid=1001(zhangsan) 组=1001(zhangsan)
[root@localhost day11]# python3 remote_comm.py server_addr.txt “echo redhat | passwd –stdin root”
Password:
[192.168.4.3] OUT:
更改用户root的密码：
passwd：所有的身份验证令牌已经成功更新。
[192.168.4.2] OUT:
更改用户root的密码：
passwd：所有的身份验证令牌已经成功更新。
#此时密码已经变成redhat
[root@localhost day11]# python3 remote_comm.py server_addr.txt “id zhangsan”
Password:
[192.168.4.2] OUT:
uid=1001(zhangsan) gid=1001(zhangsan) 组=1001(zhangsan)
[192.168.4.3] OUT:
uid=1001(zhangsan) gid=1001(zhangsan) 组=1001(zhangsan)
```


# Exercise

## 1 安装pymysql模块的方法有哪些？

- 在线安装

```shell
pip install pymysql
```

- 访问http://pypi.python.org，下载pymysql模块后本地通过pip安装

```shell
pip3 install PyMySQL-0.8.0.tar.gz
```

- 访问http://pypi.python.org，下载pymysql模块后本地安装

```shell
tar xzf PyMySQL-0.8.0.tar.gz
cd PyMySQL
python3 setup.py install
```

## 2 通过pip在线安装模块，如何提升速度？

- pip直接安装模块时，连接到的是国外官网。如果采用国内镜像站点，可以提升效率，方法如下：

```shell
[root@localhost ~]# mkdir ~/.pip/
[root@localhost ~]# vim ~/.pip/pip.conf 
[global]
index-url=http://pypi.douban.com/simple/
[install]
trusted-host=pypi.douban.com
```

## 3 使用pymysql操作数据库的一般流程是什么？

- 先连接数据库
- 创建游标
- 通过游标对数据库进行各项操作
- 如果是增删改操作，需要确认
- 关闭到数据库的连接

## 4 通过paramiko管理远程服务器的一般流程是什么？

- 创建SSHClient实例
- 设置添加主机密钥策略
- 连接ssh服务器
- 执行指定命令
- 在shell命令行中接受用于连接远程服务器的密码以及在远程主机上执行的命令

> 如有侵权，请联系作者删除



﻿@[TOC]( Regular expressions & basic usage of SED & sed application cases | Cloud computing )

---

# 1. 使用正则表达式

## 1.1 问题

本案例要求熟悉正则表达式的编写，完成以下任务：

- 利用egrep工具练习正则表达式的基本用法

## 1.2 方案

表－1 基本正则列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/de1e2bddd7fe4789bd44e8bf288fdf98.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)

表－1 扩展正则列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/652d0454bbb14783bffb4eb3e7d28748.png)


## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：正则表达式匹配练习**

1）典型的应用场合：grep、egrep检索文本行

grep命令不带-E选项时，支持基本正则匹配模式。比如“word”关键词检索、“^word”匹配以word开头的行、“word$”匹配以word结尾的行……等等。

输出以“r”开头的用户记录：

```shell
[root@svr5 ~]# grep '^r' /etc/passwd
root:x:0:0:root:/root:/bin/bash
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
```

输出以“localhost”结尾的行：

```shell
[root@svr5 ~]# grep 'localhost$' /etc/hosts
127.0.0.1               localhost.localdomain localhost
```

若希望在grep检索式同时组合多个条件，比如输出以“root”或者以“daemon”开头的行：

```shell
[root@svr5 ~]# grep '^root|^daemon' /etc/passwd          //搜索无结果
[root@svr5 ~]#
```

而若若使用grep -E或egrep命令，可支持扩展正则匹配模式，能够自动识别 |、{} 等扩展正则表达式中的特殊字符，用起来更加方便，比如：

```shell
[root@svr5 ~]# grep -E '^(root|daemon)' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
```

或者

```shell
[root@svr5 ~]# egrep '^(root|daemon)' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
```

使用grep -E 与 使用egrep命令完全等效，推荐使用后者，特别是涉及到复杂的正则表达式的时候。

2）grep、egrep命令的-q选项

选项 -q 表示 quiet（静默）的意思，结合此选项可以只做检索而并不输出，通常在脚本内用来识别查找的目标是否存在，通过返回状态 $? 来判断，这样可以忽略无关的文本信息，简化脚本输出。

比如，检查/etc/hosts文件内是否存在192.168.4.4的映射记录，如果存在则显示“YES”，否则输出“NO”，一般会执行：

```shell
[root@svr5 ~]# grep '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
192.168.4.4     svr5.tarena.com svr5
YES
```

这样grep的输出信息和脚本判断后的提示混杂在一起，用户不易辨别，所以可以改成以下操作：

```shell
[root@svr5 ~]# grep -q '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
YES
```

是不是清爽多了，从上述结果也可以看到，使用 -q 选项的效果与使用 &> /dev/null的效果类似。

3）基本元字符 ^、$ —— 匹配行首、行尾

输出注释的配置行（以#开头的行）：

```shell
[root@svr5 ~]# egrep '^#' /etc/inittab
```

统计本地用户中登录Shell为“/sbin/nologin”的用户个数：

提示：-m10仅在文件中过滤前10次，后面的行不再过滤。

```shell
[root@svr5 ~]# egrep -m10 '/sbin/nologin$' /etc/passwd  //先确认匹配正确
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
[root@svr5 ~]# egrep -c '/sbin/nologin$' /etc/passwd
32                                      //结合 -c 选项输出匹配的行数
```

使用 -c 选项可输出匹配行数，这与通过管道再 wc -l的效果是相同的，但是写法更简便。比如，统计使用“/bin/bash”作为登录Shell的正常用户个数，可执行：

```shell
[root@svr5 ~]# egrep -c '/bin/bash$' /etc/passwd
26
```

或者

```shell
[root@svr5 ~]# egrep '/bin/bash$' /etc/passwd | wc -l
26
```

4）基本元字符 . —— 匹配任意单个字符

以/etc/rc.local文件为例，确认文本内容：

```shell
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

输出/etc/rc.local文件内至少包括一个字符（\n换行符除外）的行，即非空行：

```shell
[root@svr5 ~]# egrep '.' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

输出/etc/rc.local文件内的空行（用 –v 选项将条件取反）：

```shell
[root@svr5 ~]# egrep -v '.' /etc/rc.local
[root@svr5 ~]#
```

上述取空行的操作与下列操作效果相同：

```shell
[root@svr5 ~]# egrep '^$' /etc/rc.local
[root@svr5 ~]#
```

5）基本元字符 +、?、* —— 目标出现的次数

还以/etc/rc.local文件为例：

```shell
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

输出包括 f、ff、ff、……的行，即“f”至少出现一次：

```shell
[root@svr5 ~]# egrep 'f+' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
```

输出包括init、initial的行，即末尾的“ial”最多出现一次（可能没有）：

```shell
[root@svr5 ~]# egrep 'init(ial)?' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
```

输出包括stu、stuf、stuff、stufff、……的行，即末尾的“f”可出现任意多次，也可以没有。重复目标只有一个字符时，可以不使用括号：

```shell
[root@svr5 ~]# egrep 'stuf*' /etc/rc.local
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
```

输出所有行，单独的“.*”可匹配任意行（包括空行）：

```shell
[root@svr5 ~]# egrep '.*' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

输出/etc/passwd文件内“r”开头且以“nologin”结尾的用户记录，即中间可以是任意字符：

```shell
[root@svr5 ~]# egrep '^r.*nologin$' /etc/passwd
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
```

6）元字符 {} —— 限定出现的次数范围

创建一个练习用的测试文件：

```shell
[root@svr5 ~]# vim brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
```

输出包括ababab的行，即“ab”连续出现3次：

```shell
[root@svr5 ~]# egrep '(ab){3}' brace.txt
cdcd ababab
Hello abababab World
```

输出包括abab、ababab、abababab的行，即“ab”连续出现2~4次：

```shell
[root@svr5 ~]# egrep '(ab){2,4}' brace.txt
dedef abab ghighi
cdcd ababab
Hello abababab World
```

输出包括ababab、abababab、……的行，即“ab”最少连续出现3次：

```shell
[root@svr5 ~]# egrep '(ab){3,}' brace.txt
cdcd ababab
Hello abababab World
```

7）元字符 [] —— 匹配范围内的单个字符

还以前面的测试文件bracet.txt为例：

```shell
[root@svr5 ~]# cat brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
```

输出包括abc、abd的行，即前两个字符为“ab”，第三个字符只要是c、d中的一个就符合条件：

```shell
[root@svr5 ~]# egrep 'ab[cd]' brace.txt
ab def ghi abdr
abcab CD-ROM
```

输出包括大写字母的行，使用[A-Z]匹配连续范围：

```shell
[root@svr5 ~]# egrep '[A-Z]' brace.txt
abcab CD-ROM
TARENA IT GROUP
Hello abababab World
```

过滤“非小写字母”的其他字符：

```shell
[root@svr5 ~]# egrep '[^a-z]' brace.txt
```

8）单词边界匹配

以文件/etc/rc.local为例：

```shell
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

输出包括单词“init”的行，文件中“initialization”不合要求：

```shell
[root@svr5 ~]# egrep '\binit\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
```

或者：

```shell
[root@svr5 ~]# egrep '\<init\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
```

输出包括以“ll”结尾的单词的行，使用 \> 匹配单词右边界：

```shell
[root@svr5 ~]# egrep 'll\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
```

或者：

```shell
[root@svr5 ~]# egrep 'll\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
```

9）多个条件的组合

通过dmesg启动日志查看蓝牙设备、网卡设备相关的信息：

```shell
[root@svr5 ~]# egrep -i 'eth|network|bluetooth' /var/log/dmesg
Initalizing network drop monitor service
Bluetooth: Core ver 2.10
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: HCI USB driver ver 2.9
Intel(R) PRO/1000 Network Driver - version 7.3.21-k4-3-NAPI
e1000: eth0: e1000_probe: Intel(R) PRO/1000 Network Connection
```

# 2. sed基本用法

## 2.1 问题

本案例要求熟悉sed命令的p、d、s等常见操作

## 2.2 方案

sed文本处理工具的用法：

```shell
用法1：前置命令 | sed  [选项]  '条件指令'
用法2：sed  [选项]  '条件指令'  文件.. ..
```

相关说明如下：

- 条件可以是行号或者/正则/
- 没有条件时，默认为所有条件
- 指令可以是增、删、改、查等指令
- 默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出
- 选项中可以使用-r选项，让sed支持扩展正则

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：认识sed工具的基本选项**

sed命令的常用选项如下：

-n（屏蔽默认输出，默认sed会输出读取文档的全部内容）
-r（让sed支持扩展正则）
-i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）

1）sed命令的 -n 选项

执行p打印等过滤操作时，希望看到的是符合条件的文本。但不使用任何选项时，默认会将原始文本一并输出，从而干扰过滤效果。比如，尝试用sed输出/etc/hosts的第1行：

```shell
[root@svr5 ~]# sed '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
```

可以发现所有的行都被显示出来了（第1行重复2次）。—— 正确的用法应该添加 -n 选项，这样就可以只显示第1行了：

```shell
[root@svr5 ~]# sed -n '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
```

行号可以是连续的行号，如打印passwd第3到第6行账户的信息：

```shell
[root@svr5 ~]# sed  -n '3,6p' /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

2）sed命令的 -i 选项

正常情况下，sed命令所做的处理只是把操作结果（包括打印、删除等）输出到当前终端屏幕，而并不会对原始文件做任何更改：

```shell
[root@svr5 ~]# sed 'd' /etc/passwd                      //删除所有行
[root@svr5 ~]# cat /etc/passwd                          //查看原始文本，并未改动
```

**若希望直接修改文件内容，应添加选项 -i 。**

比如，直接删除test.txt（自行创建一个任意内容的文件）的第1~4行：

```shell
[root@svr5 ~]# sed -i '1,4d' test.txt            //删除操作
[root@svr5 ~]# cat test.txt                      //确认删除结果
```

下文中关于使用sed修改文件的示例中，为了避免大家在练习过程中因误操作导致系统故障，命令省略 –i 选项，不再逐一说明。需要时，大家可自行加上此选项。

3）多个指令可以使用分号隔离

用分号来隔离多个操作，比如：

```shell
[root@svr5 ~]# sed -n '1p;4p' /etc/passwd
root:x:0:0:root:/root:/bin/bash
adm:x:3:4:adm:/var/adm:/sbin/nologin
```

**步骤二：认识sed工具的条件**
\# sed [选项] '条件指令' 文件.. ..

sed命令可以使用行号或正则做为条件匹配：

1）行号案例

打印第3行：

```shell
[root@svr5 ~]# sed -n '3p' /etc/passwd
```

打印第3到5行：

```shell
[root@svr5 ~]# sed -n '3,5p' /etc/passwd
```

打印第3和5行：

```shell
[root@svr5 ~]# sed -n '3p;5p' /etc/passwd
```

打印奇数行：

```shell
[root@svr5 ~]# sed -n '1~2p' /etc/passwd
```

打印偶数行：

```shell
[root@svr5 ~]# sed -n '2~2p' /etc/passwd
```

2）正则案例

打印包含root的行：

```shell
[root@svr5 ~]# sed -n '/root/p' /etc/passwd
```

打印bash结尾的行：

```shell
[root@svr5 ~]# sed -n '/bash$/p' /etc/passwd
```

3）没有条件，则表示匹配所有行

```shell
[root@svr5 ~]# sed -n 'p' /etc/passwd
```

**步骤三：sed工具的p、d、s操作指令案例集合**

1）下面看看sed工具的p指令案例集锦（自己提前生成一个a.txt文件）

```shell
[root@svr5 ~]# sed  -n 'p' a.txt            //输出所有行，等同于cat a.txt
[root@svr5 ~]# sed  -n '4p' a.txt            //输出第4行
[root@svr5 ~]# sed  -n '4,7p' a.txt        //输出第4~7行
 [root@svr5 ~]# sed  -n '/^bin/p' a.txt        //输出以bin开头的行
[root@svr5 ~]# sed  -n '$=' a.txt            //输出文件的行数
```

2）下面看看sed工具的d指令案例集锦（自己提前生成一个a.txt文件）

```shell
[root@svr5 ~]# sed  '3,5d' a.txt             //删除第3~5行
[root@svr5 ~]# sed  '/xml/d' a.txt            //删除所有包含xml的行
[root@svr5 ~]# sed  '/xml/!d' a.txt         //删除不包含xml的行，!符号表示取反
[root@svr5 ~]# sed  '/^install/d' a.txt    //删除以install开头的行
[root@svr5 ~]# sed  '$d' a.txt                //删除文件的最后一行
[root@svr5 ~]# sed  '/^$/d' a.txt             //删除所有空行
```

3）sed命令的s替换基本功能（s/旧内容/新内容/选项）：

```shell
[root@svr5 ~]# vim  test.txt                //新建素材
2017 2011 2018
2017 2017 2024
2017 2017 2017
[root@svr5 ~]# sed 's/2017/xxxx/'           test.txt
[root@svr5 ~]# sed 's/2017/xxxx/g'          test.txt
[root@svr5 ~]# sed 's/2017/xxxx/2'          test.txt
[root@svr5 ~]# sed 's/2017//2'              test.txt
[root@svr5 ~]# sed -n 's/2017/xxxx/p'      test.txt
```

4）下面看看sed工具的s指令案例集锦（自己提前生成一个a.txt文件）

注意：替换操作的分隔“/”可改用其他字符，如#、&等，便于修改文件路径

```shell
[root@svr5 ~]# sed 's/xml/XML/'  a.txt        //将每行中第一个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/3' a.txt     //将每行中的第3个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/g' a.txt     //将所有的xml都替换为XML
[root@svr5 ~]# sed 's/xml//g'     a.txt     //将所有的xml都删除（替换为空串）
[root@svr5 ~]# sed 's#/bin/bash#/sbin/sh#' a.txt  //将/bin/bash替换为/sbin/sh
[root@svr5 ~]# sed '4,7s/^/#/'   a.txt         //将第4~7行注释掉（行首加#号）
[root@svr5 ~]# sed 's/^#an/an/'  a.txt         //解除以#an开头的行的注释（去除行首的#号）
```

# 3. 使用sed修改系统配置

## 3.1 问题

本案例要求熟悉课上的sed应用案例，并编写脚本anonftp.sh，实现以下功能：

- 通过yum安装vsftpd软件包
- 修改vsftpd服务配置，开启匿名上传
- 调整/var/ftp/pub目录权限，允许写入
- 启动vsftpd服务，并设置开机自运行

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写anonftp.sh脚本，用来装配匿名FTP服务**

1）任务需求及思路分析

vsftpd服务的安装、改目录权限、起服务等操作可以直接写在脚本中。

修改vsftpd.conf配置的工作可以使用sed命令，根据默认配置，只需要定位到以#anon开头的行，去掉开头的注释即可。

2）根据实现思路编写脚本文件

```shell
[root@svr5 ~]# vim anonftp.sh
#!/bin/bash
yum -y install vsftpd                             //安装vsftpd软件
cp /etc/vsftpd/vsftpd.conf{,.bak}                  //备份默认的配置文件
sed -i "s/^#anon/anon/" /etc/vsftpd/vsftpd.conf      //修改服务配置
chmod 777 /var/ftp/pub                              //调整目录权限
systemctl start vsftpd                              //启动服务
systemctl enable vsftpd                            //设为自动运行
[root@svr5 ~]# chmod +x anonftp.sh
[root@svr5 ~]# ./anonftp.sh
```

# 4. sed多行文本处理

## 4.1 问题

本案例要求使用sed工具来完成下列任务操作：

- 修改主机名配置文件
- 修改hosts文件，添加两条映射记录：192.168.4.5 与 svr5.tarena.com、svr5，还有119.75.217.56与www.baidu.com

## 4.2 方案

\# sed [选项] '条件指令' 文件..

sed工具的多行文本处理操作：

- i： 在指定的行之前插入文本
- a：在指定的行之后追加文本
- c：替换指定的行

## 4.3 步骤

基本语法格式案例：

注意：系统默认没有a.txt文件，需要自己创建一个测试文件！！！

```shell
[root@svr5 ~]# sed  '2a XX'   a.txt            //在第二行后面，追加XX
[root@svr5 ~]# sed  '2i XX'   a.txt            //在第二行前面，插入XX
[root@svr5 ~]# sed  '2c XX'   a.txt            //将第二行替换为XX
```

实现此案例需要按照如下步骤进行。

**步骤一：修改主机名配置文件**

1）确认修改前的配置

```shell
[root@svr5 ~]# cat /etc/hostname
svr5.tarena.com
```

2）使用sed修改主机名配置所在行的内容（c整行替换）

```shell
[root@svr5 ~]# sed  '1c mysvr.tarena.com' /etc/hostname 
```

**步骤二：修改hosts文件，添加新的记录**

1）确认修改前的配置

```shell
[root@svr5 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
```

2）使用sed修改hosts文件，添加两行新纪录（a追加）

```shell
[root@svr5 ~]# sed  -i  '$a 192.168.4.5  svr5.tarena.com svr5'  /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.4.5  svr5.tarena.com svr5
```

# 5 案例5：sed综合脚本应用

## 5.1 问题

本案例要求编写脚本getupwd.sh，实现以下需求：

- 找到使用bash作登录Shell的本地用户
- 列出这些用户的shadow密码记录
- 按每行“用户名 --> 密码记录”保存到getupwd.log，如图-1所示
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/aa0191b4bc6a4101870244fcc4c5f599.png)
  图－1

## 5.2 方案

基本思路如下：

1. 先用sed工具取出登录Shell为/bin/bash的用户记录，保存为临 时文件/tmp/urec.tmp，并计算记录数量
2. 再结合while循环遍历取得的账号记录，逐行进行处理
3. 针对每一行用户记录，采用掐头去尾的方式获得用户名、密码字串
4. 按照指定格式追加到/tmp/getuupwd.log文件
5. 结束循环后删除临时文件，报告分析结果

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写getupwd.sh脚本**

```shell
[root@svr5 ~]# vim ./getupwd.sh

#/bin/bash

A=$(grep "bash$" /etc/passwd | sed 's/:.*//') ## 提取符合条件的账号记录

for i in $A ##遍历账号记录

do

pass1=$(grep $i /etc/shadow)

pass2=${pass1#*:}

pass=${pass2%%:*}

echo "$i --> $pass"

done

[root@svr5 ~]# chmod +x ./getupwd.sh
```

**步骤二：测试、验证执行结果**

```shell
[root@svr5 ~]# ./getupwd.sh
```

用户分析完毕，请查阅文件 /tmp/getupwd.log

```shell
[root@svr5 ~]# less /tmp/getupwd.log
root --> $6$IWgMYmRACwdbfwBo$dr8Yn983nswiJVw0dTMjzbDvSLeCd1GMYjbvsDiFEkL8jnXOLcocBQypOCr4C6BRxNowIxjh6U2qeFU0u1LST/
zengye --> $6$Qb37LOdzRl5995PI$L0zTOgnhGz8ihWkW81J.5XhPp/l7x2./Me2ag0S8tRndCBL9nIjHIKkUKulHxJ6TXyHYmffbVgUT6pbSwf8O71
clamav --> !!
mysql --> !!
abc --> !!
.. ..
```

## 总结知识点：

> #sed [选项] '条件指令' 文件

选项:

- -n 屏蔽默认输出
- -r 支持扩展正则
- -i 修改源文件

条件：

- 行号 4 4,5 4~2 4,+10
- /正则/

指令：

- p 打印
- d 删除
- s 替换s/旧/新/g
- a 追加
- i 插入
- c 替换行

# Exercise

## 1 简述egrep工具的-q选项的含义，并验证其在脚本应用中的价值。

选项-q的作用是静默、无任何输出，效果类似于正常的egrep操作添加了&> /dev/null来屏蔽输出。在脚本中当需要检测文本内是否存在指定的关键词时，可以利用egrep -q的返回状态值来作为判断依据，从而简化&>输出的操作。

验证效果可参考：

```shell
[root@svr5 ~]# cat /etc/shells                             //查看测试文本
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
/bin/tcsh
/bin/csh
/bin/zsh 
[root@svr5 ~]# egrep -q '/zsh' /etc/shells && echo yes || echo no
yes                                                          //支持zsh
[root@svr5 ~]# egrep -q '/bsh' /etc/shells && echo yes || echo no 
no                                                         //不支持bsh
```

## 2 正则表达式中的+、？、*分别表示什么含义？

这三个字符用来限制关键词的匹配次数，含义分别如下：

- +：最少匹配一次，比如a+可匹配a、aa、aaa等
- ？：最多匹配一次，比如a?可匹配零个或一个a
- *：匹配任意多次，比如a*可匹配零个或任意多个连续的a

## 3 如何编写正则表达式匹配11位的手机号？

准备测试文件：

```shell
[root@svr5 ~]# cat tel.txt 
01012315
137012345678
13401234567
10086
18966677788
```

提取包含11位手机号的行：

```shell
[root@svr5 ~]# egrep '^1[0-9]{10}$' tel.txt 
13401234567
18966677788
```

## 4 简述sed定址符的作用及表示方式。

- 作用：地址符（执行指令的条件）控制sed需要处理文本的范围；不加定址符则逐行处理所有行
- 表示方式：地址符可以使用行号或正则表达式

## 5 如何使用sed提取文本中的偶数行？

查看测试文本：

```shell
[root@svr5 ~]# cat -n /etc/rc.local 
     1  #!/bin/sh
     2  #
     3  # This script will be executed *after* all the other init scripts.
     4  # You can put your own initialization stuff in here if you don't
     5  # want to do the full Sys V style init stuff.
     6
     7  touch /var/lock/subsys/local
```

提取偶数行的操作及效果：

```shell
[root@svr5 ~]# cat -n /etc/rc.local | sed -n '2~2p'
     2  #
     4  # You can put your own initialization stuff in here if you don't
     6
```

## 6 如何使用sed删除文本中每行的第4个字符？

查看测试文本：

```shell
[root@svr5 ~]# cat /etc/rc.local 
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
```

删除每行第4个字符的操作及效果：

```shell
[root@svr5 ~]# cat /etc/rc.local | sed 's/.//4'
#!/in/sh
#
# Tis script will be executed *after* all the other init scripts.
# Yu can put your own initialization stuff in here if you don't
# wnt to do the full Sys V style init stuff.
touh /var/lock/subsys/local
```

## 7 提取/etc/passwd文件的第6-10行，另存为pass5.txt文件。

提取或导出文本：

```shell
[root@svr5 ~]# sed -n '6,10p' /etc/passwd > pass5.txt
```

确认提取结果：

```shell
[root@svr5 ~]# cat pass5.txt 
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Container image technology reveal & release container server & private image warehouse | Cloud computing )

---

# 1. 创建自定义镜像

## 1.1 问题

本案例要求使用两种方法创建自定义镜像，具体要求如下：

1. 使用 centos镜像 启动容器
2. 在容器中配置 yum 源
3. 安装软件 bash-completion net-tools iproute psmisc vim-enhanced
4. 创建自定义镜像 myos:latest
5. 验证自定义镜像

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：自定义镜像（可以在docker-0001或者docker-0002主机操作）**

1）使用commit方法创建自定义镜像。

使用现有镜像启动容器，在该容器基础上修改，使用commit制作新镜像

```shell
[root@docker-0001 ~]# docker run -it centos:latest
[root@02fd1719c038 ~]# rm -f /etc/yum.repos.d/*.repo
[root@02fd1719c038 ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.myhuaweicloud.com/repo/CentOS-Base-7.repo
[root@02fd1719c038 ~]# yum install -y net-tools vim-enhanced tree bash-completion iproute psmisc && yum clean all
[root@02fd1719c038 ~]# exit
[root@docker-0001 ~]# docker commit 02fd1719c038 myos:latest
```

2）通过Dockerfile创建自定义镜像。

通过docker build命令可以根据 Dockerfile 里的内容生成镜像


编写Dockerfile的语法格式如下：
FROM: 基础镜像
RUN: 制作镜像时执行的命令，可以有多个
ADD: 复制文件到镜像，自动解压
COPY: 复制文件到镜像，不解压
EXPOSE: 声明开放的端口
ENV: 设置容器启动后的环境变量
WORKDIR: 定义容器默认工作目录（等于cd）
CMD: 容器启动时执行的命令，仅可以有一条CMD

具体操作流程如下：
创建目录 mkdir mybuild
在目录中编写 Dockerfile



生成镜像
docker build -t 镜像名称:标签 Dockerfile所在目录



# 2. 创建apache服务镜像

## 2.1 问题

本案例要求使用Dockerfile创建apache服务镜像myos:httpd，实现以下目标：

1. 添加默认网站
2. 设置默认的工作目录/var/www/html

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：查看帮助，熟悉命令格式（可以在docker-0001或者docker-0002操作）**

```shell
[root@docker-0001 ~]# mkdir apache; cd apache
[root@docker-0001 apache]# vim Dockerfile
FROM myos:latest
RUN  yum install -y httpd php
ENV  LANG=C
ADD  webhome.tar.gz  /var/www/html/
WORKDIR /var/www/html/
EXPOSE 80
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
# 拷贝 webhome.tar.gz 到当前目录中
[root@docker-0001 apache]# docker build -t myos:httpd .
# 验证
[root@localhost web]# docker run -itd myos:httpd    
#因为是后台服务，所以要使用-d参数
```



# 3. 创建nginx/php服务镜像

本案例要求使用Dockerfile创建nginx/php服务镜像：

## 3.1 步骤

**步骤一：制作 php 镜像**

```shell
[root@docker-0001 ~]# mkdir php; cd php
[root@docker-0001 php]# vim Dockerfile
FROM myos:latest
RUN  yum install -y php-fpm
EXPOSE 9000
CMD ["/usr/sbin/php-fpm", "--nodaemonize"]
[root@docker-0001 php]# docker build -t myos:php-fpm .
# 验证服务
[root@docker-0001 ~]# docker run -itd myos:php-fpm
deb37734e52651161015e9ce7771381ee6734d1d36bb51acb176b936ab1b3196
[root@docker-0001 ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS
deb37734e526        myos:php-fpm        "/usr/sbin/php-fpm -…"   17 seconds ago      Up 15 seconds       
[root@docker-0001 ~]# docker exec -it deb37734e526 /bin/bash
[root@deb37734e526 ~]# ss -ltun
Netid  State      Recv-Q     Send-Q        Local Address:Port         Peer Address:Port              
tcp    LISTEN     0          128                    *:9000                  *:*                  
[root@deb37734e526 ~]#
```

**步骤二：制作 nginx 镜像**

```shell
# 编译软件包
[root@docker-0001 ~]# yum install -y gcc make pcre-devel openssl-devel
[root@docker-0001 ~]# useradd nginx
[root@docker-0001 ~]# tar -zxvf nginx-1.12.2.tar.gz
[root@docker-0001 ~]# cd nginx-1.12.2
[root@docker-0001 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module
[root@docker-0001 nginx-1.12.2]# make && make install
[root@docker-0001 nginx-1.12.2]# # 拷贝 docker-images/info.html和info.php 到 nginx/html 目录下
[root@docker-0001 nginx-1.12.2]# cd /usr/local/
[root@docker-0001 local]# tar czf nginx.tar.gz nginx
# 制作镜像
[root@docker-0001 local]# mkdir /root/nginx ;cd /root/nginx
[root@docker-0001 nginx]# cp /usr/local/nginx.tar.gz ./
[root@docker-0001 nginx]# vim Dockerfile 
FROM myos:latest
RUN  yum install -y pcre openssl && useradd nginx
ADD  nginx.tar.gz /usr/local/
EXPOSE 80
WORKDIR /usr/local/nginx/html
CMD  ["/usr/local/nginx/sbin/nginx", "-g", "daemon off;"]
[root@docker-0001 nginx]# docker build -t myos:nginx .
[root@docker-0001 nginx]#
# 验证服务
[root@docker-0001 ~]# docker rm -f $(docker ps -aq)
deb37734e526
[root@docker-0001 ~]# docker run -itd myos:nginx
e440b53a860a93cc2b82ad0367172c344c7207def94c4c438027c60859e94883
[root@docker-0001 ~]# curl http://172.17.0.2/info.html
<html>
  <marquee  behavior="alternate">
      <font size="12px" color=#00ff00>Hello World</font>
  </marquee>
</html>
[root@docker-0001 ~]#
```



# 4. 发布容器服务

## 4.1 问题

本案例练习测试docker的端口绑定和主机卷映射服务，分别实现以下目标：

1. 通过映射端口对外发布服务
2. 创建 /var/webroot、 /var/webconf
3. 映射配置文件到容器内，对外发布服务
4. 共享网络命名空间，配置 nginx + php 容器服务

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：通过映射端口发布服务（可以在docker-0001或者docker-0002操作）**

我们使用-p参数把容器端口和宿主机端口绑定，

一个宿主机端口只能绑定一个容器服务。

例如:把宿主机变成 apache

```shell
# 把 docker-0001 变成 apache 服务
[root@docker-0001 ~]# docker run -itd -p 80:80 myos:httpd
# 把 docker-0001 变成 nginx 服务，首先必须停止 apache
[root@docker-0001 ~]# docker stop $(docker ps -q)
[root@docker-0001 ~]# docker run -itd -p 80:80 myos:nginx
```

**步骤二：容器共享卷**

Docker容器不适合保存任何数据，数据文件与配置文件频繁更改，修改多个容器中的数据非常困难，多容器之间有数据共享、同步需求，重要数据在容器内不方便管理易丢失，解决这些问题请使用主机卷映射功能。

Docker可以映射宿主机文件或目录到容器中：

- 目标对象不存在就自动创建
- 目标对象存在就直接覆盖掉
- 多个容器可以映射同一个目标对象来达到数据共享的目的
- 启动容器时，使用 -v 映射参数（可有多个）

语法格式如下：

docker run -itd -v 宿主机对象:容器内对象 myos:latest

apache使用宿主机中的配置文件和网页家目录

```shell
[root@docker-0001 ~]# mkdir /var/webconf
[root@docker-0001 ~]# cp /usr/local/nginx/conf/nginx.conf /var/webconf/
[root@docker-0001 ~]# vim /var/webconf/nginx.conf
        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
[root@docker-0001 ~]# docker run -itd -p 80:80 --name nginx \
      -v /var/webconf/nginx.conf:/usr/local/nginx/conf/nginx.conf myos:nginx
# 查看验证
[root@docker-0001 ~]# docker exec -it nginx /bin/bash
[root@e440b53a860a html]# cat /usr/local/nginx/conf/nginx.conf
[root@e440b53a860a html]# # 查看 php 相关配置是否被映射到容器内
```



# 5. 微服务案例

## 5.1 问题

本案例要求自作镜像实现 nginx+php-fpm服务，主要完成内容：

1. 启动容器并测试

## 5.2 步骤

实现此案例需要按照如下步骤进行。

FastCGI工作原理，如图-1所示。

![img](https://img-blog.csdnimg.cn/img_convert/9d3efa10a155a015de3ab641af461bda.png)

图-1

**步骤一：运行容器（在docker-0001操作）**

在真机上面提前准备好所有需要的网页文件，然后通过共享卷将真机的文件映射到nginx和php-fpm容器中，实现数据共享。

1）在真机提前准备网页文件

所有网页文件已经提前共享到云盘，在第四阶段的kubernetes/docker-images/目录下。

```shell
[root@docker-0001 ~]# mkdir -p /var/{webroot,webconf}
[root@docker-0001 ~]# cd kubernetes/docker-images
[root@docker-0001 ~]# cp info.php info.html /var/webroot/
[root@docker-0001 ~]# cp /usr/local/nginx/conf/nginx.conf /var/webconf/
[root@docker-0001 ~]# vim /var/webconf/nginx.conf
        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
# 启动前端 nginx 服务，并映射共享目录和配置文件
[root@docker-0001 ~]# docker run -itd --name nginx -p 80:80 \
      -v /var/webconf/nginx.conf:/usr/local/nginx/conf/nginx.conf \
      -v /var/webroot:/usr/local/nginx/html myos:nginx
# 启动后端 php 服务，并映射共享目录
[root@docker-0001 ~]# docker run -itd --network=container:nginx \
      -v /var/webroot:/usr/local/nginx/html myos:php-fpm
# 验证服务
[root@docker-0001 ~]# curl http://docker-0001/info.html
<html>
  <marquee  behavior="alternate">
      <font size="12px" color=#00ff00>Hello World</font>
  </marquee>
</html>
[root@docker-0001 ~]# curl http://docker-0001/info.php
<pre>
Array
(
    [REMOTE_ADDR] => 172.17.0.1
    [REQUEST_METHOD] => GET
    [HTTP_USER_AGENT] => curl/7.29.0
    [REQUEST_URI] => /info.php
)
php_host:     f705f89b45f9
1229
```



# 6. 搭建私有镜像仓库

## 6.1 问题

本案例要求搭建私有镜像仓库，具体要求如下：

1. 在192.168.1.100上搭建私有镜像仓库
2. 所有 node 节点配置私有仓库地址

## 6.2 方案

完成后续课程的学习需要提前准备实验用的虚拟机，实验虚拟机列表如表-1所示。

所有主机的主机名和IP必须与列表相同!!!

否则后续所有试验都无法顺利完成！！！

表-1

## 6.3 步骤

实现此案例需要按照如下步骤进行。

Docker镜像参考拓扑图如图-2所示。

![img](https://img-blog.csdnimg.cn/img_convert/7519bf26773e5a9803568565d034e6bf.png)

图-2

**步骤一：搭建私有仓库服务器（在192.168.1.100服务器操作）**

1）安装软件并启动服务

```shell
[root@localhost ~]# yum install docker-distribution
[root@localhost ~]# systemctl start docker-distribution
[root@localhost ~]# systemctl enable docker-distribution
```

2）查看配置文件（不需要修改）

```shell
[root@localhost ~]# cat /etc/docker-distribution/registry/config.yml
配置文件中定义存放镜像的路径为/var/lib/registry
配置文件中默认端口号为5000
```

3）使用curl测试

```shell
[root@localhost ~]# curl http://仓库ip:5000/v2/_catalog
```

**步骤二：搭建私有仓库服务器**

注意：在所有node主机都需要操作，下面以192.168.1.31为例！！！

修改docker配置文件，改配置文件默认连接的仓库为国外官网的仓库，我们需要修改为自己定义的192.168.1.100服务器。

```shell
[root@localhost ~]# vim  /etc/docker/daemon.json     # 默认没有该文件，需要新建
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "registry-mirrors": ["https://hub-mirror.c.163.com"],
    "insecure-registries":["192.168.1.100:5000", "registry:5000"]
}
# insecure-registries后面根私有仓库的服务器IP和端口
[root@localhost ~]# docker rm -f $(docker ps -aq)
[root@localhost ~]# systemctl restart docker
# 注意：重启docker服务前要停止所有容器
```



# 7. 上传镜像到私有仓库

## 7.1 问题

本案例要求上传镜像到私有仓库，具体要求如下：

1. 在 192.168.1.100 上搭建私有镜像仓库
2. 从 docker-0001 上传镜像到仓库主机
3. 在 docker-0002 上使用远程仓库下载镜像、启动容器

## 7.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：上传镜像（在docker-0001主机操作）**

1）修改docker配置文件，指定192.168.1.100为私有仓库服务器

```shell
[root@docker-0001 ~]# vim  /etc/docker/daemon.json     # 默认没有该文件，需要新建
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "registry-mirrors": ["https://hub-mirror.c.163.com"],
    "insecure-registries":["192.168.1.100:5000", "registry:5000"]
}
[root@docker-0001 ~]# docker rm -f $(docker ps -aq)
[root@docker-0001 ~]# systemctl restart docker
# 注意：重启docker服务前要停止所有容器
```

2）上传镜像

```shell
[root@docker-0001 ~]# docker tag \
docker.io/busybox:latest  192.168.1.100:5000/busybox:latest
# 修改镜像的标签
[root@ docker-0001 ~]# docker images
# 查看镜像标签修改的效果
[root@docker-0001 ~]# docker push 192.168.1.100:5000/busybox:latest
# 上传镜像到192.168.1.100服务器（前面已经搭建好了私有仓库服务器）
The push refers to a repository [192.168.1.100:5000/busybox]
a6d503001157: Pushed 
latest: digest: sha256:43d5f7 ... ... ccd7a7cec79464 size: 527
```

3）使用curl查看刚刚上传的镜像

```shell
[root@docker-0001 ~]# curl http://192.168.1.100:5000/v2/_catalog
{"repositories":["busybox","myos"]}
[root@docker-0001 ~]# curl http://192.168.1.100:5000/v2/myos/tags/list
{"name":"myos","tags":["httpd","latest","nginx","php-fpm"]}
```

**步骤二：下载镜像（在docker-0002主机操作）**

1）修改docker配置文件，指定192.168.1.100为私有仓库服务器

```shell
[root@docker-0002 ~]# vim  /etc/docker/daemon.json     # 默认没有该文件，需要新建
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "registry-mirrors": ["https://hub-mirror.c.163.com"],
    "insecure-registries":["192.168.1.100:5000", "registry:5000"]
}
[root@docker-0002 ~]# docker rm -f $(docker ps -aq)
[root@docker-0002 ~]# systemctl restart docker
# 注意：重启docker服务前要停止所有容器
```

2）从私有仓库下载镜像

在一个没有任何镜像的机器上启动容器

语法格式：

docker run -it 仓库IP:5000/镜像的名称:镜像的标签

```shell
[root@docker-0002 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
# 查看默认没有镜像
[root@docker-0002 ~]# docker run -it 192.168.1.100:5000/myos:latest
Unable to find image '192.168.1.100:5000/myos:latest' locally
Trying to pull repository 192.168.1.100:5000/myos ... 
latest: Pulling from 192.168.1.100:5000/myos
b1300879af4c: Pull complete 
[root@09845adc59fb /]# 
```


> 如有侵权，请联系作者删除



﻿@[TOC]( Remote login & numerical & classless networking & ipv6 | Cloud computing )

---

# 1. 配置远程登录服务

## 1.1 问题

通过配置实现对路由器的远程管理，要求如下：

1. 创建远程登录用户为test01，密码为123

2. 在交换机上操作，使用ssh协议

## 1.2 方案

从交换机上远程管理路由器，如图-1所示

图-1

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置路由器**

ar2220 路由器配置

```shell
<Huawei>system-view 
Enter system view, return user view with Ctrl+Z.
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.254 24
[Huawei-GigabitEthernet0/0/0]quit
[Huawei]aaa
[Huawei-aaa]local-user test01 password cipher 123    
[Huawei-aaa]local-user test01 privilege level 3
[Huawei-aaa]local-user test01 service-type ssh
[Huawei-aaa]quit
[Huawei]user-interface vty 0 4
[Huawei-ui-vty0-4]authentication-mode aaa
[Huawei-ui-vty0-4]protocol inbound ssh
[Huawei-ui-vty0-4]quit
[Huawei]stelnet server enable
```

**步骤二：配置路由器**

S3700交换机配置

```shell
<Huawei>system-view 
Enter system view, return user view with Ctrl+Z.
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]ip address 192.168.1.100 24
[Huawei-Vlanif1]quit
[Huawei]ssh client first-time enable 
[Huawei]stelnet 192.168.1.254
Please input the username:test01
Trying 192.168.1.254 ...
Press CTRL+K to abort
Connected to 192.168.1.254 ...
The server is not authenticated. Continue to access it? [Y/N] :y
Save the server's public key? [Y/N] :y
The server's public key will be saved with the name 192.168.1.254. Please wait..
.
Enter password:
```

# 2. 数制转换

## 2.1 问题

1. 将下列数字转换为十进制数

   11011101、1101、101010

2. 将下列数字转换为二进制

   156、26、104

## 2.2 步骤

实现此案例需要按照如下步骤进行。

1. 将下列数字转换为十进制数
   (11011101)2=221
   (1101)2=13
   (101010)2=42

2. 将下列数字转换为二进制
   156=(10011100)2
   26=(11010)2
   104=(1101000)2

# 3. 子网划分

## 3.1 问题

将192.168.0.0/24划分为4个网段，并应用在下列拓扑中

## 3.2 方案

首先将该地址划分成4个网段，可用范围是
192.168.0.1 ~ 192.168.0.62
192.168.0.65 ~ 192.168.0.126
192.168.0.129 ~ 192.168.0.190
192.168.0.193 ~ 192.168.0.254

然后在交换机与pc应用，如图-2所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/74ec2c0d6f1f48b8a2549258d1bbfdbf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-2

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在交换机进行配置**

```shell
<Huawei>system-view 
Enter system view, return user view with Ctrl+Z.
[Huawei]vlan batch 2 3 4
Info: This operation may take a few seconds. Please wait for a moment...done.
[Huawei]in vlan1
[Huawei-Vlanif1]ip add 192.168.0.62 26
[Huawei-Vlanif1]in vlan 2
[Huawei-Vlanif2]ip add 192.168.0.126 26
[Huawei-Vlanif2]in vlan 3
[Huawei-Vlanif3]ip add 192.168.0.190 26
[Huawei-Vlanif3]in vlan 4
[Huawei-Vlanif4]ip add 192.168.0.254 26
[Huawei-Vlanif4]quit
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/2]port link-type access 
[Huawei-GigabitEthernet0/0/2]port default vlan 2
[Huawei-GigabitEthernet0/0/2]in g0/0/3
[Huawei-GigabitEthernet0/0/3]port link-type access
[Huawei-GigabitEthernet0/0/3]port default vlan 3
[Huawei-GigabitEthernet0/0/3]in g0/0/4
[Huawei-GigabitEthernet0/0/4]port link-type access
[Huawei-GigabitEthernet0/0/4]port default vlan 4
```

**步骤二：在各vlan所在主机配置的ip如下**

vlan1主机如图-3所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/a1ed8e0767e945e9a97974cd457b9c1e.png)
图-3

vlan2主机如图-4所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/b7f7966c91f84a2faf1d692f6c846cff.png)
图-4

vlan3主机如图-5所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/955b0e770151436bab70c8fd414cc79e.png)
图-5

vlan4主机如图-6所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/e6a6d00faff14c9489e65f6e928ab156.png)
图-6

# 4. 使用IPv6地址连接网络

## 4.1 问题

通过配置IPv6地址使下列拓扑中的设备互通，如图-7所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/f4d0a1c240a44fdd920fcd5990cfcd69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)

图-7

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：在路由器配置**

此步骤需要在上一实验基础上进行

```shell
<Huawei>system-view 
Enter system view, return user view with Ctrl+Z.
[Huawei]ipv6    
[Huawei]interface GigabitEthernet 0/0/0    
[Huawei-GigabitEthernet0/0/0]ipv6 enable     
[Huawei-GigabitEthernet0/0/0]ipv6 address 2001:2::254 64
[Huawei-GigabitEthernet0/0/0]in g0/0/1
[Huawei-GigabitEthernet0/0/1]ipv6 enable 
[Huawei-GigabitEthernet0/0/1]ipv6 address 2001:1::254 64
```

**步骤二：各主机配置的ip如下**

PC1主机如图-8所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/833a095393cd41c3b0917a40442ff559.png)
图-8

PC2主机如图-9所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/97e469f18c3840d3824fe694de19d01a.png)
图-9

PC3主机如图-10所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/a589cb1cea4e40d098636e6e36e2c989.png)
图-10


# Exercise

## 1 远程登录协议有哪些？区别是什么?

telnet与ssh两种协议可以实现远程登录功能

区别是telnet使用明文方式传递数据，可以在内部网络等安全要求不高的场合使用，而ssh使用加密方式传递数据，可以放心用在各种环境的网络中

## 2 计算机中常用数制有哪些？

二进制、十进制、十六进制

## 3 一个4GB大小的文件，如果利用200Mb带宽的网络传递，需要多久完成？

首先使用200除以8得出该网络每秒可以传递25MB的数据

4乘以1024等于4096MB，再用4096除以25得出时间是163.84秒

大约不到3分钟即可完成传递

## 4 子网划分的原因是？

满足不同网络对IP地址的需求

节省IP地址

## 5 IPv4的与IPv6的地址长度分别是多少位？

IPv4是32位

IPv6是128位

## 6 IPv6地址在配置时通常使用几进制？

十六进制

> 如有侵权，请联系作者删除



﻿@[TOC]( RPM software package management & Yum software package repository | Cloud computing )

---

# 1. 查询已安装的软件信息

## 1.1 问题

列出当前主机已安装的所有RPM软件
查看firefox软件包的安装清单
查询ifconfig命令程序是安装哪个软件包后产生的
查看firefox软件包的用途

## 1.2 方案

查询所有已安装的rpm包，可以利用命令rpm -qa。

查询一个软件安装清单，可以利用命令rpm -ql 软件名。

查询一个文件是由哪个软件包安装后产生，可以利用命令rpm -qf 文件绝对路径。本题中首先要找到，ifconfig命令的可执行程序在哪里，可以利用which命令。

查看软件的用途，可以利用命令rpm -qi 软件名。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：列出当前主机已安装的所有RPM软件**

命令操作如下所示：

```shell
[root@localhost ~]# rpm -qa
```

**步骤二：查看firefox软件包的安装清单**

命令操作如下所示：

```shell
[root@localhost ~]# rpm -ql firefox
```

**步骤三：查询ifconfig命令程序是安装哪个软件包后产生的**

命令操作如下所示：

```shell
[root@localhost ~]# which ifconfig    #查询命令所对应的程序
/sbin/ifconfig
[root@localhost ~]# rpm -qf /sbin/ifconfig
net-tools-1.60-110.el6_2.x86_64
[root@localhost ~]#
```

**步骤四：查看firefox软件包的用途**

命令操作如下所示：

```shell
[root@localhost ~]# rpm -qi firefox
Name        : firefox                      Relocations: (not relocatable)
Version     : 17.0.10                           Vendor: Red Hat, Inc.
Release     : 1.el6_4                       Build Date: 2013年10月23日 星期三 21时14分43秒
Install Date: 2015年01月06日 星期二 20时59分04秒      Build Host: x86-027.build.eng.bos.redhat.com
Group       : Applications/Internet         Source RPM: firefox-17.0.10-1.el6_4.src.rpm
Size        : 30424459                         License: MPLv1.1 or GPLv2+ or LGPLv2+
Signature   : RSA/8, 2013年10月29日 星期二 16时20分45秒, Key ID 199e2f91fd431d51
Packager    : Red Hat, Inc. <http://bugzilla.redhat.com/bugzilla>
URL         : http://www.mozilla.org/projects/firefox/
Summary     : Mozilla Firefox Web browser
Description :
Mozilla Firefox is an open-source web browser, designed for standards
compliance, performance and portability.
[root@localhost ~]#
```

# 2. 查询待安装的.rpm包

## 2.1 问题

1. 查询光盘中的 lynx 软件包的用途、安装清单
2. 查询光盘中的 wireshark 软件包的用途、安装清单

## 2.2 方案

注意在查询未安装的.rpm包信息时，提供的命令参数应该是准确的包文件路径，仅指定软件名是不行的。指定文件路径时，多利用Tab键补全。提前将RHEL6系统光盘挂载到/media目录，以便使用相关包文件。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：查询光盘中的 lynx 软件包的用途、安装清单**

首先将光盘设备手动挂载到/media目录，进行查询操作。

命令操作如下所示：

```shell
[root@localhost ~]# mount /dev/cdrom /media/
mount: block device /dev/sr0 is write-protected, mounting read-only
[root@localhost ~]# mount | tail -1
/dev/sr0 on /media type iso9660 (ro)
[root@localhost ~]# rpm -qpi /media/Packages/lynx-2.8.8-0.3.dev15.el7.x86_64.rpm 
……
[root@localhost ~]# rpm -qpl /media/Packages/lynx-2.8.8-0.3.dev15.el7.x86_64.rpm
……
```

**步骤二：查询光盘中的 wireshark 软件包的用途、安装清单**

命令操作如下所示：

```shell
[root@localhost ~]# rpm -qpi /media/Packages/wireshark-1.10.14-14.el7.x86_64.rpm
……
[root@localhost ~]# rpm -qpl /media/Packages/wireshark-1.10.14-14.el7.x86_64.rpm
……
```

# 3. RPM软件的安装和卸载

## 3.1 问题

1. 找出vim、vi是由哪两个包产生的
2. 删除vim、vi命令程序
3. 修复vim、vi
4. 安装bind-chroot包,体验Linux依赖关系

## 3.2 方案

本题的思路是，首相通过which命令查找到vim、vi命令可执行程序所在位置，在通过“rpm –qf 文件绝对路径”命令查看该可执行程序，是由那个包产生的。删除该可执行程序后，再将软件包安装重新产生即可。但在安装时需注意，系统会提示改程序已经安装，需加上“—force”选项强制安装。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：找出vim、vi是由那两个包产生的**

命令操作如下所示：

```shell
[root@localhost ~]# which vi  vim
/usr/bin/vi
/usr/bin/vim 
[root@localhost ~]# rpm -qf /usr/bin/vi
vim-minimal-7.4.160-4.el7.x86_64 
[root@localhost ~]# rpm -qf /usr/bin/vim
vim-enhanced-7.4.160-4.el7.x86_64
```

**步骤二：删除vim、vi命令程序**

命令操作如下所示：

```shell
[root@localhost ~]# rm -rf /usr/bin/vi /usr/bin/vim
[root@localhost ~]#
```

**步骤三：修复vim、vi**

首先将光盘设备手动挂载到/media目录，进行修复操作。

命令操作如下所示：

```shell
[root@localhost ~]# mount /dev/cdrom /media/
mount: block device /dev/sr0 is write-protected, mounting read-only
[root@localhost ~]# rpm -ivh --force /media/Packages/vim-minimal-7.4.160-4.el7.x86_64……
 [root@localhost ~]# rpm -ivh --force /media/Packages/vim-enhanced-7.4.160-4.el7.x86_64
……
 [root@localhost ~]#
```

**步骤四：安装bind-chroot包,体验Linux依赖关系**

命令操作如下所示：

```shell
[root@localhost ~]# cd  /media/Packages
[root@svr5 Packages]# rpm  -ivh  bind-chroot-9.9.4-61.el7.x86_64.rpm 
error: Failed dependencies:
……
 [root@svr5 Packages]# rpm  -ivh  bind-9.9.4-61.el7.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:bind                   ########################################### [100%]
[root@svr5 Packages]# rpm  -ivh  bind-chroot-9.9.4-61.el7.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:bind-chroot            ########################################### [100%]
```

# 4. 配置Yum仓库及客户端及验证

## 4.1 问题

1. 将光盘挂载到/dvd，搭建本地Yum
2. 将本机设置为客户端，进行Yum验证
3. 查询Yum库中是否有firefox包
4. 使用yum命令安装bind包
5. 利用Yum安装bind
6. 利用Yum卸载bind
7. 利用yum search查询与httpd相关的包
8. 利用yum info查询firefox包描述信息

## 4.2 方案

YUM服务器配置思路：

>第一步：确保光驱电源加电，放入Linux光盘的iso镜像
>第二步：ls -l /dev/cdrom 查看linux系统是否识别光驱设备
>第三步：创建挂载目录:mkdir /dvd （或也可以使用linux系统提供的挂载目录/media、/mnt）
>第四步：利用mount命令挂载:mount /dev/cdrom /dvd
>第五步：查看挂载情况：mount | grep dvd



YUM客户端配置思路：

>第一步：切换路径到客户端配置文件路径下：cd /etc/yum.repos.d/
>第二步：排除其他文件的干扰
>
>```shell
>[root@localhost ~]# mkdir /etc/yum.repos.d/repo
>[root@localhost ~]# mv /etc/yum.repos.d/*.repo > /etc/yum.repos.d/repo
>```
>
>第三步：更改配置文件dvd.repo。

必须更改的字段：

- 【】”内容要唯一所以要更改，注意不要有空格
- “baseurl”此字段指定软件包目录，注意路径写对。file：后要有三个“/”
- “enabled”此字段要至于“1”，代表启用

Yum在使用方面，几乎rpm能够做到的事情，Yum也能够做到。此外Yum还具备自动解决依赖关系的功能。

常用的Yum操作：

- yum install 软件名：安装一个软件包
- yum remove 软件名：卸载一个软件包

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：搭建一个本地Yum，将光盘手动挂载到/dvd**

命令操作如下所示：

```shell
[root@localhost ~]# mkdir /dvd
[root@localhost ~]# ls /dvd
[root@localhost ~]# mount /dev/cdrom /dvd/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@localhost ~]# ls /dvd/
[root@localhost ~]# ls /dvd/Packages/
```

步骤二：将本地设置为客户端，进行Yum验证

**Yum客户端需编辑配置文件，命令操作如下所示：**

```shell
[root@localhost ~]# ls /etc/yum.repos.d/
[root@localhost ~]# mkdir /etc/yum.repos.d/repo
[root@localhost ~]# mv /etc/yum.repos.d/*.repo  /etc/yum.repos.d/repo 
[root@localhost ~]# ls /etc/yum.repos.d/
[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo
[centos] #仓库标识,可以任意
name=hehe lele CentOS7         #仓库的描述信息，可以任意
baseurl=file:///dvd             #指定服务端位置，file://代表本地为服务端
enabled=1                     #是否启用本文件
gpgcheck=0                     #是否检测红帽签名信息
[root@localhost ~]# yum repolist         #列出仓库信息
```

**步骤三：查询yum库中是否有firefox包**

命令操作如下所示：

```shell
[root@localhost /]# yum list | grep firefox
```

**步骤四：利用yum安装bind包**
命令操作如下所示：

```shell
[root@localhost /]# yum -y install bind
……
```

**步骤二：利用Yum卸载bind**
命令操作如下所示：

```shell
[root@localhost /]# yum -y remove bind
……
```

**步骤四：利用yum search查询与httpd相关的包**
命令操作如下所示：

```shell
[root@localhost /]# yum search httpd
……
```

**步骤四：利用yum info查询firefox包描述信息**

命令操作如下所示：

```shell
root@localhost /]# yum info firefox
……
```

# Exercise

## 1 Linux中查询已安装软件包信息。

使用rpm命令查询已经安装的软件包时，常见的用法如下所示，请补充完整。

rpm （ ）列出已安装的所有软件包

rpm （ ） 软件名：查看指定软件的详细信息

rpm （ ） 软件名：查看指定软件的文件安装清单

- -qa
- -qi
- -ql

## 2 Linux中查询未安装软件包信息。

使用rpm命令查询尚未安装的 .rpm 文件时，常见的用法如下所示，请补充完整。

rpm （ ） *.rpm安装文件：查看该软件包的详细信息
rpm （ ） *.rpm安装文件：查看如果安装该软件将会提供的文件清单

- -qpi
- -qpl

## 3 删除hostname命令的执行程序，并修复。

```shell
[root@svr5 ~]# hostname 
svr5.tarena.com
[root@svr5 ~]# which hostname
/usr/bin/hostname
[root@svr5 ~]# rm -rf /usr/bin/hostname 
[root@svr5 ~]# hostname 
-bash: /bin/hostname: 没有那个文件或目录
[root@svr5 ~]# rpm -qf /usr/bin/hostname
hostname-3.13-3.el7.x86_64 
[root@svr5 ~]# rpm –ivh –force  /dvd/Packages/hostname-3.13-3.el7.x86_64 
Preparing...                ########################################### [100%]
   1:net-tools              ########################################### [100%]
[root@svr5 ~]# hostname 
svr5.tarena.com
```

## 4 YUM简介。什么是YUM，其作用是什么，主要支持哪几种方式提供软件源？


是一种基于“C/S”结构的RPM软件更新机制，所有的软件包由集中的软件仓库提供，能够自动分析并解决软件包之间的依赖关系。

支持的软件源主要包括：

- 本地文件夹：file://.. ..
- FTP服务器：ftp://.. ..
- HTTP服务器：http://

## 5 简述yum客户端配置文件中主要参数的含义

```shell
[root@server0 ~]# cat  /etc/yum.repos.d/rhel_dvd.repo 
[rhel_dvd]                              //仓库标识
gpgcheck = 0                             //不做签名检查
enabled = 1                             //启用此仓库
baseurl = file:///dvd                  //软件仓库的访问地址
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Source code compilation and installation & rsync synchronization operation & inotify real-time synchronization & database foundation | Cloud computing )

---

# 1 案例1：编译安装软件包

## 1.1 问题

本例要求掌握常规源代码应用的安装过程，通过编译的方式安装inotify-tools 软件工具，完成下列任务：

1. 释放 inotify-tools-3.13.tar.gz 源码包
2. 配置 ./configure
3. 编译 make、安装 make install
4. 测试inotifywait监控工具的用法及用途

## 1.2 方案

对于标准源码发布的C/C++软件包，编译安装一般包括以下过程：

1. 解包：使用tar命令，将下载的源代码释放至指定目录
2. 配置：执行源码目录内的 ./configure 脚本，指定安装目录/功能模块等选项
3. 编译：在源码目录下执行 make 操作，根据配置清单Makefile生成可执行的二进制程序文件
4. 安装：在源码目录下执行make install 操作，将编译好的程序及相关文件复制到安装目录

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：确认已配置好编译环境**

```shell
[root@svr7 ~]# yum  -y  install  gcc  gcc-c++  make
.. ..
[root@svr7 ~]# gcc  --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

**步骤二：编译安装inotify-tools软件包**

1）解包inotify-tools-3.13.tar.gz文件

```shell
[root@svr7 ~]# ls  inotify-tools-3.13.tar.gz 
inotify-tools-3.13.tar.gz
[root@svr7 ~]# tar  xf  inotify-tools-3.13.tar.gz  -C /usr/src/ 
```

2）配置 ./configure，安装目录默认（/usr/local/*/）

```shell
[root@svr7 ~]# cd  /usr/src/inotify-tools-3.13/          //进入源码目录
[root@svr7 inotify-tools-3.13]# ./configure              //配置操作
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for gawk... gawk
.. ..
configure: creating ./config.status
config.status: creating Makefile
.. ..
[root@svr7 inotify-tools-3.13]# ls  Makefile              //检查配置结果
Makefile
```

3）编译 make

```shell
[root@svr7 inotify-tools-3.13]# make
.. ..
Making all in src
make[2]: Entering directory `/usr/src/inotify-tools-3.13/src'
make[3]: Entering directory `/usr/src/inotify-tools-3.13'
make[3]: Leaving directory `/usr/src/inotify-tools-3.13'
.. ..
```

4）安装 make install

```shell
[root@svr7 inotify-tools-3.13]# make  install
.. ..
/usr/bin/install -c .libs/inotifywait /usr/local/bin/inotifywait
  /bin/sh ../libtool --mode=install /usr/bin/install -c 'inotifywatch' '/usr/local/bin/inotifywatch'
.. ..
[root@svr7 inotify-tools-3.13]# find  /usr/local/  -name  "inotify*"
/usr/local/bin/inotifywait                              //确认安装结果
/usr/local/bin/inotifywatch
/usr/local/include/inotifytools
/usr/local/include/inotifytools/inotifytools.h
```

**步骤三：测试inotify-tools软件程序**

软件包inotify-tools提供了一个主要程序inotifywait，可以用来监控指定目录或文档的变化，并及时给出通知。

1）开启对/opt目录的事件监控

```shell
[root@svr7 ~]# inotifywait  -mrq  /opt &                  //开启监控
[1] 15568
```

2）修改/opt/目录内容，观察屏幕输出信息

```shell
[root@svr7 ~]# touch  /opt/a.txt                          //新建文件a.txt
/opt/ CREATE a.txt
/opt/ OPEN a.txt
/opt/ ATTRIB a.txt
/opt/ CLOSE_WRITE,CLOSE a.txt
[root@svr7 ~]# mv  /opt/a.txt  /opt/b.txt                  //将文件改名
/opt/ MOVED_FROM a.txt
/opt/ MOVED_TO b.txt
```

3）结束inotifywait监控

杀死当前用户的第一个后台任务：

```shell
[root@svr7 ~]# kill  -9  %1
[1]+  Killed                  inotifywait -mrq /opt
```

# 2. rsync基本用法

## 2.1 问题

本例要求掌握远程同步的基本操作，使用rsync命令完成下列任务：

1. 将目录 /boot 同步到目录 /todir 下
2. 将目录 /boot 下的文档同步到目录 /todir 下
3. 在目录 /boot 下新增文件 a.txt，删除 /todir 下的子目录 grub2，再次同步使 /todir 与 /boot 一致
4. 验证 -a、-n、-v、--delete 选项的含义

## 2.2 方案

本地同步操作：

- rsync [选项...] 本地目录1 本地目录2
- rsync [选项...] 本地目录1/ 本地目录2

rsync同步工具的常用选项：

- -n：测试同步过程，不做实际修改
- --delete：删除目标文件夹内多余的文档
- -a：归档模式，相当于-rlptgoD
- -v：显示详细操作信息
- -z：传输过程中启用压缩/解压

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：rsync同步基本操作**

1）将目录 /boot 同步到目录 /todir 下

```shell
[root@svr7 ~]# ls  -l  /todir                  //同步前
ls: 无法访问/todir: 没有那个文件或目录
[root@svr7 ~]# rsync  -a  /boot  /todir          //将目录1作为目录2的子目录
[root@svr7 ~]# ls  -l  /todir                  //检查同步结果
总用量 4
dr-xr-xr-x. 4 root root 4096 11月 30 18:50 boot
```

2）将目录 /boot 下的文档同步到目录 /todir 下

```shell
[root@svr7 ~]# rm  -rf  /todir                  //清理掉目录2
[root@svr7 ~]# rsync  -a  /boot/  /todir          //将目录1下的文档同步到目录2下
[root@svr7 ~]# ls  -l  /todir                  //检查同步结果
总用量 126708
-rw-r--r--. 1 root root   126426 10月 30 2015 config-3.10.0-327.el7.x86_64
drwxr-xr-x. 2 root root     4096 11月 30 18:50 extlinux
drwx------. 6 root root      104 12月  9 09:58 grub2
.. ..
```

3）同步效果测试

在目录/boot下新增文件a.txt，删除/todir下的子目录 grub2：

```shell
[root@svr7 ~]# touch  /boot/a.txt
[root@svr7 ~]# rm  -rf  /todir/grub2/ 
```

现在目录/boot和/todir目录下的内容已经不一致了：

```shell
[root@svr7 ~]# ls  -ld  /boot/a.txt  /todir/a.txt
ls: 无法访问/todir/a.txt: 没有那个文件或目录
-rw-r--r--. 1 root root 0 1月  11 21:09 /boot/a.txt
[root@svr7 ~]# ls  -ld  /boot/grub2  /todir/grub2
ls: 无法访问/todir/grub2: 没有那个文件或目录
drwx------. 6 root root 104 12月  9 09:58 /boot/grub2
```

再次同步使/todir与/boot一致：

```shell
[root@svr7 ~]# rsync  -a  /boot/  /todir/
```

确认同步结果：

```shell
[root@svr7 ~]# ls  -ld  /boot/a.txt  /todir/a.txt
-rw-r--r--. 1 root root 0 1月  11 21:09 /boot/a.txt
-rw-r--r--. 1 root root 0 1月  11 21:09 /todir/a.txt
[root@svr7 ~]# ls  -ld  /boot/grub2  /todir/grub2
drwx------. 6 root root 104 12月  9 09:58 /boot/grub2
drwx------. 6 root root 104 12月  9 09:58 /todir/grub2
```

**步骤二：验证 -a、-v、-n、--delete 选项的含义**

1）验证-a选项

当目录1包含文件夹时，若缺少-a或-r选项则文件夹会被忽略：

```shell
[root@svr7 ~]# rsync  /home  /testa
skipping directory home
[root@svr7 ~]# ls  -ld  /testa
ls: 无法访问/testa: 没有那个文件或目录
```

添加-a后才会执行同步：

```shell
[root@svr7 ~]# rsync  -a  /home/  /testa
[root@svr7 ~]# ls  -ld  /testa
drwxr-xr-x. 4 root root 31 1月   6 17:33 /testa
```

类似的情况，当目录1中的数据出现权限、归属、修改时间等变化时，若文件内容不变默认不会同步，若希望目录2也同步这些变化，也需要-a选项。

2）验证-v选项

创建测试目录及文档：

```shell
[root@svr7 ~]# mkdir  /fdir
[root@svr7 ~]# touch  /fdir/1.txt
```

添加-v选项时，可以看到操作细节信息，比如第一次同步时：

```shell
[root@svr7 ~]# rsync  -av  /fdir/  /tdir
sending incremental file list
created directory /tdir
./
1.txt                                 //传输文档列表
sent 82 bytes  received 34 bytes  232.00 bytes/sec
total size is 0  speedup is 0.00
```

在目录/fdir/添加文件2.txt，再次跟踪同步信息：

```shell
[root@svr7 ~]# touch  /fdir/2.txt
sending incremental file list
./
2.txt                                 //传输文档列表
sent 100 bytes  received 34 bytes  268.00 bytes/sec
total size is 0  speedup is 0.00
```

确认目录1和目录2的内容已经一致：

```shell
[root@svr7 ~]# ls  /fdir/  /tdir/
/fdir/:
1.txt  2.txt
/tdir/:
1.txt  2.txt
```

再次跟踪同步信息，已经无需传输文件：

```shell
[root@svr7 ~]# rsync  -av  /fdir/  /tdir
sending incremental file list
sent 58 bytes  received 12 bytes  140.00 bytes/sec
total size is 0  speedup is 0.00
```

3）验证-n选项

将-n、-v选项合用，可以模拟同步过程，显示需要做哪些操作（但并不真的同步）。

在目录/fdir下新建文件3.txt，测试同步操作：

```shell
[root@svr7 ~]# touch  /fdir/3.txt
[root@svr7 ~]# rsync  -avn  /fdir/  /tdir/
sending incremental file list
./
3.txt                                          //提示同步时会传输哪些文件
sent 78 bytes  received 18 bytes  192.00 bytes/sec
total size is 0  speedup is 0.00 (DRY RUN)
[root@svr7 ~]# ls  -l  /tdir/3.txt                 //但实际并未真的同步
ls: 无法访问/tdir/3.txt: 没有那个文件或目录
```

去掉-n选项才会真正同步：

```shell
[root@svr7 ~]# rsync  -av  /fdir/  /tdir/
sending incremental file list
./
3.txt
sent 114 bytes  received 34 bytes  296.00 bytes/sec
total size is 0  speedup is 0.00
[root@svr7 ~]# ls  -l  /tdir/3.txt
-rw-r--r--. 1 root root 0 1月  11 21:46 /tdir/3.txt
```

4）验证--delete选项

rsync同步操作默认只是将目录1的数据同步到目录2，但如果目录2存在多余的文件却并不会去除，除非添加—delete选项。

在目录/fdir、/tdir已经完成同步后，删除/tdir/2.txt文件，再次同步：

```shell
[root@svr7 ~]# rm  -rf  /fdir/2.txt 
[root@svr7 ~]# rsync  -a  /fdir/  /tdir/
```

检查发现目标文件夹/tdir下的2.txt文件还在：

```shell
[root@svr7 ~]# ls  /fdir/  /tdir/
/fdir/:
1.txt  3.txt
/tdir/:
1.txt  2.txt  3.txt
```

这种情况下添加--delete选项再次执行同步，两个目录的内容就一致了：

```shell
[root@svr7 ~]# rsync  -a  --delete  /fdir/  /tdir/
[root@svr7 ~]# ls  /fdir/  /tdir/
/fdir/:
1.txt  3.txt
/tdir/:
1.txt  3.txt
```

# 3. rsync+SSH同步

## 3.1 问题

本例要求掌握rsync与远程SSH资源的同步操作，使用rsync命令访问远程主机svr7，完成下列任务：

1. 查看远程主机的 / 目录下有哪些子目录
2. 从远程主机下载 /etc/passwd 文件到当前目录
3. 将远程主机的 /boot/ 目录同步为本地的 /fromssh
4. 将本机的 /etc 目录同步到远程主机的 /opt/下

## 3.2 方案

列出 SSH 服务端资源

- rsync user@host:远程目录/
- rsync+SSH远程同步操作：

- rsync [...] user@host:远程目录 本地目录
- rsync [...] 本地目录 user@host:远程目录

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：列出远程主机的SSH资源**

查看远程主机svr7的/目录下有哪些子目录：

```shell
[root@pc207 ~]# rsync  root@192.168.4.7:/
root@192.168.4.7's password:                           //验证对方的密码
dr-xr-xr-x        4096 2016/12/15 10:39:34 .
lrwxrwxrwx           7 2016/12/07 09:21:50 bin
lrwxrwxrwx           7 2016/12/07 09:21:50 lib
lrwxrwxrwx           9 2016/12/07 09:21:50 lib64
lrwxrwxrwx           8 2016/12/07 09:21:50 sbin
dr-xr-xr-x        4096 2016/12/07 11:25:29 boot
drwxr-xr-x           6 2016/12/07 09:21:14 data
drwxr-xr-x        3200 2016/12/15 10:46:15 dev
drwxr-xr-x        8192 2016/12/20 17:01:02 etc
```

**步骤二：rsync+SSH同步操作**

1）从远程主机svr7下载/etc/passwd文件到当前目录

```shell
[root@pc207 ~]# rsync  root@192.168.4.7:/etc/passwd  ./
root@192.168.4.7's password:                           //验证对方的密码
[root@pc207 ~]# cat  passwd                             //检查同步结果
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
.. ..
```

2）将远程主机svr7的/boot/目录同步为本地的/fromssh

```shell
[root@pc207 ~]# rsync  -a  root@192.168.4.7:/boot/  /fromssh
root@192.168.4.7's password:                           //验证对方的密码
[root@pc207 ~]# ls  /fromssh/                             //检查同步结果
config-3.10.0-327.el7.x86_64
extlinux
grub2
initramfs-0-rescue-a19921505cc7e19d20dfcd5cea7d8aa2.img
initramfs-3.10.0-327.el7.x86_64.img
initramfs-3.10.0-327.el7.x86_64kdump.img
.. ..
```

3）将本机的/etc目录同步到远程主机svr7的/opt/下

确认目录大小：

```shell
[root@pc207 ~]# du  -sh  /etc
35M    /etc
```

上行同步到远程主机svr7上：

```shell
[root@pc207 ~]# rsync  -a  /etc  root@192.168.4.7:/opt/
root@192.168.4.7's password:
```

在远程主机上检查同步结果：

```shell
[root@svr7 ~]# du  -sh  /opt/etc
35M    /opt/etc
```

# 4. 使用inotifywait工具

## 4.1 问题

本例要求安装inotify-tools工具，并针对文件夹 /opt 启用 inotifywait 监控，完成下列任务：

1. 当此目录下出现新建、修改、更改权限、删除文件等事件时能给出提示
2. 验证上述监控事件的效果

## 4.2 方案

inotifywait监控操作：

- inotifywait [选项] 目标文件夹

inotifywait常用命令选项：

- -m，持续监控（捕获一个事件后不退出）
- -r，递归监控、包括子目录及文件
- -q，减少屏幕输出信息
- -e，指定监视的 modify、move、create、delete、attrib 等事件类别

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装inotify-tools软件包**

1）解包

```shell
[root@svr7 ~]# tar  xf  inotify-tools-3.13.tar.gz  -C  /usr/src/
```

2）配置

```shell
[root@svr7 ~]# cd  /usr/src/inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]# ./configure
```

3）编译

```shell
[root@svr7 inotify-tools-3.13]# make
```

4）安装

```shell
[root@svr7 inotify-tools-3.13]# make
```

5）检查安装结果（inotifywait程序可用）

```shell
[root@svr7 ~]# inotifywait --help
inotifywait 3.13
Wait for a particular event on a file or set of files.
Usage: inotifywait [ options ] file1 [ file2 ] [ file3 ] [ ... ]
Options:
    -h|--help         Show this help text.
.. ..
```

**步骤二：测试inotifywait监控**

1）开启监控任务，置入后台

```shell
[root@svr7 ~]# inotifywait  -mrq  -e  create,modify,move,attrib,delete /opt &
[1] 55564
```

2）测试/opt/目录下的新建、修改、改名、更改权限、删除文件等事件的响应消息

观察新建文件时的监控信息：

```shell
[root@svr7 ~]# touch  /opt/a.txt
/opt/ CREATE a.txt
/opt/ ATTRIB a.txt
```

观察修改文件内容时的监控信息：

```shell
[root@svr7 ~]# echo  Hello  >  /opt/a.txt
[root@svr7 ~]# /opt/ MODIFY a.txt
/opt/ MODIFY a.txt
```

观察将文件改名时的监控信息：

```shell
[root@svr7 ~]# mv  /opt/a.txt  /opt/b.txt
/opt/ MOVED_FROM a.txt
/opt/ MOVED_TO b.txt
```

观察修改文件权限时的监控信息：

```shell
[root@svr7 ~]# chmod  600  /opt/b.txt
/opt/ ATTRIB b.txt
```

观察删除文件时的监控信息：

```shell
[root@svr7 ~]# rm  -rf  /opt/b.txt 
/opt/ DELETE b.txt
```

3）停止监控任务

```shell
[root@svr7 ~]# kill  -9  %1
[1]+  已杀死          inotifywait -mr -e create,modify,move,attrib,delete /opt
```

# 5. 配置Web镜像同步

## 5.1 问题

本例要求为两台Web服务器svr7、pc207的网页文档目录配置镜像同步，主要基于inotifywait监控技术实现实时触发操作，需要完成下列任务：

以 svr7 为发起方，原始目录为 /var/www/html/
以 pc207 为同步目标，基于SSH免密验证
编写 inotify+rsync 同步脚本，验证实时同步效果

## 5.2 方案

inotifywait与rsync的结合，主要思路：

```shell
while  inotifywait监控操作
do
        需要执行的rsync同步操作
done
```

## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为主机svr7、pc207部署同步目录**

双方的目录均为/var/www/html/，如果安装了httpd，此目录会自动出现。

1）确认svr7的目录内容

```shell
[root@svr7 ~]# yum  -y  install  httpd
.. ..
[root@svr7 ~]# ls  /var/www/html/                     //向目录下提供一些测试文件
libreoffice
```

2）确认pc207的目录内容

```shell
[root@pc207 ~]# yum  -y  install  httpd
.. ..
[root@pc207 ~]# ls   /var/www/html                 //初始目录无数据
[root@pc207 ~]#
```

**步骤二：为svr7配置到pc207的SSH密钥对验证，实现免密码交互**

1）检查当前用户是否已经有可用的SSH密钥对文件

```shell
[root@svr7 ~]# ls  ~/.ssh/id_*
/root/.ssh/id_rsa  /root/.ssh/id_rsa.pub
```

如果找不到id_rsa、id_rsa.pub密钥对文件，则需要执行下列操作创建：

```shell
[root@svr7 ~]# ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):      //按回车，确认存放位置
Enter passphrase (empty for no passphrase):       //按回车，确认不要密码
Enter same passphrase again:                      //再次按回车，确认
Your identification has been saved in /root/.ssh/id_rsa. 
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
00:a7:cb:2d:9d:b8:8a:df:f5:ff:5b:ed:bd:04:10:fe root@svr7
The key's randomart image is:
+--[ RSA 2048]----+
|    . .    .     |
|     +    . .    |
|    . .    o     |
|   . = o    o    |
|    = + S    E   |
|     o        .. |
|    . .       ...|
| . o . .     ....|
|..o .   ....o. .+|
+-----------------+
```

2）将当前用户的SSH公钥部署到远程主机

```shell
[root@svr7 ~]# ssh-copy-id  root@192.168.4.207
The authenticity of host '192.168.4.207 (192.168.4.207)' can't be established.
ECDSA key fingerprint is d3:16:2c:9a:9d:91:28:c8:74:9c:af:2d:04:82:c9:66.
Are you sure you want to continue connecting (yes/no)? yes         //首次连yes确认
root@192.168.4.207's password:                      //验证对方的密码
Number of key(s) added: 1
Now try logging into the machine, with:   "ssh 'root@192.168.4.207'"
and check to make sure that only the key(s) you wanted were added.
```

3）验证免密码登录效果

```shell
[root@svr7 ~]# ssh  root@192.168.4.207
Last login: Fri Jan 13 09:52:08 2017 from 192.168.4.110
[root@pc207 ~]#                                      //确认已免密码连入远程主机
[root@pc207 ~]# exit                                  //退出SSH登录环境
登出
Connection to 192.168.4.207 closed.
[root@svr7 ~]#                                     //已反对原客户机
```

**步骤三：编写镜像同步脚本并测试效果**

1）编写脚本文件/root/isync.sh

```shell
[root@svr7 ~]# vim  /root/isync.sh
#!/bin/bash
while  inotifywait  -rqq  -e  modify,move,create,delete,attrib  /var/www/html/ 
do
    rsync  -az  --delete  /var/www/html/ root@192.168.4.207:/var/www/html
done  &
[root@svr7 ~]# chmod  +x  /root/isync.sh  
```

2）运行脚本

```shell
[root@svr7 ~]# /root/isync.sh
[root@svr7 ~]# pgrep  -l  inotify                      //确认任务在运行
56494 inotifywait
```

3）测试同步效果

在svr7上向/var/www/html/目录下添加一个测试网页（触发同步）：

```shell
[root@svr7 ~]# touch  /var/www/html/a.txt
[root@svr7 ~]# ls  /var/www/html/
a.txt  libreoffice
```

在pc207上检查/var/www/html/目录，内容应该已经与svr7上的同名目录一致：

```shell
[root@pc207 ~]# ls   /var/www/html
a.txt  libreoffice
```

4）结束测试后，在svr7上停止监控任务

```shell
[root@svr7 ~]# pkill  -9  inotify
[root@svr7 ~]# pgrep  -l  inotify                     //确认已没有监控任务
[root@svr7 ~]#
```

# 6. 搭建mariadb数据库系统

## 6.1 问题

本例要求在虚拟机server0上安装 MariaDB 数据库系统：

1. 安装 mariadb-server、mariadb 软件包
2. 启动 mariadb 服务

然后在客户端访问此数据库服务：

1. 执行 SHOW DATABASES; 指令列出有哪些库
2. 退出 mysql 交互界面

## 6.2 方案

数据库表及相关软件的基本知识：

- 数据（记录）：用来表示一个事物（实体）的一些信息（属性）的文字/图片文件等，例如字符串“：tedu.cn”
- 数据表：存放很多条数据记录的容器，例如学员联系信息表、学员月考成绩表
- 数据表的每一行：存放一条记录
- 数据表的每一列/字段：很多个事物的同一个属性
- 数据库：存放很多个相互关联的表格的容器，例如NSD1609学员档案库
- 数据库管理系统（DBMS）：用来管理（创建库/添加/查询/删除/授权等）数据库信息的软件平台

MariaDB服务端：软件包mariadb-server、系统服务mariadb

MariaDB客户端：软件包mariadb、管理工具mysql
MariaDB服务端配置文件：/etc/my.cnf
传输协议及端口：TCP 3306

mysql命令的简单用法：

```shell
mysql  [-u用户名]  [-p[密码]] 
```

## 6.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：搭建MariaDB数据库服务器**

1）安装软件包mariadb-server、mariadb

```shell
[root@server0 ~]# yum  -y  install  mariadb-server  mariadb
.. ..
```

2）启动系统服务mariadb，并设置开机自启

```shell
[root@server0 ~]# systemctl  restart  mariadb
[root@server0 ~]# systemctl  enable  mariadb
ln -s '/usr/lib/systemd/system/mariadb.service' '/etc/systemd/system/multi-user.target.wants/mariadb.service'
```

**步骤二：访问本机的MariaDB数据库系统**

1）以用户root连接本机的mariadb（或mysqld）数据库服务

```shell
[root@server0 ~]# mysql  -uroot
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 5.5.35-MariaDB MariaDB Server
Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MariaDB [(none)]>
```

2）查看当前数据库系统内有哪些库

```shell
MariaDB [(none)]> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)
```

3）退出操作环境

```shell
MariaDB [(none)]> QUIT
Bye
[root@server0 ~]#
```

# 7. 使用数据库查询

## 7.1 问题

本例要求配置MariaDB数据库，完成以下任务：

1. 在系统server0上使用数据库Contacts，通过SQL查询回答下列问题：密码是solicitous的人的名字？

## 7.2 方案

表记录增删改查：

```shell
insert  into  [库名.]表名  values(值1,值2,值3);
delete  from  [库名.]表名  where ...;
update  [库名.]表名  set  字段名=字段值  where ....;
select  字段列表  from  [库名.]表名  where  字段名1=值  and|or  字段名2=值; 
```

统计查询结果的数量：

```shell
select  count(*)  from  [库名.]表名  where  .. ..;
```

## 7.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：按条件查询表记录**

1）按单个条件查询

找出密码是solicitous的人的名字？

```shell
MariaDB [(none)]> SELECT  name  FROM  Contacts.base  WHERE  Password='solicitous';
+-------+
| name  |
+-------+
| James |
+-------+
1 row in set (0.00 sec)
```

# Exercise

## 1 简述rsync+SSH上/下行同步操作的命令用法

下行：rsync [...] user@host:源目录 本地目录

上行：rsync [...] 本地目录 user@host:目标目录

## 2 简述如何实现无密码ssh远程控制

首先利用ssh-keygen命令生成公钥与私钥，然后利用ssh-copy-id拷贝到对方

## 3 使用inotifywait配置实时同步时，哪些事件是有必要监控的

凡是会引起原始目录的内容发生变化的事件，都有必要监控，主要包括：

1）modify：文档的内容变更

2）attrib：文档的权限、归属、修改时间、访问控制列表等变更

3）move：文档被改名、移出或移入

4）create：在被监控的目录中增加了新的子目录或文档

5）delete：在被监控的目录中删除了某个子目录或文档

## 4 简述源码编译安装软件的主要步骤及各自的作用

1）tar解包：解压、释放安装包内的文件

2）./configure配置：针对当前系统环境指定安装目录、选择功能等设置。

3）make编译：将源代码编译成二进制的可执行程序、库文件等数据。

4）make install：将编译好的程序文件、配置文档等复制到对应的安装目录。

> 如有侵权，请联系作者删除



﻿@[TOC]( SELinux & system troubleshooting & firewall policy management & service management | Cloud computing )

---

# 1 案例1：启用SELinux保护

## 1.1 问题

本例要求为虚拟机 server0、desktop0 配置SELinux：

1. 确保 SELinux 处于强制启用模式
2. 在每次重新开机后，此设置必须仍然有效

## 1.2 方案

SELinux，Security-Enhanced Linux：是由美国NSA国家安全局提供的一套基于内核的增强的强制安全保护机制，针对用户、进程、文档标记安全属性并实现保护性限制。

SELinux安全体系直接集成在Linux内核中，包括三种运行模式：

- disabled：彻底禁用，内核在启动时不加载SELinux安全体系
- enforcing：强制启用，内核加载SELinux安全体系，并强制执行保护策略
- permissive：宽松模式，内核加载SELinux安全体系，只记录不执行
  执行getenforce可以查看当前所处的模式。

在disabled模式与enforcing、permissive模式之间切换时，需要重新启动Linux系统；而在enforcing模式与permissive模式之间切换时，并不需要重启，可以直接执行setenforce 1|0操作。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：调整当前的SELinux运行模式**

1）查看当前模式

```shell
[root@server0 ~]# getenforce 
Permissive                                      //表示当前为宽松模式
```

若上述操作显示的结果为Disabled，表示SELinux机制已被禁用，只能通过步骤修改固定配置后再重启；若显示的结果为Enforcing，表示已经处于强制启用模式。

2）切换为enforcing强制启用模式

如果在操作1）中显示的结果为Permissive，则执行以下操作切换为强制启用：

```shell
[root@server0 ~]# setenforce  1                  //强制启用
[root@server0 ~]# getenforce                      //确认切换结果
Enforcing
```

如果在操作1）中显示的结果为Disabled，则无法使用setenforcing命令：

```shell
[root@desktop0 ~]# getenforce 
Disabled
[root@desktop0 ~]# setenforce 1
setenforce: SELinux is disabled 
```

**步骤二：为SELinux运行模式建立固定配置**

1）修改配置文件/etc/selinux/config

```shell
[root@server0 ~]# vim  /etc/selinux/config
SELINUX=enforcing
.. ..
```

2）重启验证结果

```shell
[root@server0 ~]# reboot
.. .. 
[root@server0 ~]# getenforce 
Enforcing
```

# 2. 使用systemctl工具

## 2.1 问题

本例要求掌握systemctl控制工具的基本操作，完成下列任务：

1. 重启 httpd、crond、bluetooth 服务，查看状态
2. 禁止 bluetooth 服务开机自启，并停用此服务
3. 设置默认级别为 multi-user.target 并确认

## 2.2 方案

systemd是一个更高效的系统&服务管理器，其相关特性如下：

- 开机服务并行启动，各系统服务间的精确依赖
- 配置目录：/etc/systemd/system/
- 服务目录：/lib/systemd/system/
  systemctl是systemd的管理工具，将相关资源组织为unit配置单元进行管理。

不同的unit决定了一组相关的启动任务，service和target是最常用的配置单元：

- service：后台独立服务
- target：一套配置单元的组合，类似于传统“运行级别”

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：重启 httpd、crond、bluetooth 服务，查看状态**

1）重启系统服务httpd、crond、bluetooth

```shell
[root@svr7 ~]# systemctl  restart  httpd  crond  bluetooth
```

2）查看上述服务的状态

```shell
[root@svr7 ~]# systemctl  status  httpd  crond  bluetooth 
* httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: active (running) since Fri 2017-01-06 18:18:20 CST; 18s ago
.. ..
* crond.service - Command Scheduler
   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)
   Active: active (running) since Fri 2017-01-06 18:18:19 CST; 19s ago
.. ..
* bluetooth.service - Bluetooth service
   Loaded: loaded (/usr/lib/systemd/system/bluetooth.service; enabled; vendor preset: enabled)
   Active: active (running) since Fri 2017-01-06 18:18:19 CST; 19s ago
.. ..
```

**步骤二：禁止 bluetooth 服务开机自启，并停用此服务**

1）停用bluetooth服务

```shell
[root@svr7 ~]# systemctl  stop  bluetooth
```

2）禁止bluetooth服务开机自启

```shell
[root@svr7 ~]# systemctl  disable  bluetooth
Removed symlink /etc/systemd/system/dbus-org.bluez.service.
Removed symlink /etc/systemd/system/bluetooth.target.wants/bluetooth.service.
[root@svr7 ~]# systemctl  is-enabled  Bluetooth             //检查结果
disabled
```

**步骤三：设置默认级别为 multi-user.target 并确认**

1）查看默认运行级别

```shell
[root@svr7 ~]# systemctl  get-default 
graphical.target
```

2）将默认运行级别设置为multi-user.target

```shell
[root@svr7 ~]# systemctl  set-default  multi-user.target 
Removed symlink /etc/systemd/system/default.target.
Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.
```

3）确认配置结果

```shell
[root@svr7 ~]# systemctl  get-default 
multi-user.target
```

根据此处的设置，重启此虚拟机后图形桌面将不再可用。

# Exercise

## 1 配置虚拟机系统每次开机后SELinux处于宽松模式

```shell
[root@server0 ~]# vim  /etc/selinux/config 
SELINUX=permissive                         
.. ..
[root@server0 ~]# reboot  
```

## 2 防火墙体系中的预设保护区域有哪些，各自的作用是什么

public：仅允许访问本机的sshd等少数几个服务

trusted：允许任何访问

block：阻塞任何来访请求

drop：丢弃任何来访的数据包

## 3 防火墙设置策略时，如何实现永久策略

添加--permanent选项

利用firewall-cmd --reload进行重新加载防火墙配置

## 4 将Linux系统的默认运行级别设为文本模式

1）修改默认运行级别（target）

```shell
[root@svr7 ~]# systemctl  set-default  multi-user.target 
Removed symlink /etc/systemd/system/default.target.
Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.
```

2）确认修改结果

```shell
[root@svr7 ~]# systemctl  get-default 
multi-user.target
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Server hardware & deployment LNMP dynamic website | Cloud computing )

---

# 1. 服务器硬件

## 1.1 问题

服务器硬件品牌有哪些，服务器硬件组成结构分析：

- 常见服务器品牌介绍
- 服务器硬件组成
- 配置服务器硬件RAID
- Dell服务器iDRAC远程管理配置

## 1.2 方案

常见服务器品牌包括：IBM服务器、Dell服务器、HP服务器、浪潮服务器、华为服务器。

与普通电脑一样，服务器也是由主板、内存、CPU、磁盘、网卡、显卡、电源、主机箱等硬件设备组成。

服务器分为塔式服务器、机架式服务器、刀片服务器。

RAID是Redundant Arrays of Independent Drives（独立冗余磁盘阵列）的简称，RAID分为很多级别，常用级别有RAID0、RAID1、RAID5、RAID6、RAID10、RAID01。

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：常见服务器品牌**

1）Dell服务器是目前IDC机房中普遍采用的服务器品牌。

Dell入门级塔式服务器PowerEdge T340，如图-1所示，该服务器的目标应用是文件/打印，协作/共享，邮件/讯息，备份/恢复，视频监控等。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b09d0180aec0493f9661ed0dd12c1ed4.png)
图-1 PowerEdge T340服务器

产品配置如下：

- 4核和6核英特尔至强E-2100处理器
- 4个DIMM插槽(高达64GB的内存容量)
- 8个3.5英寸热插拔HDD硬盘
- 4个PCIe 3.0插槽
- 2个1GbE
- 单个或冗余的双495W电源或者单个350W有线电源

Dell高性能塔式服务器PowerEdge T640，如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/669db8ebbdc444be846567a3f446ed48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-2 PowerEdge T640服务器

产品配置如下：

- 双路英特尔至强CPU，每个处理器支持28个内核
- 24个DIMM内存插槽，最高支持192GB内存，仅支持ECC DDR4
- 电源750W、1100W、1600W、2000W、2400W

Dell入门级单路机架式服务器PowerEdge R330（1U=44.45mm=4.45cm），如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d83e369b266c4a67bdb12e88c33a91be.png)
图-3 PowerEdge R330机架式服务器

产品配置如下：

- 1路CPU，英特尔至强、英特尔奔腾、英特尔酷睿CPU
- 4个DIMM，最高支持64GB内存
- 2.5或3.5寸硬盘，STATA或SAS接口
- 双电源

Dell机架式服务器PowerEdge R740（2u=88.9mm=8.89cm），如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5e51291d018e4fcdb0da816e2e26a846.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-4 PowerEdge R740服务器

产品配置如下：

- 双路CPU，每个CPU支持28个核心
- 24个DIMM内存插槽，最高192GB，ECC DDR4
- 双电源

2）IBM服务器

IBM机架式服务器X3250M6（1U），如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0d95165fe7334a25a712fbfbe294b9ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5 IBM X3250M6服务器

产品配置如下：

- 1路CPU，英特尔至强处理器
- 4个DIMM内存插槽，最大64G内存
- 4个3.5寸磁盘位，默认无硬盘，最大可配24TB
- 支持RAID 0，1，5
- 一个300W固定电源

3）HP服务器
HPE ProLiant DL380 Gen10 服务器（2U），如图-6所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1e13e1c9f7ac431ca178ddac30ac75a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6 HPE ProLiant DL380 Gen10 服务器

产品配置如下：

- 2路CPU，英特尔至强
- 24个DIMM插槽，支持最大3T DDR4内存
- 24个磁盘接口
- iLO远程管理
- 4个网卡接口

**步骤二：服务器硬件组成**
1）CPU
英特尔：酷睿八代（i3,i5,i7,i9），酷睿九代(i3,i5,i7,i9)，酷睿十代
至强E（标准版），至强W（高功耗版）
奔腾处理器
AMD： 家用版（锐龙、速龙）
服务器版本（皓龙、霄龙）

2) 内存
   常见品牌：金士顿、三星
   家用普通内存不具有数据校验功能
   服务器配置带ECC数据校验功能的内存条
   规格：DDR1、DDR2、DDR3、DDR4、DDR5

3）硬盘
常见品牌：三星、英特尔、希捷、西部数据
家用磁盘接口：SATA
服务器磁盘接口：SAS
SSD固态硬盘
大小：2.5寸、3.5寸

4）远程管理设备
Dell： iDRAC
HP： iLO
IBM： Tivoli/ˈtɪvəli/

**步骤三：配置服务器硬件RAID**

1）RAID5

服务器开机后根据提示快速按Ctrl+R组合键即可进入RAID配置界面，如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f3f7e44908d44e898df9844bdbbd622e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-7

进入RAID配置界面可以看到所有未配置的磁盘列表，主菜单包含：VD Mgmt、PD Mgmt、Ctrl Mgmt、Properties，如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3e0eeca5a8224d8b88908900e4dd7311.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

Ctrl+N进入下一页菜单，Ctrl+P进入上一页菜单，通过F2可以进入配置菜单，如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f655f872b0854656ba76e7b7ca8ff1cc.png)
图-9

正式配置RAID之前可以使用Clear Config清空所有配置，然后选择Create New VD创建新的RADID磁盘阵列，如图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/53627243b81f426e8439195a135bf705.png)
图-10

在RAID Level中选择RAID级别，如RAID5（最少需要三块磁盘），并在右侧Physical Disks中选择使用哪些物理磁盘组合RAID，如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1cc61a7fe42c409caac375babae9ae14.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-11

点击OK确定后，可以在主菜单中看到刚刚创建的磁盘阵列，按F2选择Properties可以配置该磁盘阵列的高级属性，如图-12所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b774f8725e6a48c49300880331130791.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-12

点击Advanced高级，如图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/502450239f3840b4b8f787c2922ac17a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-13

在高级属性中开启磁盘缓存，默认未unchanged，需要设置为enable，并可以设置缓存策略：Write Through直写和Write Back回写，write through模式时数据同时被写入缓存和磁盘，安全，但是写入速度慢，write back模式时数据先写入缓存，再写入磁盘，写入速度快，但数据写入缓存时突发断电会导致数据丢失。配置菜单如图-14所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a172f0a4ef604d959a716b3750653112.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-14

创建完RADID后还需要初始化磁盘，菜单如图-15所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/29eade1c54134509b1624e42ee6089be.png)
图-15

2）RAID故障恢复

将损坏的磁盘拔掉，替换一块新的磁盘即可，注意需要将新磁盘插入损坏的磁盘相同接口。磁盘大小、品牌尽可能一致。恢复数据时界面会提示Rebuild，效果如图-16所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c124b9d08fd243528ef16015c569b636.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-16

3）配置Hot Spare磁盘

热备磁盘是提前准备一块备用的磁盘（当前并不使用），当RAID磁盘阵列出现损坏后，系统自动使用该热备磁盘，替代损坏的磁盘，从而不需要人工插拔磁盘即可自动修复。

创建新的RAID磁盘阵列时，不要使用完所有磁盘，留一块磁盘做热备磁盘，点击Advanced高级选项即可配置热备磁盘，如图-17所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/23721b037f234d9bbab23a37f3b25db3.png)
图-17

勾选Configure Hot Spare配置热备磁盘，如图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d03c710847c8482b8684b45454355ab6.png)
图-18

在弹出的对话框中勾选需要的热备磁盘即可完成配置，如图-19所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b674a17765994af19476816d5657406c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-19

4）其他级别的磁盘阵列

其他级别的磁盘阵列配置方式类似，可以根据自己的需要进行配置如RAID10，RAID6等，但是都需要磁盘阵列卡支持才可以配置。

**步骤四：Dell服务器iDRAC远程管理配置**

1）配置端口重定向

iDRAC（Integrated Dell Remote Access Controller），是戴尔服务器集成的远程控制卡。

iDRAC需要授权使用，有授权的情况下可以直接通过浏览器访问：http://服务器IP，远程管理服务器，没有授权的情况下可以通过端口重定向将服务器上的显示内容重定向到远程管理端的电脑上（一般是用自己的笔记本远程服务器），这种方式不需要授权。

开启服务器后根据提示快速按F2键进入BIOS界面，如图-20所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ccf440212ca04f01a6471c6c5adf5b96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-20

进入BIOS Settings后，选择Serial Communication菜单，如图-21所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/481937ff4c094c319911709ee4588e5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-21

将控制台重定向到com2，设置Serial Device=com1，Serial Device=com2，效果如图-22所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/044c105ef3bd4b6b942e36817facdd14.png)
图-22

2）初始化清空iDRAC设置

进入iDRAC Setting界面选择Rest iDRAC configuration to defaults，如图-23所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1d4567224dbe40929d7d1638ffdda634.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-23

3）配置iDRAC网络

进入iDRAC Setting界面选择network，如图-24所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a418e964b5754927b324de9466764cdd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-24

选择网卡并配置IP地址，如图-25和图-26所示，网段需要根据实际情况自行配置。

![在这里插入图片描述](https://img-blog.csdnimg.cn/38aea25c02ee48feb96cafbba3583789.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-25

![在这里插入图片描述](https://img-blog.csdnimg.cn/d45743004a9c455d9c741497a3a087c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-26

开启IPMI智能平台管理接口（配置后可以通过命令行管理服务器），客户端安装ipmitool软件包，如图-27所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/24e330fcc24e47d6b018bf5d05c865cb.png)
图-27

4）配置远程管理账户

进入iDRAC Setting界面选择User Configuration，如图-28所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ce6f96064c184b7fb92dfcdf5f8b8fb4.png)
图-28

配置账户名称root，并设置密码，如图-29所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/07dfefad203d46998cdea48b829c90a2.png)
图-29

5）远程管理端主机配置，安装ipmitool软件包

```shell
[root@centos7 ~]# yum -y install ipmitool
```

常用命令操作列表如下。

```shell
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power status
#查看服务器电源状态
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power on
#开启服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power off
#关闭服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power reset
#重启服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  sol activate
#远程管理
```

# 2. 部署LNMP动态网站

## 2.1 问题

部署LNMP动态网站，实现以下目标：

1. 安装LNMP平台相关软件
2. 配置Nginx实现动静分离
3. 配置数据库，创建账户与密码
4. 上线Wordpress代码
5. 使用Wordpress后台管理界面，调整Wordpress版式

## 2.2 方案

实验拓扑如图-30所示，做具体实验前请先配置好环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/426122fdae77414aaefdbe9e344325e8.png)
图-30

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装部署LNMP软件**

备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。

1）安装软件包

```shell
[root@centos7 ~]# yum -y install gcc openssl-devel pcre-devel   #安装依赖包
[root@centos7 ~]# tar -xf nginx-1.12.2.tar.gz
[root@centos7 ~]# cd nginx-1.12.2
[root@centos7 nginx-1.12.2]# ./configure   \
--with-http_ssl_module   \
--with-http_stub_status_module
[root@centos7 nginx-1.12.2]# make && make install
[root@centos7 ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
[root@centos7 ~]# yum -y install   php        php-mysql        php-fpm
```

2)启动服务(nginx、mariadb、php-fpm)

```shell
[root@centos7 ~]# /usr/local/nginx/sbin/nginx             #启动Nginx服务
[root@centos7 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@centos7 ~]# chmod +x /etc/rc.local
[root@centos7 ~]# ss -utnlp | grep :80                    #查看端口信息
[root@centos7 ~]# systemctl start   mariadb               #启动mariadb服务器
[root@centos7 ~]# systemctl enable  mariadb                #设置开机自启               
[root@centos7 ~]# systemctl start  php-fpm               #启动php-fpm服务
[root@centos7 ~]# systemctl enable php-fpm                #设置开机自启
```

备注：设置防火墙与SELinux.

```shell
[root@centos7 ~]# firewall-cmd --set-default-zone=trusted
[root@centos7 ~]# setenforce  0
[root@centos7 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

附加知识：systemd！！！

源码安装的软件默认无法使用systemd管理，如果需要使用systemd管理源码安装的软件需要手动编写服务的service文件（编写是可以参考其他服务的模板文件）。以下是nginx服务最终编辑好的模板。

Service文件存储路径为/usr/lib/systemd/system/目录。

```shell
[root@centos7 ~]# vim /usr/lib/systemd/system/nginx.service
[Unit]
Description=The Nginx HTTP Server
#描述信息
After=network.target remote-fs.target nss-lookup.target
#指定启动nginx之前需要其他的其他服务，如network.target等
[Service]
Type=forking
#Type为服务的类型，仅启动一个主进程的服务为simple，需要启动若干子进程的服务为forking
ExecStart=/usr/local/nginx/sbin/nginx
#设置执行systemctl start nginx后需要启动的具体命令.
ExecReload=/usr/local/nginx/sbin/nginx -s reload
#设置执行systemctl reload nginx后需要执行的具体命令.
ExecStop=/bin/kill -s QUIT ${MAINPID}
#设置执行systemctl stop nginx后需要执行的具体命令.
[Install]
WantedBy=multi-user.target
```

3）修改Nginx配置文件，实现动静分离

```shell
修改配置文件，通过两个location实现动静分离，一个location匹配动态页面，一个loation匹配其他所有页面。

注意修改默认首页为index.php!！！！

[root@centos7 ~]# vim /usr/local/nginx/conf/nginx.conf 
...省略部分配置文件内容...
location / {
            root   html;
            index  index.php index.html index.htm;
        }
...省略部分配置文件内容...
location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
...省略部分配置文件内容...
[root@centos7 ~]# /usr/local/nginx/sbin/nginx -s reload            #重新加载配置
```

4）配置数据库账户与权限

```shell
为网站提前创建一个数据库、添加账户并设置该账户有数据库访问权限。

[root@centos7 ~]# mysql
MariaDB [(none)]> create database wordpress character set utf8mb4;
#创建数据库，数据库名称为wordpress，该数据库支持中文（character set utf8mb4）
MariaDB [(none)]> grant all on wordpress.* to wordpress@'localhost' identified by 'wordpress';
#语法格式：grant 权限 on 数据库名.表名  to 用户名@客户端主机 identified by 密码
#创建用户并授权，用户名为wordpress，该用户对wordpress数据库下的所有表有所有权限
#wordpress用户的密码是wordpress，授权该用户可以从localhost主机登录数据库服务器
#all代表所有权限（wordpress用户可以对wordpress数据库中所有表有所有权限）
#wordpress.*代表wordpress数据库中的所有表
MariaDB [(none)]> grant all on wordpress.* to wordpress@'192.168.2.11' identified by 'wordpress';
MariaDB [(none)]> flush privileges;
#刷新权限
MariaDB [(none)]> exit
#退出数据库
如何验证？
看看是否可以使用新创建的账户登录数据库服务器：
[root@centos7 ~]# mysql -uwordpress -pwordpress -h 192.168.2.11 wordpress
#-u指定数据库账户名称，-p指定数据库账户的密码，-h指定需要远程数据库的IP地址
#最后的wordpress为数据库的名称
```

**步骤二：上线wordpress代码**

1）上线PHP动态网站代码（wordpress.zip在lnmp_soft目录中）

```shell
[root@centos7 ~]# yum -y install unzip
[root@centos7 ~]# unzip wordpress.zip
[root@centos7 ~]# cd wordpress
[root@centos7 wordpress]# tar -xf wordpress-5.0.3-zh_CN.tar.gz
[root@centos7 wordpress]# cp -r  wordpress/*  /usr/local/nginx/html/
[root@centos7 wordpress]# chown -R apache.apache  /usr/local/nginx/html/
```

提示：动态网站运行过程中，php脚本需要对网站目录有读写权限，而php-fpm默认启动用户为apache。（chown所有所有者和所属组时，使用:或者.都可以）

2)初始化网站配置（使用客户端访问web服务器IP）

```shell
客户端浏览器访问： firefox http://192.168.2.11/
```

第一次访问服务器会自动进入config配置页面，效果如图-31所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0cdb785ad0874d35b51635e990864943.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_17,color_FFFFFF,t_70,g_se,x_16)
图-31

开发人员在写代码的时候并不知道未来数据库服务器的IP、端口、数据库名称、账户等信息，该配置页面主要的作用就是动态配置数据库信息，根据前面步骤配置的数据库信息填空即可，效果如图-32所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4eeed482670944c282f672c1b8a25813.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-32

点击提交即可完成数据库的初始化工作，php动态脚本会自动在wordpress数据库中创建若干数据表，后期网站的数据都会写入对并的数据表中。效果如图-33所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d725f26c10074168aee7bce817531289.png)
图-33

第一次使用Wordpress需要给你的网站设置基本信息，如网站标题、网站管理员账户与密码等信息，配置完成后点击安装wordpress即可，如图-34所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b744484b22924bb8a6681cbd77612061.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-34

**步骤三：网站后台管理**

1）访问192.168.2.11服务器，进入并熟悉后台管理界面

通常情况下，开发人员会开发一个后台管理界面，当代码上线后，普通用户就可以管理和配置网站页面（需要使用网站的超级管理员身份才可以进入后台界面）。

```shell
客户端使用浏览器访问： firefox http://192.168.2.11  
```

访问首页后点击如图-35所示的登陆菜单，输入账户和密码进入后台管理界面。

![在这里插入图片描述](https://img-blog.csdnimg.cn/aba683ae73a247bda9109baeaa4832da.png)
图-35

或者直接在地址栏中输入后台管理界面的具体URL。

```shell
客户端使用浏览器访问： firefox  http://192.168.2.11/wp-login.php
```

输入管理员用户名和密码，效果如图-36所示。登陆后台管理界面效果如图-37所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0f25532469fd41c79e6424057eae2f56.png)
图-36

![在这里插入图片描述](https://img-blog.csdnimg.cn/b9b5f097e8424f198e85515be997dad0.png)
图-37

2）修改网站主题

Wordpress主题会影响网站的整体外观，我们可以使用默认自带的若干主题。

后台修改网站主题的菜单为<外观>--<主题>，使用默认主题，点击启用即可，如图-38所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9e2346036bb34803aabe3f867362ac7f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-38

如果需要更多更新的主题，则可以去官网下载更多新的主题，默认下载的主题格式为zip压缩包。

官方网站主题链接：（https://cn.wordpress.org/themes/browse/popular/）。

将主题下载到服务器本地后，可以在后台管理界面添加主题，<外观>--<主题>--<添加>--<上传主题>--<浏览>--<现在安装>，如图-39所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/af9de62fd08b4f4c99fbe7f846172c1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-39

部署新主题的另一种方法是，直接将下载的zip主题包拷贝到wordpress代码的特定目录，如/usr/local/nginx/html/wp-content/themes/目录，然后使用unzip解压主题即可，效果如图-40所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c9220e85e416448fbc6cbf0b83f186e8.png)
图-40

3）修改网站小工具

小工具是首页中的各种常用功能菜单，可以添加和删除。

首先可以删除一些不需要的小工具，如最近文章、最近评论等，如图-41所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2c17eeb775184480a18418c4af49a25b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-41

可以通过小工具为网站添加导航功能，使用鼠标将导航菜单拖动到合适的位置即可，默认没有导航菜单，需要自定义创建，如图-42所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/36395a6ce89a486180ef4d5a3be6c637.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-42

创建导航菜单后，可以继续创建页面，并将页面添加到导航菜单中。<页面>--<新建页面>即可添加新的页面，如图-43和图-44所示。新的页面内容可以是段落、图像、列表、引语等（每个人根据自己的需要自由发挥）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/66625d9081b145f4a2003489a070cf98.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-43

![在这里插入图片描述](https://img-blog.csdnimg.cn/e68b42b56ea549fba67ff150e409bb1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-44

新的页面添加完成后，可以将其添加到菜单中使用，如图-45所示。访问网站首页即可查看导航菜单的效果，如图-46所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1405b0e9affd4cbab7e25f28833a9eee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-45

![在这里插入图片描述](https://img-blog.csdnimg.cn/2bbcb72826524da6a26e79b05d83e864.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-46

4）扩展其他问题

其他有关wordpress的使用方法与技巧，可以参考官方网站的文档资料，文档链接：https://codex.wordpress.org/zh-cn:Main_Page。

**附加知识（常见面试题）**

1）描述raid 0、1、5的特点和优点?

答：Raid0条带卷，可以高效读写，硬盘空间利用率100%，raid1是复制卷可以实现数据的高可靠读写，硬盘空间利率50%，raid5兼得以上两种优点，硬盘空间利用率N-1，仅可用损坏一块硬盘。

2）将目录/opt/bjca3打包备份排除/opt/bjca3/logs目录，传递到远程主机192.168.1.8的/backup目录下？

答：使用--exclude选项在打包时可用排除特定的目录，但是要注意，使用tar 的--exclude 排除打包的时候，不能加“/”，否则还是会把logs目录以及其下的文件打包进去。

错误写法：

tar -czvf bjca3.tar.gz --exclude=/opt/bjca3/logs/ /opt/bjca3

正确写法：

tar -czvf bjca3.tar.gz --exclude=/opt/bjca3/logs /opt/bjca3

3) 如何远程查看Linux服务192.168.1.7运行了多少时间？

答：ssh root@192.168.1.7 uptime

4）虚拟机常用有几种网络模式？请简述其工作原理或你个人的理解？

答：有桥接模式、隔离模式、NAT模式、路由模式，如图-47所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5d19e6e526f34d638226fb4df20e2448.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-47

桥接模式：Guest与Host连接到同一个交换机上；通过桥接物理网卡，相当于直连到Host所在网络。（备注：Guest是虚拟机，Host是真实主机）

隔离模式：允许Guest访问同一虚拟交换机上的其他Guest；但是不能访问Host所在的外部网络。

NAT模式（默认）：将Guest虚拟机的默认网关指向Host物理机的虚拟网桥接口的IP地址；Guest共享真机的网络连接，以地址转换的方式访问外网。

路由模式：由Host物理机充当路由器，开启转发；需要额外设置外网与Guest虚拟机之间互访的路由条目，Guest以路由转发的方式访问外网（需要在真机配置iptables规则）。

5）在11月份内，每天的早上6点到12点中，每隔2小时执行一次 /usr/bin/httpd.sh，怎么实现？

答：

0 6-12/2 * 11 * /usr/bin/httpd.sh

6）如何查看当前系统是否有监听6666端口？

答：

netstat -untlp | grep 6666或者ss -nutlp | grep 6666

7) 如何显示CPU占用率最高的进程？

答：

top，输入大写的P

8）用什么命令可以查看上一次服务器启动时间、上一次谁登陆过服务器?

答：

last（历史登陆记录），uptime（系统累计运行的时间），who -b(上次启动系统的时间)

> 如有侵权，请联系作者删除



﻿@[TOC]( Session is shared with cookies & deployment memcached & and Session | Cloud computing )

---

# 1 案例1：PHP的本地Session信息

## 1.1 问题

通过Nginx调度器负载后端两台Web服务器，实现以下目标：

1. 部署Nginx为前台调度服务器
2. 调度算法设置为轮询
3. 后端为两台LNMP服务器
4. 部署测试页面，查看PHP本地的Session信息

## 1.2 方案

概念：

Session：存储在服务器端，保存用户名、登陆状态等信息。
Cookies：由服务器下发给客户端，保存在客户端的一个文件里。
保存的内容主要包括：SessionID。

实验拓扑环境：
使用4台RHEL7虚拟机，其中一台作为Nginx前端调度器服务器（eth0:192.168.4.5,eth1:192.168.2.5）、两台虚拟机部署为LNMP服务器，分别为Web1服务器（192.168.2.100）和Web2服务器（192.168.2.200），另外一台作为测试用的Linux客户机（192.168.4.10），拓扑如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4b744b647a3430e8d4afdd57606ea01.png)
图-2

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署后端LNMP服务器相关软件**

**注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作，下面我们以一台Web2服务器（192.168.2.200）为例，对Web1服务器执行相同操作即可。**

1）使用yum安装基础依赖包

```shell
[root@web2 ~]# yum -y install gcc openssl-devel pcre-devel
.. ..
```

2）源码安装Nginx

```shell
[root@web2 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web2 ~]# cd nginx-1.12.2
[root@web2 nginx-1.12.2]#  ./configure   \
> --with-http_ssl_module 
[root@web2 nginx-1.12.2]# make && make install
```

3）安装MariaDB数据库

```shell
[root@web2 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel
```

4）安装PHP

```shell
[root@web2 ~]# yum -y install  php  php-mysql
[root@web2 ~]# yum -y install  php-fpm
```

5）修改Nginx配置文件（修改默认首页与动静分离）

```shell
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           # fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;
        }
```

**步骤二：启动LNMP服务器相关的服务**

1）启动Nginx服务

这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。

```shell
[root@web2 ~]# systemctl stop  httpd                //如果该服务存在，则关闭该服务
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# ss -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
```

2）启动MySQL服务

```shell
[root@web2 ~]# systemctl start mariadb
[root@web2 ~]# systemctl status mariadb
```

3）启动PHP-FPM服务

```shell
[root@web2 ~]# systemctl start  php-fpm
[root@web2 ~]# systemctl status php-fpm
```

**步骤三：部署前端Nginx调度服务器**

1）使用源码安装nginx软件（如果Nginx软件包已安装可以忽略此步骤）

```shell
[root@proxy ~]# yum  -y  install   gcc pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install
```

2）修改Nginx配置文件，实现代理服务器

Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询，使用proxy_pass调用upstream定义的服务器地址池：

```shell
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
              proxy_pass http://webs;
            root   html;
            index  index.php index.html index.htm;
          }
}
```

3）重新加载配置文件

```shell
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
```

**步骤四：测试环境是否配置成功**

1）浏览器访问测试页面验证。

```shell
[root@client ~]# curl  http://192.168.4.5                //查看是否有数据
```

**步骤五：部署测试页面**

1）部署测试页面(Web1服务器）。

测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。

```shell
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/
```

2）浏览器直接访问后端服务器的测试页面（Web1服务器）。

```shell
[root@web1 ~]# firefox http://192.168.2.100    /index.php        //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        //注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
```

注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。

3）部署测试页面(Web2服务器）。

测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。

```shell
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/
```

4）浏览器直接访问后端服务器的测试页面（Web2服务器）。

```shell
[root@web2 ~]# firefox http://192.168.2.100    /index.php         //填写账户信息
[root@web2 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401                        //注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    
```

注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=green>。

5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。

真实主机使用google浏览器测试。

```shell
[root@room9pc01 ~]# google-chrome http://192.168.4.5/index.php
//填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
//第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机
```

# 2. 构建memcached服务

## 2.1 问题

本案例要求先快速搭建好一台memcached服务器，并对memcached进行简单的增、删、改、查操作：

- 安装memcached软件，并启动服务
- 使用telnet测试memcached服务
- 对memcached进行增、删、改、查等操作

## 2.2 方案

使用1台RHEL7虚拟机作为memcached服务器（192.168.4.5）。

在RHEL7系统光盘中包含有memcached，因此需要提前配置yum源，即可直接使用yum安装，客户端测试时需要提前安装telnet远程工具。

验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：

- add name 0 180 10 //变量不存在则添加
- set name 0 180 10 //添加或替换变量
- replace name 0 180 10 //替换
- get name //读取变量
- delete name //删除变量
- flush_all //清空所有
- 提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：构建memcached服务**

1）使用yum安装软件包memcached

```shell
[root@proxy ~]# yum -y  install   memcached   telnet
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64
```

2) memcached配置文件（查看即可，不需要修改）

```shell
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""
```

3）启动服务并查看网络连接状态验证是否开启成功：

ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。

```shell
[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# ss  -anptu  |  grep Memcached
udp  UNCONN  0 0    *:11211   *:*      users:(("memcached",pid=12068,fd=28))
udp  UNCONN  0 0    :::11211  :::*     users:(("memcached",pid=12068,fd=29))
tcp  LISTEN  0 128  *:11211   *:*      users:(("memcached",pid=12068,fd=26))
tcp  LISTEN  0 128  :::11211  :::*     users:(("memcached",pid=12068,fd=27))
```

**步骤二：使用telnet访问memcached服务器**

1)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。

```shell
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
……
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
set name 0 180 3                //定义变量，变量名称为name
plj                            //输入变量的值，值为plj                
STORED
get name                        //获取变量的值
VALUE name 0 3                 //输出结果
plj
END
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
add myname 0 180 10            //新建，myname不存在则添加，存在则报错
set myname 0 180 10            //添加或替换变量
replace myname 0 180 10        //替换，如果myname不存在则报错
get myname                    //读取变量
delete myname                    //删除变量
flush_all                        //清空所有
quit                            //退出登录                                  
```

# 3. PHP实现session共享

## 3.1 问题

沿用练习三，通过修改PHP-FPM配置文件，实现session会话共享：

配置PHP使用memcached服务器共享Session信息
客户端访问两台不同的后端Web服务器时，Session 信息一致

## 3.2 方案

在练习三拓扑的基础上，Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，并在两台后端LNMP服务器上实现PHP的session会话共享。拓扑结构如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1cc8d13ddac6458d80f00ceabfb3a5b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为Web服务器安装PHP扩展**

1）为web1主机的PHP添加memcache扩展

```shell
[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm
···
2）为web2主机的PHP添加memcache扩展
```shell
[root@web2 ~]# yum -y install  php-pecl-memcache
[root@web2 ~]# systemctl restart php-fpm
```

**步骤二：在后端LNMP服务器上部署Session共享**

注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。

1）修改PHP-FPM配置文件，并重启服务

注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。

```shell
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
//文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
//原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
//定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm
```

**步骤三：客户端测试**

客户端使用浏览器访问两台不同的Web服务器。

操作步骤参考练习一，最终可以获得相关的Session ID信息。


# Exercise

## 1 简述什么是memcached

- memcached是高性能的分布式缓存服务器，是一个跨平台的、开源的实现分布式缓存服务的软件
- 用来集中缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的响应速度
- memcached支持许多平台：Linux、FreeBSD、Solaris (memcached 1.2.5以上版本)、Mac OS X、Windows

## 2 PHP的Session会话共享

> 要求：PHP通过memcached实现Session会话共享，修改哪儿文件如何修改？

```shell
vim  /etc/php-fpm.d/www.conf
修改前:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
修改后
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211" 
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Shell overview & writing & executing scripts & Shell variables & numerical calculations | Cloud computing )

---

# 1 案例1：Shell基础应用

## 1.1 问题

本案例要求熟悉Linux Shell环境的特点，主要练习以下操作：

1. 切换用户的Shell环境
2. 练习命令历史、命令别名
3. 重定向标准输入/输出/错误输出
4. 管道操作实践

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：切换用户的Shell环境**

什么是shell？

Shell是在Linux内核与用户之间的解释器程序，通常指的是bash，负责向内核翻译及传达用户/程序指令，如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/592739eb50574c44909d64a33b716247.png)
图-1

shell的使用方式：

1. 交互执行指令：人工干预，执行效率底。
2. 非交互执行指令：安静地在后台执行，执行效率高，方便写脚本。

若需要临时使用另一种Shell环境，可以直接执行对应的Shell解释器程序，比如只要执行ksh可以切换到ksh命令行环境。

```shell
[root@svr5 ~]# yum -y install ksh              //若缺少ksh请先安装ksh包
.. ..
[root@svr5 ~]# cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/bin/tcsh
/bin/csh
/bin/ksh                                        //确认当前系统已识别ksh
[root@svr5 ~]# ksh                              //进入ksh环境
[root@svr5]~# exit                              //返回到切换前的bash环境
```

若希望修改用户的登录Shell，管理员可以直接通过usermod（或useradd）命令设置。比如，以下操作可将用户zhangsan的登录Shell改为/bin/ksh：

```shell
[root@svr5 ~]# usermod -s /bin/ksh zhangsan              //执行修改操作
[root@svr5 ~]# grep 'zhangsan' /etc/passwd
zhangsan:x:516:516::/home/zhangsan:/bin/ksh              //修改后
```

**步骤二：快捷键与Tab键补齐，常见快捷键如表-1所示**

![在这里插入图片描述](https://img-blog.csdnimg.cn/957aef4889bc4c268c6c60f31d59600f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
表-1


**步骤三：练习命令历史**

1）检查历史命令的容量。

默认记录1000条，通过全局变量HISTSIZE设置，对所有用户有效：

```shell
[root@svr5 ~]# grep HISTSIZE /etc/profile
HISTSIZE=1000
```

查看已为当前用户记录的历史命令条数：

```shell
[root@svr5 ~]# history | wc -l
1000
```

2）查看历史命令列表。

列出最近执行的10条历史命令：

```shell
[root@svr5 ~]# history | tail
 1028  grep 'zhangsan' /etc/passwd
 1029  cat /etc/redhat-release
 1030  usermod -s /bin/tcsh zhangsan
 1031  grep 'zhangsan' /etc/passwd
 1032  su - zhangsan
 1033  echo 1234567 | passwd --stdin zhangsan
 1034  su - zhangsan
 1035  grep HISTSIZE /etc/profile
 1036  history | wc -l
 1037  history | tail
```

3）调用指定的历史命令。

重新执行历史命令列表中的第1028条操作：

```shell
[root@svr5 ~]# !1028
grep 'zhangsan' /etc/passwd
zhangsan:x:516:516::/home/zhangsan:/bin/bash
```

重新执行最近一次以cat开头（根据实际情况变更）的历史命令操作：

```shell
[root@svr5 ~]# !cat
cat /etc/redhat-release
Red Hat Enterprise Linux Server… …
```

**步骤四：练习命令别名**

1）查看已经定义的命令别名列表。

当前的别名列表：

```shell
[root@svr5 ~]# alias
alias cp='cp -i'
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
… …
```

**步骤四：重定向标准输入/输出/错误输出**

1）重定向标准输出。

使用 > 将命令执行的正常输出重定向到文件：

```shell
[root@svr5 ~]# ls -ld /etc/                        //正常应输出到屏幕
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
[root@svr5 ~]# ls -ld /etc/ > stdout.txt              //重定向到文件
[root@svr5 ~]# cat stdout.txt                      //确认重定向输出的结果
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
```

> 操作会覆盖目标文件（先清空、再写入）：

```shell
[root@svr5 ~]# echo "I am the king." > stdout.txt          //覆盖目标文件
[root@svr5 ~]# cat stdout.txt                          //确认结果
I am the king.
```

改用 >> 可实现追加重定向输出：

```shell
[root@svr5 ~]# ls -ld /etc/  >> stdout.txt              //追加输出
[root@svr5 ~]# cat stdout.txt
I am the king.                                          //原有内容还保留
drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
```

2）重定向标准错误。

对于命令执行出错的信息，使用 > 无法保存，仍然会输出到屏幕。比如，可使用ls命令同时查看两个对象（其中nb.txt并不存在），重定向输出：

```shell
[root@svr5 ~]# ls -l nb.txt /etc/fstab > stderr.txt
 [root@svr5 ~]# cat stderr.txt                  //正常信息成功重定向到目标文件
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
```

使用 2> 可重定向错误信息，比如，可执行一个错误的命令：

```shell
[root@svr5 ~]# ls -l nb.txt /etc/fstab 2> stderr.txt 
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
//正确的信息默认输出至屏幕，错误信息重定向到目标文件 
[root@svr5 ~]# cat stderr.txt                        //从文件中查看出错信息
ls: nb.txt: 没有那个文件或目录
```

类似的，2>> 可实现追加输出：

```shell
[root@svr5 ~]# ls tmpfile 2>> stderr.txt
[root@svr5 ~]# cat stderr.txt
ls: nb.txt: 没有那个文件或目录
ls: tmpfile: 没有那个文件或目录
```

若希望将正常输出、错误输出重定向同一个文件，可使用 &> :

```shell
[root@svr5 ~]# ls -l nb.txt /etc/fstab &> stderr.txt
[root@svr5 ~]# cat stderr.txt
ls: nb.txt: 没有那个文件或目录
-rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
```

3）重定向标准输入。

```shell
[root@svr5 ~]# mail -s Error  root   < /etc/passwd
```

4）案例

```shell
[root@svr5 ~]# cat  /root/test.sh
#!/bin/bash
for  i   in   {1..10}
do
            useradd  user$i  2>>/root/user.log
            echo  '123456' | passwd  --stdin  user$i  >/dev/null
done
```

**步骤五：管道操作实践**

借助于管道符“|”，可以将一条命令的标准输出交给另一条命令处理，在一条命令行内可依次使用多个管道。

1）统计/etc/目录下资料的数量。

```shell
[root@svr5 ~]# ls -l /etc | wc -l
254
```

2）列出Yum库里名称中含cluster的软件包。

```shell
[root@svr5 ~]# yum list | grep cluster
cluster-cim.x86_64                 0.12.1-7.el5     RHEL5-Cluster
cluster-snmp.x86_64                 0.12.1-7.el5     RHEL5-Cluster
… …
```

# 2. 简单Shell脚本的设计

## 2.1 问题

本案例要求编写三个脚本程序，分别实现以下目标：

1. 在屏幕上输出一段文字“Hello World”
2. 能够为本机快速配好Yum仓库
3. 能够为本机快速装配好vsftpd服务

## 2.2 方案

一个规范的Shell脚本构成包括：

- 脚本声明（需要的解释器、作者信息等）
- 注释信息（步骤、思路、用途、变量含义等）
- 可执行语句（操作代码）

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写第一个Shell脚本，输出“Hello World”**

1）根据手动任务操作编写脚本文件

```shell
[root@svr5 ~]# vim  /root/first.sh  
#!/bin/bash
echo  'Hello World' 
exit
[root@svr5 ~]# chmod  +x  /root/first.sh                      //添加可执行权限
```

2）执行脚本，测试效果

```shell
[root@svr5 ~]# /root/first.sh 
Hello World
```

3）Shell脚本的执行方式：

方法一，作为“命令字”：指定脚本文件的路径，前提是有 x 权限

```shell
[root@svr5 ~]# ./first.sh                            //指定相对路径
[root@svr5 ~]# /root/first.sh                        //指定绝对路径
```

方法二，作为“参数”：使用bash、sh、source来加载脚本文件

```shell
[root@svr5 ~]# bash   first.sh                        //开启子进程
[root@svr5 ~]# sh        first.sh                        //开启子进程
[root@svr5 ~]# source first.sh                        //不开启子进程
```

**步骤二：编写为本机快速配Yum仓库的Shell脚本**

1）Yum仓库配置文件的参考内容如下：

```shell
[root@svr5 ~]# cat /etc/yum.repos.d/rhel.repo 
[rhel]
name=redhat
baseurl=file:///misc/cd                        //yum源不一样，不能直接抄！！！
enabled=1
gpgcheck=0
````

2）根据参考文件的内容，编写脚本内容如下：

```shell
[root@svr5 ~]# vim  /root/yum.sh
#!/bin/bash
rm  -rf  /etc/yum.repos.d/*.repo 
echo  '[rhel]
name=redhat
baseurl=file:///misc/cd
gpgcheck=0
'  > /etc/yum.repos.d/rhel.repo 
[root@svr5 ~]# chmod +x /root/yum.sh                      //添加可执行权限
```

3）执行脚本，测试效果

执行配置Yum仓库的脚本：

```shell
[root@svr5 ~]# /root/yum.sh 
```

检查配置结果：

```shell
[root@svr5 ~]# ls /etc/yum.repos.d/*                          //仓库配置已建立
/etc/yum.repos.d/rhel.repo
[root@svr5 ~]# yum repolist                                  //Yum仓库已可用
rhel-packages                              | 3.9 kB     00:00 ... 
rhel-packages/primary_db                  | 3.1 MB     00:00 ... 
repo id                repo name                       status
rhel                     redhat                         3,690
repolist: 3,690
```

**步骤三：编写快速装配vsftpd服务的Shell脚本**

1）编写参考脚本文件如下：

```shell
[root@svr5 ~]# vim  /root/ftpon.sh
#!/bin/bash
yum  -y  install  vsftpd  &> /dev/null
systemctl  start  vsftpd
systemctl  enable  vsftpd
cp /etc/hosts /var/ftp/pub
#拷贝一个文件，放到FTP共享目录下
[root@svr5 ~]# chmod  +x  /root/ftpon.sh                  //添加可执行权限
```

3）执行脚本，测试效果

执行快速装配vsftpd服务的脚本：

```shell
[root@svr5 ~]# /root/ftpon.sh 
```

确认脚本执行结果：

```shell
[root@svr5 ~]# rpm -q vsftpd
vsftpd-3.0.2-10.el7.x86_64
[root@svr5 ~]# systemctl  status  vsftpd
```

# 3. 使用Shell变量

## 3.1 问题

本案例要求熟悉Shell变量的使用，主要练习或验证下列内容：

1. 定义/赋值/查看变量
2. 环境/预定义/位置变量的应用

除了学会建立和引用变量以外，还要认识环境变量PWD、USER、HOME、SHELL，还有预定义变量\$0、\$\$、\$?、\$#、\$*，以及位置变量$1、$2、$10、……的作用。

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：变量的定义/赋值/查看**

1）新建/赋值变量

新建变量test，赋值“hello world”，通过set命令可以检查变量设置：

```shell
[root@svr5 ~]# test=11
```

2）查看变量

通过echo $变量名 可输出变量值：

```shell
[root@svr5 ~]# echo $test
11
```

查看变量时，若变量名称与后面要输出的字符串连在一起，则应该以{}将变量名括起来以便区分：

```shell
[root@svr5 ~]# echo $testRMB              //无法识别变量名test
[root@svr5 ~]# echo ${test}RMB              //区分后可以识别
11RMB
```

3）撤销自定义变量

若要撤销已有的变量，可使用unset命令：

```shell
[root@svr5 ~]# unset test                  //撤销变量test
[root@svr5 ~]# echo $test                  //查看时已无结果
```

**步骤二：使用环境变量**

1）查看环境变量相关文件

全局文件为/etc/profile，对所有用户有效；用户文件为~/.bash_profile，仅对指定的用户有效。

查看/etc/profile文件内容：

```shell
[root@svr5 ~]# cat /etc/profile
.. ..
HOSTNAME=`/bin/hostname`
HISTSIZE=1000
.. ..
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC
.. ..
```

2）使用环境变量

当前用户的环境变量USER记录了用户名、HOME记录了宿主目录、SHELL记录了登录Shell、HOSTNAME记录主机名、UID是用户的id号：

```shell
[root@svr5 ~]# echo $USER $HOME $SHELL $UID
root /root /bin/bash 0
[root@svr5 ~]# echo $HOSTNAME
svr5
```

环境变量PS1表示Shell环境的一级提示符，即命令行提示符（\u 用户名、\h 主机名、\W 工作目录、\$ 权限标识）：

```shell
[root@svr5 src]# echo $PS1                  //查看默认的一级提示
[\u@\h \W]\$
[root@svr5 src]#PS1='hehe#'                  //修改一级提示
hehe#                                      //更改结果
hehe# PS1='[\u@\h \W]\$ '                  //恢复原有设置
[root@svr5 src]# 
```

环境变量PS2表示二级提示符，出现在强制换行、at任务编辑等场合：

```shell
[root@svr5 ~]# echo $PS2                      //查看默认的二级提示
>
[root@svr5 src]# cd \                     //强制换行，观察提示符效果
> /root/
[root@svr5 ~]# PS2='=> '                      //手动修改二级提示
[root@svr5 ~]# cd \                          //再次验证提示符效果
=> ~
[root@svr5 ~]# PS2='> '                     //恢复原有设置
```

3）查看系统变量

使用env可查看所有环境变量：

```shell
[root@svr5 src]# env
HOSTNAME=svr5.tarena.com
SHELL=/bin/bash
HISTSIZE=1000
SSH_CLIENT=192.168.4.110 59026 22
OLDPWD=/root
SSH_TTY=/dev/pts/0
USER=root
.. ..
```

使用set可查看所有变量（包括env能看到的环境变量）：

```shell
[root@svr5 src]# set
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
BASH_LINENO=()
.. ..
```

**步骤三：使用位置变量与预定义变量**

1）创建一个测试脚本，用来展示。

```shell
[root@svr5 ~]# vim location.sh
#!/bin/bash
echo $0                                        //脚本的名称
echo $1                                        //第一个参数
echo $2                                        //第二个参数
echo $*                                        //所有参数
echo $#                                        //所有的综合
echo $$                                        //当前进程的进程号
echo $?                                        //上一个程序的返回状态码
[root@svr5 ~]# chmod +x location.sh              //添加可执行权限
```

2）执行脚本location.sh，细心观察结果（高明的武功需要用心参悟）。

```shell
[root@svr5 ~]# ./location.sh one 1 2 abc qq 8 7
```

**步骤四：创建账户与修改密码的脚本**

1）编写脚本。

```shell
[root@svr5 ~]# vim /root/user.sh
#!/bin/bash
useradd $1
echo "$2" |passwd --stdin $1 
```

执行脚本测试：

```shell
[root@svr5 ~]# ./user.sh jerry  123456
更改用户 jerry 的密码 。
passwd： 所有的身份验证令牌已经成功更新。
```

# 4. 变量的扩展应用

## 4.1 问题

本案例要求进一步熟悉Shell变量的赋值控制，主要练习或验证下列内容：

1. 三种引号对赋值的影响
2. 使用read命令从键盘读取变量值
3. 使用export发布全局变量

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：三种引号对变量赋值的影响**

1）双引号的应用

使用双引号可以界定一个完整字符串。

```shell
[root@svr5 ~]# xx=Tarena IT Group
-bash: IT: command not found                      //未界定时赋值失败
[root@svr5 ~]# xx="Tarena IT Group"              //界定后成功
[root@svr5 ~]# touch aa bb                      //创建了两个文件
[root@svr5 ~]# touch "aa bb"                    //创建了一个文件
[root@svr5 ~]# ls                                //查看结果
```

2）单引号的应用

界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。

```shell
[root@svr5 ~]# test=11
[root@svr5 ~]# echo "$test"
[root@svr5 ~]# echo '$test'
```

3）反撇号或$()的应用

使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。

```shell
[root@svr5 ~]# tar -czf log-`date +%Y%m%d`.tar.gz /var/log
```

**步骤二：使用read命令从键盘读取变量值**

1）read基本用法

执行后从会等待并接受用户输入（无任何提示的情况），并赋值给变量str：

```shell
[root@svr5 ~]# read str
What's happen ?                          //随便输入一些文字，按Enter键提交
[root@svr5 ~]# echo $str                  //查看赋值结果
What's happen ?
```

为了不至于使用户不知所措、莫名其妙，推荐的做法是结合-p选项给出友好提示：

```shell
[root@svr5 ~]# read -p "请输入一个整数：" i
请输入一个整数：240
[root@svr5 ~]# echo $i
240
```

2）stty终端显示控制

将回显功能关闭（stty -echo），
将回显功能恢复（stty echo）。

可参考下列操作创建一个测试脚本：

```shell
[root@svr5 ~]# vim user.sh              //创建一个测试脚本
#!/bin/bash
read -p "请输入用户名:"  username              //读取用户名
stty -echo                                  //关闭回显
read -p "请输入密码:"  passwd              //读取密码
stty echo                                  //恢复回显
echo ""                                      //恢复回显后补一个空行
useradd "$username"
echo "$passwd" | passwd --stdin "$username"
[root@svr5 ~]# chmod +x user.sh          //添加执行权限
```

执行测试脚本user.sh，验证效果：

```shell
[root@svr5 ~]# ./user.sh
请输入用户名:  root                          //输入root，回车
请输入密码:                                   //输入1234567（不会显示），回车
```

**步骤三：使用export发布全局变量**

默认情况下，自定义的变量为局部变量，只在当前Shell环境中有效，而在子Shell环境中无法直接使用。比如已定义的SCHOOL变量，当进入到sh或bash子Shell后，变量SCHOOL将处于未定义的状态：

```shell
[root@svr5 ~]# yy="Tarena IT Group"
[root@svr5 ~]# echo $yy
Tarena IT Group
[root@svr5 ~]# bash                              //开启bash子进程
[root@svr5 ~]# echo $yy                          //查看SCHOOL变量值无结果
[root@svr5 ~]# exit                              //返回原有Shell环境
exit
[root@svr5 ~]# echo $yy
````

若希望定义的变量能被子进程使用，可以使用export命令将其发布为全局变量。使用export发布时，只需指定变量名（可以有多个）即可，也可以通过export命令直接设置新的全局变量：

```shell
[root@svr5 ~]# export yy                              //发布已定义的变量
[root@svr5 ~]# export XX="1234"                      //发布新变量
```

验证刚刚发布的全局变量：

```shell
[root@svr5 ~]# bash                                  //进入bash子Shell环境
[root@svr5 ~]# echo $yy                              //查看全局变量的值 .. ..
Tarena IT Group
[root@svr5 ~]# echo $XX
1234
```

# 5. Shell中的数值运算

## 5.1 问题

本案例要求熟悉Linux Shell环境的特点，主要练习以下操作：

- 使用expr、$[ ]、let等整数运算工具：定义变量X=1234，然后计算X与78的四则运算及求模结果
- 使用bc实现小数运算操作：以交互方式计算12.34与56.78的四则运算结果，另外再以非交互方式重复上述计算，最多显示4位小数

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：整数运算工具**

1）使用expr命令

乘法操作应采用 \* 转义，避免被作为Shell通配符；参与运算的整数值与运算操作符之间需要以空格分开，引用变量时必须加$符号。

首先定义变量X=1234，然后分别计算与78的加减乘除和求模运算结果：

```shell
[root@svr5 ~]# X=1234                              //定义变量X
[root@svr5 ~]# expr  $X  +  78                      //加法
1312
[root@svr5 ~]# expr  $X  -  78                       //减法
1156
[root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义
96252
[root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果
15
[root@svr5 ~]# expr  $X  %  78                     //求模
64
```

2）使用$[]或$(())表达式

乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号；计算结果替换表达式本身，可结合echo命令输出。

同样对于变量X=1234，分别计算与78的加减乘除和求模运算结果：

```shell
[root@svr5 ~]# X=1234   
[root@svr5 ~]# echo $[X+78]
1312
[root@svr5 ~]# echo $[X-78]
1156
[root@svr5 ~]# echo $[X*78]
96252
[root@svr5 ~]# echo $[X/78]
15
[root@svr5 ~]# echo $[X%78]
64
```

3）使用let命令

expr或\$[]、\$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值。因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看：

```shell
[root@svr5 ~]# X=1234  
[root@svr5 ~]# let y=X+22
[root@svr5 ~]# echo $y
1256
[root@svr5 ~]# let X++;  echo $X        # X++(X=X+1)
[root@svr5 ~]# let X--;  echo $X        # X--(X=X-1)
[root@svr5 ~]# let X+=78 ; echo $X        # X+=78(X=X+78)
[root@svr5 ~]# let X-=78 ; echo $X     # X-=78(X=X-78)
[root@svr5 ~]# let X*=78 ; echo $X     # X*=78(X=X*78)
[root@svr5 ~]# let X/=78 ; echo $X     # X/=78(X=X/78)
[root@svr5 ~]# let X%=78 ; echo $X     # X%=78(X=X%78)
```

**步骤二：小数运算工具**

1）bc交互式运算

先执行bc命令进入交互环境，然后再输入需要计算的表达式。以计算小数12.34与5.678的四则运算为例，相关操作如下：

```shell
[root@svr5 ~]# bc 
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
12.34+56.78                                        //加法
69.12
12.34-56.78                                        //减法
-44.44
12.34*56.78                                        //乘法
700.66
12.34/56.78                                        //除法
0
quit                                              //退出交互计算器
[root@svr5 ~]#
```

2）bc非交互式运算

将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。以计算小数12.34与5.678的四则运算为例，相关操作如下：

```shell
[root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc
18.018
[root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc 
70.0665
[root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc 
2.1733
```

# Exercise

## 1 如何执行一个未设置x权限的Shell脚本？

以下三种方式任选其一：

- sh 脚本文件路径
- source 脚本文件路径
- . 脚本文件路径

## 2 自定义Shell变量时，变量名有什么规则？

- 可以包括数字、字母、下划线，不能以数字开头
- 变量名区分大小写
- 赋值时等号两边不要有空格
- 尽量不要使用关键字和特殊字符
- 给同一个变量多次赋值时，最后一次的赋值生效

## 3 编写一个Shell脚本程序，用来报告当前用户的环境信息。

> 新建脚本文件report.sh，执行后能够输出当前的主机名、登录用户名、所在的文件夹路径。效果如下所示：
>
> 当用户root执行的时候： ```shell [root@svr5 ~]# /opt/report.sh 
> 当前的主机名是：svr5.tarena.com 登录用户是：root 当前位于 /root 文件夹下
>
> ```shell
> 当普通用户mike执行的时候：
> shell [mike@svr5 ~]$ /opt/report.sh  当前的主机名是：svr5.tarena.com
> 登录用户是：mike 当前位于 /home/mike 文件夹下 
> ```

```shell
[root@svr5 ~]# cat /opt/report.sh
#!/bin/bash
echo "当前的主机名是：$HOSTNAME"
echo "登录用户是：$LOGNAME"
echo "当前位于 $PWD 文件夹下"
[root@svr5 ~]# chmod +x /opt/report.sh
```

## 4 简述预定义变量\$\$、\$?、\$0、\$#、\$*、\$!的作用。

$$ 保存当前运行进程的（PID）号
$? 保存命令执行结果的（返回状态）
$0 保存当前运行的（进程名）或（脚本名）
$# 保存位置变量的（个数）
$* 保存所有位置变量的（值）
$! 保存后台（最后一个进程）的PID号

## 5 编写一个Shell脚本程序，能够快速添加用户账号。

> 新建脚本文件quick_uad.sh，执行时指定新用户名作为参数，能够快速添加对应的用户账号，并将用户的登录密码设为123456。效果如下所示：
>
> ```shell
> [root@svr5 ~]# ./quick_uad.sh xixi                      //添加用户xixi
> 更改用户 xixi 的密码 。
> passwd： 所有的身份验证令牌已经成功更新。
> [root@svr5 ~]# id xixi
> uid=525(xixi) gid=525(xixi) 组=525(xixi)
> [root@svr5 ~]# ./quick_uad.sh haha                      //添加用户haha
> 更改用户 haha 的密码 。
> passwd： 所有的身份验证令牌已经成功更新。
> [root@svr5 ~]# id haha
> uid=526(haha) gid=526(haha) 组=526(haha)
> ```

```shell
[root@svr5 ~]# vim quick_uad.sh      
#!/bin/bash
useradd $1
echo 1234567 | passwd --stdin $1
[root@svr5 ~]# chmod +x quick_uad.sh
```

## 6 简述三种定界符在变量赋值操作中的特点。

> 双引号 " "：允许扩展，以 $ 引用其他变量
> 单引号 ' '：禁用扩展，即便 $ 也视为普通字符
> 反撇号 ` `：将命令的执行输出作为变量值

## 7 计算根分区的磁盘使用率，百分比精确到2位小数。

执行df命令可列出已挂载的文件系统使用情况：

> ```shell
> [root@svr5 ~]# df 
> Filesystem                   1K-blocks    Used Available Use% Mounted on
> /dev/mapper/VolGroup-lv_root  51606140 4292504  44692196   9% /
> tmpfs                           502204     228    501976   1% /dev/shm
> /dev/sda1                       495844   34880    435364   8% /boot
> /dev/mapper/VolGroup-lv_home  28455944  586380  26424088   3% /home
> .. ..
> ```

可以看到根分区的使用率为9%，百分比不带小数位。

手动计算时，可以用Used栏的已用量除以1K-block栏的总量乘以100，即可获得准确的百分比。结果涉及到小数，因此可以使用bc工具来实现。

```shell
[root@svr5 ~]# echo 'scale=2;4292504*100/51606140' | bc   
8.31
```

即当前根分区的准确使用率为8.31%。

> 如有侵权，请联系作者删除



﻿@[TOC]( Software package management & Systemd service management & VPN server | Cloud computing )

---

# 1. 制作nginx的RPM包

## 1.1 问题

本案例使用nginx-1.12.2版本的源码软件，生成对应的RPM包软件，具体要求如下：

软件名称为nginx

软件版本为1.12.2

RPM软件包可以查询描述信息

RPM软件包可以安装及卸载

## 1.2 方案

安装rpm-build软件包，编写SPEC配置文件，创建新的RPM软件包。

配置文件中的描述信息如表-1：

表－1 SPEC描述信息

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装rpm-build软件**

1）安装rpm-build软件包

```shell
[root@web1 ~]# yum -y install  rpm-build
```

2）生成rpmbuild目录结构

```shell
[root@web1 ~]# rpmbuild -ba nginx.spec                //会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild                    //自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
```

3）准备工作，将源码软件复制到SOURCES目录

```shell
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/
```

4）创建并修改SPEC配置文件

```shell
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                        #源码包软件名称
Version:1.12.2                                    #源码包软件的版本号
Release:    10                                        #制作的RPM包版本号
Summary: Nginx is a web server software.            #RPM软件的概述    
License:GPL                                        #软件的协议
URL:    www.test.com                                    #网址
Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
#BuildRequires:                                    #制作RPM时的依赖关系
#Requires:                                        #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
%post
useradd nginx                               #非必需操作：安装后脚本(创建账户)
%prep
%setup -q                                #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*                    #对哪些文件与目录打包
%changelog
```

**步骤二：使用配置文件创建RPM包**

1）安装依赖软件包

```shell
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel
```

2）rpmbuild创建RPM软件包

```shell
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
```

**步骤三：安装软件**

```shell
[root@web1 ~]# yum install /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# ls /usr/local/nginx/
```

# 2. 配置GRE VPN

## 2.1 问题

本案例要求搭建一个GRE VPN环境，并测试该VPN网络是否能够正常通讯，要求如下：

- 启用内核模块ip_gre
- 创建一个虚拟VPN隧道(10.10.10.0/24)
- 实现两台主机点到点的隧道通讯

## 2.2 方案

使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，使用modinfo可以查看内核模块的信息。

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。

表－1 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/ae2ef4015fc94be0973b594c7fae7e7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


实验拓扑如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/029d16b00536439cb7a19f5546adea06.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：启用GRE模块（client和proxy都需要操作）**

1）查看计算机当前加载的模块

```shell
[root@client ~]# lsmod                        //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
```

2)加载模块ip_gre

```shell
[root@client ~]# modprobe  ip_gre 
```

3）查看模块信息

```shell
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
… …  
```

**步骤二：Client主机创建VPN隧道**

1）创建隧道

```shell
[root@client ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
```

2）启用该隧道（类似与设置网卡up）

```shell
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up         //设置UP
[root@client ~]# ip link show
```

3）为VPN配置隧道IP地址

```shell
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s                      //查看IP地址
```

**步骤三：Proxy主机创建VPN隧道**

1）查看计算机当前加载的模块

```shell
[root@client ~]# lsmod                        //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
```

2)加载模块ip_gre

```shell
[root@client ~]# modprobe  ip_gre
```

3）创建隧道

```shell
[root@proxy ~]# ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.10 local 201.1.2.5
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
```

4）启用该隧道（类似与设置网卡up）

```shell
[root@proxy ~]# ip a  s
[root@proxy ~]# ip link set tun0 up         //设置UP
[root@proxy ~]# ip a  s
```

5）为VPN配置隧道IP地址

```shell
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s                      //查看IP地址
```

6)测试连通性

```shell
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10
```

# 3. 创建PPTP VPN

## 3.1 问题

本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:

- 使用PPTP协议创建一个支持身份验证的隧道连接
- 使用MPPE对数据进行加密
- 为客户端分配192.168.3.0/24的地址池
- 客户端连接的用户名为jacob，密码为123456

## 3.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-2所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。

表－2 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/ce05726ecea94731af23b4efac36d851.png)
实验拓扑如图-2所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3c96f8290d05495caa939ec57e642af0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署VPN服务器**

1）安装软件包（软件包参考lnmp_soft/vpn/）

```shell
[root@proxy ~]# yum install pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
```

2)修改配置文件

```shell
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                                    //服务器本地IP
remoteip 192.168.3.1-50                            //分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                                    //使用MPPE加密数据
ms-dns 8.8.8.8                                    //DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
jacob           *               123456      *
//用户名     服务器名称    密码      客户端IP
```

3）启动服务

```shell
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
```

4）翻墙设置（非必需操作）

```shell
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5
```

**步骤二：客户端设置**

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。

新建网络连接（具体操作如图-3所示），输入VPN服务器账户与密码（具体操作如图-4所示），连接VPN并测试网络连通性（如图-5所示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/dbd46844b22744fb8a0dd6304cea0e90.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

![在这里插入图片描述](https://img-blog.csdnimg.cn/7dce6bd2cefd4d27b0e0fb7c55501d17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

![在这里插入图片描述](https://img-blog.csdnimg.cn/b393d20d748c4957bfedbf8374851656.png)
图-5

# 4. 创建L2TP+IPSec VPN

## 4.1 问题

本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：

- 使用L2TP协议创建一个支持身份验证与加密的隧道连接
- 使用IPSec对数据进行加密
- 为客户端分配192.168.3.0/24的地址池
- 客户端连接的用户名为：jacob，密码为：123456
- 预共享密钥为：randpass

## 4.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-3所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。

表－3 主机列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/187e7659d24c4713bda8bc86e58fe420.png)

实验拓扑如图-6所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/db25f10da9f24bac82b87eee943de40f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-6

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署IPSec服务**

1）安装软件包

```shell
[root@client ~]# yum -y install libreswan
```

2)新建IPSec密钥验证配置文件

```shell
[root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv                        
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                                    //加密认证
        ike=3des-sha1;modp1024                        //加密算法
        phase2alg=aes256-sha1;modp2048                //加密算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10                                //重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any                                    //允许任何客户端连接
    rightprotoport=17/%any
```

3)创建IPSec预定义共享密钥

```shell
[root@client ~]# vim /etc/ipsec.secrets                 //修改该文件
include /etc/ipsec.d/*.secrets
201.1.2.10   %any:    PSK    "randpass"                 //randpass为预共享密钥
//201.1.2.10是VPN服务器的IP
//%any:任何客户端都可以连接服务器
//PSK（pre share key）中文预共享密钥
```

4)启动IPSec服务

```shell
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep 500
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto
```

**步骤二：部署XL2TP服务**

1）安装软件包（软件包参考lnmp_soft/vpn/）

```shell
[root@client ~]# yum  install xl2tpd-1.3.8-2.el7.x86_64.rpm
```

2) 修改xl2tp配置文件（修改3个配置文件的内容）

```shell
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
local ip = 201.1.2.10                                    //VPN服务器的IP地址
[root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
require-mschap-v2                                         //添加一行，强制要求认证
#crtscts                                                //注释或删除该行
#lock                                                //注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
jacob   *       123456  *                //账户名称   服务器名称   密码   客户端IP
```

3）启动服务

```shell
[root@client ~]# systemctl start xl2tpd
[root@client ~]# ss  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
```

4）翻墙设置（非必需操作）

```shell
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    #开启路由转发
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10
```

**步骤三：客户端设置**

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。

1. 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。

设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass，具体操作如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ed6107739cf6460da477c39bb2d5648b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-7

2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：

- 单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
- 找到下面的注册表子项，然后单击它：
- HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
- 在"编辑"菜单上，单击"新建"->"DWORD值"
- 在"名称"框中，键入"ProhibitIpSec"
- 在"数值数据"框中，键入"1"，然后单击"确定"
- 退出注册表编辑器，然后重新启动计算机
- 连接VPN并测试网络连通性（参考案例2）。

# 5. 编写systemd Unit文件

## 5.1 问题

本案例要求熟练掌握systemd进程如何管理其他服务器，具体要求如下：

- 熟悉systemctl常用命令
- 通过systemd管理shell脚本
- 通过systemd管理Nginx服务

## 5.2 方案

Unit文件语法格式参考表-4。

表－4 Unit文件语法描述
![在这里插入图片描述](https://img-blog.csdnimg.cn/48b03cc9d1034f55935945af146227d4.png)


## 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：熟悉systemctl常用命令**

1）命令列表

```shell
[root@web1 ~]# systemctl                             #列出所有启动的服务
[root@web1 ~]# systemctl status   <服务名称>            #查看服务状态
[root@web1 ~]# systemctl start     <服务名称>        #启动服务状态
[root@web1 ~]# systemctl stop      <服务名称>        #关闭服务状态
[root@web1 ~]# systemctl restart  <服务名称>        #重启服务状态
[root@web1 ~]# systemctl enable  <服务名称>            #设置开机自启
[root@web1 ~]# systemctl enable --now  <服务名称>    #设置开机自启并启动
[root@web1 ~]# systemctl disable  <服务名称>        #禁止开机自启
[root@web1 ~]# systemctl enable  <服务名称>            #设置开机自启
[root@web1 ~]# systemctl is-active <服务名称>        #查看是否激活
[root@web1 ~]# systemctl is-enabled  <服务名称>        #查看是否开启自启
[root@web1 ~]# systemctl reboot                    #重启计算机
[root@web1 ~]# systemctl poweroff                     #关闭计算机
```

**步骤二：使用systemd管理shell脚本**

1）编写shell脚本

```shell
[root@web1 ~]# vim /root/test.sh 
#!/bin/bash
while : 
do
    echo NB
    echo DACHUI
done
[root@web1 ~]# chmod +x /root/test.sh
```

2）编写Unit文件

```shell
[root@web1 ~]# cp /usr/lib/systemd/system/{crond.service,test.service}
[root@web1 ~]# vim /usr/lib/systemd/system/test.service
[Unit]
Description=my test script
After=time-sync.target
[Service]
ExecStart=/root/test.sh
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
[Install]
WantedBy=multi-user.target
```

**步骤二：使用systemd管理Nginx服务**

1）编写Unit文件

```shell
[root@web1 ~]# vim /usr/lib/systemd/system/nginx.service
[Unit]
Description=The Nginx HTTP Server        #描述信息
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
#仅启动一个主进程的服务为simple，需要启动若干子进程的服务为forking
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT ${MAINPID}
[Install]
WantedBy=multi-user.target
```

# Exercise

## 1 列出常见的VPN技术？

GRE、PPTP、L2TP+IPSEc、SSL VPN。

## 2 PPTP使用什么进行数据加密？

MPPEP支持MPPE(Microsoft Point-to-Point Encryption)加密

## 3 systemctl常用命令有哪些？

```shell
[root@web1 ~]# systemctl                             #列出所有启动的服务
[root@web1 ~]# systemctl status   <服务名称>            #查看服务状态
[root@web1 ~]# systemctl start     <服务名称>        #启动服务状态
[root@web1 ~]# systemctl stop      <服务名称>        #关闭服务状态
[root@web1 ~]# systemctl restart  <服务名称>        #重启服务状态
[root@web1 ~]# systemctl enable  <服务名称>            #设置开机自启
[root@web1 ~]# systemctl enable --now  <服务名称>    #设置开机自启并启动
[root@web1 ~]# systemctl disable  <服务名称>        #禁止开机自启
[root@web1 ~]# systemctl enable  <服务名称>            #设置开机自启
[root@web1 ~]# systemctl is-active <服务名称>        #查看是否激活
[root@web1 ~]# systemctl is-enabled  <服务名称>        #查看是否开启自启
[root@web1 ~]# systemctl reboot                    #重启计算机
[root@web1 ~]# systemctl poweroff                     #关闭计算机
```

## 4 systemd的Unit文件哪些语句可以控制进程启动顺序？

- After
- Before

## 5 Centos系统中使用什么工具可以打包RPM包

- rpm-build工具

> 如有侵权，请联系作者删除



﻿@[TOC]( Split parsing & NTP time synchronization & email communication & custom Yum repository | Cloud computing )

---

# 1 案例1：NTP时间同步

## 1.1 问题

本例要求配置一台NTP时间服务器，需要完成下列任务：

1. 部署一台NTP时间服务器
2. 设置时间服务器上层与0.centos.pool.ntp.org同步
3. 设置本地服务器层级数量为10
4. 允许192.168.4.0/24网络的主机同步时间
5. 客户端验证时间是否同步

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：虚拟机A构建NTP时间服务器**

1）使用yum安装bind、bind-chroot软件包

```shell
[root@svr7 ~]# yum -y install chrony
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
dvd                                               | 3.6 kB     00:00     
软件包 chrony-3.2-2.el7.x86_64 已安装并且是最新版本
无须任何处理
[root@svr7 ~]# rpm -q chrony
chrony-3.2-2.el7.x86_64
[root@svr7 ~]#
```

2）修改配置文件/etc/chrony.conf

```shell
[root@proxy ~]# vim  /etc/chrony.conf
server 0.centos.pool.ntp.org iburst         //server用户客户端指向上层NTP服务器
allow 192.168.4.0/24        //允许那个IP或网络访问NTP
local stratum 10            //设置NTP服务器的层数量
.. ..
```

3）重启chronyd服务

```shell
[root@mail ~]# systemctl  restart chronyd
[root@svr7 ~]# firewall-cmd --set-default-zone=trusted   #设置防火墙
```

**步骤二：虚拟机B构建NTP时间同步的客户端**

1）修改/etc/chrony.conf文件

```shell
[root@pc207 ~]# vim /etc/chrony.conf
server 192.168.4.7 iburst
```

2）重启chronyd服务

```shell
[root@pc207 ~]# systemctl  restart chronyd
[root@svr7 ~]# firewall-cmd --set-default-zone=trusted  #设置防火墙
```

3）修改时间进行测试

```shell
[root@pc207 ~]# date -s "2008-9-1"
2008年 09月 01日 星期一 00:00:00 CST
[root@pc207 ~]# date
2008年 09月 01日 星期一 00:00:01 CST
[root@pc207 ~]# systemctl restart chronyd
[root@pc207 ~]# date
2008年 09月 01日 星期一 00:01:42 CST
[root@pc207 ~]# date
2020年 04月 13日 星期一 18:44:56 CST
[root@pc207 ~]# chronyc  sources –v     #专业查看时间服务端信息命令
```

# 2. 准备邮件案例环境

## 2.1 问题

本例要求配置一台智能DNS服务器，针对同一个FQDN，当不同的客户机来查询时能够给出不同的答案。需要完成下列任务：

1. 准备DNS服务器
2. 主机名：mail.example.com
3. IP地址：192.168.4.7/24
4. 为 example.com 域提供邮件相关解析

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为tedu.cn域搭建DNS服务**

1）使用yum安装bind、bind-chroot软件包

```shell
[root@mail ~]# yum -y install bind bind-chroot
.. ..
```

2）建立配置文件named.conf

```shell
[root@mail ~]# mv /etc/named.conf /etc/named.conf.bak     //备份默认配置
[root@mail ~]# vim /etc/named.conf
options  {
        directory  "/var/named";
};
zone "example.com" IN {                                  //定义DNS父域
        type master;
        file "example.com.zone";
};
```

3）建立解析记录文件

注意添加mail.tedu.cn的解析记录：

```shell
[root@mail ~]# vim /var/named/example.com.zone
$TTL   86400
@   IN   SOA   @    root.example.com.  (
    2015052201 
    4H 
    15M 
    4H
    1D
)
example.com.      IN      NS        svr7.example.com.
example.com.       IN      MX   10      mail.example.com.
svr7    IN      A       192.168.4.7 
mail    IN      A       192.168.4.7
```

4）启动named服务

```shell
[root@mail ~]# systemctl  restart named
```

5）将本机配置为DNS客户端，测试域名解析

修改/etc/resolv.conf文件，添加本机作为DNS服务器：

```shell
[root@mail ~]# vim /etc/resolv.conf
nameserver 192.168.4.7
```

查询区域example.com的MX记录，结果为mail.example.com.：

```shell
[root@pc205 ~]# host -t mx example.com
tedu.cn mail is handled by 10 mail.example.com.
```

查询域名mail.example.com的A记录，结果为192.168.4.7：

```shell
[root@pc205 ~]# host mail.example.com
mail.example.com has address 192.168.4.7
```

# Exercise

## 1 缓存域名服务器提供的解析结果属于（ ）类型的记录

> A. 权威解析 
> B. 非权威解析 
> C. 正向解析 
> D. 反向解析

正确答案：B选项，非权威解析。

## 2 配置缓存DNS服务器时，为客户机提供的解析记录如何获取

方式1，全局转发：将请求转发给指定的公共DNS，请求递归服务；

方式2，根域迭代：依次向根、一级、二级……域的DNS服务器迭代。

> 如有侵权，请联系作者删除



﻿@[TOC]( System management module & grammar style and layout & string details | Cloud computing )

---

# 1. 创建文件

## 1.1 问题

编写mktxtfile.py脚本，实现以下目标：

1. 编写一个程序，要求用户输入文件名
2. 如果文件已存在，要求用户重新输入
3. 提示用户输入数据，每行数据先写到列表中
4. 将列表数据写入到用户输入的文件名中

## 1.2 方案

用三个函数分别实现文件名获取、文件内容获取、将获取到的文件内容写入get_fname()函数获取的文件中 这三个方法，最终调用三个函数，完成文件创建：

1. 获取文件名函数get_fname()：利用while语句循环判断文件名是否存在，input文件名，如果不存在，循环停止，返回用户输入的文件名，如果存在，提示已存在，重新进入循环，直至文件名不存在为止，返回文件名用户输入的文件名

2. 文件内容获取函数get_contents()：创建空列表存储获取到的数据，利用while语句让用户循环输入数据，如果输入的数据是end，循环停止，返回列表中内容，如果输入的数据不是end，将输入的数据追加到列表结尾，返回列表中内容

3. wfile()函数：用with语句将获取到的文件以写方式打开，这样打开代码块结束后文件会自动关闭，将get_contents()函数返回内容写入到已打开文件中

4. 最终当用户cat文件名时，可以看到写入结果

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day04]# vim mktxtfile.py
#!/usr/bin/env python3
import os
def get_fname():
    while True:
        filename = input('请输入文件名：')
        if not os.path.exists(filename):
            break
        print('%s 已存在，请重试。' % filename)
    return filename
def get_contents():
    contents = []
    print('请输入内容，结束请输入end。')
    while True:
        line = input('> ')
        if line == 'end':
            break
        contents.append(line)
    return contents
def wfile(fname, contents):
    with open(fname, 'w') as fobj:
        fobj.writelines(contents)
if __name__ == '__main__':
    fname = get_fname()
    contents = get_contents()
    contents = ['%s\n' % line for line in contents]
    wfile(fname, contents)
```

**步骤二：测试脚本执行**

```shell
[root@localhost day04]# ls
adduser.py    format_str2.py  list_method.py  mylist.py     string_op.py
checkid.py    format_str.py   mkseq.py        randpass2.py
fmtoutput.py  get_val.py      mktxtfile.py    seq_func.py
[root@localhost day04]# python3 mktxtfile.py 
请输入文件名：passwd
请输入内容，结束请输入end。
> nihao,welcom
> woshi
> end
[root@localhost day04]# python3 mktxtfile.py 
请输入文件名：mkseq.py                                                
mkseq.py 已存在，请重试。
请输入文件名：randpass.py
请输入内容，结束请输入end。
> myname
> end 
[root@localhost day04]# cat passwd
nihao,welcom
woshi
[root@localhost day04]# cat randpass.py
myname
[root@localhost day04]# ls
adduser.py    format_str2.py  list_method.py  mylist.py     randpass.py
checkid.py    format_str.py   mkseq.py        passwd        seq_func.py
fmtoutput.py  get_val.py      mktxtfile.py    randpass2.py  string_op.py
```

# 2. 创建用户

## 2.1 问题

创建adduser.py文件，实现以下目标：

1. 编写一个程序，实现创建用户的功能
2. 提示用户输入用户名
3. 随机生成8位密码
4. 创建用户并设置密码
5. 将用户相关信息写入指定文件

## 2.2 方案

创建add_user()函数，让函数具有创建用户、创建密码、将用户密码写入到指定文件三种方法，因此为函数设置3个参数，分别是用户名、密码及用户名密码存放文件，最终通过函数调用上传实参的方式，完成用户创建

1. 利用subprocess.call函数运行用户创建命令
2. subprocess.call函数运行密码设置命令
3. 用with语句将指定的文件以追加模式打开，这样打开代码块结束后文件会自动关闭，将用户密码用指定格式写入指定文件
4. 调用add_user()函数时上传的用户名实参，是利用sys.argv[]参数，在命令行调用的时候由系统传递给程序，这个变量其实是一个List列表，用于保存命令行上的参数，argv[0] 一般是“被调用的脚本文件名或全路径”，argv[1]和以后就是传入的系统命令参数

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

将randpass文件的代码以模块形式导入以下代码中,直接调用gen_pass()函数获取返回值（即获取随机生成的密码）：

```shell
[root@localhost day04] # vim adduser.py
#!/usr/bin/env python3
import sys
import subprocess
from randpass import gen_pass 
def add_user(username, password, fname):
    info = """user information:
username: %s
password: %s
"""
    subprocess.run('useradd %s' % username, shell=True)
    subprocess.run(
        'echo %s | passwd --stdin %s' % (password, username),
        shell=True
    )                                                                                                           
    with open(fname, 'a') as fobj:
        fobj.write(info % (username, password))
if __name__ == '__main__':
    username = sys.argv[1]
    password = gen_pass()
    fname = '/tmp/users.txt'
    add_user(username, password, fname) 
```

步骤二：测试脚本执行

```shell
[root@localhost day04]# python3 adduser.py b c d 
更改用户 b 的密码 。
passwd：所有的身份验证令牌已经成功更新。
[root@localhost day04]# python3 adduser.py a c d 
useradd：用户“a”已存在
更改用户 a 的密码 。
passwd：所有的身份验证令牌已经成功更新。
[root@localhost day04]# cat /tmp/users.txt
user information:
username: a
password: hD31SmTS
user information:
username: b
password: DztS7ycn
user information:
username: a
password: f2iH0Znt
```

# 3. 格式化输出

## 3.1 问题

创建fmtoutput.py脚本，要求如下：

1. 提示用户输入（多行）数据
2. 假定屏幕的宽度为50，用户输入的多行数据如图-1所示（文本内容居中）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/48e0a40c5b8a4a32937d8a6ef52e8ebe.png)
图-1

## 3.2 方案

利用for循环方式遍历获取到的用户输入数据列表，将用户输入的每一条数据依次遍历出来

通过format()方法，把遍历得到的字符串当作一个模版，通过传入的参数进行格式化。这个用来格式化的模版使用大括号({,})作为特殊字符，其中^代表居中对齐、48代表宽度。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

将mktxtfile文件的代码以模块形式导入以下代码中,直接调用get_contents ()函数获取返回值（即获取用户输入数据列表）：

```shell
[root@localhost day04]# vim fmtoutput.py
#!/usr/bin/env python3
from mktxtfile import get_contents
width = 48
contents = get_contents()
print('+%s+' % ('*' * 48))
for line in contents:
    print('+{:^48}+'.format(line))    
print('+%s+' % ('*' * 48))  
```

**步骤二：测试脚本执行**

```shell
[root@localhost day04]# python3 fmtoutput.py 
请输入内容，结束请输入end。
> nihao
> my name zhangzhigang
> bye
> end
+************************************************+
+                     nihao                          +
+              my name zhangzhigang                 +
+                      bye                            +
+************************************************+
```

# Exercise

## 1 使用shutil模块的copyfileobj方法，将/etc/hosts拷贝到/tmp目录下，目标文件名为zhuji

```shell
import shutil
with open('/etc/hosts', 'rb') as src_fobj:
    with open('/tmp/zhuji', 'wb') as dst_fobj:
        shutil.copyfileobj(src_fobj, dst_fobj)
```

## 2 使用shutil模块的copy方法，将/etc/hosts拷贝到/tmp目录下，目标文件名为zhuji2

```shell
import shutil
shutil.copy('/etc/hosts', '/tmp/zhuji2')
```

## 3 使用shutil模块，将/etc/security目录拷贝到/tmp目录下，目标目录名为anquan

```shell
import shutil
shutil.copytree('/etc/security', '/tmp/anquan')
```

## 4 如何将两个变量a和b的值互换？

```shell
a = 10
b = 20
a, b = b, a
```

## 5 标识符满足哪些条件，才是合法标识符？

- 第一个字符必须是字母或下划线（_）
- 其余的字符可以是字母和数字或下划线
- 大小写敏感

## 6 如何获取python中所有的关键字？

```shell
>>> import keyword
>>> print(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

## 7 举例说明python的模块文件布局

```shell
#!/usr/bin/env python                 #起始行
“this is a test module”               #模块文档字符串
import sys                             #导入模块
import os
debug = True                           #全局变量声明
class FooClass(object):               #类定义
    'Foo class'
    pass
def test():                            #函数定义
    "test function"
    foo = FooClass()
if __name__ == ‘__main__’:           #程序主体
    test()
```

## 8 将name和age两个字符串进行格式化，name要求点10个宽度，age占8个宽度。它们都采用左对齐。

```shell
    '%-10s%-8s' % ('name', 'age')
```

## 9 字符串变量astr的内容是hello。将其转换为大写字母的方法是astr.upper()，执行完毕后，astr会不会变成大写字母？为什么？

- 不会变成大写字母。因为字符串是不可变类型，它能返回一个新的大写字母字符串，但是它本身不变。

> 如有侵权，请联系作者删除



﻿@[TOC]( Table structure & MySQL key values | Cloud computing )

---

# 1. 表管理

## 1.1 问题

具体要求如下：

- 建库练习
- 建表练习
- 管理表记录练习

## 1.2 步骤

在host50主机做如下练习

**步骤一：建库练习**
库，用来存放表的目录，默认创建在数据库目录下

1. 库的查看创建与删除

```sql
[root@host50 ~]# mysql -uroot -pNSD123...a   数据库管理员登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 26
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> select user() ; 查看登录的用户
+----------------+
| user()         |
+----------------+
| root@localhost |  用户@客户端地址 （在本机管理员登录）
+----------------+
1 row in set (0.00 sec)
mysql> 
mysql> show databases;  查看已有的库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| tarena             |
+--------------------+
5 rows in set (0.00 sec)
mysql> 
mysql> select database() ;  查看当前所在的库
+------------+
| database() |
+------------+
| NULL       |  表示没有在任何一个库，此时所在的位置是/var/lib/mysql 目录
+------------+
1 row in set (0.00 sec)
mysql> 
mysql> use tarena; 切换库到tarena库里
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
mysql> 
mysql> select database() ;  再次查看所在的库 
+------------+
| database() |
+------------+
| tarena     |  在tarena库里 所在位置 /var/lib/mysql/tarena 目录
+------------+
1 row in set (0.00 sec)
mysql> 
mysql> show tables;  查看库下已有的表
+------------------+
| Tables_in_tarena |
+------------------+
| departments      |
| employees        |
| salary           |
| user             |
+------------------+
4 rows in set (0.01 sec)
mysql> 
mysql> create database db1; 创建新库
Query OK, 1 row affected (0.00 sec)
mysql> show databases;  此时查看已有库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db1                |      刚创建的db1库 ， 在数据库目录/var/lib/myql 下会有对应名称的db1目录
| mysql              |
| performance_schema |
| sys                |
| tarena             |
+--------------------+
6 rows in set (0.00 sec)
mysql> 
mysql> system  ls -ld /var/lib/mysql/db1  使用system 命令 在登录状态下执行系统命令
drwxr-x--- 2 mysql mysql 20 9月   7 13:52 /var/lib/mysql/db1
mysql> 
mysql> create database DB1; 库名区别字母大小写 
Query OK, 1 row affected (0.00 sec)
mysql> create database DB1; 库名具有唯一性 所以会报错
ERROR 1007 (HY000): Can't create database 'DB1'; database exists
mysql> 
mysql>  create database if not exists  DB1; 加if not exists语句避免重名报错 
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql> 
mysql> drop database  db1;删除库，如果库里有表会一并被删除
Query OK, 0 rows affected (0.00 sec)
mysql> drop database  db1;  删除没有的库，会报错
ERROR 1008 (HY000): Can't drop database 'db1'; database doesn't exist
mysql> 
mysql> drop database  if exists db1;  加if  exists 语句 避免报错
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql>
```

**步骤二：建表练习**
表：存储数据的文件。创建在所在库对应的目录下，表必须创建在库里

表的创建与删除

```sql
mysql> create table DB1.t1( 姓名 char(10) , 班级  char(7) ); 在DB1库里创建t1表
Query OK, 0 rows affected (0.20 sec)
mysql> desc DB1.t1;  查看表头名称
+--------+----------+------+-----+---------+-------+
| Field  | Type     | Null | Key | Default | Extra |
+--------+----------+------+-----+---------+-------+
| 姓名   | char(10) | YES  |     | NULL    |       |
| 班级   | char(7)  | YES  |     | NULL    |       |
+--------+----------+------+-----+---------+-------+
2 rows in set (0.00 sec)
mysql> drop table DB1.t1;  删除创建的表
Query OK, 0 rows affected (0.11 sec)
mysql> 
为了便于操作通常使用英文定义表头名和表名
mysql> create table DB1.t1 ( name  char(15) , class char(10));
Query OK, 0 rows affected (0.25 sec)
mysql> desc DB1.t1; 查看表头
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(15) | YES  |     | NULL    |       |
| class | char(10) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
2 rows in set (0.00 sec)
mysql> 
```

修改表
Alter table 库.表 add 字段名 类型(宽度) [约束条件] ;

```sql
mysql> alter table  DB1.t1 add school  char(20) ; 添加1个新字段school
Query OK, 0 rows affected (0.36 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;  默认新添加的字段追加在已有列的末尾
+--------+----------+------+-----+---------+-------+
| Field  | Type     | Null | Key | Default | Extra |
+--------+----------+------+-----+---------+-------+
| name   | char(15) | YES  |     | NULL    |       |
| class  | char(10) | YES  |     | NULL    |       |
| school | char(20) | YES  |     | NULL    |       |
+--------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> 
一起添加2个字段 分别是 mail 和  address 
mysql> alter table  DB1.t1 add mail char(50) , add address  char(80) ;
Query OK, 0 rows affected (0.37 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;  查看新添加的表头，都在追加在末尾
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| name    | char(15) | YES  |     | NULL    |       |
| class   | char(10) | YES  |     | NULL    |       |
| school  | char(20) | YES  |     | NULL    |       |
| mail    | char(50) | YES  |     | NULL    |       |
| address | char(80) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
5 rows in set (0.00 sec)
mysql> 
添加新表头number 在第1列的位置
mysql> alter table  DB1.t1 add number int first ;
Query OK, 0 rows affected (0.32 sec)
Records: 0  Duplicates: 0  Warnings: 0
添加新表头在city 放在name的后边
mysql> alter table DB1.t1 add  city  char(10) after name;
Query OK, 0 rows affected (0.42 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| number  | int(11)  | YES  |     | NULL    |       |
| name    | char(15) | YES  |     | NULL    |       |
| city    | char(10) | YES  |     | NULL    |       |
| class   | char(10) | YES  |     | NULL    |       |
| school  | char(20) | YES  |     | NULL    |       |
| mail    | char(50) | YES  |     | NULL    |       |
| address | char(80) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
7 rows in set (0.00 sec)
mysql> 
mysql> alter table DB1.t1 drop city;  一次删除一个表头
Query OK, 0 rows affected (0.31 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> alter table DB1.t1 drop class , drop school; 一起删除多个表头
Query OK, 0 rows affected (0.32 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;  查看表头
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| number  | int(11)  | YES  |     | NULL    |       |
| name    | char(15) | YES  |     | NULL    |       |
| mail    | char(50) | YES  |     | NULL    |       |
| address | char(80) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
4 rows in set (0.00 sec)
mysql> 
mysql> alter table DB1.t1 modify number tinyint after name; 修改类型和位置，
Query OK, 0 rows affected (0.71 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;  查看修改，把类型修改为tinyint  并移动name表头的后边
+---------+------------+------+-----+---------+-------+
| Field   | Type       | Null | Key | Default | Extra |
+---------+------------+------+-----+---------+-------+
| name    | char(15)   | YES  |     | NULL    |       |
| number  | tinyint(4) | YES  |     | NULL    |       |
| mail    | char(50)   | YES  |     | NULL    |       |
| address | char(80)   | YES  |     | NULL    |       |
+---------+------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
mysql> 
mysql> alter table  DB1.t1 change  address homedir char(80); 只修改表头名，类型原样抄下来
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;查看修改，address 修改为了 homedir
+---------+------------+------+-----+---------+-------+
| Field   | Type       | Null | Key | Default | Extra |
+---------+------------+------+-----+---------+-------+
| name    | char(15)   | YES  |     | NULL    |       |
| number  | tinyint(4) | YES  |     | NULL    |       |
| mail    | char(50)   | YES  |     | NULL    |       |
| homedir | char(80)   | YES  |     | NULL    |       |
+---------+------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
mysql> 
mysql> alter table  DB1.t1 change mail email varchar(60); 表头名和类型一起修改
Query OK, 0 rows affected (0.44 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc DB1.t1;查看修改表头名类型都变了
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | char(15)    | YES  |     | NULL    |       |
| number  | tinyint(4)  | YES  |     | NULL    |       |
| email   | varchar(60) | YES  |     | NULL    |       |
| homedir | char(80)    | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
mysql> use DB1;  切换到 DB1库
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
mysql>  show tables;  查看已有表
+---------------+
| Tables_in_DB1 |
+---------------+
| t1            |
+---------------+
1 row in set (0.00 sec)
mysql> alter table DB1.t1 rename stuinfo; 修改表名为 stuinfo
Query OK, 0 rows affected (0.07 sec)
mysql> show tables; 查看表名 已经改变
+---------------+
| Tables_in_DB1 |
+---------------+
| stuinfo       |
+---------------+
1 row in set (0.00 sec)
mysql> 
```

复制表

原表的主键 外键 普通索引不会被复制给新表
新表的数据和表头有select查询语句决定

```sql
mysql> create table DB1.t2  select  * from tarena.user;  复制表结构及数据
mysql> use DB1;  切换到DB1库
Database changed
mysql> show tables; 查看表
+---------------+
| Tables_in_DB1 |
+---------------+
| stuinfo        |
| t2              | 多了t2表
+---------------+
2 rows in set (0.00 sec)
mysql> select  * from  DB1.t2;  查看记录
mysql> create table DB1.t3  select  name , uid,gid  from tarena.user; 只复制原表的3个表头的记录
Query OK, 27 rows affected (0.30 sec)
Records: 27  Duplicates: 0  Warnings: 0
mysql> desc DB1.t3;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(20) | YES  |     | NULL    |       |
| uid   | int(11)  | YES  |     | NULL    |       |
| gid   | int(11)  | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> select  * from DB1.t3; 查询表记录
只复制表结构
mysql> create table DB1.t4  select  * from  tarena.user where  1  = 2 ;
Query OK, 0 rows affected (0.26 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> show tables; 查看表
+---------------+
| Tables_in_DB1 |
+---------------+
| stuinfo       |
| t2            |
| t3            |
| t4            | 多了 t4表
+---------------+
4 rows in set (0.00 sec)
mysql> desc t4;  有表结构
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id       | int(11)     | NO   |     | 0       |       |
| name     | char(20)    | YES  |     | NULL    |       |
| password | char(1)     | YES  |     | NULL    |       |
| uid      | int(11)     | YES  |     | NULL    |       |
| gid      | int(11)     | YES  |     | NULL    |       |
| comment  | varchar(50) | YES  |     | NULL    |       |
| homedir  | varchar(80) | YES  |     | NULL    |       |
| shell    | char(30)    | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
8 rows in set (0.00 sec)
mysql> select  * from DB1.t4;  没有记录
Empty set (0.00 sec)
mysql> 
```

**步骤三、管理表记录**

1. 插入表记录

```sql
添加1行给所有表头赋值
mysql> insert into DB1.stuinfo  values ("yaya",1,"yaya@tedu.cn","beijing");
Query OK, 1 row affected (0.03 sec)
添加多行给所有表头赋值
mysql> insert into DB1.stuinfo  values ("plj",8,"plj@163.com","shanghai"),("jing",9,"jing@163.com","beijing");
Query OK, 2 rows affected (0.04 sec)
Records: 2  Duplicates: 0  Warnings: 0
mysql> select  * from DB1.stuinfo; 查看表记录
+------+--------+--------------+----------+
| name | number | email        | homedir  |
+------+--------+--------------+----------+
| yaya |      1 | yaya@tedu.cn | beijing  |
| plj  |      8 | plj@163.com  | shanghai |
| jing |      9 | jing@163.com | beijing  |
+------+--------+--------------+----------+
3 rows in set (0.00 sec)
mysql> 
添加1行 ，给指定的表头赋值，
mysql> insert into DB1.stuinfo (name,homedir)values("nb","nb@tedu.cn");
Query OK, 1 row affected (0.04 sec)
添加多行，给指定表头赋值
mysql> insert into DB1.stuinfo (name,homedir)values("nb2","nb2@tedu.cn"),("nb3","nb3@tedu.cn");
Query OK, 2 rows affected (0.03 sec)
Records: 2  Duplicates: 0  Warnings: 0
没有赋值的表头number和email 没有数据 ，值是 null （空）
mysql> select  * from DB1.stuinfo;
+------+--------+--------------+-------------+
| name | number | email        | homedir     |
+------+--------+--------------+-------------+
| yaya |      1 | yaya@tedu.cn | beijing     |
| plj  |      8 | plj@163.com  | shanghai    |
| jing |      9 | jing@163.com | beijing     |
| nb   |   NULL | NULL         | nb@tedu.cn  |
| nb2  |   NULL | NULL         | nb2@tedu.cn |
| nb3  |   NULL | NULL         | nb3@tedu.cn |
+------+--------+--------------+-------------+
6 rows in set (0.00 sec)
mysql> 
使用select 查询结果插入数据
mysql> insert into DB1.stuinfo (select * from DB1.stuinfo); 把已经插入的记录全都重新插入一遍。
Query OK, 6 rows affected (0.04 sec)
Records: 6  Duplicates: 0  Warnings: 0
mysql> select  * from DB1.stuinfo;  查看记录
+------+--------+--------------+-------------+
| name | number | email        | homedir     |
+------+--------+--------------+-------------+
| yaya |      1 | yaya@tedu.cn | beijing     |
| plj  |      8 | plj@163.com  | shanghai    |
| jing |      9 | jing@163.com | beijing     |
| nb   |   NULL | NULL         | nb@tedu.cn  |
| nb2  |   NULL | NULL         | nb2@tedu.cn |
| nb3  |   NULL | NULL         | nb3@tedu.cn |
| yaya |      1 | yaya@tedu.cn | beijing     |
| plj  |      8 | plj@163.com  | shanghai    |
| jing |      9 | jing@163.com | beijing     |
| nb   |   NULL | NULL         | nb@tedu.cn  |
| nb2  |   NULL | NULL         | nb2@tedu.cn |
| nb3  |   NULL | NULL         | nb3@tedu.cn |
+------+--------+--------------+-------------+
12 rows in set (0.00 sec)
mysql> 
给指定的表头使用使用查询结果赋值
mysql> insert into DB1.stuinfo(name,number) (select name , number from DB1.stuinfo where number in (1,8,9));
Query OK, 6 rows affected (0.04 sec)
Records: 6  Duplicates: 0  Warnings: 0
mysql> select  * from DB1.stuinfo;
+------+--------+--------------+-------------+
| name | number | email        | homedir     |
+------+--------+--------------+-------------+
| yaya |      1 | yaya@tedu.cn | beijing     |
| plj  |      8 | plj@163.com  | shanghai    |
| jing |      9 | jing@163.com | beijing     |
| nb   |   NULL | NULL         | nb@tedu.cn  |
| nb2  |   NULL | NULL         | nb2@tedu.cn |
| nb3  |   NULL | NULL         | nb3@tedu.cn |
| yaya |      1 | yaya@tedu.cn | beijing     |
| plj  |      8 | plj@163.com  | shanghai    |
| jing |      9 | jing@163.com | beijing     |
| nb   |   NULL | NULL         | nb@tedu.cn  |
| nb2  |   NULL | NULL         | nb2@tedu.cn |
| nb3  |   NULL | NULL         | nb3@tedu.cn |
| yaya |      1 | NULL         | NULL        |此行向下新插入的行
| plj  |      8 | NULL         | NULL        |
| jing |      9 | NULL         | NULL        |
| yaya |      1 | NULL         | NULL        |
| plj  |      8 | NULL         | NULL        |
| jing |      9 | NULL         | NULL        |
+------+--------+--------------+-------------+
18 rows in set (0.00 sec)
mysql> 
使用set语句插入记录 
mysql> insert into  DB1.stuinfo set name="plj" , number=10;
```

2）修改表记录

```sql
mysql> select name , homedir from DB1.stuinfo;
+--------+-------------+
| name   | homedir     |
+--------+-------------+
| yaya   | beijing     |
| plj    | shanghai    |
| jing   | beijing     |
| nb     | nb@tedu.cn  |
| nb2    | nb2@tedu.cn |
| nb3    | nb3@tedu.cn |
| yaya   | beijing     |
| plj    | shanghai    |
| jing   | beijing     |
| nb     | nb@tedu.cn  |
| nb2    | nb2@tedu.cn |
| nb3    | nb3@tedu.cn |
| yaya   | NULL        |
| plj    | NULL        |
| jing   | NULL        |
| yaya   | NULL        |
| plj    | NULL        |
| jing   | NULL        |
| panglj | NULL        |
| plj    | NULL        |
| plj    | NULL        |
+--------+-------------+
21 rows in set (0.00 sec)
只修改与条件匹配的表头值  把邮箱地址是空的都修改成stu@163.com 
mysql> update DB1.stuinfo set email="stu@163.com" where email is null;
Query OK, 15 rows affected (0.05 sec)
Rows matched: 15  Changed: 15  Warnings: 0
mysql>
不加条件批量修改
mysql> update DB1.stuinfo set homedir="beijing";
Query OK, 17 rows affected (0.04 sec)
Rows matched: 21  Changed: 17  Warnings: 0
mysql> 
```

3）删除表记录

```sql
mysql> delete from DB1.stuinfo where number is null; 只删除number字段没有数据的记录
Query OK, 7 rows affected (0.04 sec)
mysql> 
清空表记录
mysql> TRUNCATE TABLE DB1.stuinfo;
Query OK, 0 rows affected (0.14 sec)
mysql> select  * from DB1.stuinfo;
Empty set (0.00 sec)
mysql> 
或
mysql> delete from  DB1.stuinfo;
Query OK, 0 rows affected (0.00 sec)
mysql> 
```

# 2. 数据类型

## 2.1 问题

按要求建表：如图-1 和 图-2

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb4e547afe3b4e2192f4b406b9d10d6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

![在这里插入图片描述](https://img-blog.csdnimg.cn/af6b0f19c20b4cac946f0680e6367e40.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

## 2.2 步骤

在host50主机做如下练习
**步骤一：创建图-1表**

```sql
[root@host50 ~]# mysql -uroot -pNSD123...a 管理员登录
Mysql> 
mysql> create database db1;  创建db1库
Query OK, 1 row affected (0.00 sec)
mysql> create table db1.t1(  创建t4表
    -> name  char(4),
    -> your_start  year,
    -> up_time time,
    -> birthday date,
    -> party datetime
    -> );
Query OK, 0 rows affected (0.25 sec)
mysql> desc db1.t1; 查看表结构
+------------+----------+------+-----+---------+-------+
| Field      | Type     | Null | Key | Default | Extra |
+------------+----------+------+-----+---------+-------+
| name       | char(4)  | YES  |     | NULL    |       |
| your_start | year(4)  | YES  |     | NULL    |       |
| up_time    | time     | YES  |     | NULL    |       |
| birthday   | date     | YES  |     | NULL    |       |
| party      | datetime | YES  |     | NULL    |       |
+------------+----------+------+-----+---------+-------+
5 rows in set (0.00 sec)
mysql> 
```

步骤二：创建图-2表

```sql
mysql> create table db1.t2 (   建表
    -> stu_num  int  ,
    -> name  char(5),
    -> age tinyint unsigned,
    -> pay float ,
    -> money float(5,2)
    -> );
Query OK, 0 rows affected (0.28 sec)
mysql> desc db1.t2; 查看表结构
+---------+---------------------+------+-----+---------+-------+
| Field   | Type                | Null | Key | Default | Extra |
+---------+---------------------+------+-----+---------+-------+
| stu_num | int(11)             | YES  |     | NULL    |       |
| name    | char(5)             | YES  |     | NULL    |       |
| age     | tinyint(3) unsigned | YES  |     | NULL    |       |
| pay     | float               | YES  |     | NULL    |       |
| money   | float(5,2)          | YES  |     | NULL    |       |
+---------+---------------------+------+-----+---------+-------+
5 rows in set (0.00 sec)
mysql> 
```

# 3. 数据批量处理

## 3.1 问题

- 修改检索目录为/myload
- 将/etc/passwd文件导入db1库的t3表里
- 将db1库t3表所有记录导出, 存到/myload/user.txt 文件里。

**步骤一：修改检索目录为/myload**

1. 修改配置文件，重启服务

```sql
]# vim  /etc/my.cnf
        [mysqld]
        secure_file_priv="/myload”
:wq
]# mkdir  /myload  
]# chown  mysql  /myload 
]#  setenforce 0   禁用selinux
]# systemctl  restart mysqld
]# ]# mysql -uroot -pNSD123...a  管理员登录
mysql> show  variables  like  “secure_file_priv”;  //查看
 +------------------+-----------------------+
| Variable_name    | Value                          |
+------------------+-----------------------+
| secure_file_priv   | /myload/   |
+------------------+-----------------------+     
Mysql>           
```

2. 创建存储数据的库和表

```sq
mysql> CREATE DATABASE  if not exists db1; 建库
create table db1.t3(    
        name char(50),
        password  char(1),      
        uid int,
        gid int,
        comment  char(150),     
        homedir char(50),       
        shell   char(50)        
);  建表
Query OK, 0 rows affected (0.70 sec)
Mysql>
```

**步骤二：将/etc/passwd文件导入db1库的t3表里**

1）拷贝文件到检索目录下

```sql
]# cp  /etc/passwd   /myload/
```

2）导入数据

```sql
]#  mysql –uroot –ptarena
mysql> load data infile "/myload/passwd" into table db1.t3
       fields terminated by ":" lines terminated by "\n" ;   导入数据
mysql> select  * from  db1.t3;  //查看表记录
```

**步骤三：将db1库t3表所有记录导出, 存到/myload/user.txt 文件里。**

1）查询要导出的数据

```sql
mysql> select  * from  db1.t3 ；            
```

2）导出数据

```sql
mysql> select  * from  db1.t3  into outfile "/myload/user.txt";
```

3）查看文件内容

```shell
cat  /myload/user.txt  
```

# Exercise

## 1 简述索引的优点与缺点？

- 索引的优点：加快查询表记录的速度。
- 索引的缺点：会减慢写的速度(如： insert 、update )，占用物理存储空间。

## 2 简述普通索引与主键的约束规则。

1. index普通索引

- 一个表中可以有多个INDEX字段
- 字段的值允许有重复，且可以赋NULL值
- 经常把做查询条件的字段设置为INDEX字段
- INDEX字段的KEY标志是MUL

2. primary key 主键

- 一个表中只能有一个primary key字段
- 对应的字段值不允许有重复，且不允许赋NULL值
- 如果有多个字段都作为PRIMARY KEY，称为复合主键，必须一起创建。
- 主键字段的KEY标志是PRI 、通常与 AUTO_INCREMENT 连用
- 经常把表中能够唯一标识记录的字段设置为主键字段[如：记录编号字段]

## 3 根据图-1显示，修改studentdb.stu_info表的结构,原表结构见DAY01练习的图-1。

> ![在这里插入图片描述](https://img-blog.csdnimg.cn/b7ec14a2293f43e486bd78faf2c9c9aa.png)
> 图-1

```sql
mysql> alter table studentdb.stuinfo  add  id int(2) zerofill  primary key auto_increment first;
mysql> create unique index stu_id on studentdb.stuinfo(stu_id);
mysql> alter table studentdb.stuinfo add mail varchar(50) default "student@tedu.cn" after name;
mysql> alter table studentdb.stuinfo add tel char(11) not null ,add qq varchar(11);
mysql> alter table studentdb.stuinfo add pay float(7,2) not null default 18800 after sex;
mysql> create index name on studentdb.stuinfo(name);
```

## 4 简述在表中创建外键字段要满足那些条件？

foreign key 外键使用规则如下：
表的存储引擎必须是innodb
字段的数据类型要匹配
被参考的字段必须是key 中的一种 (通常使用primary key)

> 如有侵权，请联系作者删除



﻿@[TOC]( Time method & exception handling & file system related modules | Cloud computing )

---

# 1. 简化除法判断

## 1.1 问题

创建mydiv.py脚本，要求如下：

1. 提示用户输入一个数字作为除数
2. 如果用户按下Ctrl+C或Ctrl+D则退出程序
3. 如果用户输入非数字字符，提示用户应该输入数字
4. 如果用户输入0，提示用户0不能作为除数

## 1.2 方案

首先，执行try子句（在关键字try和关键字except之间的语句），输入数字，让这个数字被100整除，

1. 如果没有异常发生，忽略except子句，try子句执行后，执行else子句和finally子句，最后执行 try 语句之后的代码结束整个程序。

2. 如果在执行try子句的过程中发生了异常，异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。然后执行finally子句，最后执行 try 语句之后的代码结束整个程序。

需要注意的是：允许用户中断这个程序（使用Ctrl+C或Ctrl+D方法）。用户中断的信息会引发KeyboardInterrupt 和EOFError 这两种异常。

一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。

处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。

try except 语句只有一个可选的else子句，使用这个子句，必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。

finally子句是无论异常是否发生，是否捕捉都会执行的一段代码，使用finally可以保证文件总是能正常的关闭

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day05]# vim mydiv.py
#!/usr/bin/env python3
try:
    num = int(input("number: "))
    result = 100 / num
except ValueError:
    print('请输入数字')
except ZeroDivisionError:
    print('不允许使用0')
except (KeyboardInterrupt, EOFError):
    print('\nBye-bye')
else:
    print(result)  # 不发生异常才执行的语句
finally:
    print('Done')  # 不管异常是否发生都要执行的语句
print('end of program')  
#不是必须把所有的语句写全，常用的有try-except和try-finally组合
```

步骤二：测试脚本执行

```shell
[root@localhost day05]# python3 mydiv.py 
number: 0
不允许使用0
Done
end of program
[root@localhost day05]# python3 mydiv.py 
number: nighao
请输入数字
Done
end of program
[root@localhost day05]# python3 mydiv.py 
number: 3
33.333333333333336
Done
end of program
[root@localhost day05]# python3 mydiv.py 
number: 55^C
Bye-bye
Done
end of program
[root@localhost day05]# python3 mydiv.py 
number: 
Bye-bye
Done
end of program
```

# 2. 自定义异常

## 2.1 问题

创建myerror.py脚本，要求如下：

1. 编写第一个函数，函数接收姓名和年龄，如果年龄不在1到120之间，产生ValueError异常
2. 编写第二个函数，函数接收姓名和年龄，如果年龄不在1到120之间，产生断言异常

## 2.2 方案

两个函数，分别有引发异常及断言异常的功能：

1. 当set_age()函数调用名字与年龄两个实参时，如果年龄在0-120范围内，打印“bob is 25 years old”，如果年龄在0-120范围外，利用raise 语句抛出一个指定的异常

2. 当set_age2()函数调用名字与年龄两个实参时，如果年龄在0-120范围内，表达式为true，打印“bob is 20 years old”，如果年龄在0-120范围外，表达式为Flase，利用assert 断言语句抛出一个指定的异常

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day05]# vim myerror.py
#!/usr/bin/env python3
def set_age(name, age):
    if not 0 < age < 120:
        raise ValueError("age out of range.")
    print("%s is %s years old" % (name, age))
def set_age2(name, age):
    assert 0 < age < 120, 'age out of range.'
    print("%s is %s years old" % (name, age))
if __name__ == '__main__':
    set_age('bob', 25)
    set_age2('bob', 20)
```

**步骤二：测试脚本执行**

```shell
[root@localhost day05]# python3 myerror.py
bob is 25 years old
bob is 20 years old
[root@localhost day05]# python3 myerror.py 
Traceback (most recent call last):
  File "myerror.py", line 11, in <module>
    set_age('bob', 125)
  File "myerror.py", line 3, in set_age
    raise ValueError("age out of range.")
ValueError: age out of range.
[root@localhost day05]# python3 myerror.py 
bob is 25 years old
Traceback (most recent call last):
  File "myerror.py", line 12, in <module>
    set_age2('bob', 120)
  File "myerror.py", line 7, in set_age2
    assert 0 < age < 100, 'age out of range.'
AssertionError: age out of range.
```

# 3. 操作文件系统

## 3.1 问题

创建os_module.py脚本，熟悉os模块操作,要求如下：

1. 切换到/tmp目录
2. 创建example目录
3. 切换到/tmp/example目录
4. 创建test文件，并写入字符串foo bar
5. 列出/tmp/exaple目录内容
6. 打印test文件内容
7. 反向操作，把test文件以及example目录删除

## 3.2 方案

用os方法查看用户当前所在位置，切换到指定目录，创建example目录，切换到创建目录下，以读写方式打开并创建一个新文件，将指定内容写入新文件中，列出目录下有指定目录下有哪些文件，指定从开始位置读取指定文件字符串并打印出来，关闭打开文件，并删除文件，删除目录。

注意：读取打印文件内容时，要将字节转化为字符串读取出来。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day05]# vim os_module.py
#!/usr/bin/env python3
import os
#1)    切换到/tmp目录
os.getcwd()        #'/root/python代码/os'
os.chdir("/tmp") 
os.getcwd()        #'/tmp'
#2)    创建example目录 
os.mkdir("example")
#3)    切换到/tmp/example目录
os.chdir("/tmp/example")
os.getcwd()        #'/tmp/example' 
#4)    创建test文件，并写入字符串foo bar
f=os.open("test.txt",os.O_RDWR|os.O_CREAT)        #以读写方式打开/创建并打开一个新文件
os.write(f,b"foo bar nihao")
#5)    列出/tmp/exaple目录内容
os.listdir("/tmp/example")     #['test.txt']
#6)    打印test文件内容 
os.lseek(f,0,0)        #指定从开始位置读取字符串
str=os.read(f,100)
str = bytes.decode(str)
print("读取的字符是：",str)
os.close(f)
#7)    反向操作，把test文件以及example目录删除
os.remove("/tmp/example/test.txt")
os.removedirs("/tmp/example")
```

步骤二：测试脚本执行

```shell
[root@localhost day05]# python3 os_module.py 
读取的字符是： foo bar
```

# 4. 记账程序

## 4.1 问题

创建account.py脚本，要求如下：

1. 假设在记账时，有一万元钱
2. 无论是开销还是收入都要进行记账
3. 记账内容包括时间、金额和说明等
4. 记账数据要求永久存储

## 4.2 方案

创建4个函数，分别实现记录开销、记录收入、查询收支、判断函数调用的四个方法，导入时间模块获取时间，导入os模块判断文件是否存在，导入pickle模块用来python特有类型与数据类型转换：

1. 调用show_menu()函数后，先判断记录余额文件是否存在，如果不存在创建文件并写入余额，如果存在，利用while循环在交互端输出提示，请用户input0/1/2/3任意数值，如果输入的值不是0/1/2/3，打印输入值无效请重新输入并重新开始循环，如果输入的值是3，停止整个循环，如果输入的值是0/1/2通过字典键值对关联关系，调用相对应函数

2. 如果输入的值是0，字典cmds中0键对应的值是spend_money，调用spend_money ()记录开销函数，让此函数实现获取当前系统日期、输入开销金额、输入开销备注信息、以二进制读方式打开记录余额文件计算本次开销后余额，以写方式打开记录余额文件将计算后开销余额写入文件，以追加方式打开记账文件，将日期、开销、备注、余额写入追加入记账文件最后

3. 如果输入的值是1，字典cmds中0键对应的值是save_money，调用save_money ()记录收入函数，让此函数实现获取当前系统日期、输入收入金额、输入收入备注信息、以二进制读方式打开记录余额文件计算本次收入后余额，以写方式打开记录余额文件将计算后收入余额写入文件，以追加方式打开记账文件，将日期、开销、备注、余额写入追加入记账文件最后

4. 如果输入的值是2，调用查询收支函数query ()，以二进制读方式打开记账文件，利用for循环遍历文件中数据，打印出来，打开记录余额文件读取余额并打印。

需要注意的是：为确保代码可以正常执行，while循环利用try except语句处理异常，优先匹配特殊异常，让用户按下Ctrl+C或Ctrl+D可以退出程序，遇到索引错误可以结束当次循环，重新开始选择选项。

将记录余额文件以及记账文件作为参数传入函数中

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：编写脚本**

```shell
[root@localhost day05]# vim account.py
#!/usr/bin/env python3
# 日期　　开销　　收入　　余额　　备注
import time
import os
import pickle as p
def spend_money(record, wallet):
    date = time.strftime('%Y-%m-%d')
    amount = int(input('金额: '))
    comment = input('备注: ')
    with open(wallet, 'rb') as fobj:
#load从数据文件中读取数据，并转换为Python的数据结构
        balance = p.load(fobj) – amount        
    with open(wallet, 'wb') as fobj:
           #dump将数据通过特殊形式转换为只有python语言认识的字符串，并写入文件
        p.dump(balance, fobj)
    with open(record, 'a') as fobj:
        fobj.write(
            "%-15s%-8s%-8s%-10s%-20s\n" %
            (date, amount, 'n/a', balance, comment)
        )
def save_money(record, wallet):
    date = time.strftime('%Y-%m-%d')
    amount = int(input('金额: '))
    comment = input('备注: ')
    with open(wallet, 'rb') as fobj:
        balance = p.load(fobj) + amount
    with open(wallet, 'wb') as fobj:
        p.dump(balance, fobj)
    with open(record, 'a') as fobj:
        fobj.write(
            "%-15s%-8s%-8s%-10s%-20s\n" %
            (date, 'n/a', amount, balance, comment)
        )
def query(record, wallet):
    with open(record) as fobj:
        for line in fobj:
            print(line, end='')
    with open(wallet, 'rb') as fobj:
          #load从数据文件中读取数据，并转换为Python的数据结构
        balance = p.load(fobj)
    print('当前余额: %s' % balance)
def show_menu():
    prompt = """(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): """
    cmds = {'0': spend_money, '1': save_money, '2': query}
    record = 'record.txt'   # 记帐
    wallet = 'wallet.data'  # 记录余额
    if not os.path.exists(wallet):        #判断文件是否存在
        with open(wallet, 'wb') as fobj:
            p.dump(10000, fobj)
    while True:
        try:
            choice = input(prompt).strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt, EOFError):
            print('\nBye-bye')
            choice = '3'
        if choice not in '0123':
            print('无效输入，请重试')
            continue
        if choice == '3':
            break
        cmds[choice](record, wallet)
if __name__ == '__main__':
    show_menu()
```

**步骤二：测试脚本执行**

```shell
[root@localhost day05]# python3 account.py
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): 0
金额: 2000
备注: huafei
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): 1
金额: 1000
备注: shouru
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): 2
2018-04-25     2000    n/a     28890     huafei              
2018-04-25     n/a     1000    29890     shouru              
当前余额: 29890
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): 3
[root@localhost day05]# python3 account.py
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): ^C
Bye-bye
[root@localhost day05]# python3 account.py
(0) 记录开销
(1) 记录收入
(2) 查询收支记录
(3) 退出
请选择(0/1/2/3): 
Bye-bye
```

# Exercise

## 1 获取字典adict['name']的值，如果没有找到，则返回'Not Found'

```shell
>>> adict.get('name', 'Not Found')
```

## 2 遍历字典adict，通过两种方法取出字典的key和value。

```shell
>>> for key in adict:
...   print('%s: %s' % (key, adict[key]))
>>> for key, val in adict.items():
...   print('%s: %s' % (key, val))
```

## 3 aset和bset是两个可变集合，举例说明什么是交集、并集和差补。

- 交集：aset & bset，取出两个集合中都包含的元素
- 并集：aset | bset，取出两个集合中所有的元素
- 差补：aset - bset，取出在第一个集合中有，而第二个集合中没有的元素

## 4 通过time模块，显示当前时间：年月-月-日 时：分：秒

```shell
>>> import time
>>> time.strftime('%Y-%m-%d %H:%H:%S')
```

## 5 time.time()返回的是什么？

- 返回的是时间戳。也就是1970年1月1日0点到执行time.time()之间的秒数。

## 6 写出异常处理的语法结构

```shell
try:
    有可能发生异常的语句
except (要补获的异常):
    发生异常时执行的语句
else:
    异常不发生才执行的语句
finally:
    不管是否发生异常都要执行的语句
```

## 7 os.path模块有哪些判断路径的方法？

- os.path.isabs(path)：判断是否为绝对路径
- os.path.isfile(path)：判断是否为文件
- os.path.ismount(path)：判断是否为挂载点
- os.path.isdir(path)：判断是否为目录
- os.path.islink(path)：判断是否为链接
- os.path.exists(path)：判断是否存在

## 8 pickle模块的主要作用和方法是什么？

- pickle模块可以将任意的数据类型保存到文件中，并且可以无损的将其取出来
- pickle.dump()：用于将数据存入文件
- pickle.load()：用于将数据从文件中取出

> 如有侵权，请联系作者删除



﻿@[TOC]( Tomcat server & Tomcat application cases & Maven application cases | Cloud computing )

---

# 1. 安装部署Tomcat服务器

## 1.1 问题

本案例要求部署Tomcat服务器，具体要求如下：

- 安装部署JDK基础环境
- 安装部署Tomcat服务器
- 创建JSP测试页面，文件名为test.jsp，显示服务器当前时间

然后客户机访问此Web服务器验证效果：

- 使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认首页
- 使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认测试页面

## 1.2 方案

使用2台RHEL7虚拟机，其中一台作为Tomcat服务器（192.168.2.100）、另外一台作为测试用的Linux客户机（192.168.2.5），如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0b6a24d3af0042d9bd4a80f2d8c8e80e.png)
图-1

使用RPM安装JDK基础环境

使用源码安装部署Tomcat服务器

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署Tomcat服务器软件(192.168.2.100/24)**

1）使用RPM安装JDK环境

```shell
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# java -version                                    //查看JAVA版本
```

2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）

```shell
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/                                            //主程序目录
lib/                                            //库文件目录
logs/                                          //日志目录  
temp/                                         //临时目录
work/                                        //自动编译目录jsp代码转换servlet
conf/                                        //配置文件目录
webapps/                                        //页面目录
```

3）启动服务

```shell
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

4）服务器验证端口信息

```shell
[root@web1 ~]# ss -nutlp |grep java        //查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java 
tcp        0      0 :::8009              :::*                LISTEN      2778/java                     
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java
```

提示：如果检查端口时，8005端口启动非常慢，默认tomcat启动需要从/dev/random读取大量的随机数据，默认该设备生成随机数据的速度很慢，可用使用下面的命令用urandom替换random（非必须操作）。

```shell
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random
```

另外，还可以使用方案二解决：

```shell
[root@web1 ~]# yum install rng-tools
[root@web1 ~]# systemctl start rngd
[root@web1 ~]# systemctl enable rngd
```

5）客户端浏览测试页面(proxy作为客户端)

```shell
[root@proxy ~]# firefox http://192.168.2.100:8080
```

**步骤二：修改Tomcat配置文件**

1）创建测试JSP页面

```shell
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>
```

**步骤三：验证测试**

1）客户端浏览测试页面(proxy充当客户端角色)

```shell
[root@proxy ~]# firefox http://192.168.2.100:8080
[root@proxy ~]# firefox http://192.168.2.100:8080/test.jsp
```

# 2. 使用Tomcat部署虚拟主机

## 2.1 问题

沿用练习二，使用Tomcat部署加密虚拟主机，实现以下要求：

- 实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
- 使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
- 使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
- 访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
- 访问页面时支持SSL加密通讯
- 私钥、证书存储路径为/usr/local/tomcat/conf/cert
- 每个虚拟主机都拥有独立的访问日志文件
- 配置tomcat集群环境

## 2.2 方案

修改server.xml配置文件，创建两个域名的虚拟主机，修改如下两个参数块：

```shell
# cat /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
     <Engine name="Catalina" defaultHost="localhost">
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
… …
```

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置服务器虚拟主机**

1）修改server.xml配置文件，创建虚拟主机

```shell
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
```

2）创建虚拟主机对应的页面根路径

```shell
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html
```

3）重启Tomcat服务器

```shell
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)

注意：ssh远程连接时使用使用-X参数才可以！！！

```shell
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@proxy ~]# firefox http://www.b.com:8080/
```

**步骤二：修改www.b.com网站的首页目录为base**

1）使用docBase参数可以修改默认网站首页路径

```shell
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base"/>
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

2）测试查看页面是否正确(proxy充当客户端角色)

```shell
[root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容
```

**步骤三：跳转**

1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面

```shell
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

2）测试查看页面是否正确(proxy充当客户端角色)

```shell
[root@proxy ~]# firefox http://www.a.com:8080/test    
//返回/var/www/html/index.html的内容
//注意，访问的端口为8080
```

**步骤四：配置Tomcat支持SSL加密网站**

1）创建加密用的私钥和证书文件

```shell
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair     生成密钥对
//-alias tomcat     密钥别名
//-keyalg RSA     定义密钥算法为RSA算法
//-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
```

2)再次修改server.xml配置文件，创建支持加密连接的Connector

```shell
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
```

3）重启Tomcat服务器

```shell
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)

```shell
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox https://www.a.com:8443/
[root@proxy ~]# firefox https://www.b.com:8443/
[root@proxy ~]# firefox https://192.168.2.100:8443/
```

**步骤五：配置Tomcat日志**

1)为每个虚拟主机设置不同的日志文件

```shell
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
.. ..
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
.. ..
```

2）重启Tomcat服务器

```shell
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

3）查看服务器日志文件

```shell
[root@web1 ~]# ls /usr/local/tomcat/logs/
```

**步骤六：扩展实验(配置Tomcat集群)**

1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）

```shell
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  
```

2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器

以下以Web1为例：

```shell
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
```

3）启动服务

```shell
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
```

4）客户端验证

为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。

# 3. 使用Maven部署网站系统

## 3.1 问题

通过安装配置Maven，实现如下目标：

- 查询Maven版本
- 配置镜像地址
- 打包并上线网站项目

## 3.2 方案

通过tar包安装Maven

- 释放tar包，拷贝到/usr/local目录
- 安装并运行数据库
- 打包网站项目，之后利用tomcat上线该网站

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装maven工具，以及java环境**

1）释放tar包，并拷贝到指定目录

```shell
[root@web1 ~]# tar -xf apache-maven-3.6.3-bin.tar.gz
[root@web1 ~]# mv apache-maven-3.6.3 /usr/local/maven
```

2）安装java依赖包

```shell
[root@web1 ~]# yum -y install java-1.8.0-openjdk
[root@web1 ~]# yum -y install java-devel
[root@web1 ~]# /usr/local/maven/bin/mvn -v
```

3）修改镜像地址，在第158行下添加

```shell
[root@web1 ~]# vim /usr/local/maven/conf/settings.xml  
<mirror>
          <id>nexus-aliyun</id>
          <mirrorOf>*</mirrorOf>
          <name>Nexus aliyun</name>
          <url>http://maven.aliyun.com/nexus/content/groups/public</url> 
</mirror>
```

**步骤二：配置数据库并打包项目**

1）配置数据库

```shell
[root@web1 ~]# yum install -y mariadb-server
[root@web1 ~]# systemctl start mariadb
[root@web1 ~]# cd CMS/
[root@web1 CMS]# cp src/main/resources/shishuocms.properties .
[root@web1 CMS]# mysql -uroot < sql/install.sql
[root@web1 CMS]# mysqladmin password
```

2）打包项目

```shell
[root@web1 CMS]# /usr/local/maven/bin/mvn clean package
```

**步骤三：上线测试**

1）备份原有网站页面

```shell
[root@web1 CMS]# mv /usr/local/tomcat/webapps/ROOT /opt/tomcat_ROOT
```

2）将war包拷贝到tomcat网站页面目录

```shell
[root@web1 CMS]#cp target/shishuocms-2.0.1.war /usr/local/tomcat/webapps/ROOT.war
[root@web1 CMS]#/usr/local/tomcat/bin/startup.sh
```

# Exercise

## 1 哪些参数影响了Tomcat部署网站时的路径

appBase，docBase，path。

## 2 使用keytool生成密钥文件的命令是什么？

```shell
[root@localhost ~]keytool -genkeypair -alias tomcat -keyalg RSA \
> -keystore /usr/local/tomcat/keystore
```

## 3 Tomcat配置虚拟主机的关键词是什么？

首先以<Host ......> 开头
......
然后以</Host>结尾，中间包含的 . 的内容是虚拟主机的各种参数配置

## 4 Maven的功能是什么？

是一个软件项目管理工具

> 如有侵权，请联系作者删除



﻿@[TOC]( Upgrade the website running platform & deploy the cache service & migrate data & deploy clusters | Cloud computing )

---

# 1. 升级网站运行平台

## 1.1 问题

具体配置如下：

1. 清除当前配置
2. 部署LNMP
3. 测试配置

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：清除当前配置**

1）停止网站服务

```shell
[root@web33 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web33 ~]# vim  /etc/rc.local
#/usr/local/tomcat/bin/startup.sh
:wq
```

2）卸载共享存储

```shell
[root@web33 ~]# umount /usr/local/tomcat/webapps/ROOT  //卸载当前挂载
[root@web33 ~]# vim /etc/fstab   //清除开机挂载
#192.168.4.30:/sitedir    /usr/local/tomcat/webapps/ROOT  nfs  defaults   0   0 
:wq
```

**步骤二：部署LNMP**

1）安装软件

```shell
[root@web33 ~]# yum -y install gcc  zlib-devel  pcre-devel  //安装源码Nginx依赖软件
已安装:
  gcc.x86_64 0:4.8.5-28.el7                          pcre-devel.x86_64 0:8.32-17.el7                          zlib-devel.x86_64 0:1.2.7-17.el7                         
作为依赖被安装:
  cpp.x86_64 0:4.8.5-28.el7 glibc-devel.x86_64 0:2.17-222.el7 glibc-headers.x86_64 0:2.17-222.el7 kernel-headers.x86_64 0:3.10.0-862.el7 libmpc.x86_64 0:1.0.1-3.el7
  mpfr.x86_64 0:3.1.1-4.el7
完毕！
[root@web33 ~]#
[root@web33 ~]# tar -zxvf nginx-1.12.2.tar.gz //解压
[root@web33 ~]# cd nginx-1.12.2  //进源码目录
[root@web33 nginx-1.12.2]# ./configure  //配置
......
Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + using system zlib library
  nginx path prefix: "/usr/local/nginx"
  nginx binary file: "/usr/local/nginx/sbin/nginx"
  nginx modules path: "/usr/local/nginx/modules"
  nginx configuration prefix: "/usr/local/nginx/conf"
  nginx configuration file: "/usr/local/nginx/conf/nginx.conf"
  nginx pid file: "/usr/local/nginx/logs/nginx.pid"
  nginx error log file: "/usr/local/nginx/logs/error.log"
  nginx http access log file: "/usr/local/nginx/logs/access.log"
  nginx http client request body temporary files: "client_body_temp"
  nginx http proxy temporary files: "proxy_temp"
  nginx http fastcgi temporary files: "fastcgi_temp"
  nginx http uwsgi temporary files: "uwsgi_temp"
  nginx http scgi temporary files: "scgi_temp"
[root@web33 nginx-1.12.2]# make  //编译
……
……
sed -e "s|%%PREFIX%%|/usr/local/nginx|" \
    -e "s|%%PID_PATH%%|/usr/local/nginx/logs/nginx.pid|" \
    -e "s|%%CONF_PATH%%|/usr/local/nginx/conf/nginx.conf|" \
    -e "s|%%ERROR_LOG_PATH%%|/usr/local/nginx/logs/error.log|" \
    < man/nginx.8 > objs/nginx.8
make[1]: 离开目录“/root/nginx-1.12.2”
[root@web33 nginx-1.12.2]#
[root@web33 nginx-1.12.2]# make install  //安装
……
……
cp conf/nginx.conf '/usr/local/nginx/conf/nginx.conf.default'
test -d '/usr/local/nginx/logs' \
    || mkdir -p '/usr/local/nginx/logs'
test -d '/usr/local/nginx/logs' \
    || mkdir -p '/usr/local/nginx/logs'
test -d '/usr/local/nginx/html' \
    || cp -R html '/usr/local/nginx'
test -d '/usr/local/nginx/logs' \
    || mkdir -p '/usr/local/nginx/logs'
make[1]: 离开目录“/root/nginx-1.12.2”
[root@web33 nginx-1.12.2]#
[root@web33 nginx-1.12.2]# ls /usr/local/nginx   //查看安装目录
conf  html  logs  sbin
[root@web33 nginx-1.12.2]#
[root@web33 ~]# yum  -y  install   php-fpm   //安装php-fpm 软件
……
……
已安装:
  php-fpm.x86_64 0:5.4.16-45.el7                                                                                                                                       
作为依赖被安装:
  libzip.x86_64 0:0.10.1-8.el7                                                    php-common.x86_64 0:5.4.16-45.el7                                                   
完毕！
[root@web33 ~]# yum -y install  php  php-mysql  //安装php 及 php-mysql 软件
……
……
已安装:
  php.x86_64 0:5.4.16-45.el7                                                      php-mysql.x86_64 0:5.4.16-45.el7                                                     
作为依赖被安装:
  mariadb-libs.x86_64 1:5.5.56-2.el7                        php-cli.x86_64 0:5.4.16-45.el7                        php-pdo.x86_64 0:5.4.16-45.el7                       
完毕！
[root@web33 ~]#
```

2）挂载共享存储

```shell
[root@web33 ~]# vim /etc/fstab   //开机挂载
192.168.4.30:/sitedir    /usr/local/nginx/html  nfs  defaults   0   0 
:wq
[root@web33 ~]# mount   -a  //挂载设备
[root@web33 ~]# mount |  grep  "/usr/local/nginx/html" //查看挂载
192.168.4.30:/sitedir on /usr/local/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=192.168.4.33,local_lock=none,addr=192.168.4.30)
[root@web33 ~]#
```

3）启动服务

```shell
[root@web33 ~]# vim +65 /usr/local/nginx/conf/nginx.conf  //修改主配置文件
location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           #fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi.conf;
        }
:wq
[root@web33 ~]# /usr/local/nginx/sbin/nginx //启动服务
[root@web33 ~]# 
[root@web33 ~]# netstat -utnlp  | grep :80   //查看端口
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      26335/nginx: master 
[root@web33 ~]#
[root@web33 ~]# systemctl  start php-fpm
[root@web33 ~]# 
[root@web33 ~]# netstat -utnlp  | grep :9000
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      26345/php-fpm: mast 
[root@web33 ~]# 
```

**步骤三：测试配置**

1）编写PHP脚本

```shell
[root@nfs30 ~]# vim /sitedir/linkdb2.php  //在nfs30共享目录编写php脚本文件
<?php
$conn=mysql_connect("192.168.4.11","yaya99","123qqq...A");
mysql_select_db("gamedb");
$sql = 'insert into user (name) values ("PLJ")';
mysql_query($sql);
mysql_close();
echo "save data ok";
?>
:wq
```

2）访问脚本

```shell
[root@client50 ~]# curl  http://192.168.4.33/linkdb2.php //访问web33服务器
save data ok
[root@client50 ~]# 
```

3）查看数据

```shell
[root@mysql11 ~]# mysql –uyaya99 -p123qqq...A -e 'select  * from gamedb.user where name="PLJ"' //在数据库服务器查看数据
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| name |
+------+
| PLJ  |
+------+
[root@mysql11 ~]#
```



# 2. 部署内存存储服务

## 2.1 问题

具体操作如下：

1. 部署redis服务器
2. 创建redis集群
3. 配置网站服务器
4. 测试配置

## 2.2 方案

克隆7台虚拟机配置要求如图-1所示。

![img](https://img-blog.csdnimg.cn/img_convert/c5061cec71d147fb6622496904021e6e.png)

图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署redis服务器（6台都要配置）**

1）搭建redis服务器

```shell
[root@redisA ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisA ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisA ~]# cd redis-4.0.8/   //进源码目录
[root@redisA redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisA redis-4.0.8]# 
[root@redisA redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisA redis-4.0.8]#  
[root@redisA redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisA redis-4.0.8]#
[root@redisA redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.51
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisA redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisA redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.51:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.51:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
[root@redisB ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisB ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisB ~]# cd redis-4.0.8/   //进源码目录
[root@redisB redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisB redis-4.0.8]# 
[root@redisB redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisB redis-4.0.8]#  
[root@redisB redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisB redis-4.0.8]#
[root@redisB redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.52
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisB redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisB redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.52:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.52:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
[root@redisC ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisC ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisC ~]# cd redis-4.0.8/   //进源码目录
[root@redisC redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisC redis-4.0.8]# 
[root@redisC redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisC redis-4.0.8]#  
[root@redisC redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisC redis-4.0.8]#
[root@redisC redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.53
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisC redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisC redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.53:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.53:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
[root@redisD ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisD ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisD ~]# cd redis-4.0.8/   //进源码目录
[root@redisD redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisD redis-4.0.8]# 
[root@redisD redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisD redis-4.0.8]#  
[root@redisD redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisD redis-4.0.8]#
[root@redisD redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.54
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisD redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisD redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.54:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.54:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
[root@redisE ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisE ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisE ~]# cd redis-4.0.8/   //进源码目录
[root@redisE redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisE redis-4.0.8]# 
[root@redisE redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisE redis-4.0.8]#  
[root@redisE redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisE redis-4.0.8]#
[root@redisE redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.55
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisE redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisE redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.55:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.55:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
[root@redisF ~]# rpm -q gcc  ||  yum -y  install gcc  //安装编译工具
[root@redisF ~]# tar -zxvf redis-4.0.8.tar.gz //解压
[root@redisF ~]# cd redis-4.0.8/   //进源码目录
[root@redisF redis-4.0.8]# make install  //安装软件
……
……
INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: 离开目录“/root/redis-4.0.8/src”
[root@redisF redis-4.0.8]# 
[root@redisF redis-4.0.8]# ./utils/install_server.sh //初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: [6379] //端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] //服务启动启动程序 
Selected config: //配置总结
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...   //服务启动提示
Installation successful!   //安装完成提示
[root@redisF redis-4.0.8]#  
[root@redisF redis-4.0.8]# /etc/init.d/redis_6379  stop  //停止服务
Stopping ...
Redis stopped
[root@redisF redis-4.0.8]#
[root@redisF redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件，启用集群配置
70 bind 192.168.4.56
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisF redis-4.0.8]# /etc/init.d/redis_6379  start  //启动服务
Starting Redis server...
[root@redisF redis-4.0.8]# netstat  -utnlp  | grep  redis-server  //查看端口
tcp        0      0 192.168.4.56:6379       0.0.0.0:*               LISTEN      29720/redis-server   //redis服务端口
tcp        0      0 192.168.4.56:16379      0.0.0.0:*               LISTEN      29720/redis-server  //集群端口
```

**步骤二：创建redis集群**

1）配置管理主机

```shell
[root@mgm ~]# yum -y  install ruby rubygems  //安装依赖
……
……
已安装:
  ruby.x86_64 0:2.0.0.648-33.el7_4                                                 rubygems.noarch 0:2.0.14.1-33.el7_4                                                
作为依赖被安装:
  libyaml.x86_64 0:0.1.4-11.el7_0             ruby-irb.noarch 0:2.0.0.648-33.el7_4  ruby-libs.x86_64 0:2.0.0.648-33.el7_4  rubygem-bigdecimal.x86_64 0:1.2.0-33.el7_4 
  rubygem-io-console.x86_64 0:0.4.2-33.el7_4  rubygem-json.x86_64 0:1.7.7-33.el7_4  rubygem-psych.x86_64 0:2.0.0-33.el7_4  rubygem-rdoc.noarch 0:4.0.0-33.el7_4       
完毕！
[root@mgm ~]#
[root@mgm ~]# gem install redis-3.2.1.gem  //安装依赖软件gem程序
Successfully installed redis-3.2.1
Parsing documentation for redis-3.2.1
Installing ri documentation for redis-3.2.1
1 gem installed
[root@mgm ~]# mkdir /root/bin
[root@mgm ~]# tar -zxvf redis-4.0.8.tar.gz
[root@mgm ~]# cp  redis-4.0.8/src/redis-trib.rb   /root/bin/  //拷贝脚本
[root@mgm ~]# 
[root@mgm ~]# chmod  +x /root/bin/redis-trib.rb  //确保脚本有执行权限
[root@mgm ~]#
[root@mgm ~]# redis-trib.rb help  //查看帮助
Usage: redis-trib <command> <options> <arguments ...>
  create          host1:port1 ... hostN:portN
                  --replicas <arg>
  check           host:port
  info            host:port
  fix             host:port
                  --timeout <arg>
  reshard         host:port
                  --from <arg>
                  --to <arg>
                  --slots <arg>
                  --yes
                  --timeout <arg>
                  --pipeline <arg>
  rebalance       host:port
                  --weight <arg>
                  --auto-weights
                  --use-empty-masters
                  --timeout <arg>
                  --simulate
                  --pipeline <arg>
                  --threshold <arg>
  add-node        new_host:new_port existing_host:existing_port
                  --slave
                  --master-id <arg>
  del-node        host:port node_id
  set-timeout     host:port milliseconds
  call            host:port command arg arg .. arg
  import          host:port
                  --from <arg>
                  --copy
                  --replace
  help            (show this help)
For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.
[root@mgm ~]#
```

2）创建集群

```shell
]# redis-trib.rb  create  --replicas  1   \
192.168.4.51:6379    192.168.4.52:6379    192.168.4.53:6379  \  192.168.4.54:6379   192.168.4.55:6379     192.168.4.56:6379
>>> Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.4.51:6379
192.168.4.52:6379
192.168.4.53:6379
Adding replica 192.168.4.56:6379 to 192.168.4.51:6379
Adding replica 192.168.4.55:6379 to 192.168.4.52:6379
Adding replica 192.168.4.54:6379 to 192.168.4.53:6379
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6379
   slots:0-5460 (5461 slots) master
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6379
   slots:5461-10922 (5462 slots) master
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6379
   slots:10923-16383 (5461 slots) master
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6379
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.56:6379
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.55:6379
   replicates 324e05df3f143ef97e50d09be0328a695e655986
Can I set the above configuration? (type 'yes' to accept): yes //同意以上配置
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join...
>>> Performing Cluster Check (using node 192.168.4.51:6379)
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6379
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6379
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6379
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6379
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6379
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.57:6379
   slots: (0 slots) slave
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.  //提示16384个槽分配完毕
[root@mgm ~]#
```

3）查看集群信息

```shell
[root@mgm ~]# redis-trib.rb info 192.168.4.51:6379 //查看集群信息
192.168.4.51:6379 (d9f8fe6d...) -> 0 keys | 5461 slots | 1 slaves.
192.168.4.52:6379 (324e05df...) -> 0 keys | 5462 slots | 1 slaves.
192.168.4.53:6379 (9e44139c...) -> 0 keys | 5461 slots | 1 slaves.
[OK] 0 keys in 3 masters.
keys per slot on average
```

```shell
[root@mgm ~]# redis-trib.rb check 192.168.4.51:6379 //检测集群

\>>> Performing Cluster Check (using node 192.168.4.51:6379)

M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6379

slots:0-5460 (5461 slots) master

1 additional replica(s)

S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6379

slots: (0 slots) slave

replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645

S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.55:6379

slots: (0 slots) slave

replicates 324e05df3f143ef97e50d09be0328a695e655986

M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6379

slots:5461-10922 (5462 slots) master

1 additional replica(s)

M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6379

slots:10923-16383 (5461 slots) master

1 additional replica(s)

S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.56:6379

slots: (0 slots) slave

replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb

[OK] All nodes agree about slots configuration.

\>>> Check for open slots...

\>>> Check slots coverage...

[OK] All 16384 slots covered.
```

4）测试配置（在客户端连接集群中的任意一台服务器存取数据）

```shell
[root@client50 ~]# redis-cli  -c  -h 192.168.4.51 -p 6379 //连接服务器51
192.168.4.51:6379>
192.168.4.51:6379> set x 100  //存储
-> Redirected to slot [16287] located at 192.168.4.53:6379  //提示存储在53主机
OK
192.168.4.53:6379> keys *
1) "x"
192.168.4.53:6379>
192.168.4.53:6379> set y 200
OK
192.168.4.53:6379> keys *
1) "y"
2) "x"
192.168.4.53:6379> set z 300 //存储
-> Redirected to slot [8157] located at 192.168.4.52:6379 //提示存储在52主机
OK
192.168.4.52:6379> keys *  //在52主机查看数据 只有变量z 
1) "z"
192.168.4.52:6379> get x 
-> Redirected to slot [16287] located at 192.168.4.53:6379 //连接53主机获取数据
"100"
192.168.4.53:6379> keys *
1) "y"
2) "x"
192.168.4.53:6379> get z
-> Redirected to slot [8157] located at 192.168.4.52:6379
"300"
192.168.4.52:6379> set i 400
-> Redirected to slot [15759] located at 192.168.4.53:6379
OK
192.168.4.53:6379> set j 500
-> Redirected to slot [3564] located at 192.168.4.51:6379
OK
192.168.4.51:6379>
```

**步骤三：配置网站服务器**

```shell
[root@web33 ~ ]# yum -y install php-devel  //安装依赖
……
……
已安装:
  php-devel.x86_64 0:5.4.16-45.el7                                                                                                                                     
作为依赖被安装:
  autoconf.noarch 0:2.69-11.el7 automake.noarch 0:1.13.4-3.el7 m4.x86_64 0:1.4.16-10.el7 perl-Test-Harness.noarch 0:3.28-3.el7 perl-Thread-Queue.noarch 0:3.02-2.el7
完毕！
[root@web33 ~]#
[root@web33 ~]# tar -zxvf redis-cluster-4.3.0.tgz  //解压
[root@web33 ~]# cd redis-4.3.0/  //进入源码目录
[root@web33 redis-4.3.0]# phpize  //创建configure命令及配置信息文件/usr/bin/php-config
Configuring for:
PHP Api Version:         20100412
Zend Module Api No:      20100525
Zend Extension Api No:   220100525
[root@web33 redis-4.3.0]#
[root@web33 redis-4.3.0]# ./configure --with-php-config=/usr/bin/php-config
……
……
configure: creating ./config.status
config.status: creating config.h
config.status: config.h is unchanged
config.status: executing libtool commands
[root@web33 redis-4.3.0]#
[root@web33 redis-4.3.0]# make  //编译
……
……
Build complete.
Don't forget to run 'make test'.
[root@web33 redis-4.3.0]#
[root@web33 redis-4.3.0]# make install  //安装
Installing shared extensions:     /usr/lib64/php/modules/   //提示模块安装目录
[root@web33 redis-4.3.0]# 
[root@web33 redis-4.3.0]# ls /usr/lib64/php/modules/ //查看目录列表
curl.so  fileinfo.so  json.so  mysqli.so  mysql.so  pdo_mysql.so  pdo.so  pdo_sqlite.so  phar.so  redis.so  sqlite3.so  zip.so
[root@web33 redis-4.3.0]#
```

修改配置文件

```shell
[root@web33 redis-4.3.0]# vim /etc/php.ini
728 extension_dir = "/usr/lib64/php/modules/"   //模块目录
730 extension = "redis.so"   //模块名
:wq
[root@web33 redis-4.3.0]# systemctl  restart php-fpm  //重启php-fpm服务
[root@web33 redis-4.3.0]# php -m   |  grep   -i  redis  //查看模块
redis
[root@web33 redis-4.3.0]#
```

**步骤四：测试配置**

1）在存储服务器共享目录下，创建连接集群PHP脚本

```shell
nfs30~ ]# vim  /sitedir/set_data.php    //存储数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.55:6379','192.168.4.56:6379'];  //定义redis服务器列表
$client = new RedisCluster(NUll,$redis_list); //定义连接redis服务器变量
$client->set("i","tarenaA "); //存储数据 变量名 i
$client->set("j","tarenaB ");  //存储数据 变量名 j
$client->set("k","tarenaC ");  //存储数据 变量名 k 
?>
:wq
nfs30~ ]# vim   /sitedir/get_data.php    //获取数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.55:6379','192.168.4.56:6379']; //定义redis服务器列表
$client = new RedisCluster(NUll,$redis_list); //定义连接redis服务器变量
echo $client->get("i");  //获取变量i 的数据
echo $client->get("j");  //获取变量j 的数据
echo $client->get("k");  //获取变量k 的数据
?>
:wq
nfs30~ ]#  vim   /sitedir/test3.php    //存/取数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.55:6379','192.168.4.56:6379'];
$client = new RedisCluster(NUll,$redis_list);
$client->set(“name“,”panglijing”);  //存数据
echo $client->get(“name”);  //取数据
?>
:wq
```

2）访问网站执行脚本(在任意主机访问网站服务器都可以)

```shell
]# curl  http://192.168.4.33/set_data.php
]# curl  http://192.168.4.33/get_data.php
]# curl  http://192.168.4.33/test3.php
```

3）命令行连接任意一台redis服务器查看数据(在任意主机连接redis服务器都可以)

```shell
]# redis-cli  -c  -h  192.168.4.51  -p  6379 
192.168.4.51:6379> keys  *
1) i
192.168.4.51:6379> exit
]# redis-cli  -c  -h  192.168.4.52  -p  6379
192.168.4.52:6379> keys  *
1) j
192.168.4.52:6379> exit
]# redis-cli  -c  -h  192.168.4.53  -p  6379
192.168.4.52:6379> keys  *
1) k
192.168.4.52:6379> exit
```



# 3. 数据迁移

## 3.1 问题

要求如下：

1. 配置从服务器
2. 配置第1台PXC服务器
3. 配置第2台PXC服务器
4. 配置第3台PXC服务器
5. 公共配置
6. 测试配置

### 3.2 方案

创建3台新的虚拟机，具体配置要求如图-2所示。

![img](https://img-blog.csdnimg.cn/img_convert/8c7c69f687bc96c158b328846be3ad51.png)

图-2

### 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置从服务器(把主机192.168.4.66 配置为192.168.4.11的从服务器)**

1）在192.168.4.66主机安装数据库服务软件并启动mysqld服务

```shell
[root@pxcnode66 ~]# tar -xvf mysql-5.7.17.tar  //解包
./mysql-community-client-5.7.17-1.el7.x86_64.rpm
./mysql-community-common-5.7.17-1.el7.x86_64.rpm
./mysql-community-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-5.7.17-1.el7.x86_64.rpm
./mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
./mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
./mysql-community-server-5.7.17-1.el7.x86_64.rpm
./mysql-community-test-5.7.17-1.el7.x86_64.rpm
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# ls *.rpm  //查看软件列表
mysql-community-client-5.7.17-1.el7.x86_64.rpm
mysql-community-common-5.7.17-1.el7.x86_64.rpm
mysql-community-devel-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm
mysql-community-embedded-devel-5.7.17-1.el7.x86_64.rpm
mysql-community-libs-5.7.17-1.el7.x86_64.rpm
mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm
mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
mysql-community-server-5.7.17-1.el7.x86_64.rpm
mysql-community-test-5.7.17-1.el7.x86_64.rpm
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# yum -y  install mysql-community-*.rpm  //安装软件
已加载插件：fastestmirror
正在检查 mysql-community-client-5.7.17-1.el7.x86_64.rpm: mysql-community-client-5.7.17-1.el7.x86_64
mysql-community-client-5.7.17-1.el7.x86_64.rpm 将被安装
……
……
已安装:
  mysql-community-client.x86_64 0:5.7.17-1.el7                             mysql-community-common.x86_64 0:5.7.17-1.el7
  mysql-community-devel.x86_64 0:5.7.17-1.el7                              mysql-community-embedded.x86_64 0:5.7.17-1.el7
  mysql-community-embedded-compat.x86_64 0:5.7.17-1.el7                    mysql-community-embedded-devel.x86_64 0:5.7.17-1.el7
  mysql-community-libs.x86_64 0:5.7.17-1.el7                               mysql-community-libs-compat.x86_64 0:5.7.17-1.el7
  mysql-community-minimal-debuginfo.x86_64 0:5.7.17-1.el7                  mysql-community-server.x86_64 0:5.7.17-1.el7
  mysql-community-test.x86_64 0:5.7.17-1.el7
作为依赖被安装:
  perl-Data-Dumper.x86_64 0:2.145-3.el7                                      perl-JSON.noarch 0:2.59-2.el7
完毕！
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# systemctl start  mysqld  //启动服务
[root@pxcnode66 ~]# ls /var/lib/mysql  //查看数据库文件列表
auto.cnf    client-cert.pem  ibdata1      ibtmp1      mysql.sock.lock     public_key.pem   sys
ca-key.pem  client-key.pem   ib_logfile0  mysql       performance_schema  server-cert.pem
ca.pem      ib_buffer_pool   ib_logfile1  mysql.sock  private_key.pem     server-key.pem
[root@pxcnode66 ~]# systemctl enable  mysqld  //设置服务开机运行
[root@pxcnode66 ~]# netstat -utnlp  | grep  :3306  //查看端口
tcp6       0      0 :::3306                 :::*                    LISTEN      1531/mysqld
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# grep password  /var/log/mysqld.log //查看初始密码
2019-07-05T01:56:51.895852Z 1 [Note] A temporary password is generated for root@localhost: bB0*uCmu:.Kj
[root@pxcnode66 ~]# mysql -uroot -p'bB0*uCmu:.Kj'  //初始密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.17
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> 
mysql> alter user root@"localhost" identified by "123qqq...A";//修改登录密码
Query OK, 0 rows affected (0.01 sec)
mysql>
mysql> exit //断开连接
Bye
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A  //新密码登录
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.17 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql> show  databases; //查看数据库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
Mysql> 
```

2）修改服务主配置文件

```
[root@pxcnode66 ~]# vim /etc/my.cnf
[mysqld]
server_id=66  //指定server_id
:wq
[root@pxcnode66 ~]# systemctl  restart mysqld  //重启服务
[root@pxcnode66 ~]#
```

3）确保数据一致 （pxcnode66主机 使用mysql11主机的完全备份恢复数据确保数据一致 ）

```shell
[root@mysql11 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm //安装依赖软件
[root@mysql11 ~]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm //安装在线热备软件
[root@mysql11 ~]# innobackupex  --user root --password 123qqq...A  --slave-info  /allbak --no-timestamp //备份所有数据，并记录备份数据对应的binlog日志名
[root@mysql11 ~]# scp -r /allbak  root@192.168.4.66:/root/   //把备份文件发送给pxcnode66主机
[root@pxcnode66 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm  //安装依赖软件
[root@pxcnode66 ~]# yum -y install  percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm //安装在线热备软件
[root@pxcnode66 ~]# systemctl  stop  mysqld //停止服务
[root@pxcnode66 ~]# rm  -rf  /var/lib/mysql/*  //清空数据库目录
[root@pxcnode66 ~]# innobackupex --apply-log /root/allbak/  //准备恢复数据
[root@pxcnode66 ~]# innobackupex --copy-back /root/allbak/  //恢复数据
[root@pxcnode66 ~]# chown -R mysql:mysql /var/lib/mysql //修改所有者
[root@pxcnode66 ~]# systemctl start  mysqld  //启动服务
```

4）指定主服务器

```shell
[root@pxcnode66 ~]# cat /root/allbak/xtrabackup_info  | grep master11 //查binlog日志
binlog_pos = filename 'master11.000001', position '7700'
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A  //管理员登录指定主服务器信息
mysql> change master to  
master_host="192.168.4.11", //主服务器ip地址
master_user="repluser", //主服务器授权用户
master_password="123qqq...A", //授权密码
master_log_file="master11.000001",  //binlog日志名
master_log_pos=7700; //日志偏移量
Query OK, 0 rows affected, 2 warnings (0.31 sec)
mysql> start slave ;  //启动slave 程序
Query OK, 0 rows affected (0.09 sec)
mysql> exit  //断开连接
Bye
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i 192.168.4.11  //查看主服务器地址
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.11 //主服务器ip地址
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i "yes" //查看状态信息
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes  //IO线程正常
            Slave_SQL_Running: Yes  //SQL线程正常
[root@pxcnode66 ~]#
```

**步骤二：配置第1台PXC服务器(192.168.4.66)**

1）停止mysqld服务、卸载mysqld服务软件

```shell
[root@pxcnode66 ~]# systemctl  stop mysqld  //停止服务
[root@pxnode66 ~]# rpm -qa  | grep -i mysql   //查看安装的MySQL服务软件
mysql-community-server-5.7.17-1.el7.x86_64
mysql-community-embedded-compat-5.7.17-1.el7.x86_64
mysql-community-common-5.7.17-1.el7.x86_64
mysql-community-client-5.7.17-1.el7.x86_64
mysql-community-devel-5.7.17-1.el7.x86_64
mysql-community-test-5.7.17-1.el7.x86_64
mysql-community-libs-compat-5.7.17-1.el7.x86_64
mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64
perl-DBD-MySQL-4.023-6.el7.x86_64
mysql-community-libs-5.7.17-1.el7.x86_64
mysql-community-embedded-5.7.17-1.el7.x86_64
mysql-community-embedded-devel-5.7.17-1.el7.x86_64
[root@pxcnode66 ~]# 
[root@pxcnode66 ~]# rpm -e --nodeps mysql-community-server mysql-community-embedded-compat mysql-community-common mysql-community-client mysql-community-devel \
> mysql-community-test mysql-community-libs-compat mysql-community-minimal-debuginfo mysql-community-libs mysql-community-embedded mysql-community-embedded-devel  //卸载所有的MySQL服务软件
警告：/etc/my.cnf 已另存为 /etc/my.cnf.rpmsave
[root@pxcnode66 ~]#
```

2）安装PXC软件、修改配置文件、启动mysql服务

```shell
[root@pxcnode66 ~]# cd PXC  //进软件目录
[root@pxcnode66 PXC]# rpm -ivh qpress-1.1-14.11.x86_64.rpm  //安装依赖
警告：qpress-1.1-14.11.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 6cb7b81f: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:qpress-1.1-14.11                 ################################# [100%]
[root@pxcnode66 PXC]#
[root@pxcnode66 PXC]# tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar  //解压PXC软件包
Percona-XtraDB-Cluster-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-57-debuginfo-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-client-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-devel-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-full-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-garbd-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-server-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-compat-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-test-57-5.7.25-31.35.1.el7.x86_64.rpm
[root@pxcnode66 PXC]#
[root@pxcnode66 PXC]# yum -y  install Percona-XtraDB-Cluster-*.rpm //安装软件
已安装:
  Percona-XtraDB-Cluster-57.x86_64 0:5.7.25-31.35.1.el7                                Percona-XtraDB-Cluster-57-debuginfo.x86_64 0:5.7.25-31.35.1.el7                 
  Percona-XtraDB-Cluster-client-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-devel-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-full-57.x86_64 0:5.7.25-31.35.1.el7                           Percona-XtraDB-Cluster-garbd-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-server-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-shared-57.x86_64 0:5.7.25-31.35.1.el7                    
  Percona-XtraDB-Cluster-shared-compat-57.x86_64 0:5.7.25-31.35.1.el7                  Percona-XtraDB-Cluster-test-57.x86_64 0:5.7.25-31.35.1.el7                      
作为依赖被安装:
  keyutils-libs-devel.x86_64 0:1.5.8-3.el7   krb5-devel.x86_64 0:1.15.1-18.el7     libcom_err-devel.x86_64 0:1.42.9-11.el7   libkadm5.x86_64 0:1.15.1-18.el7         
  libselinux-devel.x86_64 0:2.5-12.el7       libsepol-devel.x86_64 0:2.5-8.1.el7   libverto-devel.x86_64 0:0.2.5-4.el7       openssl-devel.x86_64 1:1.0.2k-12.el7    
  pcre-devel.x86_64 0:8.32-17.el7            perl-Env.noarch 0:1.04-2.el7          perl-Test-Harness.noarch 0:3.28-3.el7     perl-Test-Simple.noarch 0:0.98-243.el7  
  zlib-devel.x86_64 0:1.2.7-17.el7          
完毕！
[root@pxcnode66 PXC]#
[root@pxcnode66 PXC]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf //修改数据库服务配置文件
[mysqld]
server-id=66 //指定server_id
:wq
[root@pxcnode66 PXC]#
[root@pxcnode66 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf //修改集群服务配置文件
wsrep_cluster_address=gcomm://       不需要写ip地址
wsrep_node_address=192.168.4.66   //指定本机Ip地址
wsrep_cluster_name=pxc-cluster  //指定集群名称（另外2台的集群名称要于此相同）
wsrep_node_name=pxcnode66  //指定本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //数据全量同步授权用户及密码
:wq
[root@pxcnode66 PXC]#
[root@pxcnode66 PXC]# systemctl  start mysql  //启动服务
[root@pxcnode66 PXC]# netstat -utnlp  | grep  :3306 //查看MySQL服务端口
tcp6       0      0 :::3306                 :::*                    LISTEN      24482/mysqld        
[root@pxcnode66 PXC]# netstat -utnlp  | grep  :4567  //查看集群通信端口
tcp        0      0 0.0.0.0:4567            0.0.0.0:*               LISTEN      24472/mysqld        
[root@pxcnode66 PXC]# systemctl  enable mysql  //设置服务开机运行
[root@pxcnode66 PXC]#
```

3）数据库管理员登录、用户授权、查看状态信息

```shell
[root@pxcnode66 PXC]# mysql -uroot -p123qqq...A //管理员登录
mysql> grant all on *.* to sstuser@"localhost" identified by "123qqq...A"; //用户授权
Query OK, 0 rows affected, 1 warning (0.10 sec)
mysql> show status like "%wsrep%"; //查看集群状态信息
| wsrep_incoming_addresses         | 192.168.4.66:3306                    |
| wsrep_cluster_weight             | 1                                    |
| wsrep_desync_count               | 0                                    |
| wsrep_evs_delayed                |                                      |
| wsrep_evs_evict_list             |                                      |
| wsrep_evs_repl_latency           | 0/0/0/0/0                            |
| wsrep_evs_state                  | OPERATIONAL                          |
| wsrep_gcomm_uuid                 | 73809cc5-cf00-11e9-aac3-b223959fecdf |
| wsrep_cluster_conf_id            | 1                                    |
| wsrep_cluster_size               | 1                                    |
| wsrep_cluster_state_uuid         | 73848b1a-cf00-11e9-9058-36c1ac1e1359 |
| wsrep_cluster_status             | Primary                              |
| wsrep_connected                  | ON                                   |
| wsrep_local_bf_aborts            | 0                                    |
| wsrep_local_index                | 0                                    |
| wsrep_provider_name              | Galera                               |
| wsrep_provider_vendor            | Codership Oy <info@codership.com>    |
| wsrep_provider_version           | 3.35(rddf9876)                       |
| wsrep_ready                      | ON                                   |
+----------------------------------+--------------------------------------+
71 rows in set (0.00 sec)
mysql> exit ;
[root@pxcnode66 ~]#
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i "yes" //查看状态信息依然是192.168.4.11的从服务器
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes  //IO线程正常
            Slave_SQL_Running: Yes  //SQL线程正常
[root@pxcnode66 ~]#
```

**步骤三：配置第2台PXC服务器(192.168.4.10)**

1）安装PXC软件

```shell
[root@pxcnode10 ~]# cd PXC  //进软件目录
[root@pxcnode10 PXC]# rpm -ivh qpress-1.1-14.11.x86_64.rpm  //安装依赖
警告：qpress-1.1-14.11.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 6cb7b81f: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:qpress-1.1-14.11                 ################################# [100%]
[root@pxcnode10 PXC]#
[root@pxcnode10 PXC]# tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar  //解压PXC软件包
Percona-XtraDB-Cluster-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-57-debuginfo-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-client-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-devel-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-full-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-garbd-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-server-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-compat-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-test-57-5.7.25-31.35.1.el7.x86_64.rpm
[root@pxcnode10 PXC]#
[root@pxcnode10 PXC]# yum -y  install Percona-XtraDB-Cluster-*.rpm //安装软件
已安装:
  Percona-XtraDB-Cluster-57.x86_64 0:5.7.25-31.35.1.el7                                Percona-XtraDB-Cluster-57-debuginfo.x86_64 0:5.7.25-31.35.1.el7                 
  Percona-XtraDB-Cluster-client-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-devel-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-full-57.x86_64 0:5.7.25-31.35.1.el7                           Percona-XtraDB-Cluster-garbd-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-server-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-shared-57.x86_64 0:5.7.25-31.35.1.el7                    
  Percona-XtraDB-Cluster-shared-compat-57.x86_64 0:5.7.25-31.35.1.el7                  Percona-XtraDB-Cluster-test-57.x86_64 0:5.7.25-31.35.1.el7                      
作为依赖被安装:
  keyutils-libs-devel.x86_64 0:1.5.8-3.el7   krb5-devel.x86_64 0:1.15.1-18.el7     libcom_err-devel.x86_64 0:1.42.9-11.el7   libkadm5.x86_64 0:1.15.1-18.el7         
  libselinux-devel.x86_64 0:2.5-12.el7       libsepol-devel.x86_64 0:2.5-8.1.el7   libverto-devel.x86_64 0:0.2.5-4.el7       openssl-devel.x86_64 1:1.0.2k-12.el7    
  pcre-devel.x86_64 0:8.32-17.el7            perl-Env.noarch 0:1.04-2.el7          perl-Test-Harness.noarch 0:3.28-3.el7     perl-Test-Simple.noarch 0:0.98-243.el7  
  zlib-devel.x86_64 0:1.2.7-17.el7          
完毕！
[root@pxcnode10 PXC]#
```

2）修改配置文件

```shell
[root@pxcnode10 PXC]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf //修改数据库服务配置
[mysqld]
server-id=10 //指定server_id
:wq
[root@pxcnode10 PXC]#
[root@pxcnode10 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf //修改集群服务配置文件
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.10       //集群成员列表
wsrep_node_address=192.168.4.10   //指定本机Ip地址
wsrep_cluster_name=pxc-cluster  //指定集群名称（另外2台的集群名称要于此相同）
wsrep_node_name=pxcnode10  //指定本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //数据全量同步授权用户及密码
:wq
[root@pxcnode10 PXC]#
```

3）启动mysql服务

```shell
[root@pxcnode10 PXC]# systemctl  start mysql  //启动服务
[root@pxcnode10 PXC]# systemctl  enable mysql  //服务开机运行
[root@pxcnode10 PXC]# netstat -utnlp  | grep  :3306 //查看MySQL服务端口
tcp6       0      0 :::3306                 :::*                    LISTEN      24482/mysqld  
[root@pxcnode10 PXC]# netstat -utnlp  | grep  :4567 //查看集群端口
tcp6       0      0 :::4567                 :::*                    LISTEN      24489/mysqld 
[root@pxcnode10 PXC]#
mysql> show status like "%wsrep%"; //查看集群状态信息
| wsrep_incoming_addresses         | 192.168.4.66:3306，192.168.4.10:3306|
| wsrep_cluster_weight             | 1                                    |
| wsrep_desync_count               | 0                                    |
| wsrep_evs_delayed                |                                      |
| wsrep_evs_evict_list             |                                      |
| wsrep_evs_repl_latency           | 0/0/0/0/0                            |
| wsrep_evs_state                  | OPERATIONAL                          |
| wsrep_gcomm_uuid                 | 73809cc5-cf00-11e9-aac3-b223959fecdf |
| wsrep_cluster_conf_id            | 1                                    |
| wsrep_cluster_size               | 1                                    |
| wsrep_cluster_state_uuid         | 73848b1a-cf00-11e9-9058-36c1ac1e1359 |
| wsrep_cluster_status             | Primary                              |
| wsrep_connected                  | ON                                   |
| wsrep_local_bf_aborts            | 0                                    |
| wsrep_local_index                | 0                                    |
| wsrep_provider_name              | Galera                               |
| wsrep_provider_vendor            | Codership Oy <info@codership.com>    |
| wsrep_provider_version           | 3.35(rddf9876)                       |
| wsrep_ready                      | ON                                   |
+----------------------------------+--------------------------------------+
71 rows in set (0.00 sec)
mysql> exit ;
    [root@pxcnode10 ~]#
```

**步骤四：配置第3台PXC服务器(192.168.4.88)**

1）安装PXC软件

```shell
[root@pxcnode88 ~]# cd PXC  //进软件目录
[root@pxcnode88 PXC]# rpm -ivh qpress-1.1-14.11.x86_64.rpm  //安装依赖
警告：qpress-1.1-14.11.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 6cb7b81f: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:qpress-1.1-14.11                 ################################# [100%]
[root@pxcnode88 PXC]#
[root@pxcnode88 PXC]# tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar  //解压PXC软件包
Percona-XtraDB-Cluster-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-57-debuginfo-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-client-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-devel-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-full-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-garbd-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-server-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-shared-compat-57-5.7.25-31.35.1.el7.x86_64.rpm
Percona-XtraDB-Cluster-test-57-5.7.25-31.35.1.el7.x86_64.rpm
[root@pxcnode88 PXC]#
[root@pxcnode88 PXC]# yum -y  install Percona-XtraDB-Cluster-*.rpm //安装软件
已安装:
  Percona-XtraDB-Cluster-57.x86_64 0:5.7.25-31.35.1.el7                                Percona-XtraDB-Cluster-57-debuginfo.x86_64 0:5.7.25-31.35.1.el7                 
  Percona-XtraDB-Cluster-client-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-devel-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-full-57.x86_64 0:5.7.25-31.35.1.el7                           Percona-XtraDB-Cluster-garbd-57.x86_64 0:5.7.25-31.35.1.el7                     
  Percona-XtraDB-Cluster-server-57.x86_64 0:5.7.25-31.35.1.el7                         Percona-XtraDB-Cluster-shared-57.x86_64 0:5.7.25-31.35.1.el7                    
  Percona-XtraDB-Cluster-shared-compat-57.x86_64 0:5.7.25-31.35.1.el7                  Percona-XtraDB-Cluster-test-57.x86_64 0:5.7.25-31.35.1.el7                      
作为依赖被安装:
  keyutils-libs-devel.x86_64 0:1.5.8-3.el7   krb5-devel.x86_64 0:1.15.1-18.el7     libcom_err-devel.x86_64 0:1.42.9-11.el7   libkadm5.x86_64 0:1.15.1-18.el7         
  libselinux-devel.x86_64 0:2.5-12.el7       libsepol-devel.x86_64 0:2.5-8.1.el7   libverto-devel.x86_64 0:0.2.5-4.el7       openssl-devel.x86_64 1:1.0.2k-12.el7    
  pcre-devel.x86_64 0:8.32-17.el7            perl-Env.noarch 0:1.04-2.el7          perl-Test-Harness.noarch 0:3.28-3.el7     perl-Test-Simple.noarch 0:0.98-243.el7  
  zlib-devel.x86_64 0:1.2.7-17.el7          
完毕！
[root@pxcnode88 PXC]#
```

2）修改配置文件

```shell
[root@pxcnode88 PXC]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf //修改数据库服务配置
[mysqld]
server-id=88 //指定server_id
:wq
[root@pxcnode88 PXC]#
[root@pxcnode88 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf //修改集群服务配置文件
wsrep_cluster_address=gcomm://192.168.4.66       //集群成员ip地址
wsrep_node_address=192.168.4.88   //指定本机Ip地址
wsrep_cluster_name=pxc-cluster  //指定集群名称（另外2台的集群名称要于此相同）
wsrep_node_name=pxcnode88  //指定本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //数据全量同步授权用户及密码
:wq
[root@pxcnode88 PXC]#
```

3）启动mysql服务

```shell
[root@pxcnode88 PXC]# systemctl  start mysql  //启动服务
[root@pxcnode88 PXC]# systemctl  enable mysql  //服务开机运行
[root@pxcnode88 PXC]# netstat -utnlp  | grep  :3306 //查看MySQL服务端口
tcp6       0      0 :::3306                 :::*                    LISTEN      24472/mysqld  
[root@pxcnode88 PXC]# netstat -utnlp  | grep  :4567 //查看集群端口
tcp6       0      0 :::4567                 :::*                    LISTEN      24486/mysqld 
[root@pxcnode88 PXC]#
```

**步骤五：公共配置(192.168.4.88、192.168.4.10、192.168.4.66)**

1）修改192.168.4.88主机的集群配置文件

```shell
[root@pxcnode88 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf  
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.10,192.168.4.88 //指定集群成员列表
:wq
[root@pxcnode88 ~]#
```

2）修改192.168.4.10主机的集群配置文件

```shell
[root@pxcnode10 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf  
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.88,192.168.4.10 //指定集群成员列表
:wq
[root@pxcnode10 ~]#
```

3）修改192.168.4.66主机的集群配置文件

```shell
[root@pxcnode66 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf  
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.88,192.168.4.10 //指定集群成员列表
:wq
[root@pxcnode66 ~]#
```

**步骤6：测试配置:在网站服务器连接PXC集群主机存取数据：**

1）存储数据：在网站服务器连接PXC集群主机存储数据

```shell
[root@web33 ~]# mysql  -h192.168.4.66  -uyaya99  -p123qqq…A  gamedb
Mysql> insert  into  gamedb.user values (“pljA”);
Mysql> exit ;
[root@web33 ~]# mysql  -h192.168.4.10  -uyaya99  -p123qqq…A  gamedb
Mysql> insert  into  gamedb.user values (“pljB”);
Mysql> exit ;
[root@web33 ~]# mysql  -h192.168.4.88  -uyaya99  -p123qqq…A  gamedb
Mysql> insert  into  gamedb.user values (“pljC”);
Mysql> exit ;
```

2）查询数据：在网站服务器连接PXC集群主机查询数据

```shell
[root@web44 ~]# mysql  -h192.168.4.66  -uyaya99  -p123qqq…A  gamedb
Mysql> select  *  from   gamedb.user;
+------+
|  name|
+------+
|  pljA|
|  pljB|
|  pljC|
+------+
Mysql> exit ;
[root@web44 ~]# mysql  -h192.168.4.10  -uyaya99  -p123qqq…A  gamedb
Mysql> select  *  from   gamedb.user;
+------+
|  name|
+------+
|  pljA|
|  pljB|
|  pljC|
+------+
Mysql> exit ;Mysql> exit ;
[root@web44 ~]# mysql  -h192.168.4.88  -uyaya99  -p123qqq…A  gamedb
Mysql> select  *  from   gamedb.user;
+------+
|  name|
+------+
|  pljA|
|  pljB|
|  pljC|
+------+
Mysql> exit ;Mysql> exit ;
```



# 4. 部署LB集群

## 4.1 问题

配置步骤如下：

1. 安装软件
2. 修改配置文件
3. 启动服务
4. 测试配置

### 4.2 方案

拓扑结构如图-3所示。创建1台新的虚拟机，配置ip地址 eth0 192.168.4.99 主机名 haproxy99 ；运行haproxy服务 接受客户端访问数据库的连接请求，把请求平均分发给3台PXC集群主机。

![img](https://img-blog.csdnimg.cn/img_convert/a0f9a269d2a832e5e5a904455614eaf5.png)

图-3

### 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装软件: 在haproxy99主机上安装haproxy软件**

```shell
[root@haproxy99 ~]# yum -y install haproxy
    ……
Running transaction
  正在安装    : haproxy-1.5.18-7.el7.x86_64                                                                          1/1 
  验证中      : haproxy-1.5.18-7.el7.x86_64                                                                          1/1 
已安装:
  haproxy.x86_64 0:1.5.18-7.el7                                                                                          
完毕！
[root@haproxy99 ~]#
```

**步骤二：修改配置文件**

```shell
[root@haproxy99 ~]# vim  /etc/haproxy/haproxy.cfg
Global   //全局配置默认即可
    log         127.0.0.1 local2
    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon
    stats socket /var/lib/haproxy/stats
defaults //默认配置(不需要修改)
    mode                    http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8
    option                  redispatch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000
listen status  //定义监控页面
        mode http   //模式为http
        bind *:80   //端口80
        stats enable //启用配置
        stats uri /admin  //访问目录名
        stats auth admin:admin  //登录用户与密码
listen mysql_3306 *:3306 //定义haproxy服务名称与端口号
    mode    tcp        //mysql服务 得使用 tcp 协议
    option  tcpka      //使用长连接
    balance roundrobin //调度算法
    server  mysql_01 192.168.4.66:3306 check  //第1台数据库服务器
    server  mysql_02 192.168.4.10:3306 check  //第2台数据库服务器
    server  mysql_03 192.168.4.88:3306 check  //第3台数据库服务器
:wq
[root@haproxy99 haproxy]#                    
```

**步骤三：启动服务**

```shell
[root@haproxy99 ~]# systemctl  start haproxy //启动服务
[root@haproxy99 ~]# systemctl  enable haproxy  //开机运行
Created symlink from /etc/systemd/system/multi-user.target.wants/haproxy.service to /usr/lib/systemd/system/haproxy.service.
[root@haproxy99 ~]# netstat -utnlp  | grep  :3306  //查看端口
tcp6       0      0 :::3306                 :::*                    LISTEN      29768/haproxy        
[root@haproxy99 ~]#
```

**步骤四：测试配置：在网站服务器连接haproxy99主机访问数据**

```shell
[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq…A -e  'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode66  |   //第1次连接
+------------+
[root@web33 ~]#
[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq…A -e  'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode10  |   //第2次连接
+------------+
[root@web33 ~]#
[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq…A -e  'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode88  |   //第3次连接
+------------+
[root@web33 ~]#
```



# 5 案例5：部署HA集群

## 5.1 问题

具体配置如下：

1. 准备备用调度器主机
2. 安装软件
3. 修改配置文件
4. 启动服务
5. 测试配置

### 5.2 方案

拓扑结构如图-4所示。创建1台新的虚拟机，在eth0 接口配置ip地址为192.168.4.98做备用调度器。

![img](https://img-blog.csdnimg.cn/img_convert/578af96a0015a9a43933cd98f066d478.png)

图-4

### 5.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备备用调度器主机**

```shell
[root@haproxy98 ~]# yum -y  install haproxy
正在安装    : haproxy-1.5.18-7.el7.x86_64                                                                          1/1 
  验证中      : haproxy-1.5.18-7.el7.x86_64                                                                          1/1 
已安装:
  haproxy.x86_64 0:1.5.18-7.el7                                                                                          
完毕！
[root@haproxy98 ~]#
```

2）修改haproxy98主机haproxy.conf文件（直接拷贝haproxy99主机的配置文件也可以）

```shell
[root@haproxy98 ~]# scp  root@192.168.4.99:/etc/haproxy/haproxy.cfg /etc/haproxy/
Warning: Permanently added '192.168.4.99' (ECDSA) to the list of known hosts.
root@192.168.4.99's password: //输入haproxy99主机的密码
haproxy.cfg                                                                            100% 3142     6.0MB/s   00:00    
[root@haproxy98 ~]#
```

3）启动haproxy服务

```shell
[root@haproxy98 ~]# systemctl  start  haproxy  //启动服务
[root@haproxy98 ~]# systemctl  enable  haproxy  //服务开机运行
Created symlink from /etc/systemd/system/multi-user.target.wants/haproxy.service to /usr/lib/systemd/system/haproxy.service.
[root@haproxy98 ~]# netstat -utnlp  | grep  :3306  //查看端口
tcp6       0      0 :::3306                 :::*                    LISTEN      29768/haproxy
```

**步骤二：安装软件**

1）在haproxy99主机安装keepalived软件

```shell
[root@haproxy99 ~]# yum -y  install keepalived.x86_64
已安装:
  keepalived.x86_64 0:1.3.5-6.el7                                                                                        
作为依赖被安装:
  lm_sensors-libs.x86_64 0:3.4.0-4.20160601gitf9185e5.el7            net-snmp-agent-libs.x86_64 1:5.7.2-32.el7           
  net-snmp-libs.x86_64 1:5.7.2-32.el7                               
[root@haproxy99 ~]#
```

2）在haproxy98主机安装keepalived软件

```shell
[root@haproxy98 ~]# yum -y  install keepalived.x86_64
已安装:
  keepalived.x86_64 0:1.3.5-6.el7                                                                                        
作为依赖被安装:
  lm_sensors-libs.x86_64 0:3.4.0-4.20160601gitf9185e5.el7            net-snmp-agent-libs.x86_64 1:5.7.2-32.el7           
  net-snmp-libs.x86_64 1:5.7.2-32.el7                               
[root@haproxy98 ~]#
完毕！
[root@haproxy98 ~]#
```

**步骤三：修改配置文件**

1）修改haproxy99主机的配置文件

```shell
[root@haproxy99 ~]# sed -i  '36,$d' /etc/keepalived/keepalived.conf  //删除无关的配置行
[root@haproxy99 ~]#vim  /etc/keepalived/keepalived.conf
global_defs {
……
……
vrrp_iptables   //禁止iptables 
}
vrrp_instance VI_1 {
    state MASTER   //主服务器标识
    interface eth0
    virtual_router_id 51
    priority 150      //haproxy99 主机做主服务器，优先级要比 haproxy88主机高
    advert_int 1
    authentication {
        auth_type PASS  //主备服务器连接方式
        auth_pass 1111   //连接密码
    }
    virtual_ipaddress {
        192.168.4.100   //定义vip地址
    }
}
[root@haproxy99 ~]# scp  /etc/keepalived/keepalived.conf  root@192.168.4.98: /etc/keepalived/
root@192.168.4.98's password:  //输入haproxy98主机的密码
```

2）修改haproxy98主机的配置文件

```shell
[root@haproxy98 ~]#vim  /etc/keepalived/keepalived.conf
global_defs {
……
……
vrrp_iptables   //禁止iptables 
}
vrrp_instance VI_1 {
    state BACKUP   //备用服务器标识
    interface eth0
    virtual_router_id 51
    priority 100      //优先级要比 haproxy99低
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.4.100   //定义vip地址
    }
}
[root@haproxy98 ~]#
```

**步骤四：启动服务**

1）在haproxy99主机启动keepalived服务

```shell
[root@haproxy99 ~]# systemctl  start keepalived.service //启动服务
[root@haproxy99 ~]# 
[root@haproxy99 ~]# ip addr show | grep   192.168.4.100  //查看vip地址
    inet 192.168.4.100/32 scope global eth0
[root@haproxy99 ~]#
```

2）在haproxy98主机启动keepalived服务

```shell
[root@haproxy98 ~]# systemctl  start keepalived.service //启动服务
[root@haproxy98 ~]# 
[root@haproxy98 ~]# ip addr show  | grep   192.168.4.100 //查看不到vip 
[root@haproxy98 ~]#
```

**步骤五：测试配置**

1）客户端连接vip地址，访问数据库服务

```shell
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode66  |
+------------+
[root@web33 ~]# 
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode10  |
+------------+
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode88  |
+------------+
[root@web33 ~]#
```

2）测试高可用

```shell
[root@haproxy99 ~]# ip addr  show  | grep 192.168.4.100  //在haproxy99 主机查看VIP地址
    inet 192.168.4.100/32 scope global eth0
[root@haproxy99 ~]# 
[root@haproxy99 ~]# systemctl  stop keepalived.service //停止keepalived服务 
[root@haproxy99 ~]# 
[root@haproxy99 ~]# 
[root@haproxy99 ~]# ip addr  show  | grep 192.168.4.100  //查看不到vip地址
[root@haproxy99 ~]#
[root@haproxy98 ~]# ip addr show  | grep  192.168.4.100 //在备用的haproxy98主机查看地址
    inet 192.168.4.100/32 scope global eth0
[root@haproxy98 ~]#
//客户端连接vip地址访问数据库服务
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode66  |
+------------+
[root@web33 ~]# 
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode10  |
+------------+
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq…A -e 'select @@hostname'
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+
| @@hostname |
+------------+
| pxcnode88  |
+------------+
[root@web33 ~]#
```

> 如有侵权，请联系作者删除



@[TOC]( User authorization & full backup, incremental backup | Cloud computing )

---

# 1. 常用函数

## 1.1 问题

- 练习字符函数
- 练习数学函数
- 练习日期函数
- 练习聚集函数
- 练习数学函数
- 练习if函数
- 练习case函数

## 1.2 步骤

在主机192.168.4.50主机用tarena库下的表，做如下练习。
练习的表结构说明如图-1、图-2、图-3所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4c7ce0e93a048709de9d3ef014fbe54.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

![在这里插入图片描述](https://img-blog.csdnimg.cn/7bd92de24091461988c45b4eb5d3e92d.png)
图-2

![在这里插入图片描述](https://img-blog.csdnimg.cn/3d4fe5c1dac84313ac1acdf06ef5f770.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

**步骤一：练习字符函数**
LENGTH(str)：返字符串长度，以字节为单位

```sql
mysql> select length('abc');+---------------+| length('abc') |+---------------+|             3 |+---------------+1 row in set (0.00 sec)​​mysql> select length('你好');+------------------+| length('你好')   |+------------------+|                6 |+------------------+1 row in set (0.00 sec)​​mysql> select name, email, length(email) from employees where name='李平';+--------+----------------+---------------+| name   | email          | length(email) |+--------+----------------+---------------+| 李平   | liping@tedu.cn |            14 |+--------+----------------+---------------+1 row in set (0.00 sec)
```

CHAR_LENGTH(str): 返回字符串长度，以字符为单位

```sql
mysql> select char_length('abc');+--------------------+| char_length('abc') |+--------------------+|                  3 |+--------------------+1 row in set (0.00 sec)​​mysql> select char_length('你好');+-----------------------+| char_length('你好')   |+-----------------------+|                     2 |+-----------------------+1 row in set (0.00 sec)
```

CONCAT(s1,s2，...): 返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL

```sql
# 拼接字符串mysql> select concat(dept_id, '-', dept_name) from departments;+---------------------------------+| concat(dept_id, '-', dept_name) |+---------------------------------+| 1-人事部                        || 2-财务部                        || 3-运维部                        || 4-开发部                        || 5-测试部                        || 6-市场部                        || 7-销售部                        || 8-法务部                        |+---------------------------------+8 rows in set (0.00 sec)
```

UPPER(str)和UCASE(str): 将字符串中的字母全部转换成大写

```sql
mysql> select name, upper(email) from employees where name like '李%';+-----------+----------------------+| name      | upper(email)         |+-----------+----------------------+| 李玉英    | LIYUYING@TEDU.CN     || 李平      | LIPING@TEDU.CN       || 李建华    | LIJIANHUA@TARENA.COM || 李莹      | LIYING@TEDU.CN       || 李柳      | LILIU@TARENA.COM     || 李慧      | LIHUI@TARENA.COM     || 李静      | LIJING@TARENA.COM    || 李瑞      | LIRUI@TARENA.COM     |+-----------+----------------------+8 rows in set (0.00 sec)
```

LOWER(str)和LCASE(str):将str中的字母全部转换成小写

```sql
# 转小写mysql> select lower('HelloWorld');+---------------------+| lower('HelloWorld') |+---------------------+| helloworld          |+---------------------+1 row in set (0.00 sec)
```

SUBSTR(s, start, length): 从子符串s的start位置开始，取出length长度的子串，位置从1开始计算

```sql
mysql> select substr('hello world', 7);+--------------------------+| substr('hello world', 7) |+--------------------------+| world                    |+--------------------------+1 row in set (0.00 sec)​​# 取子串，下标从7开始取出3个mysql> select substr('hello world', 7, 3);+-----------------------------+| substr('hello world', 7, 3) |+-----------------------------+| wor                         |+-----------------------------+1 row in set (0.00 sec)
```

INSTR(str,str1)：返回str1参数，在str参数内的位置

```sql
# 子串在字符串中的位置mysql> select instr('hello world', 'or');+----------------------------+| instr('hello world', 'or') |+----------------------------+|                          8 |+----------------------------+1 row in set (0.00 sec)​​mysql> select instr('hello world', 'ol');+----------------------------+| instr('hello world', 'ol') |+----------------------------+|                          0 |+----------------------------+1 row in set (0.00 sec)
```

TRIM(s): 返回字符串s删除了两边空格之后的字符串

```sql
mysql> select trim('  hello world.  ');+--------------------------+| trim('  hello world.  ') |+--------------------------+| hello world.             |+--------------------------+1 row in set (0.00 sec)
```

**步骤二：练习数学函数**
ABS(x)：返回x的绝对值

```sql
mysql> select abs(-10);+----------+| abs(-10) |+----------+|       10 |+----------+1 row in set (0.00 sec)
```

PI(): 返回圆周率π，默认显示6位小数

```sql
mysql> select pi();+----------+| pi()     |+----------+| 3.141593 |+----------+1 row in set (0.00 sec)
```

MOD(x,y): 返回x被y除后的余数

```sql
mysql> select mod(10, 3);+------------+| mod(10, 3) |+------------+|          1 |+------------+1 row in set (0.00 sec)
```

CEIL(x)、CEILING(x): 返回不小于x的最小整数

```sql
mysql> select ceil(10.1);+------------+| ceil(10.1) |+------------+|         11 |+------------+1 row in set (0.00 sec)
```

FLOOR(x): 返回不大于x的最大整数

```sql
mysql> select floor(10.9);+-------------+| floor(10.9) |+-------------+|          10 |+-------------+1 row in set (0.00 sec)
```

ROUND(x)、ROUND(x,y): 前者返回最接近于x的整数，即对x进行四舍五入；后者返回最接近x的数，其值保留到小数点后面y位，若y为负值，则将保留到x到小数点左边y位

```sql
mysql> select round(10.6666);+----------------+| round(10.6666) |+----------------+|             11 |+----------------+1 row in set (0.00 sec)mysql> select round(10.6666, 2);+-------------------+| round(10.6666, 2) |+-------------------+|             10.67 |+-------------------+1 row in set (0.00 sec)
```

**步骤三：练习日期函数**
CURDATE()、CURRENT_DATE(): 将当前日期按照"YYYY-MM-DD"或者"YYYYMMDD"格式的值返回，具体格式根据函数用在字符串或是数字语境中而定

```sql
mysql> select curdate();+------------+| curdate()  |+------------+| 2021-03-09 |+------------+1 row in set (0.00 sec)mysql> select curdate() + 0;+---------------+| curdate() + 0 |+---------------+|      20210309 |+---------------+1 row in set (0.00 sec)
```

NOW(): 返回当前日期和时间值，格式为"YYYY_MM-DD HH:MM:SS"或"YYYYMMDDHHMMSS"，具体格式根据函数用在字符串或数字语境中而定

```sql
mysql> select now();+---------------------+| now()               |+---------------------+| 2021-03-09 02:28:26 |+---------------------+1 row in set (0.00 sec)mysql> select now() + 0;+----------------+| now() + 0      |+----------------+| 20210309022848 |+----------------+1 row in set (0.00 sec)
```

MONTH(date)和MONTHNAME(date):前者返回指定日期中的月份，后者返回指定日期中的月份的名称

```sql
mysql> select month('20211001120000');+-------------------------+| month('20211001120000') |+-------------------------+|                      10 |+-------------------------+1 row in set (0.00 sec)mysql> select monthname('20211001120000');+-----------------------------+| monthname('20211001120000') |+-----------------------------+| October                     |+-----------------------------+1 row in set (0.00 sec)
```

DAYNAME(d)、DAYOFWEEK(d)、WEEKDAY(d): DAYNAME(d)返回d对应的工作日的英文名称，如Sunday、Monday等；DAYOFWEEK(d)返回的对应一周中的索引，1表示周日、2表示周一；WEEKDAY(d)表示d对应的工作日索引，0表示周一，1表示周二

```sql
mysql> select dayname('20211001120000');+---------------------------+| dayname('20211001120000') |+---------------------------+| Friday                    |+---------------------------+1 row in set (0.00 sec)mysql> select dayname('20211001');+---------------------+| dayname('20211001') |+---------------------+| Friday              |+---------------------+1 row in set (0.00 sec)
```

WEEK(d): 计算日期d是一年中的第几周

```sql
mysql> select week('20211001');+------------------+| week('20211001') |+------------------+|               39 |+------------------+1 row in set (0.00 sec)
```

DAYOFYEAR(d)、DAYOFMONTH(d)： 前者返回d是一年中的第几天，后者返回d是一月中的第几天

```sql
mysql> select dayofyear('20211001');+-----------------------+| dayofyear('20211001') |+-----------------------+|                   274 |+-----------------------+1 row in set (0.00 sec)
```

YEAR(date)、QUARTER(date)、MINUTE(time)、SECOND(time): YEAR(date)返回指定日期对应的年份，范围是1970到2069；QUARTER(date)返回date对应一年中的季度，范围是1到4；MINUTE(time)返回time对应的分钟数，范围是0~59；SECOND(time)返回制定时间的秒值

```sql
mysql> select year('20211001');+------------------+| year('20211001') |+------------------+|             2021 |+------------------+1 row in set (0.00 sec)mysql> select quarter('20211001');+---------------------+| quarter('20211001') |+---------------------+|                   4 |+---------------------+1 row in set (0.00 sec)
```

**步骤四：练习聚集函数**
sum() ：求和

```sql
mysql> select employee_id, sum(basic+bonus) from salary where employee_id=10 and year(date)=2018;+-------------+------------------+| employee_id | sum(basic+bonus) |+-------------+------------------+|          10 |           116389 |+-------------+------------------+1 row in set (0.00 sec)
```

avg() ：求平均值

```sql
mysql> select employee_id, avg(basic+bonus) from salary where employee_id=10 and year(date)=2018;+-------------+------------------+| employee_id | avg(basic+bonus) |+-------------+------------------+|          10 |       29097.2500 |+-------------+------------------+1 row in set (0.00 sec)
```

max() ：求最大值

```sql
mysql> select employee_id, max(basic+bonus) from salary where employee_id=10 and year(date)=2018;+-------------+------------------+| employee_id | max(basic+bonus) |+-------------+------------------+|          10 |            31837 |+-------------+------------------+1 row in set (0.00 sec)
```

min() ：求最小值

```sql
mysql> select employee_id, min(basic+bonus) from salary where employee_id=10 and year(date)=2018;+-------------+------------------+| employee_id | min(basic+bonus) |+-------------+------------------+|          10 |            24837 |+-------------+------------------+1 row in set (0.00 sec)
```

count() ：计算个数

```sql
mysql> select count(*) from departments;+----------+| count(*) |+----------+|        9 |+----------+1 row in set (0.00 sec)
```

**步骤五：练习数学计算**

加法计算： 给user表里前5行用户对uid 号分别 加1

```sql
//修改前查看
mysql> select id , name , uid from tarena.user where id <= 5 ;
+----+--------+------+
| id | name   | uid  |
+----+--------+------+
|  1 | root   |    0 |
|  2 | bin    |    1 |
|  3 | daemon |    2 |
|  4 | adm    |    3 |
|  5 | lp     |    4 |
+----+--------+------+
5 rows in set (0.00 sec)
//修改
mysql> update tarena.user set uid = uid +1  where id <= 5;
Query OK, 5 rows affected (0.03 sec)
Rows matched: 5  Changed: 5  Warnings: 0
mysql> 
//修改后查看
mysql> select id , name , uid from tarena.user where id <= 5 ;
+----+--------+------+
| id | name   | uid  |
+----+--------+------+
|  1 | root   |    1 |
|  2 | bin    |    2 |
|  3 | daemon |    3 |
|  4 | adm    |    4 |
|  5 | lp     |    5 |
+----+--------+------+
5 rows in set (0.00 sec)
mysql> 
```

减法计算：把编号8的员工 2020年12 月的减去500

```sql
//修改前查看
mysql> select employee_id , bonus  from  tarena.salary where employee_id =8 and year(date)=2020 and month(date)=12;
+-------------+-------+
| employee_id | bonus |
+-------------+-------+
|           8 |  2000 |
+-------------+-------+
1 row in set (0.00 sec)
mysql> 
//修改
mysql> update tarena.salary set bonus = bonus - 500  where employee_id =8 and year(date)=2020 and month(date)=12;
Query OK, 1 row affected (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//修改后查看
mysql> select employee_id , bonus  from  tarena.salary where employee_id =8 and year(date)=2020 and month(date)=12;
+-------------+-------+
| employee_id | bonus |
+-------------+-------+
|           8 |  1500 |
+-------------+-------+
1 row in set (0.00 sec)
```

乘法计算: 把编号8的员工 2020年12 月的工资改为源工资的5倍

```sql
//修改前查看
mysql> select employee_id , basic  from  tarena.salary where employee_id =8 and year(date)=2020 and month(date)=12;
+-------------+-------+
| employee_id | basic |
+-------------+-------+
|           8 | 25459 |
+-------------+-------+
1 row in set (0.00 sec)
mysql>
//修改
mysql> update tarena.salary set basic=basic*5 where employee_id =8 and year(date)=2020 and month(date)=12;
Query OK, 1 row affected (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 0
//修改后查看
mysql> select employee_id , basic  from  tarena.salary where employee_id =8 and year(date)=2020 and month(date)=12;
+-------------+--------+
| employee_id | basic  |
+-------------+--------+
|           8 | 127295 |
+-------------+--------+
1 row in set (0.00 sec)
mysql> 
```

除法计算：查看平均工资

```sql
mysql> select employee_id , basic , bonus , (basic+bonus)/2  As 平均工资 from  tarena.salary where employee_id =8 and year(date)=2020 and month(date)=8;
+-------------+-------+-------+--------------+
| employee_id | basic | bonus | 平均工资     |
+-------------+-------+-------+--------------+
|           8 | 24247 |  4000 |   14123.5000 |
+-------------+-------+-------+--------------+
1 row in set (0.00 sec)
```

取余计算：显示偶数行

```sql
mysql> select  * from tarena.user where id % 2  =  0 ;
+----+-----------------+----------+-------+-------+----------------------------+--------------------+---------------+
| id | name            | password | uid   | gid   | comment                    | homedir            | shell         |
+----+-----------------+----------+-------+-------+----------------------------+--------------------+---------------+
|  2 | bin             | x        |     1 |     1 | bin                        | /bin               | /sbin/nologin |
|  4 | adm             | x        |     3 |     4 | adm                        | /var/adm           | /sbin/nologin |
|  6 | sync            | x        |     5 |     0 | sync                       | /sbin              | /bin/sync     |
|  8 | halt            | x        |     7 |     0 | halt                       | /sbin              | /sbin/halt    |
| 10 | operator        | x        |    11 |     0 | operator                   | /root              | /sbin/nologin |
| 12 | ftp             | x        |    14 |    50 | FTP User                   | /var/ftp           | /sbin/nologin |
| 14 | systemd-network | x        |   192 |   192 | systemd Network Management | /                  | /sbin/nologin |
| 16 | polkitd         | x        |   999 |   998 | User for polkitd           | /                  | /sbin/nologin |
| 18 | postfix         | x        |    89 |    89 |                            | /var/spool/postfix | /sbin/nologin |
| 20 | rpc             | x        |    32 |    32 | Rpcbind Daemon             | /var/lib/rpcbind   | /sbin/nologin |
| 22 | nfsnobody       | x        | 65534 | 65534 | Anonymous NFS User         | /var/lib/nfs       | /sbin/nologin |
+----+-----------------+----------+-------+-------+----------------------------+--------------------+---------------+
11 rows in set (0.00 sec)
mysql> 
```

**步骤六: 练习流程控制函数**
IF(expr,v1,v2): 如果expr是TRUE则返回v1，否则返回v2

```sql
mysql> select if(3>0, 'yes', 'no');+----------------------+| if(3>0, 'yes', 'no') |+----------------------+| yes                  |+----------------------+1 row in set (0.00 sec)mysql> select name, dept_id, if(dept_id=1, '人事部', '非人事部')  from employees where name='张亮';+--------+---------+--------------------------------------------+| name   | dept_id | if(dept_id=1, '人事部', '非人事部')        |+--------+---------+--------------------------------------------+| 张亮   |       7 | 非人事部                                   |+--------+---------+--------------------------------------------+1 row in set (0.00 sec)
```

IFNULL(v1,v2): 如果v1不为NULL，则返回v1，否则返回v2

```sql
mysql> select dept_id, dept_name, ifnull(dept_name, '未设置') from departments;+---------+-----------+--------------------------------+| dept_id | dept_name | ifnull(dept_name, '未设置')    |+---------+-----------+--------------------------------+|       1 | 人事部    | 人事部                         ||       2 | 财务部    | 财务部                         ||       3 | 运维部    | 运维部                         ||       4 | 开发部    | 开发部                         ||       5 | 测试部    | 测试部                         ||       6 | 市场部    | 市场部                         ||       7 | 销售部    | 销售部                         ||       8 | 法务部    | 法务部                         |+---------+-----------+--------------------------------+8 rows in set (0.00 sec)mysql> insert into departments(dept_id) values(9);mysql> select dept_id, dept_name, ifnull(dept_name, '未设置') from departments; +---------+-----------+--------------------------------+| dept_id | dept_name | ifnull(dept_name, '未设置')    |+---------+-----------+--------------------------------+|       1 | 人事部    | 人事部                         ||       2 | 财务部    | 财务部                         ||       3 | 运维部    | 运维部                         ||       4 | 开发部    | 开发部                         ||       5 | 测试部    | 测试部                         ||       6 | 市场部    | 市场部                         ||       7 | 销售部    | 销售部                         ||       8 | 法务部    | 法务部                         ||       9 | NULL      | 未设置                         |+---------+-----------+--------------------------------+9 rows in set (0.00 sec)
```

CASE expr WHEN v1 THEN r1 [WHEN v2 THEN v2] [ELSE rn] END: 如果expr等于某个vn，则返回对应位置THEN后面的结果，如果与所有值都不想等，则返回ELSE后面的rn

```sql
mysql> select dept_id, dept_name,    -> case dept_name    -> when '运维部' then '技术部门'    -> when '开发部' then '技术部门'    -> when '测试部' then '技术部门'    -> when null then '未设置'    -> else '非技术部门'    -> end as '部门类型'    -> from departments;+---------+-----------+-----------------+| dept_id | dept_name | 部门类型        |+---------+-----------+-----------------+|       1 | 人事部    | 非技术部门      ||       2 | 财务部    | 非技术部门      ||       3 | 运维部    | 技术部门        ||       4 | 开发部    | 技术部门        ||       5 | 测试部    | 技术部门        ||       6 | 市场部    | 非技术部门      ||       7 | 销售部    | 非技术部门      ||       8 | 法务部    | 非技术部门      ||       9 | NULL      | 非技术部门      |+---------+-----------+-----------------+9 rows in set (0.00 sec)mysql> select dept_id, dept_name,    -> case     -> when dept_name='运维部' then '技术部门'    -> when dept_name='开发部' then '技术部门'    -> when dept_name='测试部' then '技术部门'    -> when dept_name is null then '未设置'    -> else '非技术部门'    -> end as '部门类型'    -> from departments;+---------+-----------+-----------------+| dept_id | dept_name | 部门类型        |+---------+-----------+-----------------+|       1 | 人事部    | 非技术部门      ||       2 | 财务部    | 非技术部门      ||       3 | 运维部    | 技术部门        ||       4 | 开发部    | 技术部门        ||       5 | 测试部    | 技术部门        ||       6 | 市场部    | 非技术部门      ||       7 | 销售部    | 非技术部门      ||       8 | 法务部    | 非技术部门      ||       9 | NULL      | 未设置          |+---------+-----------+-----------------+9 rows in set (0.00 sec)
```

# 2. 查询结果处理

## 2.1 问题：具体要求如下

- 分组练习
- 排序练习
- 过滤练习
- 分页练习

## 2.2 步骤

**步骤一：分组练习**

查询每个部门的人数

```sql
mysql> select dept_id, count(*) from employees group by dept_id;+---------+----------+| dept_id | count(*) |+---------+----------+|       1 |        8 ||       2 |        5 ||       3 |        6 ||       4 |       55 ||       5 |       12 ||       6 |        9 ||       7 |       35 ||       8 |        3 |+---------+----------+8 rows in set (0.00 sec)
```

查询每个部门中年龄最大的员工

```sql
mysql> select dept_id, min(birth_date) from employees group by dept_id;+---------+-----------------+| dept_id | min(birth_date) |+---------+-----------------+|       1 | 1971-08-19      ||       2 | 1971-11-02      ||       3 | 1971-09-09      ||       4 | 1972-01-31      ||       5 | 1971-08-14      ||       6 | 1973-04-14      ||       7 | 1971-12-10      ||       8 | 1989-05-19      |+---------+-----------------+8 rows in set (0.00 sec)
```

查询每个部门入职最晚员工的入职时间

```sql
mysql> select dept_id, max(hire_date) from employees group by dept_id;+---------+----------------+| dept_id | max(hire_date) |+---------+----------------+|       1 | 2018-11-21     ||       2 | 2018-09-03     ||       3 | 2019-07-04     ||       4 | 2021-02-04     ||       5 | 2019-06-08     ||       6 | 2017-10-07     ||       7 | 2020-08-21     ||       8 | 2019-11-14     |+---------+----------------+8 rows in set (0.00 sec)
```

统计各部门使用tedu.cn邮箱的员工人数

```sql
mysql> select dept_id, count(*) from employees 
where email like '%@tedu.cn' group by dept_id;+---------+----------+| dept_id | count(*) |+---------+----------+|       1 |        5 ||       2 |        2 ||       3 |        4 ||       4 |       32 ||       5 |        7 ||       6 |        5 ||       7 |       15 ||       8 |        1 |+---------+----------+8 rows in set (0.00 sec)
```

**步骤二：排序练习**
查看员工2018年工资总收入，按总收入进行降序排列

```sql
mysql> select employee_id, sum(basic+bonus) as total from salary where year(date)=2018 group by employee_id order by total desc;
```

默认升序

```sql
//查出符合条件的用户
mysql> select name, birth_date from employees where birth_date>'19980101';
+-----------+------------+
| name      | birth_date |
+-----------+------------+
| 姚琳      | 1998-05-20 |
| 吴雪      | 1998-06-13 |
| 薄刚      | 2000-05-17 |
| 张玉英    | 1998-06-22 |
| 刘倩      | 1998-10-27 |
| 申峰      | 1999-01-13 |
| 陈勇      | 1998-02-04 |
| 厉秀云    | 1999-09-08 |
| 张桂英    | 1999-05-31 |
| 赵峰      | 1998-03-06 |
| 蒙梅      | 2000-09-01 |
| 陈欢      | 1998-07-01 |
| 马磊      | 2000-08-07 |
| 赵秀梅    | 1998-09-25 |
+-----------+------------+
14 rows in set (0.00 sec)
//默认升序排序
mysql> select name, birth_date from employees 
where birth_date>'19980101' order by birth_date;
+-----------+------------+
| name      | birth_date |
+-----------+------------+
| 陈勇      | 1998-02-04 |
| 赵峰      | 1998-03-06 |
| 姚琳      | 1998-05-20 |
| 吴雪      | 1998-06-13 |
| 张玉英    | 1998-06-22 |
| 陈欢      | 1998-07-01 |
| 赵秀梅    | 1998-09-25 |
| 刘倩      | 1998-10-27 |
| 申峰      | 1999-01-13 |
| 张桂英    | 1999-05-31 |
| 厉秀云    | 1999-09-08 |
| 薄刚      | 2000-05-17 |
| 马磊      | 2000-08-07 |
| 蒙梅      | 2000-09-01 |
+-----------+------------+
14 rows in set (0.00 sec)
//降序排序
mysql> select name, birth_date from employees where birth_date>'19980101'
 order by birth_date desc;
+-----------+------------+
| name      | birth_date |
+-----------+------------+
| 蒙梅      | 2000-09-01 |
| 马磊      | 2000-08-07 |
| 薄刚      | 2000-05-17 |
| 厉秀云    | 1999-09-08 |
| 张桂英    | 1999-05-31 |
| 申峰      | 1999-01-13 |
| 刘倩      | 1998-10-27 |
| 赵秀梅    | 1998-09-25 |
| 陈欢      | 1998-07-01 |
| 张玉英    | 1998-06-22 |
| 吴雪      | 1998-06-13 |
| 姚琳      | 1998-05-20 |
| 赵峰      | 1998-03-06 |
| 陈勇      | 1998-02-04 |
+-----------+------------+
14 rows in set (0.00 sec)
# 查询2015年1月10号员工工资情况
mysql> select date, employee_id, basic, bonus from salary where date='20150110';
# 查询2015年1月10号员工工资情况，以基本工资进行降序排列；如果基本工资相同，再以奖金升序排列
mysql> select date, employee_id, basic, bonus from salary where date='20150110' order by basic desc, bonus;
# 查询2015年1月10号员工工资情况，以工资总额为排序条件
mysql> select date, employee_id, basic, bonus, basic+bonus as total from salary where date='20150110' order by total;
```

**步骤三：过滤练习**
查询部门人数少于5人

```sql
mysql> select dept_id, count(*) from employees group by dept_id having count(*)<10;+---------+----------+| dept_id | count(*) |+---------+----------+|       1 |        8 ||       2 |        5 ||       3 |        6 ||       6 |        9 ||       8 |        3 |+---------+----------+5 rows in set (0.00 sec)
```

**步骤四：分页练习**
使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示,比如每次只显示100条

要实现分页功能，实际上就是从结果集中显示第1至100条记录作为第1页，显示第101至200条记录作为第2页，以此类推

```sql
# 按employee_id排序，取出前5位员姓名
mysql> select employee_id, name from employees
    -> order by employee_id
    -> limit 0, 5;
+-------------+-----------+
| employee_id | name      |
+-------------+-----------+
|           1 | 梁伟      |
|           2 | 郭岩      |
|           3 | 李玉英    |
|           4 | 张健      |
|           5 | 郑静      |
+-------------+-----------+
5 rows in set (0.00 sec)
# 按employee_id排序，取出前15至20号员姓名
mysql> select employee_id, name from employees
    -> order by employee_id
    -> limit 15, 5;
+-------------+--------+
| employee_id | name   |
+-------------+--------+
|          16 | 聂想   |
|          17 | 陈阳   |
|          18 | 戴璐   |
|          19 | 陈斌   |
|          20 | 蒋红   |
+-------------+--------+
5 rows in set (0.00 sec)
//查询uid号最大的用户名和uid号
mysql> select  name , uid  from user order by uid desc limit 1;
+-----------+-------+
| name      | uid   |
+-----------+-------+
| nfsnobody | 65534 |
+-----------+-------+
1 row in set (0.00 sec)
mysql> 
```

# 3. 连接查询

## 3.1 问题，具体如下：

- 练习内连接查询
- 练习外连接查询
- 练习全连接查询
- 练习交叉连接查询
- 练习子查询
- 练习多表更新与删除

## 3.2 步骤

练习使用的表说明：三张表的关系 如图-1所示

部门表departments与员工表employees之间有外键约束关系，employees表的的dept_id字段必须出现在departments表中

员工表employees和工资表salary表之间有外键约束关系，salary表的employee_id必须出现在employees表中

![在这里插入图片描述](https://img-blog.csdnimg.cn/ff104c51ee15439fadc751ea9fc602ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-1

**步骤一：练习内连接查询**

查询每个员工所在的部门名

```sql
mysql> select name, dept_name    -> from employees    -> inner join departments    -> on employees.dept_id=departments.dept_id;
```

查询每个员工所在的部门名，使用别名

```sql
mysql> select name, dept_name    -> from employees as e    -> inner join departments as d    -> on e.dept_id=d.dept_id;
```

查询每个员工所在的部门名，使用别名。两个表中的同名字段，必须指定表名

```sql
mysql> select name, d.dept_id, dept_name    -> from employees as e    -> inner join departments as d    -> on e.dept_id=d.dept_id;
```

查询11号员工的名字及2018年每个月工资

```sql
mysql> select name, date, basic+bonus as total    -> from employees as e    -> inner join salary as s    -> on e.employee_id=s.employee_id    -> where year(s.date)=2018 and e.employee_id=11;
```

查询2018年每个员工的总工资

```sql
mysql> select name, sum(basic+bonus) from employees    -> inner join salary    -> on employees.employee_id=salary.employee_id    -> where year(s.date)=2018    -> group by name;
```

查询2018年每个员工的总工资，按工资升序排列

```sql
mysql> select name, sum(basic+bonus) as total from employees as e    -> inner join salary as s    -> on e.employee_id=s.employee_id    -> where year(s.date)=2018    -> group by name    -> order by total;
```

查询2018年总工资大于30万的员工，按工资降序排列

```sql
 mysql> select name, sum(basic+bonus) as total from employees as e    -> inner join salary as s    -> on e.employee_id=s.employee_id    -> where year(s.date)=2018    -> group by name    -> having total>300000    -> order by total desc;
```

非等值连接：使用不相等做为连接筛选条件

准备工作：创建工资级别表：
id：主键。仅作为表的行号
grade：工资级别，共ABCDE五类
low：该级别最低工资
high：该级别最高工资

```sql
mysql> use tarena;mysql> create table wage_grade    -> (    -> id int,    -> grade char(1),    -> low int,    -> high int,    -> primary key (id)
);
```

向wage_grade表中插入五行数据：

```sql
mysql> insert into wage_grade values    -> (1, 'A', 5000, 8000),    -> (2, 'B', 8001, 10000),    -> (3, 'C', 10001, 15000),    -> (4, 'D', 15001, 20000),    -> (5, 'E', 20001, 1000000);
```

查询2018年12月员工基本工资级别

```sql
mysql> select employee_id, date, basic, grade    -> from salary as s    -> inner join wage_grade as g    -> on s.basic between g.low and g.high    -> where year(date)=2018 and month(date)=12;
```

查询2018年12月员工各基本工资级别的人数

```sql
mysql> select grade, count(*)    -> from salary as s    -> inner join wage_grade as g    -> on s.basic between g.low and g.high    -> where year(date)=2018 and month(date)=12    -> group by grade;+-------+----------+| grade | count(*) |+-------+----------+| A     |       13 || B     |       12 || C     |       30 || D     |       32 || E     |       33 |+-------+----------+5 rows in set (0.00 sec)
```

查询2018年12月员工基本工资级别，员工需要显示姓名

```sql
mysql> select name, date, basic, grade    -> from employees as e    -> inner join salary as s    -> on e.employee_id=s.employee_id    -> inner join wage_grade as g    -> on s.basic between g.low and g.high    -> where year(date)=2018 and month(date)=12;
```

自连接：自己连接自己，将一张表作为两张使用，每张表起一个别名

查看哪些员的生日月份与入职月份相同

```sql
mysql> select e.name, e.hire_date, em.birth_date    -> from employees as e    -> inner join employees as em    -> on month(e.hire_date)=month(em.birth_date)    -> and e.employee_id=em.employee_id;+-----------+------------+------------+| name      | hire_date  | birth_date |+-----------+------------+------------+| 李玉英    | 2012-01-19 | 1974-01-25 || 郑静      | 2018-02-03 | 1997-02-14 || 林刚      | 2007-09-19 | 1990-09-23 || 刘桂兰    | 2003-10-14 | 1982-10-11 || 张亮      | 2015-08-10 | 1996-08-25 || 许欣      | 2011-09-09 | 1982-09-25 || 王荣      | 2019-11-14 | 1999-11-22 |+-----------+------------+------------+7 rows in set (0.00 sec)
```

**步骤二：练习外连接查询**

外连接
常用于查询一个表中有，另一个表中没有的记录
如果从表中有和它匹配的，则显示匹配的值
如j要从表中没有和它匹配的，则显示NULL
外连接查询结果=内连接查询结果+主表中有而从表中没有的记录
左外连接中，left join左边的是主表
右外连接中，right join右边的是主表
左外连接和右外连接可互换，实现相同的目标
查询所有部门的人员以及没有员工的部门

```sql
mysql> select d.*, e.name    -> from departments as d    -> left  join employees as e    -> on d.dept_id=e.dept_id;
```

右连接(也称右外连接）示例
查询所有部门的人员以及没有员工的部门

```sql
mysql> select d.*, e.name    -> from employees as e    -> right  join departments as d    -> on d.dept_id=e.dept_id;
```

**步骤三：练习交叉连接查询**
交叉连接：返回笛卡尔积
查询员工表和部门表的笛卡尔积

```sql
mysql> select name, dept_name    -> from employees    -> cross join departments;
```

**步骤四：练习联合查询**
联合查询UNION
作用：将多条select语句的结果，合并到一起，称之为联合操作。

语法：( ) UNION ( )

要求查询时，多个select语句的检索到的字段数量必须一致
每一条记录的各字段类型和顺序最好是一致的

UNION关键字默认去重，可以使用UNION ALL包含重复项

```sql
mysql> (select 'yes') union (select 'yes');
+-----+
| yes |
+-----+
| yes |
+-----+
1 row in set (0.00 sec)
mysql> (select 'yes') union all (select 'yes');
+-----+
| yes |
+-----+
| yes |
| yes |
+-----+
2 rows in set (0.00 sec)
```

查询1972年或2000年后出生的员工

```sql
# 普通方法
mysql> select name, birth_date from employees
    -> where year(birth_date)<1972 or year(birth_date)>2000;
+-----------+------------+
| name      | birth_date |
+-----------+------------+
| 梁伟      | 1971-08-19 |
| 张建平    | 1971-11-02 |
| 窦红梅    | 1971-09-09 |
| 温兰英    | 1971-08-14 |
| 朱文      | 1971-08-15 |
| 和林      | 1971-12-10 |
+-----------+------------+
6 rows in set (0.01 sec)
# 联合查询的方法
mysql> (
    -> select name, birth_date from employees
    ->   where year(birth_date)<1972
    -> )
    -> union
    -> (
    ->   select name, birth_date from employees
    ->   where year(birth_date)>2000
    -> );
+-----------+------------+
| name      | birth_date |
+-----------+------------+
| 梁伟      | 1971-08-19 |
| 张建平    | 1971-11-02 |
| 窦红梅    | 1971-09-09 |
| 温兰英    | 1971-08-14 |
| 朱文      | 1971-08-15 |
| 和林      | 1971-12-10 |
+-----------+------------+
6 rows in set (0.00 sec)
//一起输出user表中uid号最小和uid号最大的用户信息
mysql> select * from user where uid = (select min(uid) from user) union select * from user where uid = (select max(uid) from user);
+----+-----------+----------+-------+-------+--------------------+--------------+---------------+
| id | name      | password | uid   | gid   | comment            | homedir      | shell         |
+----+-----------+----------+-------+-------+--------------------+--------------+---------------+
|  1 | root      | x        |     1 |     0 | root               | /root        | /bin/bash     |
| 22 | nfsnobody | x        | 65534 | 65534 | Anonymous NFS User | /var/lib/nfs | /sbin/nologin |
+----+-----------+----------+-------+-------+--------------------+--------------+---------------+
2 rows in set (0.00 sec)
mysql> 
```

**步骤五：练习子查询**
查询运维部所有员工信息

```sql
//首先从departments表中查出运维部的编号
mysql> select dept_id from departments where dept_name='运维部';+---------+| dept_id |+---------+|       3 |+---------+1 row in set (0.00 sec)
//再从employees表中查找该部门编号和运维部编号相同的员工
mysql> select *    -> from employees    -> where dept_id=(    ->   select dept_id from departments where dept_name='运维部'    -> );
```

查询2018年12月所有比100号员工基本工资高的工资信息

```sql
//首先查到2018年12月100号员工的基本工资
mysql> select basic from salary    -> where year(date)=2018 and month(date)=12 and employee_id=100;+-------+| basic |+-------+| 14585 |+-------+1 row in set (0.00 sec)
//再查询2018年12月所有比100号员工基本工资高的工资信息
mysql> select * from salary    -> where year(date)=2018 and month(date)=12 and basic>(    ->   select basic from salary    ->   where year(date)=2018 and month(date)=12 and employee_id=100    -> );
```

查询部门员工人数比开发部人数少的部门

```sql
//查询开发部部门编号
mysql> select dept_id from departments where dept_name='开发部';+---------+| dept_id |+---------+|       4 |+---------+1 row in set (0.00 sec)
//查询开发部人数
mysql> select count(*) from employees    -> where dept_id=(    ->   select dept_id from departments where dept_name='开发部'    -> );+----------+| count(*) |+----------+|       55 |+----------+1 row in set (0.00 sec)
//分组查询各部门人数
mysql> select count(*), dept_id from employees group by dept_id;+----------+---------+| count(*) | dept_id |+----------+---------+|        8 |       1 ||        5 |       2 ||        6 |       3 ||       55 |       4 ||       12 |       5 ||        9 |       6 ||       35 |       7 ||        3 |       8 |+----------+---------+8 rows in set (0.01 sec)
//查询部门员工人数比开发部人数少的部门
mysql> select count(*), dept_id from employees group by dept_id    -> having count(*)<(    ->   select count(*) from employees    ->   where dept_id=(    ->     select dept_id from departments where dept_name='开发部'    ->   )    -> );+----------+---------+| count(*) | dept_id |+----------+---------+|        8 |       1 ||        5 |       2 ||        6 |       3 ||       12 |       5 ||        9 |       6 ||       35 |       7 ||        3 |       8 |+----------+---------+7 rows in set (0.00 sec)
```

查询每个部门的人数

```sql
//查询所有部门的信息
mysql> select d.* from departments as d;+---------+-----------+| dept_id | dept_name |+---------+-----------+|       1 | 人事部    ||       2 | 财务部    ||       3 | 运维部    ||       4 | 开发部    ||       5 | 测试部    ||       6 | 市场部    ||       7 | 销售部    ||       8 | 法务部    ||       9 | NULL      |+---------+-----------+9 rows in set (0.00 sec
//查询每个部门的人数
mysql> select d.*, (    ->  select count(*) from employees as e    ->   where d.dept_id=e.dept_id    -> ) as amount    -> from departments as d;+---------+-----------+--------+| dept_id | dept_name | amount |+---------+-----------+--------+|       1 | 人事部    |      8 ||       2 | 财务部    |      5 ||       3 | 运维部    |      6 ||       4 | 开发部    |     55 ||       5 | 测试部    |     12 ||       6 | 市场部    |      9 ||       7 | 销售部    |     35 ||       8 | 法务部    |      3 ||       9 | NULL      |      0 |+---------+-----------+--------+9 rows in set (0.00 sec)
```

查询人事部和财务部员工信息

```sql
//查询人事部和财务部编号
mysql> select dept_id from departments    -> where dept_name in ('人事部', '财务部');+---------+| dept_id |+---------+|       1 ||       2 |+---------+2 rows in set (0.00 sec)
//查询部门编号是两个部门编号的员工信息
mysql> select * from employees    -> where dept_id in (    ->   select dept_id from departments    ->   where dept_name in ('人事部', '财务部')    -> );
```

查询人事部2018年12月所有员工工资

```sql
//查询人事部部门编号
mysql> select dept_id from departments where dept_name='人事部';+---------+| dept_id |+---------+|       1 |+---------+1 row in set (0.00 sec)
//查询人事部员的编号
mysql> select employee_id from employees    -> where dept_id=(    ->   select dept_id from departments where dept_name='人事部'    -> );+-------------+| employee_id |+-------------+|           1 ||           2 ||           3 ||           4 ||           5 ||           6 ||           7 ||           8 |+-------------+8 rows in set (0.00 sec)
//查询2018年12月人事部所有员工工资
mysql> select * from salary    -> where year(date)=2018 and month(date)=12 and employee_id in (    ->   select employee_id from employees    ->   where dept_id=(    ->     select dept_id from departments where dept_name='人事部'    ->   )    -> );+------+------------+-------------+-------+-------+| id   | date       | employee_id | basic | bonus |+------+------------+-------------+-------+-------+| 6252 | 2018-12-10 |           1 | 17016 |  7000 || 6253 | 2018-12-10 |           2 | 20662 |  9000 || 6254 | 2018-12-10 |           3 |  9724 |  8000 || 6255 | 2018-12-10 |           4 | 17016 |  2000 || 6256 | 2018-12-10 |           5 | 17016 |  3000 || 6257 | 2018-12-10 |           6 | 17016 |  1000 || 6258 | 2018-12-10 |           7 | 23093 |  4000 || 6259 | 2018-12-10 |           8 | 23093 |  2000 |+------+------------+-------------+-------+-------+8 rows in set (0.00 sec)
```

查找2018年12月基本工资和奖金都是最高的工资信息

```sql
//查询2018年12月最高的基本工资
mysql> select max(basic) from salary    -> where year(date)=2018 and month(date)=12;+------------+| max(basic) |+------------+|      25524 |+------------+1 row in set (0.00 sec)
//查询2018年12月最高的奖金
mysql> select max(bonus) from salary    -> where year(date)=2018 and month(date)=12;+------------+| max(bonus) |+------------+|      11000 |+------------+1 row in set (0.00 sec)
//查询
mysql> select * from salary    -> where year(date)=2018 and month(date)=12 and basic=(    ->   select max(basic) from salary    ->   where year(date)=2018 and month(date)=12    -> ) and bonus=(    ->   select max(bonus) from salary    ->   where year(date)=2018 and month(date)=12    -> );+------+------------+-------------+-------+-------+| id   | date       | employee_id | basic | bonus |+------+------------+-------------+-------+-------+| 6368 | 2018-12-10 |         117 | 25524 | 11000 |+------+------------+-------------+-------+-------+1 row in set (0.01 sec)
```

查询3号部门及其部门内员工的编号、名字和email

```sql
//查询3号部门和员工的所有信息
mysql> select d.dept_name, e.*    -> from departments as d    -> inner join employees as e    -> on d.dept_id=e.dept_id;
//将上述结果当成一张临时表，必须为其起别名。再从该临时表中查询
mysql> select dept_id, dept_name, employee_id, name, email    -> from (    ->   select d.dept_name, e.*    ->   from departments as d    ->   inner join employees as e    ->   on d.dept_id=e.dept_id    -> ) as tmp_table    -> where dept_id=3;+---------+-----------+-------------+-----------+--------------------+| dept_id | dept_name | employee_id | name      | email              |+---------+-----------+-------------+-----------+--------------------+|       3 | 运维部    |          14 | 廖娜      | liaona@tarena.com  ||       3 | 运维部    |          15 | 窦红梅    | douhongmei@tedu.cn ||       3 | 运维部    |          16 | 聂想      | niexiang@tedu.cn   ||       3 | 运维部    |          17 | 陈阳      | chenyang@tedu.cn   ||       3 | 运维部    |          18 | 戴璐      | dailu@tedu.cn      ||       3 | 运维部    |          19 | 陈斌      | chenbin@tarena.com |+---------+-----------+-------------+-----------+--------------------+6 rows in set (0.00 sec)
```

**步骤六：练习多表更新与删除**

```sql
mysql> use tarena;
Database changed
mysql> 
//创建t1表
mysql> create table t1 select uid , name  from user limit 3 ;
Query OK, 3 rows affected (0.04 sec)
Records: 3  Duplicates: 0  Warnings: 0
//创建t2表
mysql> create table t2 select uid , homedir,shell  from user limit 6 ;
Query OK, 6 rows affected (0.02 sec)
Records: 6  Duplicates: 0  Warnings: 0
mysql> select  * from t1;
+------+--------+
| uid  | name   |
+------+--------+
|    0 | root   |
|    1 | bin    |
|    2 | daemon |
+------+--------+
3 rows in set (0.00 sec)
mysql> select  * from t2;
+------+----------------+---------------+
| uid  | homedir        | shell         |
+------+----------------+---------------+
|    0 | /root          | /bin/bash     |
|    1 | /bin           | /sbin/nologin |
|    2 | /sbin          | /sbin/nologin |
|    3 | /var/adm       | /sbin/nologin |
|    4 | /var/spool/lpd | /sbin/nologin |
|    5 | /sbin          | /bin/sync     |
+------+----------------+---------------+
6 rows in set (0.00 sec)
//连接查询
mysql> select * from t1 inner join t2 on  t1.uid = t2.uid ;
+------+--------+------+---------+---------------+
| uid  | name   | uid  | homedir | shell         |
+------+--------+------+---------+---------------+
|    0 | root   |    0 | /root   | /bin/bash     |
|    1 | bin    |    1 | /bin    | /sbin/nologin |
|    2 | daemon |    2 | /sbin   | /sbin/nologin |
+------+--------+------+---------+---------------+
3 rows in set (0.00 sec)
mysql>
//多表修改
mysql> update t1 inner join t2 on  t1.uid = t2.uid  set shell=NULL , t1.uid=101 , t2.uid=102 where t1.uid=0 ;
Query OK, 2 rows affected (0.01 sec)
Rows matched: 2  Changed: 2  Warnings: 0
mysql>
//查看修改
mysql> select  * from t1;
+------+--------+
| uid  | name   |
+------+--------+
|  101 | root   |     # uid = 101
|    1 | bin    |
|    2 | daemon |
+------+--------+
3 rows in set (0.00 sec)
mysql> select  * from t2;
+------+----------------+---------------+
| uid  | homedir        | shell         |
+------+----------------+---------------+
|  102 | /root          | NULL          |    #shell=null  uid=102
|    1 | /bin           | /sbin/nologin |
|    2 | /sbin          | /sbin/nologin |
|    3 | /var/adm       | /sbin/nologin |
|    4 | /var/spool/lpd | /sbin/nologin |
|    5 | /sbin          | /bin/sync     |
+------+----------------+---------------+
6 rows in set (0.01 sec)
mysql>
//连接查询
mysql> select * from t1 inner join t2 on  t1.uid = t2.uid;
+------+--------+------+---------+---------------+
| uid  | name   | uid  | homedir | shell         |
+------+--------+------+---------+---------------+
|    1 | bin    |    1 | /bin    | /sbin/nologin |
|    2 | daemon |    2 | /sbin   | /sbin/nologin |
+------+--------+------+---------+---------------+
2 rows in set (0.00 sec)
//多表删除
mysql> delete t1,t2  from t1 inner join t2 on  t1.uid = t2.uid;
Query OK, 4 rows affected (0.00 sec)
mysql>
//查看表记录
mysql> select  * from t1;  #uid=1和 uid=2 的记录被删除了
+------+------+
| uid  | name |
+------+------+
|  101 | root |
+------+------+
1 row in set (0.00 sec)
mysql> select  * from t2; #uid=1和 uid=2 的记录被删除了
+------+----------------+---------------+
| uid  | homedir        | shell         |
+------+----------------+---------------+
|  102 | /root          | NULL          |
|    3 | /var/adm       | /sbin/nologin |
|    4 | /var/spool/lpd | /sbin/nologin |
|    5 | /sbin          | /bin/sync     |
+------+----------------+---------------+
4 rows in set (0.00 sec)
mysql>
```

# Exercise

## 1 简述用户授权命令的语法格式。

```sql
GRANT  权限列表  ON  库名.表名  TO  用户名@'客户端地址'   [ IDENTIFIED BY '密码' ]  [ WITH GRANT OPTION ];
```

## 2 数据库授权综合练习，按题目要求写出对应的授权命令。

> 1. 查看当前数据库服务器有哪些授权用户?
> 2. 授权管理员用户可以在网络中的任意主机登录，对所有库和表有完全权限且有授权的权限登陆密码123456
> 3. 授权webadmin用户可以从网络中的所有主机登录，对bbsdb库拥有完全权限，且有授权权限，登录密码为 123456
> 4. 不允许数据库管理员在数据库服务器本机登录。

```sql
1.select user from mysql.user;
2.grant all on *.*  to  root@“%” identified  by “123456” with grant option;
3.grant all  on  bbsdb.*  to   webadmin@“%” identified  by “123456” with grant option; grant insert  on  mysql.user to  webadmin@“%”;
4.delete from mysql.user where host in (“::1”,”127.0.0.1”,”localhost”,”stu.tedu.cn”) and user=”host”;flush privileges;
```

## 3 简述撤销用户授权命令的语法格式。

```sql
revoke  权限列表  on  数据库名  from  用户名@”客户端地址”；
```

## 4 简述binlog日志格式。

```sql
statement 、  row  、  mixed
```

## 5 简述备份策略的类型。

完全备份：备份所有数据。
差异备份：备份自完全备份后所有新产生的数据。
增量备份：备份上次备份后所有新产生的数据。

> 如有侵权，请联系作者删除



@[TOC]( User management &  group account management & scheduled tasks | Cloud computing )

---

# 1. 添加用户账号

## 1.1 问题

1. 创建一个名为tedu01的用户账号
2. 检查/etc/passwd、/etc/shadow文件的最后一行
3. 检查/home/新增加的宿主目录（家目录）
4. 新建用户tedu02，宿主目录位于/opt/tedu02
5. 新建系统账号system01，将UID设为1234，登录Shell设为/sbin/nologin
6. 新建用户admin，附加组设为adm、root

## 1.2 方案

在Linux同添加一个用户账户的命令为useradd，常用的选项较多。可以利用man命令查看其帮助信息。

本题涉及的选项：

- -u：设置 UID 标记号
- -d：指定宿主目录，缺省为 /home/用户名
- -G：指定所属的附加组
- -s：指定用户的登录解释器

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：添加一个tedu01的用户账号**

命令操作如下所示：

```shell
[root@localhost ~]# useradd   tedu01
```

**步骤二：/etc/passwd、/etc/shadow文件的最后一行**

```shell
[root@localhost ~]# grep  tedu01 /etc/passwd /etc/shadow   //查看是否创建成功
```

**步骤三：检查/home/新增加的宿主目录（家目录）**

```shell
[root@localhost ~]# ls /home                     //查看家目录是否创建成功
[root@localhost ~]#
```

**步骤四：新建用户tedu02，宿主目录位于/opt/tedu02**

```shell
[root@localhost ~]# useradd   -d   /opt/tedu02   tedu02
[root@localhost ~]# id  tedu02
[root@localhost ~]# grep tedu02  /etc/passwd
[root@localhost ~]# ls /opt
```

**步骤五：新建系统账号system01，将UID设为1234，登录Shell设为/sbin/nologin**

```shell
[root@localhost ~]# useradd  -u  1234  -s  /sbin/nologin  system01
[root@localhost ~]# id  system01
[root@localhost ~]# grep system01 /etc/passwd
[root@localhost ~]# 
```

**步骤四：新建用户admin，附加组设为adm、root**

```shell
 [root@localhost ~]# useradd  -G  adm,root  admin
 [root@localhost ~]# id  admin
```

# 2. 设置用户密码

## 2.1 问题

1. 为用户tedu01设置一个密码：123456
2. 过滤/etc/shadow文件中包含tedu01的内容
3. 为用户system01设置密码，并测试是否能够登录
4. 非交互式给用户tedu02设置密码123456
5. 交互式给用户admin，设置密码为redhat

## 2.2 方案

为账户设置密码的命令为passwd，管理员root可以修改任何用户的口令，所有用户（包括普通用户）都可以修改自己的口令。

常用命令选项:

- --stdin：从标准输入（比如管道）取密码

查看结果可以利用grep命令，从/etc/shadow筛选。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：为用户tedu01设置一个密码：123456**

命令操作如下所示：

```shell
[root@localhost ~]# echo 123456 |  passwd  --stdin   tedu01
```

**步骤二：过滤/etc/shadow文件中包含tedu01的内容**

```shell
[root@localhost ~]# grep  tedu01   /etc/shadow
```

**步骤三：为用户system01设置密码，并测试是否能够登录**

由于登录的解释器为/sbin/nologin,所以是无法登录系统

```shell
[root@localhost ~]# echo 123456  |  passwd –stdin  system01  
```

**步骤四：新建用户tedu02，宿主目录位于/opt/tedu02**

```shell
[root@localhost ~]# useradd   -d   /opt/tedu02   tedu02
[root@localhost ~]# id  tedu02
[root@localhost ~]# grep tedu02  /etc/passwd
[root@localhost ~]# ls /opt
```

**步骤五：非交互式给用户tedu02设置密码123456**

```shell
[root@localhost ~]# echo 123456  |  passwd –stdin  tedu02
```

**步骤六：交互式给用户admin，设置密码为redhat**

```shell
[root@localhost ~]# passwd admin
更改用户 admin 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@localhost ~]#
```

# 3. 配置用户和组账号

## 3.1 问题

本例要求创建下列用户、组以及组的成员关系：

1. 新建用户 alex，其用户ID为3456，密码是flectrag
2. 创建一个名为 adminuser 的组
3. 创建一个名为 natasha 的用户，其属于 adminuser 组，这个组是该用户的从属组
4. 创建一个名为 harry 的用户，其属于 adminuser 组，这个组是该用户的从属组
5. 创建一个名为 sarah 的用户，其在系统中没有可交互的 Shell，并且不是 adminuser 组的成员
6. natasha 、harry、sarah 的密码都要设置为 flectrag

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建组账号**

```shell
[root@server0 ~]# groupadd  adminuser
```

**步骤二：按照要求的属性创建用户账号**

```shell
[root@server0 ~]# useradd  -u  3456  alex
[root@server0 ~]# useradd  -G  adminuser  natasha
[root@server0 ~]# useradd  -G  adminuser  harry
[root@server0 ~]# useradd  -s  /sbin/nologin  sarah
```

**步骤三：为用户设置登录密码**

```shell
[root@server0 ~]# echo  flectrag  |  passwd  --stdin  alex
更改用户 alex 的密码 。
passwd：所有的身份验证令牌已经成功更新。
[root@server0 ~]# echo  flectrag  |  passwd  --stdin  natasha
更改用户 natasha 的密码 。
passwd：所有的身份验证令牌已经成功更新。
[root@server0 ~]# echo  flectrag  |  passwd  --stdin  harry
更改用户 harry 的密码 。
passwd：所有的身份验证令牌已经成功更新。
[root@server0 ~]# echo  flectrag  |  passwd  --stdin  sarah
更改用户 sarah 的密码 。
passwd：所有的身份验证令牌已经成功更新。
```

# 4. 配置一个cron任务

## 4.1 问题

本例要求为用户 natasha 配置一个定时任务，具体要求如下：

1. 每天在本地时间 14:23 执行
2. 需要完成的任务操作为 /bin/echo hiya

## 4.2 方案

配置格式可参考 /etc/crontab 文件：

```shell
分  时  日  月  周      任务命令行（绝对路径）
```

在表示各段的时间点时，除了明确的数值以外，还可以参考以下形式：

- *：匹配范围内任意时间
- ,：分隔多个不连续的时间点
- -：指定连续时间范围
- /n：指定时间频率，每n ...

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：配置crontab任务记录**

> 1）确保系统服务crond可用

```shell
[root@server0 ~]# systemctl  restart  crond
[root@server0 ~]# systemctl  enable  crond
```

> 2）为用户natasha添加计划任务

```shell
[root@server0 ~]# crontab  -e  -u  natasha
23  14  *  *  *  /bin/echo hiya
```

**步骤二：检查任务是否执行**

> 1）将系统日期时间临时调整到任务时间点前10秒左右

```shell
[root@server0 ~]# date  -s  '14:22:50'              //设置
Sat Nov 26 14:22:50 CST 2016
[root@server0 ~]# date                              //确认日期时间
Sat Nov 26 14:22:55 CST 2016
```

> 2）等待10秒后查看/var/log/cron日志，应该会有执行记录

```shell
[root@server0 ~]# tail  /var/log/cron
.. ..
Nov 26 14:23:02 localhost CROND[3818]: (natasha) CMD (/bin/echo hiya)
```

# Exercise

## 1 采取免交互方式将用户root的密码设置为redhat

```shell
[root@server0 ~]# echo  redhat  |  passwd  --stdin  root
Changing password for user root.
passwd: all authentication tokens updated successfully.
```

## 2 新建系统账号sys01，将UID设为1234，登录Shell设为/sbin/nologin

```shell
[root@server0 ~]# useradd -u 1234 -s /sbin/nologin sys01
[root@server0 ~]# id sys01
uid=1234(sys01) gid=1234(sys01) 组=1234(sys01)
[root@server0 ~]# grep sys01 /etc/passwd
sys01:x:1234:1234::/home/sys01:/sbin/nologin
[root@server0 ~]#
```

## 3 每3小时执行一次“/bin/echo hiya”任务，简述对应的cron配置

```shell
[root@server0 ~]# crontab  -e 
0  */3  *  *  *    /bin/echo hiya
```

## 4 用户与组相关配置文件。

Linux用户的家目录、登录解释器等信息保存在（ ）文件内，而加密的密码字符串、密码有效期等信息保存在（ ）文件内。通过（ ）文件可以查看系统中有哪些组账号，以及各个组包括那些成员用户。

/etc/passwd、/etc/shadow、/etc/group

## 5 useradd命令常用选项。

使用useradd命令添加用户账号时，常用的选项有哪些、各自的作用是什么？

- -u：指定 UID 标记号
- -d：指定宿主目录，缺省为 /home/用户名
- -G：指定所属的附加组（组名或GID）
- -s：指定用户的登录解释器

## 6 为某个用户设置永久别名。

为root用户设置一个永久别名为，myls='ls -lhd'。

```shell
[root@svr5 /]# vim /root/.bashrc
# .bashrc
# User specific aliases and functions
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias myls='ls -lhd'                                  //添加此行
.. ..
```

当开启新的命令行终端时，检查别名即已生效。

```shell
[root@svr5 /]# alias 
alias cp='cp -i'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias myls='ls -lhd'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
[root@svr5 /]#
```

## 7 创建及修改iamkiller用户属性。

新建一个名为iamkiller的本地用户账号，要求如下：

1）宿主文件夹位于/opt/.private/iamkiller。
2）使用/sbin/nologin作为登录解释器。
3）将UID号指定为1234。
4）修改登录shell为/bin/bash。

```shell
[root@svr5 ~]# mkdir /opt/.private
[root@svr5 ~]# useradd -d /opt/.private/iamkiller -s /sbin/nologin -u 1234 iamkiller
[root@svr5 /]# usermod -s /bin/bash iamkiller
```

> 如有侵权，请联系作者删除



﻿@[TOC]( Version control & Git basics & Git advanced | Cloud computing )

---

# 1. Git基本操作

## 1.1 问题

本案例要求先快速搭建好一台Git服务器，并测试该版本控制软件，要求如下：

- 安装Git软件
- 创建版本库
- 客户端克隆版本仓库到本地
- 本地工作目录修改数据
- 提交本地修改到服务器

## 1.2 方案

今日实验环境准备：

1）准备两台RHEL8虚拟机，主机名分别为develop和git。
2）develop主机的IP地址为192.168.4.10，不需要配置网关和DNS。
3）git主机的IP地址为192.168.4.20，不需要配置网关和DNS。
4）给develop和git两台主机配置可用的YUM源。

备注：跨网段走路由，相同网段不需要配置网关就可以互联互通！

实验拓扑如图-1所示，Git工作流如图-2所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c0a3ad41599a4b7f8a68865fe0833f3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_15,color_FFFFFF,t_70,g_se,x_16)
图-1

![在这里插入图片描述](https://img-blog.csdnimg.cn/319a4ec4673645db97b46f16bd3861a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-2

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署Git服务器（192.168.4.20作为git服务器）**

1）YUM安装Git软件。

```shell
[root@git ~]# yum -y install git
```

2)初始化一个空仓库。

```shell
[root@git ~]# mkdir -p /var/lib/git
[root@git ~]# git init /var/lib/git/project --bare    #创建空仓库
[root@git ~]# ls /var/lib/git/project    #查看仓库中是否有内容
config  description  HEAD  hooks  info  objects  refs 
```

英文单词：bare[ber]裸露的；project[prəˈdʒekt]项目；init初始化。

3）设置防火墙信任所有，设置SELinux放行所有。

```shell
[root@git ~]# firewall-cmd --set-default-zone=trusted
[root@git ~]# setenforce 0
[root@git ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

**步骤二：客户端测试(192.168.4.10作为开发人员的客户端主机)**

使用git常用指令列表如表-1所示。

表－1 git常用指令列表
![在这里插入图片描述](https://img-blog.csdnimg.cn/e5af5f2215344bb3b372e58ad8f68680.png)


1) 设置防火墙信任所有，设置SELinux放行所有。

```shell
[root@develop ~]# firewall-cmd --set-default-zone=trusted
[root@develop ~]# setenforce 0
[root@develop ~]# sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
```

2）使用clone指令克隆服务器仓库到本地。

提示：默认会将仓库下载到本地的当前目录（当前目录在root家目录）！

```shell
[root@develop ~]# yum -y install git
[root@develop ~]# git clone root@192.168.4.20:/var/lib/git/project 
Are you sure you want to continue connecting (yes/no)? <第一次远程需要输入yes>
root@192.168.4.20's password:<克隆git主机的资料，需要输入git主机的密码>
[root@develop ~]# ls /root           #查看是否将仓库下载到了本地，名称为project
[root@develop ~]# cd project
[root@develop project]# ls 
[root@develop project]# git remote -v   #查看服务器信息(输出信息如下)
origin  root@192.168.4.20:/var/lib/git/project (fetch)
origin  root@192.168.4.20:/var/lib/git/project (push)
```

3) 修改git配置。

```shell
[root@develop project]# git config --global user.email "you@example.com"
[root@develop project]# git config --global user.name "Your Name"
[root@develop project]# cat ~/.gitconfig 
[user]
    email = you@example.com
    name = Your Name
```

4） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。

```shell
[root@develop project]# echo "init date" > init.txt
[root@develop project]# mkdir demo
[root@develop project]# cp /etc/hosts demo
```

5） 查看本地仓库中数据的状态。

```shell
[root@develop project]# git status
```

6） 将工作区的修改提交到暂存区。

```shell
[root@develop project]# git add .
```

7) 将暂存区修改提交到本地仓库。

```shell
[root@develop project]# git commit  -m  "注释，这里可以为任意字符"
[root@develop project]# git status
英语单词：status[ˈsteɪtəs]状态；add[æd]加、增加；commit[kəˈmɪt]提交、承诺。
```

8） 将本地仓库中的数据推送到远程服务器(develop将数据推送到git)。

```shell
[root@develop project]# git config --global push.default simple    #根据git版本不同，这个步骤可能需要或不需要
[root@develop project]# git push                     #将本地数据推送给git服务器
root@192.168.4.20's password:  输入git服务器root密码
[root@develop project]# git status
[root@develop project]# git remote -v                #查看远程服务器的信息
[root@develop project]# git push origin              #将数据推送至origin服务器
9) 将服务器上的数据更新到本地（git服务器的数据更新到develop）。
```

备注：可能其他人也在修改数据并提交git服务器，就会导致自己的本地数据为旧数据，使用pull指令就可以将服务器上新的数据更新到本地。

```shell
[root@develop project]# git pull
```

10) 查看版本日志。

```shell
[root@develop project]# git log
[root@develop project]# git log --pretty=oneline
[root@develop project]# git log --oneline
[root@develop project]# git reflog
```

英语单词：push[pʊʃ]推；pull[pʊl]拉；pretty[ˈprɪti]精致、漂亮。

备注：客户端也可以使用图形程序访问服务器。

Windows需要安装git和tortoiseGit。如图-3、图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/77c0bb4617ef4f35a3c2a1c4803a246d.png)
图-3

![在这里插入图片描述](https://img-blog.csdnimg.cn/0bde270807494117a2a903ca5666deea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-4

# 2. HEAD指针操作

## 2.1 问题

沿用练习一，学习操作HEAD指针，具体要求如下：

- 查看Git版本信息
- 移动指针
- 通过移动HEAD指针恢复数据

## 2.2 方案

HEAD指针是一个可以在任何分支和版本移动的指针，通过移动指针我们可以将数据还原至任何版本。每做一次提交操作都会导致git更新一个版本，HEAD指针也跟着自动移动。

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：HEAD指针基本操作**

1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。

注意：这里是在project仓库目录下做的所有操作！！

```shell
[root@develop project]# echo "new file" > new.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "add new.txt"
[root@develop project]# echo "first" >> new.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "new.txt:first line"
[root@develop project]# echo "second" >> new.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "new.txt:second"
[root@develop project]# echo "third" >> new.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "new.txt:third"
[root@develop project]# git push
[root@develop project]# echo "123" > num.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "num.txt:123"
[root@develop project]# echo "456" > num.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "num.txt:456"
[root@develop project]# echo "789" > num.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "num.txt:789"
[root@develop project]# git push
```

2) 查看Git版本信息。

```shell
[root@develop project]# git reflog
[root@develop project]# git log --oneline
04ddc0f num.txt:789
7bba57b num.txt:456
301c090 num.txt:123
b427164 new.txt:third
0584949 new.txt:second
ece2dfd new.txt:first line
e1112ac add new.txt
1a0d908 初始化
```

3）移动HEAD指针，将数据还原到任意版本。

提示：当前HEAD指针为HEAD@{0}，HEAD@{1}是上一次指针的位置。

```shell
[root@develop project]# git reset --hard 301c0         #不能照抄这里的301c0
[root@develop project]# git reflog
301c090 HEAD@{0}: reset: moving to 301c0
04ddc0f HEAD@{1}: commit: num.txt:789
7bba57b HEAD@{2}: commit: num.txt:456
301c090 HEAD@{3}: commit: num.txt:123
b427164 HEAD@{5}: commit: new.txt:third
0584949 HEAD@{6}: commit: new.txt:second
ece2dfd HEAD@{7}: commit: new.txt:first line
e1112ac HEAD@{8}: commit: add new.txt
1a0d908 HEAD@{9}: commit (initial): 初始化
[root@develop project]# cat num.txt                  #查看文件是否为123
123
[root@develop project]# git reset --hard 7bba57b     #不能照抄这里的7bba57b
[root@develop project]# cat num.txt                 #查看文件是否为123，456
123
456
[root@develop project]# git reflog                #查看指针移动历史
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@develop project]# git reset --hard 04ddc0f    #回到最后一次修改的版本
```

# 3. Git分支操作

## 3.1 问题

沿用练习二，学习操作Git分支，具体要求如下：

- 查看分支
- 创建分支
- 切换分支
- 合并分支
  解决分支的冲突
  3.2 方案
  Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响，分支效果如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b0eb2355a72a4dc6b5fc6e7d2b6696ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-5

常见的分支规范如下：

MASTER分支（MASTER是主分支，是代码的核心）。
DEVELOP分支（DEVELOP最新开发成果的分支）。
RELEASE分支（为发布新产品设置的分支）。
HOTFIX分支（为了修复软件BUG缺陷的分支）。
FEATURE分支（为开发新功能设置的分支）。

**步骤一：查看并创建分支**

1）查看当前分支。

```shell
[root@develop project]# git status
# On branch master
nothing to commit, working directory clean
[root@develop project]# git branch -v
* master 0dc2b76 delete init.txt
```

2）创建分支。

```shell
[root@develop project]# git branch hotfix  #创建hotfix分支
[root@develop project]# git branch feature   #创建feature分支
[root@develop project]# git branch -v    #查看分支信息
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt
```

备注：如果需要删除分支，命令：git branch -d 分支名称。

**步骤二：切换与合并分支**

1）切换分支。

```shell
[root@develop project]# git checkout hotfix
[root@develop project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt
```

2）在新的分支上可以继续进行数据操作（增、删、改、查）。

```shell
[root@develop project]# echo "fix a bug" >> new.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "fix a bug"
```

3）将hotfix修改的数据合并到master分支。

注意，合并前必须要先切换到master分支，然后再执行merge命令。

```shell
[root@develop project]# git checkout master
[root@develop project]# cat new.txt    #默认master分支中没有hotfix分支中的数据
[root@develop project]# git merge hotfix
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)
```

英语单词：branch[bræntʃ]分支、树枝；merge[mɜːrdʒ]融合、合并。

**步骤二：解决版本分支的冲突问题**

1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。

```shell
[root@develop project]# git checkout hotfix
[root@develop project]# echo "AAA" > a.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "add a.txt by hotfix"
[root@develop project]# git checkout master
[root@develop project]# echo "BBB" > a.txt
[root@develop project]# git add .
[root@develop project]# git commit -m "add a.txt by master"
[root@develop project]# git merge hotfix
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt（Merge conflict in a.txt）
自动合并失败（merge failed），修正冲突（fix conflicts）然后提交修正的结果。
```

英语单词：conflict[kənˈflɪkt]冲突、矛盾；failed[feɪld]失败的；fix[fɪks]修正。

2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。

```shell
[root@develop project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@develop project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@develop project]# git add .
[root@develop project]# git commit -m "resolved"
```

总结：分支指针与HEAD指针的关系。

- 创建分支的本质是在当前提交上创建一个可以移动的指针
- 如何判断当前分支呢？答案是根据HEAD这个特殊指针

分支操作流程如图-6，图-7，图-8，图-9，图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c0bb384c19946ae89375f09507918b8.png)
图-6 HEAD指针指向master分支

![在这里插入图片描述](https://img-blog.csdnimg.cn/f03c0ff9d97a4f7ab9ace0c3944b2b93.png)
图-7 切换分支，HEAD指针指向testing分支

![在这里插入图片描述](https://img-blog.csdnimg.cn/f8849d5400fd4182b5eb2f374a13dc90.png)
图-8 在testing分支中修改并提交代码

![在这里插入图片描述](https://img-blog.csdnimg.cn/3aa041b4f1c0428dadb115ebb42f9c32.png)
图-9 将分支切换回master分支

![在这里插入图片描述](https://img-blog.csdnimg.cn/fda6db2a06414781a51966209f6dfd2e.png)
图-10 在master分支中修改数据，更新版本

# 4. Git服务器

## 4.1 问题

沿用练习三，学习Git不同的服务器形式，具体要求如下：

- 创建SSH协议服务器

## 4.2 方案

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。

**步骤一：SSH协议服务器（支持读写操作）**

1）创建基于密码验证的SSH协议服务器（git主机操作）。

```shell
[root@git ~]# git init --bare /var/lib/git/web
```

2)客户端访问的方式（develop主机操作）。

```shell
[root@develop ~]# cd ~                 #回到家目录(将仓库下载到本地家目录)
[root@develop ~]# git clone root@192.168.4.20:/var/lib/git/web
#默认需要密码才能下载仓库中的资料
[root@develop ~]# rm -rf web               #将刚刚下载的仓库删除
```

3）客户端生成SSH密钥，实现免密码登陆git服务器（develop主机操作）。

```shell
[root@develop ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
#-f后面指定将创建的密钥文件存放到哪里
#-N后面是空，不对生成的密钥文件加密
[root@develop ~]# ssh-copy-id  192.168.4.20
[root@develop ~]# git clone root@192.168.4.20:/var/lib/git/web  
#生成完密钥并传递密钥后，再次克隆下载服务器的资料不需要输入密码
[root@develop ~]# cd web
[root@develop web]# git push
#将本地资料推送到git服务器也不需要密码
[root@develop web]# cd ..
[root@develop ~]# rm  -rf   web                     #删除本地仓库
```

**步骤二：客户端部署新仓库**

客户端没有任何仓库资料的情况下，从服务器克隆部署新仓库。

```shell
[root@develop ~]# git clone root@192.168.4.20:/var/lib/git/web  
[root@develop ~]# cd web
[root@develop web]# touch README.md
[root@develop web]# git add .
[root@develop web]# git commit  -m  "readme"
[root@develop web]# git remote  -v                         #查看远程服务器信息
[root@develop web]# git push                               #默认推送
[root@develop web]# git push -u origin  master            #指定推送的服务器和分支
[root@develop ~]# cd ..
[root@develop ~]# rm -rf  web
```

**步骤三：在客户端现有的文件夹下克隆仓库**

```shell
[root@develop ~]# mkdir mygit
[root@develop ~]# cd mygit
[root@develop mygit]# git init                  #将当前目录创建为git空仓库
[root@develop mygit]# git remote -v            #此时该仓库没有对应的远程服务器
[root@develop mygit]# git remote add origin 192.168.4.20:/var/lib/git/web
#添加远程服务器，给远程服务器的web仓库取一个本地名称为origin
[root@develop mygit]# git remote -v           #查看远程服务器信息
[root@develop mygit]# ls                       #本地还是空目录，没有任何资料
[root@develop mygit]# git pull  origin master   
#从origin服务器的master分支拉取数据
[root@develop mygit]# ls
[root@develop mygit]# echo new > new.txt
[root@develop mygit]# git add .
[root@develop mygit]# git commit -m "newfile"
[root@develop mygit]# git push -u origin master
```

**步骤四：客户端在现有仓库基础上添加新Git仓库**

```shell
[root@develop mygit]# git remote rename origin new-name
#将老服务器信息重命名
[root@develop mygit]# git remote add origin 192.168.4.20:/var/lib/git/web
#添加新服务器信息
[root@develop mygit]# git push -u origin --all
#推送origin服务器的所有分支到服务器
英语单词：remote[rɪˈmoʊt]远程、遥远的；origin[ˈɔːrɪdʒɪn]起源、源头。
```

**步骤五：课外扩展知识：注册使用Github**

1. 登陆网站https://github.com，点击Sign up（注册），如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3b3256e7e6c945d7a084ea2abb3b59d5.png)
图-11

2. 填写注册信息（用户名，邮箱，密码），如图-12所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/09836df636a546b892b292ecee665df1.png)
图-12

3. 初始化操作，如图-13和图-14所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3ac4d375504c4774bb9c9cc580cc8c9c.png)
图-13

![在这里插入图片描述](https://img-blog.csdnimg.cn/fc3007034b6442e5bdac1e7783f7fd40.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_12,color_FFFFFF,t_70,g_se,x_16)
图-14

注意，初始化完成后，到邮箱中去激活Github账户。

4. 创建仓库、使用仓库

点击Start a project（如图-15所示），

![在这里插入图片描述](https://img-blog.csdnimg.cn/01718fccc1ef4d1f9c6e1ae246ac1a38.png)
图-15

填写项目名称（项目名称任意），如图-16所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9215993104f04ac38c26c60dd6a08c57.png)
图-16

往仓库中上传文件或新建文件，如图-17所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/813613816cf24f488b6c7755c3502d7d.png)
图-17

下载仓库中的代码，如图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5979b9abef9145c7b29a6125f93eddd3.png)
图-18

5. 命令行操作（需要联网的主机，如真实机）

```shell
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull
#pull可以从githuab服务器拉取数据到本地
```

**步骤三：Gitlab服务器**

GitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。

附加思维导图，如图-19所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/96d929e67b2e49648906f52ea553feb1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-19


# Exercise

## 1 什么是git

git是一个自由，开源的分布式版本控制系统。在git管理下，文件和目录可以超越时空。git将文件存放在版本库里。它可以记录每一次文件和目录的修改情况，这样就可以籍此将数据恢复到以前的版本，并可以查看数据的更改细节。

## 2 客户端与git服务器通信的方式有哪些

- 本地访问 git clone file:///var/git/project
- ssh服务器方式访问 git clone root@服务器IP:/var/git/project
- git服务器方式访问 git clone git://服务器IP/var/git/project
- web服务的方式 firefox http://服务器IP/git

## 3 Git移动HEAD指针的命令是什么

- git reset --hard 版本编号

## 4 Git如何创建并切换分支

- 创建分支：git branch 分支名称
- 切换分支：git checkout 分支名称

> 如有侵权，请联系作者删除



@[TOC]( Cloud computing underlying technology secrets & virtualization management & public cloud overview | Cloud computing )

---

# 1 案例1：安装虚拟机软件

## 1.1 问题

本案例要求创建虚拟机，安装虚拟化平台：

- 最低配置： 2CPU，4G内存
- 安装虚拟化平台 libvirtd
- qemu-kvm
- libvirt-daemon
- libvirt-daemon-driver-qemu
- libvirt-client

## 1.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：创建虚拟机，由于之前已经创建过很多次虚拟机，这里按照以下要求创建即可

最小安装，能访问互联网

IP地址：192.168.1.xx/24

硬件最低配置：2CPU，16G内存

步骤二：安装虚拟化平台

查看是否支持虚拟化

```shell
[root@localhost ~]# grep -P "vmx|svm" /proc/cpuinfoflags        : ... ... vmx[root@localhost ~]# lsmod |grep kvmkvm_intel               174841      6 kvm                        578518      1 kvm_intelirqbypass                 13503      1 kvm
```

创建虚拟机 2cpu，4G内存（默认用户名: root 密码: a）

```shell
[root@localhost ~]# base-vm create ecsvm ecs create                                              [  OK  ][root@localhost ~]# 
```

验证 yum 仓库的配置

```shell
[root@localhost ~]# yum makecacheLoaded plugins: fastestmirrorDetermining fastest mirrorslocal_repo                                   | 3.6 kB   00:00     (1/4): local_repo/group_gz                | 166 kB   00:00     (2/4): local_repo/filelists_db            | 6.9 MB   00:00     (3/4): local_repo/primary_db              | 5.9 MB   00:00     (4/4): local_repo/other_db              | 2.5 MB   00:00     Metadata Cache Created[root@localhost ~]# yum repolistLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfilerepo id                           repo name                               statuslocal_repo                        CentOS-7 - Base                         9,911repolist: 9,911[root@localhost ~]#
```

安装 libvirtd

```shell
[root@localhost ~]# yum install -y qemu-kvm \                                   libvirt-daemon \                                   libvirt-daemon-driver-qemu \                                   libvirt-client[root@localhost ~]# systemctl enable --now libvirtd[root@localhost ~]# virsh version
```



# 2 案例2：创建虚拟磁盘，配置虚拟网络

## 2.1 问题

本案例要求创建虚拟机的硬盘文件：

- 后端数据盘：cirros.qcow2
- 创建前端盘：/var/lib/libvirt/images/vmhost.img
- 前端盘的大小是 30G
- 创建虚拟机的网络设备
- 写配置文件 vbr.xml
- 定义ip范围，与真机不要冲突
- 创建 vbr 网络设备

## 2.2 方案

虚拟机组成 硬盘文件 /var/lib/libvirt/images/ 配置文件 /etc/libvirt/qemu/

虚拟化实验图例效果如图-1所示。

![img](https://img-blog.csdnimg.cn/img_convert/f8e9b1815e8740d04f8e5f40f9a4c1d7.png)

图-1

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：准备虚拟机**

上传 cirros.qcow2 到虚拟机，通过 qemu-img 创建虚拟机磁盘。命令格式: qemu-img 子命令 子命令参数 虚拟机磁盘文件 大小。

```shell
[root@localhost ~]# cp cirros.qcow2 /var/lib/libvirt/images/[root@localhost ~]# cd /var/lib/libvirt/images/[root@localhost ~]# qemu-img create -f qcow2 -b cirros.qcow2 vmhost.img 30G[root@localhost ~]# qemu-img info vmhost.img #查看信息
```

**步骤二：虚拟网络配置**

1）虚拟网络管理命令如表-1所示。

表-1

2）创建配置文件 /etc/libvirt/qemu/networks/vbr.xml

```shell
[root@localhost ~]# vim /etc/libvirt/qemu/networks/vbr.xml<network>  <name>vbr</name>  <forward mode='nat'/>  <bridge name='vbr' stp='on' delay='0'/>  <ip address='192.168.100.254' netmask='255.255.255.0'>    <dhcp>      <range start='192.168.100.100' end='192.168.100.200'/>    </dhcp>  </ip></network>
```

3）创建虚拟交换机

```shell
[root@localhost ~]# cd /etc/libvirt/qemu/networks/[root@localhost ~]# virsh net-define vbr.xml[root@localhost ~]# virsh net-start vbr[root@localhost ~]# virsh net-autostart vbr[root@localhost ~]# ifconfig # 查看验证
```

虚拟机管理命令如表-2所示。

表-2

**步骤三：虚拟网络配置**

虚拟机配置文件

官方文档地址 https://libvirt.org/format.html

整体流程

1、拷贝 node_base.xml 到虚拟机中

2、拷贝 node_base.xml 到 /etc/libvirt/qemu/虚拟机名字.xml

3、修改配置文件，启动运行虚拟机

```shell
[root@localhost ~]# cp node_base.xml /etc/libvirt/qemu/vmhost.xml[root@localhost ~]# vim /etc/libvirt/qemu/vmhost.xml2:    <name>vmhost</name>3:    <memory unit='KB'>1024000</memory>4:    <currentMemory unit='KB'>1024000</currentMemory>5:    <vcpu placement='static'>2</vcpu>26:    <source file='/var/lib/libvirt/images/vmhost.img'/>
```



# 3 案例3：创建虚拟机

## 3.1 问题

本案例要求创建虚拟机：

- 熟悉 virsh 命令及子命令
- 通过命令行创建虚拟机

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建虚拟机**

```shell
[root@localhost ~]# virsh list[root@localhost ~]# virsh define /etc/libvirt/qemu/vmhost.xml[root@localhost ~]# virsh start vmhost[root@localhost ~]# virsh console vmhost # 两次回车退出使用 ctrl + ]
```



# 4 案例4：华为云用户注册

## 4.1 问题

本案例要求注册华为云账户：

- 用户注册
- 在华为云上注册用户并完成实名认证
- 绑定合作伙伴

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：注册**

网址：https://www.huaweicloud.com

效果如图-2所示。

![img](https://img-blog.csdnimg.cn/img_convert/f3c0a8c79fc4d60095fa4e29d12f67ad.png)

图-2

实名认证，效果如图-3和图-4所示。

![img](https://img-blog.csdnimg.cn/img_convert/c2c979452904bd1c4f68cf9b27ea3f69.png)

图-3

![img](https://img-blog.csdnimg.cn/img_convert/1ef5fe0e8481028381f7cc30109e41a5.png)

图-4



# 5 案例5：熟悉常见云主机管理工具

## 5.1 问题

本案例要求在Windows上完成xshell软件的安装：

- 使用xshell连接到linux
- 上传下载文件

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：Windows 上完成 Xshell 软件的安装，并开启 zmodem 的配置**

1) 开启 zmodem 的配置 如图-5所示：

![img](https://img-blog.csdnimg.cn/img_convert/9ade488f8442257440548ddc18fccee0.png)

图-5

2) 安装lrzsz

```shell
[root@localhost ~]# yum -y install lrzsz
```

> 如有侵权，请联系作者删除



﻿@[TOC]( VLAN technology & application & TRUNK & network layer resolution | Cloud computing )

---

# 1. 划分VLAN

## 1.1 问题

在交换机上创建以下VLAN，按照拓扑图-1将端口加入到指定的VLAN并配置服务器IP地址，实现同VLAN主机的通信

![在这里插入图片描述](https://img-blog.csdnimg.cn/5a733d197b9b4bffba6bfafa7658dd63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-1

## 1.2 步骤

实现此案例需要按照如下步骤进行

**步骤一：创建vlan，并将接口加入**

由于默认情况下所有接口都在VLAN1中，且VLAN1默认就存在，所以只需要配置VLAN2和VLAN3即可

```shell
<Huawei>system-view 
[Huawei]vlan batch 2 3            //创建VLAN2、3
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4
[Huawei-port-group-1]port link-type access 
[Huawei-port-group-1]port default vlan 2                        
[Huawei-port-group-1]quit
[Huawei]port-group 2
[Huawei-port-group-2]group-member Ethernet0/0/5 Ethernet0/0/6
[Huawei-port-group-2]port link-type access 
[Huawei-port-group-2]port default vlan 3    
```

# 2. 多交换机VLAN的划分

## 2.1 问题

通过配置交换机实现图-2中的VLAN划分

![在这里插入图片描述](https://img-blog.csdnimg.cn/831376cda2b24401af184d0e6d8af14b.png)
图-2

## 2.2 步骤

注：以下配置需要在案例1的基础上完成

**步骤一：创建vlan，并将接口加入**

1）S1配置

```shell
[Huawei]interface Ethernet0/0/7
[Huawei-Ethernet0/0/7] port link-type access
[Huawei-Ethernet0/0/7] port default vlan 3
```

2）S2配置

```shell
<Huawei>system-view 
[Huawei]vlan 3            //创建VLAN3
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet0/0/5 to Ethernet0/0/7
[Huawei-port-group-1]port link-type access 
[Huawei-port-group-1]port default vlan 3    
```

# 3. 配置trunk中继链路

## 3.1 问题

通过配置实现跨交换机的同VLAN通信，如图-3所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/1861447b2ce240e298d34e05c68c9923.png)
图-3

## 3.2 步骤

注：以下配置需要在案例2的基础上完成

**步骤一：配置trunk，放行所有vlan**

1）S1配置

```shell
如果接口被改动过，则需要恢复默认配置
[Huawei] clear configuration interface Ethernet0/0/7
[Huawei]interface Ethernet0/0/7
[Huawei-Ethernet0/0/7]port default vlan 1
[Huawei-Ethernet0/0/7]port link-type trunk
[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all
```

2）S2配置

```shell
<Huawei>system-view 
[Huawei]vlan 2         //创建VLAN2
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4
[Huawei-port-group-1]port link-type access 
[Huawei-port-group-1]port default vlan 2                        
[Huawei]interface Ethernet0/0/7
[Huawei-Ethernet0/0/7]port default vlan 1
[Huawei-Ethernet0/0/7]port link-type trunk
[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all
```

# 4. 链路聚合配置

## 4.1 问题

参照图-4将两台交换机的f0/1-f0/2接口互联，并实现高可用

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b41e741582a4592a308b7f2f0d385e7.png)
图-4

## 4.2 步骤

**步骤一：创建链路聚合接口，并捆绑物理接口**

1）S1配置

```shell
[Huawei]interface Eth-trunk 1
[Huawei- Eth-trunk1]trunkport ethernet 0/0/1  0/0/2
如果接口被改动过，则需要恢复默认配置
[Huawei] clear configuration interface Ethernet0/0/1
```

2）S2配置

```shell
[Huawei]interface Eth-trunk 1
[Huawei- Eth-trunk1]trunkport ethernet 0/0/1  0/0/2
```

# 5. 配置静态路由

## 5.1 问题

按照图-5拓扑结构配置接口ip地址并通过静态路由实现全网互通

![在这里插入图片描述](https://img-blog.csdnimg.cn/7e6997fe3bce49a9ac9bdd4380ffba33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-5

## 5.2 步骤

**步骤一：配置ip地址，添加静态路由**

1）R1配置

```shell
<Huawei>system-view 
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/1]ip address 192.168.1.254 24
[Huawei-GigabitEthernet0/0/1]quit
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.1 24
[Huawei]ip route-static 192.168.3.0 24 192.168.2.2
[Huawei]ip route-static 192.168.4.0 24 192.168.2.2
```

2）R2配置

```shell
<Huawei>system-view 
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/1]ip address 192.168.3.254 24
[Huawei-GigabitEthernet0/0/1]quit
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.2 24
[Huawei-GigabitEthernet0/0/1]quit
[Huawei]interface GigabitEthernet 0/0/2
[Huawei-GigabitEthernet0/0/1]ip address 192.168.4.254 24
[Huawei]ip route-static 192.168.1.0 24 192.168.2.1
```

# 6. 三层交换机基本配置

## 6.1 问题

按照图-6的拓扑结构配置ip地址并通过三层交换实现VLAN间通信

![在这里插入图片描述](https://img-blog.csdnimg.cn/d06ae60bb321411d89efc1776bee14cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_16,color_FFFFFF,t_70,g_se,x_16)
图-6

## 6.2 步骤

**步骤一：创建vlan，并配置虚拟接口的ip**

三层交换机配置

```shell
[Huawei]vlan batch 2 3
[Huawei]interface Vlanif 1
[Huawei-Vlanif1]ip address 192.168.1.254 24
[Huawei]interface Vlanif 2
[Huawei-Vlanif1]ip address 192.168.2.254 24
[Huawei]interface Vlanif 3
[Huawei-Vlanif1]ip address 192.168.3.254 24
[Huawei]interface G0/0/2
[Huawei-GigabitEthernet0/0/2] port link-type access
[Huawei-GigabitEthernet0/0/2] port default vlan 2
[Huawei]interface G0/0/3
[Huawei-GigabitEthernet0/0/2] port link-type access
[Huawei-GigabitEthernet0/0/2] port default vlan 3
```

# Exercise

## 1 VLAN的作用是什么？

广播控制，增加安全性，提高带宽利用，降低延迟

## 2 TRUNK的作用是什么？

为数据帧打上VLAN标识，使不同VLAN数据可以用一条链路传递

## 3 链路聚合的作用是什么？

链路聚合为交换机提供了接口捆绑的技术，允许两个交换机之间通过两个或多个接口并行连接，同时传输数据，以提供更高的带宽和可靠性

## 4 网络层的功能有哪些？

定义了基于IP协议的逻辑地址
连接不同的媒介类型
选择数据通过网络的最佳路径

## 5 ping工具与哪个协议有关？

ICMP

## 6 获取路由表的方式有哪些？

直连路由、静态路由、动态路由


> 如有侵权，请联系作者删除



﻿@[TOC]( Website architecture evolution & LNP+Mariadb database separation & Web server cluster | Cloud computing )

---

# 1. 网站架构演变

## 1.1 问题

学习从单机架构到集群架构的演变之路：

- 单机版LNMP
- 独立数据库服务器
- Web服务器集群与Session保持
- 动静分离、数据库集群
- 各种缓存服务器
- 业务模型

## 1.2 步骤

此案例主要是学习网站架构演变的过程，以拓扑图和理论为主，具体实现还需要结合具体的软件。

**步骤一：单机版LNMP**

单机版网站，拓扑如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/042eba1aff0f44d1b82dcdbbe239f19c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-1 单机版网站服务器

用户量少时使用，简单、成本低、存在单点故障。

**步骤二：独立数据库服务器**

独立数据库服务器是将网站静态文件、代码文件等资料与数据库分离的架构，当用户量增加时单机的处理能力有限，PHP或JAVA代码的执行需要消耗大量CPU资源，数据库的增删改查需要调用大量的内存资源，将两者分离可以减轻服务器的压力，其拓扑结构如图-2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7476eeb68d1048b3aefc6082fc06cc74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2 web服务器与数据库分离

Web服务器和数据库服务器的压力都可以得到有效改善，访问量有所增加。但是服务器依然存在单点故障问题。

**步骤三：Web服务器集群与Session保持**

我们可以通过Nginx、Haproxy代理服务器实现Web负载均衡集群，也可以使用LVS调度器实现Web负载均衡集群。部署完Web集群后还需要考虑如何进行Session会话保持，方法很多，如：根据源IP保持，代理服务器重写Cookie信息，共享文件系统保存session，使用数据库共享session等等。

该架构拓扑如图-3所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4750b301af3f4a20be8ce0c3b5c6ca33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-3

但是如果只有一台调度器依然会导致单点故障的问题，因此还需要使用Keepalived或Heartbeat之类的软件进行高可用配置，如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/185422ae996d4b31a0d0bbc83cd17232.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-4

对于网站内容而言可以分离为动态页面和静态页面，静态页面就需要数据文件，动态页面则需要CPU解析代码，需要消耗大量的CPU资源，因此可以将静态和动态分离为两组服务器，动态页面有脚本代码组成，是一种基于网页的应用程序，因此这一组服务器也称为应用服务器，其架构如图-5所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/aa70d6b678b042d5a4dc6a06e7ebde0b.png)
图-5

**步骤四：动静分离、数据库集群**

随着服务器的增加，虽然性能与并发量得到了明显的提升，但是数据的一致性、管理的便利性成为了新的问题，因此就需要增加统一的存储服务器，实现数据的同步一致，可以使用NFS，GlusterFS、Ceph等软件实现该功能，其架构如图-6所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c41e188f8574fa98c03ed9679187634.png)
图-6

此时所有应用服务器都连接一台数据库服务器进行读写操作，而且后期随着数据库中的数据不断增加，会导致数据库成为整个网站的瓶颈！这就需要我们对数据进行分库分表，创建数据库主从或者数据库集群，实现读写分离，其拓扑如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8f3e3e402f6a40f2a3c3a7c0dd3aa54e.png)
图-7

**步骤五：缓存服务器与业务模型**

对于静态数据我们可以通过varnish、squid或者nginx进行缓存，将数据缓存到距离用户更近的位置，构建CDN（内容分发网络）架构。

对于传统的SQL数据库而言，我们也可以通过增加NoSQL数据库，实现数据缓存的功能，提升数据库的访问速度。

备注：数据库相关知识在第三阶段课程有详细介绍，第二阶段项目暂时不做数据库优化。

最后，基于前面的架构，我们还可以将网站按照公司的业务进行分离，每个业务都可以是一个独立的集群，如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/29f08e81f84145c6a1bbb357f0567dfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-8

# 2. LNP+Mariadb数据库分离

## 2.1 问题

部署LNP+Mariadb实现数据库与Web服务器分离，实现以下目标：

- 将旧的数据库备份，迁移到新的服务器
- 修改配置调用新的数据库服务器

## 2.2 方案

实验拓扑如图-9所示，做具体实验前请先配置好环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/62df7e2df7f24dba8f2bde8932e2e336.png)
图-9

主机配置如表-1所示。

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/e4afe5a42cf74eac97f400dc28d0f4f3.png)

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署数据库服务器**

1）准备一台独立的服务器，安装数据库软件包

```shell
[root@database ~]# yum -y install mariadb mariadb-server mariadb-devel
[root@database ~]# systemctl start mariadb
[root@database ~]# systemctl enable mariadb
[root@database ~]# firewall-cmd --set-default-zone=trusted
[root@database ~]# setenforce  0
[root@database ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

2)将之前单机版LNMP网站中的数据库迁移到新的数据库服务器。

登陆192.168.2.11主机，备份数据库并拷贝给新的服务器，关闭旧的数据库服务：

```shell
[root@centos7 ~]# mysqldump wordpress > wordpress.bak     
#备份数据库到文件（备份的文件名和扩展名任意）
[root@centos7 ~]# scp wordpress.bak 192.168.2.21:/root/    #拷贝备份文件到远程主机
[root@centos7 ~]# systemctl stop mariadb
[root@centos7 ~]# systemctl disable mariadb
```

登陆192.168.2.21主机，创建空数据库，使用备份文件还原数据库：

```shell
 [root@database ~]# mysql
MariaDB [(none)]> create database wordpress character set utf8mb4;
#创建数据库wordpress，该数据库支持中文
MariaDB [(none)]> exit
```

使用备份文件还原数据：

```shell
[root@database ~]# mysql wordpress < wordpress.bak        
#使用备份文件导入数据到wordpress数据库
```

重新创建账户并授权访问：

```shell
[root@database ~]# mysql
MariaDB [(none)]> grant all on wordpress.* to wordpress@'%' identified by 'wordpress';
#语法格式：grant 权限 on 数据库名.表名  to 用户名@客户端主机 identified by 密码
#创建用户并授权，用户名为wordpress，该用户对wordpress数据库下的所有表有所有权限
#wordpress用户的密码是wordpress，授权该用户可以从localhost主机登录数据库服务器
#all代表所有权限（wordpress用户可以对wordpress数据库中所有表有所有权限）
#wordpress.*代表wordpress数据库中的所有表
MariaDB [(none)]> flush privileges;
#刷新权限
MariaDB [(none)]> exit
```

备注：在MySQL和MariaDB中%代表所有，这里是授权任何主机都可以连接数据库。

3）修改wordpress网站配置文件，调用新的数据库服务器。

Wordpress在第一次初始化操作时会自动生产配置文件：wp-config.php，登陆192.168.2.11修改该文件即可调用新的数据库服务。

```shell
[root@centos7 ~]# vim /usr/local/nginx/html/wp-config.php
修改前内容如下：
define('DB_HOST', '192.168.2.11');
修改后内容如下：
define('DB_HOST', '192.168.2.21');
```

**步骤二：客户端测试**

1）客户端使用浏览器访问wordpress网站。

```shell
客户端浏览器访问 firefox http://192.168.2.11
```

# 3. Web服务器集群

## 3.1 问题

使用HAProxy部署Web服务器集群，实现以下目标：

- 部署三台Web服务器
- 迁移网站数据，使用NFS实现数据共享
- 部署HAProxy代理服务器实现负载均衡
- 部署DNS域名解析服务器

## 3.2 方案

实验拓扑如图-10所示，做具体实验前请先配置好环境。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1f0625d3dd3344dca924151d99f4c5a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-10

备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。

主机配置如表-2所示。

表-2
![在这里插入图片描述](https://img-blog.csdnimg.cn/0af4d57677cb4022b06fbb5bd5e5e4a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)


## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：部署web2和web3服务器**

1）安装LNP软件包

```shell
[root@web2 ~]# yum -y install gcc pcre-devel openssl-devel 
[root@web2 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
[root@web2 lnmp_soft]# cd nginx-1.12.2/
[root@web2 nginx-1.12.2]# ./configure \
--with-http_ssl_module \
--with-http_stub_status_module
[root@web2 nginx-1.12.2]# make && make install
[root@web2 ~]# yum -y install php php-fpm php-mysql mariadb-devel
[root@web3 ~]# yum -y install gcc pcre-devel openssl-devel 
[root@web3 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
[root@web3 lnmp_soft]# cd nginx-1.12.2/
[root@web3 nginx-1.12.2]# ./configure \
--with-http_ssl_module \
--with-http_stub_status_module
[root@web3 nginx-1.12.2]# make && make install
[root@web3 ~]# yum -y install php php-fpm php-mysql mariadb-devel
```

2）修改nginx配置实现动静分离（web2和web3操作）

web2修改默认首页index.php，配置两个location实现动静分离。

```shell
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php index.html index.htm;
        }
location ~ \.php$ {
            root            html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include         fastcgi.conf;
        }
```

web3修改默认首页index.php，配置两个location实现动静分离。

```shell
[root@web3 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php index.html index.htm;
        }
location ~ \.php$ {
            root            html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include         fastcgi.conf;
        }
```

3）启动相关服务、设置防火墙和SELinux

```shell
[root@web2 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@web2 ~]# chmod +x /etc/rc.local
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# systemctl start  php-fpm                   #启动php-fpm服务
[root@web2 ~]# systemctl enable php-fpm                   #设置服务开启自启
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce  0
[root@web2 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
[root@web3 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@web3 ~]# chmod +x /etc/rc.local
[root@web3 ~]# /usr/local/nginx/sbin/nginx
[root@web3 ~]# systemctl start  php-fpm                   #启动php-fpm服务
[root@web3 ~]# systemctl enable php-fpm                #设置服务开机自启
[root@web3 ~]# firewall-cmd --set-default-zone=trusted
[root@web3 ~]# setenforce  0
[root@web3 ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

附加知识：systemd！！！

源码安装的软件默认无法使用systemd管理，如果需要使用systemd管理源码安装的软件需要手动编写服务的service文件（编写是可以参考其他服务的模板文件）。以下是nginx服务最终编辑好的模板。

Service文件存储路径为/usr/lib/systemd/system/目录。

```shell
[root@centos7 ~]# vim /usr/lib/systemd/system/nginx.service
[Unit]
Description=The Nginx HTTP Server
#描述信息
After=network.target remote-fs.target nss-lookup.target
#指定启动nginx之前需要其他的其他服务，如network.target等
[Service]
Type=forking
#Type为服务的类型，仅启动一个主进程的服务为simple，需要启动若干子进程的服务为forking
ExecStart=/usr/local/nginx/sbin/nginx
#设置执行systemctl start nginx后需要启动的具体命令.
ExecReload=/usr/local/nginx/sbin/nginx -s reload
#设置执行systemctl reload nginx后需要执行的具体命令.
ExecStop=/bin/kill -s QUIT ${MAINPID}
#设置执行systemctl stop nginx后需要执行的具体命令.
[Install]
WantedBy=multi-user.target
```

**步骤二：部署NFS，将网站数据迁移至NFS共享服务器**

1）部署NFS共享服务器

```shell
[root@nfs ~]# yum install nfs-utils
[root@nfs ~]# mkdir /web_share
[root@nfs ~]# vim /etc/exports
/web_share  192.168.2.0/24(rw,no_root_squash)
[root@nfs ~]# systemctl restart rpcbind
[root@nfs ~]# systemctl enable rpcbind
```

no_root_squash参数可以在网络上搜索扩展下自己的知识。

NFS使用的是随机端口，每次启动NFS都需要将自己的随机端口注册到rpcbind服务，这样客户端访问NFS时先到rpcbind查询端口信息，得到端口信息后再访问NFS服务。

```shell
[root@nfs ~]# systemctl restart nfs
[root@nfs ~]# systemctl enable nfs
[root@nfs ~]# firewall-cmd --set-default-zone=trusted
[root@nfs ~]# setenforce  0
[root@nfs ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

2）迁移旧的网站数据到NFS共享服务器

将web1（192.168.2.11）上的wordpress代码拷贝到NFS共享。

```shell
[root@web1 ~]# cd /usr/local/nginx/
[root@web1 nginx]# tar -czpf html.tar.gz html/
#-p代表打包时保留文件的权限
[root@web1 nginx]# scp html.tar.gz 192.168.2.31:/web_share/
```

登陆nfs服务器，将压缩包解压

```shell
[root@nfs ~]# cd /web_share/
[root@nfs web_share]# tar -xf html.tar.gz
```

3)所有web服务器访问挂载NFS共享数据。

```shell
[root@web1 ~]# rm -rf /usr/local/nginx/html/*
[root@web1 ~]# yum -y install nfs-utils
[root@web1 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web1 ~]# mount -a
[root@web2 ~]# yum -y install nfs-utils
[root@web2 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web2 ~]# mount -a
[root@web3 ~]# yum -y install nfs-utils
[root@web3 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web3 ~]# mount -a
```

**步骤三：部署HAProxy代理服务器**

1）部署HAProxy

安装软件，手动修改配置文件，添加如下内容。

```shell
[root@proxy ~]# yum -y install haproxy 
[root@proxy ~]# vim /etc/haproxy/haproxy.cfg
listen wordpress *:80        #监听80端口
  balance roundrobin         #轮询算法
  server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
  server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
  server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
[root@proxy ~]# systemctl start haproxy
[root@proxy ~]# systemctl enable haproxy
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
[root@proxy ~]# setenforce  0
[root@proxy ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

**步骤三：部署DNS域名服务器**

1）安装DNS相关软件（192.168.4.5操作）。

```shell
 [root@proxy ~]# yum -y  install bind bind-chroot
```

2）修改主配置文件，添加zone。

```shell
[root@proxy ~]# vim /etc/named.conf
options {
        listen-on port 53 { any; };           #服务监听的地址与端口
        directory       "/var/named";         #数据文件路径
        allow-query     { any; };             #允许任何主机访问DNS服务
... ...
};
zone "lab.com" IN {                        #定义正向区域
        type master;
        file "lab.com.zone";
};
#include "/etc/named.rfc1912.zones";        #注释掉改行
#include "/etc/named.root.key";              #注释掉改行
[root@proxy ~]# named-checkconf /etc/named.conf            #检查语法
```

3）修改正向解析记录文件。

注意：保留文件权限（相关配置文件知识参考第一阶段课程）。

```shell
[root@proxy named]# cp -p /var/named/named.localhost /var/named/lab.com.zone
[root@proxy named]# vim /var/named/lab.com.zone
$TTL 1D
@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@        NS     dns.lab.com.
dns     A       192.168.4.5
www     A       192.168.4.5
```

4）启动服务

```shell
[root@proxy named]# systemctl start named
[root@proxy named]# systemctl enable named
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
[root@proxy ~]# setenforce  0
[root@proxy ~]# sed -i  '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```

5）客户端修改DNS

如果客户端是Linux主机，则客户端修改DNS解析文件

提示：做完实验修改回原始内容。

```shell
[root@room9pc01 data]# cat /etc/resolv.conf
# Generated by NetworkManager
search tedu.cn
nameserver 192.168.4.5
nameserver 172.40.1.10
nameserver 192.168.0.220
```

如何客户端是Windows则需要在图形中配置网卡的DNS服务器。如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6d963f379dd9417c8ee28830000a8f74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-11

备注：

如果不做DNS，也可以直接修改hosts解析文件。

如果是Linux客户端，则修改/etc/hosts文件。

如果是Windows客户端，则需要以管理员身份启动记事本修改C:\Windows\System32\drivers\etc\hosts文件。

**步骤四：修改wordpress配置文件**

1）修改wp-config.php

在define('DB_NAME', 'wordpress')这行前面添加如下两行内容：

```shell
[root@web3 html]# vim /usr/local/nginx/html/wp-config.php
define('WP_SITEURL', 'http://www.lab.com');
define('WP_HOME', 'http://www.lab.com');
```

如果不添加这两行配置，浏览器访问网站某个子页面后，URL会固定到某一台后端服务器不轮询。

警告：添加的这两行必须与前面的域名解析一致！！！！

**附加知识（常见面试题）**

1) 什么是灰度发布：

答：
灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。

让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。

2) DNS服务器有哪些种，其使用的端口为多少？

答：
有 根DNS、一级DNS、二级DNS、三级DNS、缓存DNS
主DNS服务器、从DNS服务器
端口：53

3) 从日志/opt/bjca3/logs/ca_access.log中截取14点到16点的日志，将截取的日志导入到/tmp/ca_access.txt中，日志格式如下：

```shell
[Fri Mar 17 13:59:00 2017] [debug] mod_cmp.c(1600):[client 192.168.97.8] [CMP] CMP_set_status: starting …
[Fri Mar 17 13:59:00 2017] [debug] mod_cmp.c(938):[client 192.168.97.8] [CMP] CMP_cu_integer_set: starting …
[Fri Mar 17 13:59:00 2017] [debug] mod_cmp.c(957):[client 192.168.97.8] [CMP] CMP_cu_integer_set: ending ok …
………
[Fri Mar 17 16:36:00 2017] [debug] mod_cmp.c(1014):[client 192.168.97.8] [CMP] cu_octet_str_set: starting …
[Fri Mar 17 16:36:00 2017] [debug] mod_cmp.c(1037):[client 192.168.97.8] [CMP] cu_octet_str_set: ending ok …
```

答：
awk '$4>="14:00:00"&&$4<="16:59:00"' ca_access.log

4) 监控检查，使用ping命令编写脚本来查询一组IP地址同时检测他们是否处于活跃状态。要求（range：192.168.1.200-192.168.1.220，一个IP发送4个ping包，ping的过程不能输出信息到终端）？

答：

```shell
#!/bin/bash
for i in {200..220}
do
ping -c 4  -i 0.2  -W 1  192.168.1.$i &>/dev/null
if  [  $? -ne 0 ];then
    echo  "192.168.1.$i is down" >> log.txt
fi
done
```

5) 假设nginx的访问日志格式如下，统计访问页面前10位的IP数？

```shell
202.101.129.218 - - [26/Mar/2017:23:59:55 +0800] "GET /online/stat_inst.php?
pid=d065HTTP/1.1" 302 20 -"-" "-" "Mozilla/4.0(compatible;MSIE 6.0;Windows NT 5.1)"
```

答：
awk '{IP[$1]++} END{for(i in IP){print i,IP[i]}}' access.log \
| sort -n | tail -10

6) 请列举出10个以上的你所知晓的SQL语句？

```shell
insert  select   delete  update  create  show   drop   grant    revoke   load data   create view
```

7) 如何切换到某个数据库，并在上面工作？
   答：
   use 库名;

8) 列出数据库内的所有表？

答：
show tables;

9) 如何删除表、删除数据库？

答：
drop table 表名;drop database 库名;

10) 如何列出表"xrt"内name域值为"tecmint"，web_address域值为"tecmint.com"的所有数据？

```shell
select  *  from  xrt  where  name="tecmint" and  web_address="tecmint.com";
```

> 如有侵权，请联系作者删除



﻿@[TOC]( YAML syntax & Ansible Playbook scripts & Ansible variables & summaries and QQS | Cloud computing )

---

# 1. Playbook应用案例

## 1.1 问题

沿用练习二，编写Ansible Playbook剧本，使用Playbook完成自动化操作，具体要求如下：

- 熟悉Playbook语法格式
- 编写Playbook管理系统账户
- 编写Playbook管理逻辑卷
- 编写Playbook管理软件包

## 1.2 方案

Ansible ad-hoc可以通过命令行形式远程管理其他主机，适合执行一些临时性简单任务。另外还有一种远程管理的方式叫Playbook，Ansible Playbook中文名称叫剧本,它将经常需要执行的任务写入一个文件，这个文件就叫剧本。

- 剧本中可以包含多个任务
- 剧本写后，我们随时根据剧本，执行相关的任务命令
- Playbook剧本要求按照YAML格式编写
- 适合执行周期性经常执行的复杂任务

YAML是什么？

- YAML是一个可读性高、用来表达数据序列的格式语言
- YAML：YAML Ain't a Markup Language
- YAML以数据为中心，重点描述数据的关系和结构

YAML的格式要求如下：

- "#"代表注释，一般第一行为三个横杠（---）
- 键值（key/value）对使用":"表示，数组使用"-"表示，"-"后面有空格
- key和value之间使用":"分隔，":"后面必须有空格
- 一般缩进由两个或以上空格组成
- 相同层级的缩进必须对齐，缩进代表层级关系
- 全文不可以使用tab键
- 区分大小写
- 扩展名为yml或者yaml
- 跨行数据需要使用>或者|，其中|会保留换行符

YAML示例展示：

1）demo1

```shell
---
"诗仙": "李白"
或者
"诗仙": 
   "李白"
```

2）demo2

```shell
#数组的例子
---
- "李白"
- "杜甫"
- "白居易"
- "唐僧"
```

3）demo3

```shell
#使用一行表示数组的例子
---
"诗人": ["李白","杜甫","白居易"]
```

4)demo4

```shell
#键值对和数组符合例子：
---
"诗人":
  - "李白"
  - "杜甫"
  - "白居易"
```

5)demo5

```shell
#复杂案例
---
- "诗人":
    - 唐代:
         - "李白"
         - "杜甫"
    - 宋代:
         - "苏轼"
         - "李清照"
```

6）demo6

```shell
#喜欢的电影
---   
- 芳华
- 战狼
- 霸王别姬
```

7）demo7

```shell
#人物描述
---   
- 姓名: 李白
  年龄: 61
  作品: 蜀道难
  好友: 汪伦
```

8）demo8

```shell
#跨行文本（计算机理解为一行）
---  
自我介绍:  >
  字太白,号青莲居士,
  唐代诗人,祖籍陇西郡,
  今甘肃省平凉市
```

9）demo9

```shell
#跨行文本（计算机理解为多行）
---  
自我介绍:  |
  字太白,号青莲居士,
  唐代诗人,祖籍陇西郡,
  今甘肃省平凉市 
```

10）demo10

注意-和:后面必须有空格。

```shell
#一张发票
--- 
发票编号: 34843
日期: 2028-12-12
商品:
  - 商品编号: BL394D
    描述: 足球
    价格: 100
  - 商品编号: BL4438H
    描述: 棒球
    价格: 200
税费: 10.00
总价: 310.00
备注: >
    本次采购商品均
    属于球类运动商品.   
```

11）demo11

```shell
#错误日志
---
时间: 2028-10-01  15:01:42
用户: ed
错误信息: 
  - 文件: nginx.conf
    行号: 23
    错误编码: "0x3D5FF1"
  - 文件: test.php
    行号: 12
    错误代码: "0xA4C51E"
警告信息: |
    你有两个错误信息需要查看,
    一条是配置文件错误,
    一条是脚本语法错误,
    具体内容参考错误信息.   
```

Playbook语法格式要求如下：

- playbook采用YAML格式编写
- playbook文件中由一个或多个play组成
- 每个play中可以包含:
- hosts(主机)、tasks(任务)、vars(变量)等元素组成
- 使用ansible-playbook命令运行playbook剧本

**步骤一：测试Playbook语法格式**

1）编写第一个Playbook（剧本）

```shell
hosts、tasks、name是关键词（不可修改），ping是模块，调用不同模块完成不同任务。

[root@control ansible]# vim ~/ansible/test.yml 
---
- hosts: all                                #hosts定义要远程谁？
  tasks:                                    #tasks定义远程后要执行的任务有哪些？
      - name: This is my first playbook      #name后面的具体内容可以任意
        ping:
[root@control ansible]# ansible-playbook ~/ansible/test.yml
执行效果如图-1所示。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/736dce3f7c25445bafbf2bb9fbd69835.png)图-1

2）定义多个主机和任务的剧本

hosts由一个或多个组或主机组成，逗号分隔，tasks由一个或多个任务组成，多个任务按顺序执行，执行ansible-playbook命令可以使用-f选项自定义并发量。

```shell
[root@control ansible]# vim ~/ansible/test.yml 
- hosts: test,webserver
  tasks:
      - name: This is my first playbook     #name后面的内容可以任意
        ping:
      - name: Run a shell command
        shell: touch ~/shell.txt
#hosts定义需要远程哪些被管理主机，hosts是关键词
#tasks定义需要执行哪些任务，tasks是关键词
#第一个任务调用ping模块,该模块没有参数
#第二个任务调用shell模块在被管理主机创建一个空文件~/shell.txt
[root@control ansible]# ansible-playbook ~/ansible/test.yml  -f 5
## 验证：到node1、node3、node4主机分别执行命令ls /root/shell.txt查看是否有该文件
```

3）多个play的Playbook文件

```shell
[root@control ansible]# vim ~/ansible/test.yml
#第一个play剧目
---
- hosts: test
  tasks:
      - name: This is first play
        ping:
#第二个play剧目
- hosts: webserver
  tasks:
      - name: This is second play
        ping:
```

**步骤二：Playbook应用案例**

1）用户管理，创建系统账户、账户属性、设置密码（ansible-doc user）。

```shell
[root@control ansible]# vim ~/ansible/test_john.yml
---
- hosts: webserver
  tasks:
    - name: Add the user 'johnd' 
      user:
        name: johnd
        uid: 1040
        group: daemon
        password: "{{ '123' | password_hash('sha512') }}"
#hosts定义需要远程的对象是webserver组，hosts是关键词
#tasks定义需要执行的任务，tasks是关键词
# name是第一个任务的描述信息，描述信息可以任意
# user是第一个任务需要调用的模块，user下面的缩进内容是给user模块的参数
# name是需要创建的用户名，uid是用户ID号
# group是用户属于哪个基本组
# password是用户的密码，密码是123，密码经过sha512算法加密
[root@control ansible]# vim ~/ansible/user_james.yml
---
- hosts: webserver
  tasks:    
    - name:  Add 'james' with a bash shell
      user:
        name: james
        shell: /bin/bash
        groups: bin,adm
        password: "{{ '123' | password_hash('sha512') }}" 
#与上一个案例类似，groups指定用户属于哪些附加组.
[root@control ansible]# vim ~/ansible/user_johnd.yml
---
- hosts: webserver
  tasks:
    - name: Remove the user 'johnd'
      user:
        name: johnd
        state: absent
#删除系统账户johnd，state的值设置为absent是删除用户
```

2）使用playbook管理逻辑卷

准备工作：给node2主机再添加一块磁盘（以下实验磁盘名称仅为参考，不要照抄）。

`注意：请确保node2主机提前安装了lvm2软件包。`

（ansible-doc parted，ansible-doc lvg，ansible-doc lvol）

```shell
[root@control ansible]# vim ~/ansible/lvm.yml
---
- hosts: node2                            #远程node2主机
  tasks:
    - name: Create a new primary partition with a size of 1GiB  #任务的描述信息
      parted:                                 #调用parted模块进行分区         
        device: /dev/vdb                     #对/dev/vdb磁盘进行分区(磁盘名称不要照抄)
        label: gpt                          #分区表类型为gpt，或msdos
        number: 1                           #分区编号(创建第几个分区)
        state: present                     #present是创建分区,absent是删除分区
        part_start: 1MiB                   #分区的开始位置（默认从最开始位置分区）
        part_end: 1GiB                     #分区的结束位置（不写就分到磁盘最后位置）
    - name: Create a volume group on top of /dev/vdb1     #第二个任务的描述信息
      lvg:                                  #调用lvg模块,创建VG卷组
        vg: my_vg                          #要创建的卷组名称
        pvs: /dev/vdb1                     #使用哪个分区创建PV
    - name: Create a logical volume of 512m          #第三个任务的描述信息
      lvol:                                 #调用lvol模块创建LV
        vg: my_vg                          #使用哪个VG创建LV
        lv: my_lv                          #需要创建的LV名称
        size: 512m                         #要创建的LV大小,可以不指定单位，默认单位m
```

3）使用playbook管理软件（ansible-doc yum）

RHEL或CentOS系统中的软件有组包的概念，使用yum grouplist或者dnf grouplist可以查看组包的名称。

```shell
[root@control ansible]# vim ~/ansible/package.yml
---
- hosts: webserver                        #需要远程的主机是谁
  tasks:                                   #定义剧本需要执行的任务
    - name: Install a list of packages  #第一个任务的描述信息 
      yum:                                 #调用yum模块安装软件
        name:                              #安装软件的名字，它的值有多个，使用数组-
          - httpd                          #安装httpd软件
          - mariadb                        #安装mariadb软件
          - mariadb-server                #安装mariadb-server
    - name: install the 'RPM Development Tools' package group   #第二个任务的描述信息
      yum:                                  #调用yum模块安装软件组包
        name: "@RPM Development Tools"        #安装哪个组包，@是关键词
    - name: update software               #第三个任务的描述信息
      yum:                                  #调用yum模块升级软件
        name: '*'                           #需要升级哪些软件
        state: latest                       #latest代表升级软件
#备注:state的值可以是(present|absent|latest)
#present代表安装软件(默认是present)；absent代表卸载软件
#latest代表升级软件
```

# 2. Ansible变量应用案例

## 2.1 问题

沿用前面课程环境，继续练习Ansible 特殊模块并掌握自定义变量的方式，具体要求如下：

- 熟悉setup与debug模块
- 熟悉各种常见的变量定义方式

**步骤一：Ansible特殊模块**

1）setup模块

ansible_facts用于采集被管理设备的系统信息，所有收集的信息都被保存在变量中，每次执行playbook默认第一个任务就是Gathering Facts，使用setup模块可以查看收集到的facts信息。

```shell
[root@control ansible]# ansible test -m setup
192.168.4.10 | SUCCESS => {
"ansible_facts": {
   "ansible_all_ipv4_addresses": [
… 省略部分内容…
```

试试自己找出下列变量：

- ansible_all_ipv4_addresses #IP地址
- ansible_bios_version #主板BIOS版本
- ansible_memtotal_mb #总内存
- ansible_hostname #主机名
- ansible_fqdn #主机的域名
- ansible_devices.vda.partitions.vda1.size #某个磁盘分区的大小

2）debug模块

debug模块可以显示变量的值，可以辅助排错，通过msg可以显示变量的值，变量需要使用{{}}扩起来。

```shell
[root@control ansible]# vim ~/ansible/debug.yml
---
- hosts: test
  tasks:
    - debug:
        msg: "主机名是:{{ ansible_hostname }}"
    - debug:
        msg: "总内存大小:{{ ansible_memtotal_mb }}"
#备注调用debug模块显示某些具体的变量值
#debug模块可以显示变量的值，可以辅助排错
```

**步骤二：定义变量的方法**

Ansible支持十几种定义变量的方式，这里我们仅介绍其中一部分变量。

下面是根据优先级排序的定义方式：

1. Inventory变量
2. Host Facts变量
3. Playbook变量
4. 变量文件

1）Inventory变量(在主机清单配置文件中定义变量）。

```shell
[root@control ansible]# vim ~/ansible/inventory
[test]
node1  iname="nb" 
[proxy]
node2
[webserver]
node[3:4]
[webserver:vars]
iname="dachui"
#备注，在node1主机后面给该主机添加变量iname,值为nb.
#给webserver组定义变量,vars是关键词不可以改变,webserver是上面定义的组
#给这个组定义变量iname="dachui"
... ...<部分后面的内容省略>... ...
```

下面编写剧本调用刚才的变量：(在剧本中需要调用变量是要使用{{}})

```shell
[root@control ansible]# vim ~/ansible/inventory_var.yml
---
- hosts: node1,webserver                         #定义需要远程管理的主机是谁               
  tasks:                                           #剧目要完成哪些任务
    - name: create a user with var.              #剧目中的第一个任务描述信息
      user:                                        #调用user模块创建用户
        name: "{{ iname }}"                      #需要创建的用户名是iname这个变量
#注意事项：
#在ansible剧本中当调用变量时，开始位置就调用变量,就需要在{{}}外面加双引号
#如果是在后面或者中间位置调用变量{{}}外面可以不加双引号,也可以加双引号
#如:
#  "{{ iname }}"
#  nihao {{ iname }}
```

2）Host Facts变量（可以直接调用ansible收集的系统信息）

```shell
[root@control ansible]# vim ~/ansible/facts_var.yml
---
- hosts: test
  tasks:
    - name: create user.
      user:
        name: "{{ansible_hostname}}"
#定义剧本，远程所有被管理主机，调用user模块，创建用户
#需要创建的用户名ansible_hostname是一个ansible_facts变量
#验证： 到node1主机查看是否有一个与主机名同名的用户
```

3）Playbook变量(使用vars关键词可以在playbook内定义变量）。

```shell
[root@control ansible]# vim ~/ansible/playbook_var.yml
---
- hosts: test
  vars:                                     #vars是关键词，用来定义变量用的
    iname: heal                            #具体变量名是iname，值是heal
    ipass: '123456'                       #再定义一个变量名是ipass，值是123456
#注意密码必须是字符串，需要引号                           
  tasks:                                   #tasks定义需要执行的任务
    - name: Use variables create user.  #给任务写个描述信息   
      user:                                #调用user模块创建用户
        name: "{{ iname }}"               #用户名的是前面定义的变量
        password: "{{ ipass | password_hash('sha512') }}"
#密码是前面定义好的ipass,管道给password_hash把密码加密.
```

4）单独定义个变量文件，在playbook中用vars_files调用该文件。

```shell
[root@control ansible]# vim ~/ansible/file_var.yml
---
- hosts: test
  vars_files: variables.yml             #当变量比较多时，专门定义一个文件用来存变量
  tasks:
    - name: create user.
      user:
        name: "{{ iname }}"
        password: "{{ ipass | password_hash('sha512') }}"
#调用user模块创建用户
#用户名是变量文件variables.yml中定义的变量iname，密码也是变量文件中定义的变量
[root@control ansible]# vim  ~/ansible/variables.yml
---
iname: cloud
ipass: '123456'
```

附加思维导图，如图-2所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/af36ba35d9fe4627b408cfe1c6765312.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2


# Exercise

## 1 在YAML文件中使用什么符号支持跨行文本

\> 或者 |

## 2 在Ansible的Playbook剧本中使用什么关键词定义任务？

tasks

## 3 YAML文件中用什么代表数组，什么代表kv数据？

`-`代表数组
`:`代表kv数据

## 4 简单描述ansible_facts的作用？

- ansible_facts用于采集被管理设备的系统信息
- 所有收集的信息都被保存在变量中
- 每次执行playbook默认第一个任务就是Gathering Facts
- 使用setup模块可以查看收集到的facts信息

> 如有侵权，请联系作者删除



﻿@[TOC]( Zabbix alarm mechanism & Zabbix advanced operation & monitoring cases | Cloud computing )

---

# 1. 实现Zabbix报警功能

## 1.1 问题

沿用前面的Zabbix练习环境，使用Zabbix实现报警功能，实现以下目标：

1. 监控Linux服务器系统账户数量
2. 创建Media，设置邮件服务器及收件人邮箱
3. 当系统账户数量超过35人时发送报警邮件

## 1.2 方案

自定义的监控项默认不会自动报警，首页也不会提示错误，需要配置触发器与报警动作才可以自定报警。

什么是触发器（trigger）？
表达式，如内存不足300M，用户超过30个等
当触发条件发生后，会导致一个触发事件
触发事件会执行某个动作

什么是动作（action）？
动作是触发器的条件被触发后所执行的行为
可以是发送邮件、也可以是重启某个服务等

参考如下操作步骤：

1. 创建触发器并设置标记
2. 设置邮箱（发件人，收件人）
3. 创建Action动作

## 1.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建触发器规则**

1）创建触发器

创建触发器时强烈建议使用英文的语言环境，通过Configuration（配置）--> Templates（模板），找到我们之前创建的count.line.passwd模板，点击模板后面的triggers（触发器），如图-1所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4ffee9907ff048b1adeb6f7aecacdcd5.png)
图-1

2）触发器表达式

创建触发器时需要定义表达式，触发器表达式（Expression）是触发异常的条件，触发器表达式格式如下：

{<server>:<key>.<function>(<parameter>)}<operator><constant>

{主机：key.函数(参数)}<表达式>常数

在如图-2所示的蓝色方框中编写触发器表达式，可以直接手写，也可以通过add选择表达式模板。

![在这里插入图片描述](https://img-blog.csdnimg.cn/039cb63f3a554a738bda644b1836dacc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-2

下面，我们看几个表达式的案例：

{web1:system.cpu.load[all,avg1].last(0)}>5 #0为最新数据

如果web1主机最新的CPU平均负载值大于5，则触发器状态Problem

{vfs.fs.size[/,free].max(5m)}<10G #5m为最近5分钟

根分区，最近5分钟的最大容量小于10G，则状态进入Problem

{vfs.file.cksum[/etc/passwd].diff(0)}>0 #0为最新数据

最新一次校验/etc/passwd如果与上一次有变化，则状态进入Problem

大多数函数使用秒作为参数，可以使用#来表示其他含义（具体参考表-1）。

avg, count, last, min and max 等函数支持额外的第二个参数time_shift（时间偏移量），这个参数允许从过去一段时间内引用数据。

表-1
![在这里插入图片描述](https://img-blog.csdnimg.cn/7d0b941b8f464cc69e1886a0debb97b4.png)


3）配置触发器

设置触发器名称，如图-3所示，点击add添加表达式，填写表达式：监控项为账户数量，最近账户数量大于35（根据系统账户数量实际填写），效果如图-4所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/207c264ec9264efe85b7ab49a2847f68.png)
图-3

![在这里插入图片描述](https://img-blog.csdnimg.cn/cd67c242301641e38b1679df2db24a15.png)
图-4

选择触发器报警级别，如图-5所示，Add创建该触发器，如图-6所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7d46ef8b692d46ea8c1a26420efae187.png)

图-5

![在这里插入图片描述](https://img-blog.csdnimg.cn/058ec6f330cf43c18942b032e8e80d05.png)
图-6

**步骤二：设置邮件**

1）创建Media(设置发件人信息)

通过Administration（管理）-->Media Type（报警媒体类型）-->选择Email（邮件），如图-7所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fab4e1d374a44bc5987cb65651d82d2f.png)
图-7

设置邮件服务器信息，设置邮件服务器及发件人邮件账户信息，如图-8所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ccbaa63c262f4ed0b120efe1f03905d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-8

2)为用户添加Media（设置收件人信息）

在Administration（管理）-->Users（用户）中找到选择admin账户，如图-9所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e86424070fe642d8ba3ac7b2f9fc40e2.png)
图-9

点击Admin账户后，在弹出的界面中选择Media（报警媒介）菜单-->点击Add(添加)报警媒介，如图-10所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8287f5e519764e20a62fc3e86fc6f23b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-10

点击Add（添加）后，在Meida Type（类型）中填写报警类型，收件人，时间等信息，如图-11所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/398689e13fb043fc85d87947ebcdeb7f.png)
图-11

**步骤三：创建Action动作**

1）Action动作

Action（动作）是定义当触发器被触发时的时候，执行什么行为。

通过Configuration（配置）-->Actions（动作）-->Create action（创建动作），注意事件源选择触发器，如图-12所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/78365c5d2d9f4572a4ce7dc5c60d0ac0.png)
图-12

2）配置Action动作的触发条件

填写Action动作的名称，配置什么触发器被触发时会执行本Action动作（账户数量大于35），如图-13所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ef74c1e796a54e63af160916444fb792.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-13

3）配置Action动作的具体行为

配置动作的具体操作行为（发送信息或执行远程命令），无限次数发送邮件，60秒1次，发送给Admin用户，如图-14和图-15所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/537c163a05164f0b8072db67eae2450c.png)
图-14

![在这里插入图片描述](https://img-blog.csdnimg.cn/32818d8dcdc440afb043d005a9463494.png)
图-15

4）测试效果

在被监控主机创建账户（让账户数量大于35），然后登录监控端Web页面，在仪表盘中查看问题报警（需要等待一段时间），如图-16所示。

[root@web1 ~]# useradd user1   #创建若干测试用户

![在这里插入图片描述](https://img-blog.csdnimg.cn/778f02a129c64964857cff0c7b9058b1.png)
图-16

查看报警邮件，需要在监控服务器上面有发邮件软件postfix和收取邮件的软件mailx，启动postfix后，可以在监控服务器上使用mail命令查收报警邮件，如图-17所示。

```shell
[root@zabbixserver ~]# yum -y install postfix  mailx   #安装软件
[root@zabbixserver ~]# systemctl start  postfix    #启动服务
[root@zabbixserver ~]# systemctl enable  postfix    #设置开机自启动
[root@zabbixserver ~]# mail                        #收取邮件   
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/a813c094773346bca0f181656169d4e6.png)
图-17

# 2. Zabbix自动发现

## 2.1 问题

沿用前面的练习，配置Zabbix的自动发现机制，实现以下目标：

1. 创建自动发现规则
2. 创建自动发现后的动作，添加主机、为主机链接模板

## 2.2 方案

什么是自动发现（Discovery）？

当Zabbix需要监控的设备越来越多，手动添加监控设备越来越有挑战，此时，可以考虑使用自动发现功能，自动添加被监控主机，实现自动批量添加一组监控主机功能。

自动发现可以实现：

- 自动发现、添加主机，自动添加主机到组；
- 自动连接模板到主机，自动创建监控项目与图形等。

自动发现（Discovery）流程：

- 创建自动发现规则
- 创建Action动作，说明发现主机后自动执行什么动作
- 通过动作，执行添加主机，链接模板到主机等操作

## 2.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：自动发现规则**

1）创建自动发现规则

通过Configuration（配置）-->Discovery（自动发现）-->Create discovery rule（创建发现规则），如图-18所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2d53f88f0c5480387431e4c54b553e1.png)
图-18

2）填写规则

填写自动发现的IP范围（逗号隔开可以写多个），多久做一次自动发现（默认为1小时，仅实验修改为1m），如图-19所示。配置检查的方式：Ping、HTTP、FTP、Agent的自定义key等检查，如图-20所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0bc1358415454c8dbcb4bf14b0d3209e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_14,color_FFFFFF,t_70,g_se,x_16)
图-19

![在这里插入图片描述](https://img-blog.csdnimg.cn/00d5f8429ed349088fb7cb628b0d5303.png)
图-20

**步骤二：创建动作**

1）创建Action动作

通过Configuration（配置）--> Actions（动作）--> Actions Event source(事件源)：自动发现(Discovery)-->Create action（创建动作），如图-21所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e83177221c724deeb312cae12af35aee.png)
图-21

2）配置Action动作具体行为

配置动作，添加动作名称，添加触发动作的条件，如图-22所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba4bee3e69474d979e5cabda0174eda1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-22

点击操作（触发动作后要执行的操作指令），操作细节：添加主机到组，与模板链接（HTTP模板），如图-23所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/108ad4f30cb9477095778516bf224401.png)
图-23

**步骤二：添加新的虚拟机**

1）创建新的虚拟机

创建一台新的主机，验证zabbix是否可以自动发现该主机，可以重新部署一台新的虚拟机（注意前面的课程，我们已经创建了虚拟机web2，并且已经安装部署了Zabbix agent）。

2）验证结果

登陆Zabbix服务器的Web页面，查看主机列表，确认新添加的主机是否被自动加入监控主机列表。

# 3. Zabbix主动监控

## 3.1 问题

沿用前面的练习，配置Zabbix主动监控，实现以下目标：

1. 修改被监控主机agent为主动监控模式
2. 克隆模板，修改模板为主动监控模板
3. 添加监控主机，并链接主动监控模板

## 3.2 方案

默认zabbix采用的是被动监控，主动和被动都是对被监控端主机而言的！

被动监控：Server向Agent发起连接，索取监控数据。

主动监控：Agent向Server发起连接，Agent周期性地收集数据发送给Server。

区别：Server不用每次需要数据都连接Agent，Agent会自己收集数据并处理数据，Server仅需要保存数据即可。如图-24、图-25所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2a42b8836e3c40dfb319ea3749991f9d.png)
图-24

![在这里插入图片描述](https://img-blog.csdnimg.cn/9463bccdab3c4b5d9705438ce7bbd40d.png)
图-25

当监控主机达到一定量级后，Zabbix服务器会越来越慢，此时，可以考虑使用主动监控，释放服务器的压力。

另外，Zabbix也支持分布式监控，也是可以考虑的方案。

## 3.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：添加被监控主机**

1）为被监控主机安装部署zabbix agent

注意：前面的实验如果我们已经在web2主机安装部署了zabbix agent，如果已经完成，则如下操作可以忽略。

```shell
[root@web2 ~]# yum -y install gcc pcre-devel autoconf
[root@web2 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@web2 ~]# cd zabbix-3.4.4/
[root@web2 ~]#./configure --enable-agent
[root@web2 ~]# make && make install
```

2）修改agent配置文件

将agent监控模式修改为主动模式。

```shell
[root@web2 ~]# vim /usr/local/etc/zabbix_agentd.conf 
#Server=127.0.0.1,192.168.2.5
#93行，注释该行，允许谁监控本机
StartAgents=0            
#118行，被动监控时启动几个Agent进程监听10050端口
#设置为0，则禁止被动监控，不启动zabbix_agentd服务及端口
ServerActive=192.168.2.5
#134行，允许哪些主机监控本机（主动模式），一定要取消127.0.0.1
Hostname=web2
#145行，告诉监控服务器，是谁发的数据信息
#一定要和zabbix服务器配置的监控主机名称一致（后面设置）
RefreshActiveChecks=120
#183行，默认120秒检测一次
UnsafeUserParameters=1            
#280行，允许自定义监控传参
Include=/usr/local/etc/zabbix_agentd.conf.d/
#264行，自定义监控的位置
[root@web2 ~]# vim /usr/lib/systemd/system/zabbix_agentd.service
[Unit]
Description=zabbix agent
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_agentd.pid
ExecStart=/usr/local/sbin/zabbix_agentd
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
[root@web2 ~]# systemctl restart zabbix_agentd            #重启服务
[root@web2 ~]# ss -nutlp |grep  zabbix_agentd            #应该查看不到任何端口信息
```

**步骤二：创建主动监控的监控模板**

1）克隆Zabbix自动的监控模板

为了方便，克隆系统自带模板（在此基础上修改更方便）。

通过Configuration（配置）-->Templates（模板）-->选择Template OS Linux

-->全克隆，克隆该模板，新建一个新的模板。如图-26所示。

新模板名称为：Template OS Linux Server Active。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cca3507570854edd80d392a97384ae72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-26

2）修改模板中的监控项目的监控模式

将模板中的所有监控项目全部修改为主动监控模式，通过Configuration（配置）-->Templates（模板）-->选择新克隆的模板，点击后面的Items（监控项）-->点击全选，选择所有监控项目，点击<批量更新>，将类型修改为：Zabbix Agent（Active主动模式），如图-27所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1c211f2b6d084a9587ddfd8bba5519f3.png)
图-27

3）禁用部分监控项目

批量修改监控项的监控模式后，并非所有监控项目都支持主动模式，批量修改后，会发现有几个没有修改主动模式成功，说明，这些监控项目不支持主动模式，关闭即可。

可以点击类型排序，方便操作，点击状态即可关闭。如图-28所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2e9bacea025b48f8a2b145aa0f969423.png)
图-28

**步骤三：添加监控主机**

1）手动添加监控主机（主动模式监控）

在Zabbix监控服务器，添加被监控的主机（主动模式），设置主机名称：web2 （必须与被监控端的配置文件Hostname一致），将主机添加到Linux servers组，IP地址修改为0.0.0.0，端口设置为0，如图-29和图-30所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cfa947a20533445aac7de46a4cccb860.png)
图-29

![在这里插入图片描述](https://img-blog.csdnimg.cn/17074af4c1c04c7eb989081095d6d51f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-30

为主机添加监控模板，选择刚刚创建的模板（主动模式），添加链接模板到主机，如图-31所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/18ce913e829d43d498a00a72e4b4d9f1.png)
图-31

2）验证监控效果

查看数据图表，通过Monitoring（监控中）-->Latest（最新数据）菜单，选择需要查看的主机组、主机以及图形，查看效果，如图-32所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d276cc5c22c74ed5954cb44ad4ed1ad1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_18,color_FFFFFF,t_70,g_se,x_16)
图-32

# 4. 拓扑图与聚合图形

## 4.1 问题

沿用前面的练习，熟悉zabbix拓扑图与聚合图形，实现以下目标：

1. 创建修改拓扑图
2. 创建聚合图形

## 4.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：创建拓扑图**

1）创建拓扑

绘制拓扑图可以快速了解服务器架构，通过Monitoring（监控中）-->Maps（拓扑图），选择默认的Local network拓扑图，编辑即可（也可以新建一个拓扑图），如图-33所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/37bfe2a9590f4892b0ca004dc6226248.png)
图-33

2）拓扑图图表说明

- Icon（图标），添加新的设备后可以点击图标修改属性
- Shape（形状）
- Link（连线），先使用Ctrl选择两个图标，再选择连线
- 完成后，点击Update（更新）

创建完拓扑图，效果如图-34所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/11744d6739824d768084916caed67464.png)
图-34

**步骤二：创建聚合图形**

1）创建聚合图形

聚合图形可以在一个页面显示多个数据图表，方便了解多组数据。

通过Monitoring（监控中）-->Screens（聚合图形）-->Create screen(创建聚合图形)即可创建聚合图形，如图-35所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bd3a1ab1abd247158771d250db65be06.png)
图-35

修改聚合图形参数如下：

- Owner（所有者）：使用默认的Admin用户
- Name（名称）：名称设置为web2_host
- Columns（列）：列数设置为2列
- Rows（行）：行数设置为2行

2）为聚合图形中添加监控图形

选择刚刚创建的聚合图形（web2_host)，点击后面的构造函数（constructor），点击Change(更改)，设置每行每列需要显示的数据图表，如图-36所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5158a0327ee94306b672b92873da8a8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-36

# 5. 自定义监控案例

## 5.1 问题

沿用前面的练习，使用自定义key监控常用监控项目，实现以下目标：

监控Nginx状态
监控网络连接状态

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：监控Nginx服务状态**

1）准备环境，部署nginx软件

安装nginx软件，开启status模块（参考前面的课程知识）

```shell
[root@web1 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web1 ~]# cd nginx-1.12.2
[root@web1 nginx-1.12.2]# yum -y install gcc pcre-devel openssl-devel
[root@web1 nginx-1.12.2]# ./configure \
> --with-http_stub_status_module 
[root@web1 nginx-1.12.2]# make && make install
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf        #参考前面的课程内容
location /status {
                stub_status on;
        }
[root@web1 ~]# /usr/local/nginx/sbin/nginx          #启动服务
[root@web1 ~]# curl  http://192.168.2.100/status
Active connections: 1 
server accepts handled requests
10 10 3 
Reading: 0 Writing: 1 Waiting: 0
```

2）自定义监控key

编写自定义监控脚本（仅供参考，未检测完整状态）

```shell
[root@web1 ~]# vim /usr/local/bin/nginx_status.sh
#!/bin/bash
case $1 in
active)
    curl -s http://192.168.2.100/status |awk '/Active/{print $NF}';;
waiting)
    curl -s http://192.168.2.100/status |awk '/Waiting/{print $NF}';;
accepts)
    curl -s http://192.168.2.100/status |awk 'NR==3{print $2}';;
esac
[root@web1 ~]# chmod +x  /usr/local/bin/nginx_status.sh
```

创建自定义key
语法格式：
UserParameter=key,command
UserParameter=key[*],<command> $1

key里的所有参数，都会传递给后面命令的位置变量

注意：被监控端修改配置文件，注意要允许自定义key并设置Include！

```shell
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf.d/nginx.status
UserParameter=nginx.status[*],/usr/local/bin/nginx_status.sh $1
[root@web1 ~]# systemctl restart zabbix_agentd            #重启服务
```

测试效果：

```shell
[root@web1 ~]# zabbix_get  -s 127.0.0.1 -k 'nginx.status[accepts]'
```

登陆Zabbix监控Web，创建监控项目item，点击Configuration（配置）-->Hosts(主机)，点击主机后面的items（监控项），点击Create item（创建监控项）。修改监控项参数如图-37所示。

备注：Type（类型）后面的Zabbix agent中文是Zabbix 客户端。

Key的中文是键值。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9a7e3d68b7bf412d8c5d8672c024da11.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_13,color_FFFFFF,t_70,g_se,x_16)
图-37

**步骤二：监控网络连接状态**

1）了解TCP协议

熟悉TCP三次握手，参考图-38。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d13bcdc086834e5888b2c0bfe8abc5f7.png)
图-38

熟悉TCP连接的四次断开，参考图-39。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b46b022b5d6842e4b91e27c1d30e4783.png)
图-39

2）查看网络连接状态

模拟多人并发连接(如果没有ab命令，则安装httpd-tools软件包)

```shell
[root@web1 ~]# ab -c 1000 -n 100000 http://192.168.2.100/
```

查看网络连接状态，仔细观察、分析第二列的数据

```shell
[root@web1 ~]# ss -antup
#-a显示所有
#-t显示TCP连接状态
#-u显示UDP连接状态
#-n以数字形式显示端口号和IP地址
#-p显示连接对应的进程名称
```

3）创建自定义key

编写自定义监控脚本（仅供参考，未检测完整状态）

```shell
[root@web1 ~]# vim /usr/local/bin/net_status.sh 
#!/bin/bash
case $1 in
estab)
    ss -antp |awk 'BEGIN{x=0}  /^ESTAB/{x++} END{print x}';;
close_wait)
    ss -antp |awk 'BEGIN{x=0} /^CLOSE-WAIT/{x++} END{print x}';;
time_wait)
    ss -antp |awk 'BEGIN{x=0} /^TIME-WAIT/{x++} END{print x}';;
esac 
[root@web1 ~]# chmod +x  /usr/local/bin/net_status.sh
```

注意：被监控端修改配置文件，注意要允许自定义key并设置Include参数。

如果没有killall命令，则需要安装psmisc软件包。

```shell
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf.d/net.status
UserParameter=net.status[*],/usr/local/bin/net_status.sh $1
[root@web1 ~]# systemctl restart zabbix_agentd            #重启服务
```

测试效果：

```shell
[root@web1 ~]# zabbix_get  -s 127.0.0.1 -k 'net.status[time_wait]'
```

4) 监控netstatus

在监控服务器，添加监控项目item，Configuration（配置）-->Hosts（主机）点击主机后面的items（监控项）

点击Create item（创建监控项），如图-40所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3b6dfa318ef04032913b3d951a365399.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_19,color_FFFFFF,t_70,g_se,x_16)
图-40

附加思维导图，如图-41所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/be70c4e738b148f596e4692a24ad7d63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6aWF6aCt,size_20,color_FFFFFF,t_70,g_se,x_16)
图-41



# Exercise

## 1 设置Zabbix触发器规则：当Linux系统账户数量大于35时触发

```shell
{count.line.passwd:count.line.passwd.last(,300)}>35 
```

## 2 Zabbix支持的报警媒介类型有哪些？

Email、Jabber、SMS。

## 3 简单描述Zabbix自动发现的功能

当Zabbix需要监控的设备越来越多，手动添加监控设备越来越有挑战，此时，可以考虑使用自动发现功能，需要批量一次性添加一组监控主机，也可以使用自动发现功能。

自动发现、添加主机，自动添加主机到组，自动连接模板到主机，自动创建监控项目与图形等。

## 4 查看网络连接状态的ss命令有哪些常用选项

```shell
[root@localhost ~]# ss -antup
```

//-a显示所有
//-t显示TCP连接状态
//-u显示UDP连接状态
//-n以数字形式显示端口号和IP地址
//-p显示连接对应的进程名称

> 如有侵权，请联系作者删除



﻿@[TOC]( Zookeeper high availability cluster & distributed message queue Kafka & set up high availability Hadoop cluster | Cloud computing )

---

# 1. 组建zookeeper集群

## 1.1 问题

本案例要求：

- 组建 zookeeper 集群
- 1 个 leader
- 2 个 follower
- 1 个 observer

## 1.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：安装Zookeeper**

1）编辑/etc/hosts ,所有集群主机可以相互 ping 通（在hadoop1上面配置，同步到node-0001，node-0002，node-0003）

```shell
[root@hadoop1 hadoop]# vim /etc/hosts
192.168.1.50  hadoop1
192.168.1.51  node-0001
192.168.1.52  node-0002
192.168.1.53  node-0003
192.168.1.56  newnode
[root@nn01 hadoop]# for i in {52..54}  \
do    \
scp /etc/hosts 192.168.1.$i:/etc/    \
done        //同步配置
hosts       100%  253   639.2KB/s   00:00    
hosts       100%  253   497.7KB/s   00:00    
hosts       100%  253   662.2KB/s   00:00  
```

2）安装 java-1.8.0-openjdk-devel,由于之前的hadoop上面已经安装过，这里不再安装，若是新机器要安装

3）zookeeper 解压拷贝到 /usr/local/zookeeper

```shell
[root@hadoop1 ~]# tar -xf zookeeper-3.4.13.tar.gz 
[root@hadoop1 ~]# mv zookeeper-3.4.13 /usr/local/zookeeper
```

4）配置文件改名，并在最后添加配置

```shell
[root@hadoop1 ~]# cd /usr/local/zookeeper/conf/
[root@hadoop1 conf]# ls
configuration.xsl  log4j.properties  zoo_sample.cfg
[root@hadoop1 conf]# mv zoo_sample.cfg  zoo.cfg
[root@hadoop1 conf]# chown root.root zoo.cfg
[root@hadoop1 conf]# vim zoo.cfg
server.1=node-0001:2888:3888
server.2=node-0002:2888:3888
server.3=node-0003:2888:3888
server.4=hadoop1:2888:3888:observer
```

5）拷贝 /usr/local/zookeeper 到其他集群主机

```shell
[root@hadoop1 conf]# for i in {52..54}; do rsync -aSH --delete /usr/local/zookeeper/ 192.168.1.$i:/usr/local/zookeeper  -e 'ssh' & done
[4] 4956
[5] 4957
[6] 4958
```

6）创建 mkdir /tmp/zookeeper，每一台都要

```shell
[root@hadoop1 conf]# mkdir /tmp/zookeeper
[root@hadoop1 conf]# ssh node-0001 mkdir /tmp/zookeeper
[root@hadoop1 conf]# ssh node-0002 mkdir /tmp/zookeeper
[root@hadoop1 conf]# ssh node-0003 mkdir /tmp/zookeeper
```

7）创建 myid 文件，id 必须与配置文件里主机名对应的 server.(id) 一致

```shell
[root@hadoop1 conf]# echo 4 >/tmp/zookeeper/myid
[root@hadoop1 conf]# ssh node-0001 'echo 1 >/tmp/zookeeper/myid'
[root@hadoop1 conf]# ssh node-0002 'echo 2 >/tmp/zookeeper/myid'
[root@hadoop1 conf]# ssh node-0003 'echo 3 >/tmp/zookeeper/myid'
```

8）启动服务，单启动一台无法查看状态，需要启动全部集群以后才能查看状态，每一台上面都要手工启动（以hadoop1为例子）

```shell
[root@hadoop1 conf]# /usr/local/zookeeper/bin/zkServer.sh start
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED
```

注意：刚启动zookeeper查看状态的时候报错，启动的数量要保证半数以上，这时再去看就成功了

9）查看状态

```shell
[root@hadoop1 conf]# /usr/local/zookeeper/bin/zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg
Mode: observe
[root@hadoop1 conf]# /usr/local/zookeeper/bin/zkServer.sh stop  
//关闭之后查看状态其他服务器的角色
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg
Stopping zookeeper ... STOPPED
```



# 2. 测试集群的远程管理和高可用

## 2.1 问题

本案例要求：

- 测试集群的远程管理和高可用

## 2.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：测试集群的远程管理和高可用**

```shell
[root@hadoop1 conf]# socat - TCP:node1:2181
stat
... ...
Outstanding: 0
Zxid: 0x0
Mode: follower
Node count: 4
[root@hadoop1 conf]# vim api.sh
#!/bin/bash
function getstatus(){
    exec 9<>/dev/tcp/$1/2181 2>/dev/null
    echo stat >&9
    MODE=$(cat <&9 |grep -Po "(?<=Mode:).*")
    exec 9<&-
    echo ${MODE:-NULL}
}
for i in node{1..3} hadoop1;do
    echo -ne "${i}\t"
    getstatus ${i}
done
[root@hadoop1 conf]# chmod 755 api.sh
[root@hadoop1 conf]# ./api.sh 
node-0001        follower
node-0002        leader
node-0003        follower 
hadoop1        observer
```



# 3. 在node节点上搭建3台kafka

## 3.1 问题

本案例要求：

- 在node节点上搭建3台kafka
- node-0001
- node-0002
- node-0003
- 发布订阅消息测试

## 3.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：搭建Kafka集群**

1）解压 kafka 压缩包

Kafka在node-0001，node-0002，node-0003上面操作即可

```shell
[root@node-0001 hadoop]# tar -xf kafka_2.12-2.1.0.tgz
```

2）把 kafka 拷贝到 /usr/local/kafka 下面

```shell
[root@node-0001 ~]# mv kafka_2.12-2.1.0 /usr/local/kafka
```

3）修改配置文件 /usr/local/kafka/config/server.properties

```shell
[root@node-0001 ~]# cd /usr/local/kafka/config
[root@node-0001 config]# vim server.properties
broker.id=22
zookeeper.connect=node-0001:2181,node-0002:2181,node-0003:2181
```

4）拷贝 kafka 到其他主机，并修改 broker.id ,不能重复

```shell
[root@node-0001 config]# for i in 53 54; do rsync -aSH --delete /usr/local/kafka 192.168.1.$i:/usr/local/; done
[1] 27072
[2] 27073
[root@node-0002 ~]# vim /usr/local/kafka/config/server.properties        
//node-0002主机修改
broker.id=23
[root@node-0003 ~]# vim /usr/local/kafka/config/server.properties        
//node-0003主机修改
broker.id=24
```

5）启动 kafka 集群（node-0001，node-0002，node-0003启动）

```shell
[root@node-0001 local]# /usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties 
[root@node-0001 local]# jps        //出现kafka
26483 DataNode
27859 Jps
27833 Kafka
26895 QuorumPeerMain
```

6）验证配置，创建一个 topic

```shell
[root@node-0001 local]# /usr/local/kafka/bin/kafka-topics.sh --create --partitions 1 --replication-factor 1 --zookeeper localhost:2181 --topic mymsg
    
Created topic "mymsg".
```

\7) 模拟生产者，发布消息

```shell
[root@node-0002 ~]# /usr/local/kafka/bin/kafka-console-producer.sh --broker-list  localhost:9092 --topic mymsg
        //写一个数据
ccc
ddd
```

9）模拟消费者，接收消息

```shell
[root@node-0003 ~]# /usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic mymsg
        //这边会直接同步
ccc
ddd
```

注意：kafka比较吃内存，做完这个kafka的实验可以把它停了



# 4. 准备实验环境

## 4.1 问题

本案例要求：

- 所有节点
- 192.168.1.50 hadoop1
- 192.168.1.56 hadoop2
- 192.168.1.51 node-0001
- 192.168.1.52 node-0002
- 192.168.1.53 node-0003
- 新机器安装 java-1.8.0-openjdk-devel
- 新机器配置 /etc/hosts
- 新机器配置 ssh 免密钥登录
- 修改配置文件

## 4.2 方案

配置Hadoop的高可用，解决NameNode单点故障问题，使用之前搭建好的hadoop集群，新添加一台hadoop2，ip为192.168.1.56，具体要求如图-1所示：

![img](https://img-blog.csdnimg.cn/img_convert/6b896447f79e0a29676117c72736ec4a.png)

图-1

## 4.3 步骤

实现此案例需要按照如下步骤进行。

**步骤一：hadoop的高可用**

1）停止所有服务（由于 kafka的实验做完之后就已经停止，这里不在重复）

```shell
[root@hadoop1 ~]# cd /usr/local/hadoop/
[root@hadoop1 hadoop]# ./sbin/stop-all.sh  //停止所有服务 
```

2）启动zookeeper（需要一台一台的启动）这里以hadoop1为例子

```shell
[root@hadoop1 hadoop]# /usr/local/zookeeper/bin/zkServer.sh start
[root@hadoop1 hadoop]# sh /usr/local/zookeeper/conf/api.sh //利用之前写好的脚本查看
node-0001        follower
node-0002        leader
node-0003        follower
hadoop1        observer
```

3）新加一台机器hadoop2，这里之前有一台newnode，可以用这个作为hadoop2

```shell
[root@newnode ~]# echo hadoop2 > /etc/hostname 
[root@newnode ~]# hostname hadoop2
```

4）修改vim /etc/hosts

```shell
[root@hadoop1 hadoop]# vim /etc/hosts
192.168.1.50  hadoop1
192.168.1.56  hadoop2
192.168.1.51  node-0001
192.168.1.52  node-0002
192.168.1.53  node-0003
```

5）同步到hadoop2，node-0001，node-0002，node-0003

```shell
[root@hadoop1 hadoop]# for i in {51..53} 56; do rsync -aSH --delete /etc/hosts 192.168.1.$i:/etc/hosts  -e 'ssh' & done
[1] 14355
[2] 14356
[3] 14357
[4] 14358
```

6）配置SSH信任关系

注意：hadoop1和hadoop2互相连接不需要密码，hadoop2连接自己和node-0001，node-0002，node-0003同样不需要密码

```shell
[root@hadoop2 ~]# vim /etc/ssh/ssh_config
Host *
        GSSAPIAuthentication yes
        StrictHostKeyChecking no
[root@hadoop1 hadoop]# cd /root/.ssh/
[root@hadoop1 .ssh]# scp id_rsa id_rsa.pub  hadoop2:/root/.ssh/    
//把hadoop1的公钥私钥考给hadoop2
```

7）所有的主机删除/var/hadoop/*

```shell
[root@hadoop1 .ssh]# rm -rf /var/hadoop/*
```



# 5. 配置namenode与resourcemanager高可用

## 5.1 问题

本案例要求：

- 配置 namenode 与 resourcemanager 高可用
- hadoop-env.sh
- core-site.xml
- hdfs-site.xml
- mapred-site.xml
- yarn-site.xml
- slaves

## 5.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：hadoop的高可用**

1）配置 core-site

```shell
[root@hadoop1 .ssh]# vim /usr/local/hadoop/etc/hadoop/core-site.xml
<configuration>
<property>
        <name>fs.defaultFS</name>
        <value>hdfs://nsdcluster</value>    
//nsdcluster是随便起的名。相当于一个组，访问的时候访问这个组
    </property>
    <property>
        <name>hadoop.tmp.dir</name>
        <value>/var/hadoop</value>
    </property>
    <property>
        <name>ha.zookeeper.quorum</name>
        <value>node-0001:2181,node-0002:2181,node-0003:2181</value>    //zookeepe的地址
    </property>
    <property>
        <name>hadoop.proxyuser.nfs.groups</name>
        <value>*</value>
    </property>
    <property>
        <name>hadoop.proxyuser.nfs.hosts</name>
        <value>*</value>
    </property>
</configuration>
```

2）配置 hdfs-site

```shell
[root@hadoop1 ~]# vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml
<configuration>
    <property>
        <name>dfs.replication</name>
        <value>2</value>
    </property>
    <property>
        <name>dfs.nameservices</name>
        <value>nsdcluster</value>
    </property>
    <property>
        <name>dfs.ha.namenodes.nsdcluster</name>                
//nn1,nn2名称固定，是内置的变量，nsdcluster里面有nn1，nn2
        <value>nn1,nn2</value>
    </property>
    <property>
        <name>dfs.namenode.rpc-address.nsdcluster.nn1</name>        
//声明nn1 8020为通讯端口，是hadoop1的rpc通讯端口
        <value>hadoop1:8020</value>
    </property>
    <property>
        <name>dfs.namenode.rpc-address.nsdcluster.nn2</name>        
//声明nn2是谁，hadoop2的rpc通讯端口
        <value>hadoop2:8020</value>
    </property>
    <property>
        <name>dfs.namenode.http-address.nsdcluster.nn1</name>    
//hadoop1的http通讯端口
        <value>hadoop1:50070</value>
    </property>
    <property>
        <name>dfs.namenode.http-address.nsdcluster.nn2</name>     
//hadoop1和hadoop2的http通讯端口
        <value>hadoop2:50070</value>
    </property>
    <property>
        <name>dfs.namenode.shared.edits.dir</name>        
//指定namenode元数据存储在journalnode中的路径
        <value>qjournal://node-0001:8485;node-0002:8485;node-0003:8485/nsdcluster</value>
    </property>
    <property>
        <name>dfs.journalnode.edits.dir</name>            
//指定journalnode日志文件存储的路径
        <value>/var/hadoop/journal</value>
    </property>
    <property>
        <name>dfs.client.failover.proxy.provider.nsdcluster</name>    
//指定HDFS客户端连接active namenode的java类
        <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>
    </property>
    <property>
        <name>dfs.ha.fencing.methods</name>                    //配置隔离机制为ssh
        <value>sshfence</value>
    </property>
    <property>
        <name>dfs.ha.fencing.ssh.private-key-files</name>    //指定密钥的位置
        <value>/root/.ssh/id_rsa</value>
    </property>
    <property>
        <name>dfs.ha.automatic-failover.enabled</name>        //开启自动故障转移
        <value>true</value>                
    </property>
</configuration>
```

3）配置yarn-site

```shell
[root@hadoop1 ~]# vim /usr/local/hadoop/etc/hadoop/yarn-site.xml
<configuration>
<!-- Site specific YARN configuration properties -->
    <property>
        <name>yarn.nodemanager.aux-services</name>
        <value>mapreduce_shuffle</value>
    </property>
    <property>
        <name>yarn.resourcemanager.ha.enabled</name>
        <value>true</value>
    </property> 
    <property>
        <name>yarn.resourcemanager.ha.rm-ids</name>        //rm1,rm2代表hadoop1和hadoop2
        <value>rm1,rm2</value>
    </property>
    <property>
        <name>yarn.resourcemanager.recovery.enabled</name>
        <value>true</value>
    </property>
    <property>
        <name>yarn.resourcemanager.store.class</name>
        <value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value>
    </property>
    <property>
        <name>yarn.resourcemanager.zk-address</name>
        <value>node-0001:2181,node-0002:2181,node-0003:2181</value>
    </property>
    <property>
        <name>yarn.resourcemanager.cluster-id</name>
        <value>yarn-ha</value>
    </property>
    <property>
        <name>yarn.resourcemanager.hostname.rm1</name>
        <value>hadoop1</value>
    </property>
    <property>
        <name>yarn.resourcemanager.hostname.rm2</name>
        <value>hadoop2</value>
    </property>
</configuration>
```



# 6. 启动服务，验证高可用

## 6.1 问题

本案例要求：

- 启动服务，验证高可用
- 分析数据时停止一个活跃节点
- 验证高可用状态及数据

## 6.2 步骤

实现此案例需要按照如下步骤进行。

**步骤一：hadoop高可用的验证**

1）同步到hadoop2，node-0001，node-0002，node-0003

```shell
[root@hadoop1 ~]# for i in {51..53} 56; do rsync -aSH --delete /usr/local/hadoop/ 192.168.1.$i:/usr/local/hadoop  -e 'ssh' & done
[1] 25411
[2] 25412
[3] 25413
[4] 25414
```

2）删除所有机器上面的/user/local/hadoop/logs，方便排错

```shell
[root@hadoop1 ~]# for i in {50..53} 56; do ssh 192.168.1.$i rm -rf /usr/local/hadoop/logs ; done
```

3）同步配置

```shell
[root@hadoop1 ~]# for i in {51..53} 56; do rsync -aSH --delete /usr/local/hadoop 192.168.1.$i:/usr/local/hadoop -e 'ssh' & done
[1] 28235
[2] 28236
[3] 28237
[4] 28238
```

4）初始化ZK集群

```shell
[root@hadoop1 ~]# /usr/local/hadoop/bin/hdfs zkfc -formatZK 
...
18/09/11 15:43:35 INFO ha.ActiveStandbyElector: Successfully created /hadoop-ha/nsdcluster in ZK    //出现Successfully即为成功
...
```

5）在node-0001，node-0002，node-0003上面启动journalnode服务（以node-0001为例子）

```shell
[root@node-0001 ~]# /usr/local/hadoop/sbin/hadoop-daemon.sh start journalnode 
starting journalnode, logging to /usr/local/hadoop/logs/hadoop-root-journalnode-node-0001.out
[root@node-0001 ~]# jps
29262 JournalNode
26895 QuorumPeerMain
29311 Jps
```

6）格式化，先在node-0001，node-0002，node-0003上面启动journalnode才能格式化

```shell
[root@hadoop1 ~]# /usr/local/hadoop//bin/hdfs  namenode  -format   
//出现Successfully即为成功
[root@hadoop1 hadoop]# ls /var/hadoop/
dfs
```

7）hadoop2数据同步到本地 /var/hadoop/dfs

```shell
[root@hadoop2 ~]# cd /var/hadoop/
[root@hadoop2 hadoop]# ls
[root@hadoop2 hadoop]# rsync -aSH  hadoop1:/var/hadoop/  /var/hadoop/
[root@hadoop2 hadoop]# ls
dfs
```

8）初始化 JNS

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs namenode -initializeSharedEdits
18/09/11 16:26:15 INFO client.QuorumJournalManager: Successfully started new epoch 1        //出现Successfully，成功开启一个节点
```

9）停止 journalnode 服务（node-0001，node-0002，node-0003）

```shell
[root@node-0001 hadoop]# /usr/local/hadoop/sbin/hadoop-daemon.sh stop journalnode
stopping journalnode
[root@node-0001 hadoop]# jps
29346 Jps
26895 QuorumPeerMain
```

**步骤二：启动集群**

1）hadoop1上面操作

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/start-all.sh  //启动所有集群
This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh
Starting namenodes on [hadoop1 hadoop2]
hadoop1: starting namenode, logging to /usr/local/hadoop/logs/hadoop-root-namenode-hadoop1.out
hadoop2: starting namenode, logging to /usr/local/hadoop/logs/hadoop-root-namenode-hadoop2.out
node-0002: starting datanode, logging to /usr/local/hadoop/logs/hadoop-root-datanode-node-0002.out
node-0003: starting datanode, logging to /usr/local/hadoop/logs/hadoop-root-datanode-node-0003.out
node-0001: starting datanode, logging to /usr/local/hadoop/logs/hadoop-root-datanode-node-0001.out
Starting journal nodes [node-0001 node-0002 node-0003]
node-0001: starting journalnode, logging to /usr/local/hadoop/logs/hadoop-root-journalnode-node-0001.out
node-0003: starting journalnode, logging to /usr/local/hadoop/logs/hadoop-root-journalnode-node-0003.out
node-0002: starting journalnode, logging to /usr/local/hadoop/logs/hadoop-root-journalnode-node-0002.out
Starting ZK Failover Controllers on NN hosts [hadoop1 hadoop2]
hadoop1: starting zkfc, logging to /usr/local/hadoop/logs/hadoop-root-zkfc-hadoop1.out
hadoop2: starting zkfc, logging to /usr/local/hadoop/logs/hadoop-root-zkfc-hadoop2.out
starting yarn daemons
starting resourcemanager, logging to /usr/local/hadoop/logs/yarn-root-resourcemanager-hadoop1.out
node-0002: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0002.out
node-0001: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0001.out
node-0003: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-node-0003.out
```

2）hadoop2上面操作

```shell
[root@hadoop2 hadoop]# /usr/local/hadoop/sbin/yarn-daemon.sh start resourcemanager
starting resourcemanager, logging to /usr/local/hadoop/logs/yarn-root-resourcemanager-hadoop2.out
```

3）查看集群状态

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn1
active
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn2
standby
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm1
active
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm2
standby
```

4）查看节点是否加入

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs dfsadmin -report
...
Live datanodes (3):    //会有三个节点
...
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn  node  -list
Total Nodes:3
         Node-Id         Node-State    Node-Http-Address    Number-of-Running-Containers
     node-0002:43307            RUNNING           node-0002:8042                               0
     node-0001:34606            RUNNING           node-0001:8042                               0
     node-0003:36749            RUNNING           node-0003:8042  
```

**步骤三：访问集群**

1）查看并创建

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hadoop  fs -ls  /
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hadoop  fs -mkdir /aa //创建aa
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hadoop  fs -ls  /        //再次查看
Found 1 items
drwxr-xr-x   - root supergroup          0 2018-09-11 16:54 /aa
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hadoop  fs -put *.txt /aa
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hadoop  fs -ls hdfs://nsdcluster/aa  
//也可以这样查看
Found 3 items
-rw-r--r--  2 root supergroup 86424 2018-09-11 17:00 hdfs://nsdcluster/aa/LICENSE.txt
-rw-r--r--  2 root supergroup 14978 2018-09-11 17:00 hdfs://nsdcluster/aa/NOTICE.txt
-rw-r--r--  2 root supergroup 1366 2018-09-11 17:00 hdfs://nsdcluster/aa/README.txt
```

2）验证高可用，关闭 active namenode

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn1
active
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/hadoop-daemon.sh stop namenode
stopping namenode
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn1      
//再次查看会报错
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn2  
//hadoop2由之前的standby变为active
active
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm1
active
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/yarn-daemon.sh stop resourcemanager  
//停止resourcemanager 
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm2
active
```

3） 恢复节点

```shell
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/hadoop-daemon.sh start namenode       
//启动namenode
[root@hadoop1 hadoop]# /usr/local/hadoop/sbin/yarn-daemon.sh start resourcemanager 
//启动resourcemanager
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn1      
//查看
[root@hadoop1 hadoop]# /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm1      
//查看
```



# Exercise

## 1 简述什么是Zookeeper以及其作用

什么是Zookeeper：

Zookeeper是一个开源的分布式应用程序协调服务



作用：

用来保证数据在集群间的事务一致性

## 2 简述Zookeeper角色与特性

Leader：接受所有Follower的提案请求并统一协调发起提案的投票，负责与所有的Follower进行内部数据交换

Follower：直接为客户端服务并参与提案的投票，同时与Leader进行数据交换

Observer：直接为客户端服务但并不参与提案的投票，同时也与Leader进行数据交换

## 3 如何利用 api 查看Zookeeper的状态

```shell
[root@nn01 conf]# /usr/local/zookeeper/bin/zkServer.sh start
[root@nn01 conf]# vim api.sh
#!/bin/bash
function getstatus(){
    exec 9<>/dev/tcp/$1/2181 2>/dev/null
    echo stat >&9
    MODE=$(cat <&9 |grep -Po "(?<=Mode:).*")
    exec 9<&-
    echo ${MODE:-NULL}
}
for i in node{1..3} nn01;do
    echo -ne "${i}\t"
    getstatus ${i}
done
[root@nn01 conf]# chmod 755 api.sh
[root@nn01 conf]# ./api.sh 
node1    follower
node2    leader
node3    follower 
nn01    observer
```

## 4 如何在Kafka集群里创建一个topic

```shell
[root@node1 local]# /usr/local/kafka/bin/kafka-topics.sh --create --partitions 1 --replication-factor 1 --zookeeper node3:2181 --topic aa    
Created topic "aa".
```



> 如有侵权，请联系作者删除





---

@[TOC]( Admin & Engineer & Services Topic | Cloud computing )

---

# Single Choice

1、podman运行容器映射端口命令格式为_____。
A.podman  run   -itd   -p  真机端口:容器端口    镜像名称:标签 
B.podman  run   -itd   -c  真机端口:容器端口    镜像名称:标签 
C.podman  run   -itd   -r  真机端口:容器端口    镜像名称:标签 
D.podman  run   -itd   -t  真机端口:容器端口    镜像名称:标签 
【答案】**A**

---

2、/tmp/存放的是_____文件。
A.内存中的映射文件，不占用磁盘 
B.系统运行中使用的临时文件 
C.日志文件 
D.硬盘，键盘，鼠标，等各种设备文件 
【答案】**B**

---

3、Apache的网页文件默认根目录是在_____。
A./etc/http/httpd/ 
B./etc/http/ 
C./var/www/html/ 
D./etc/httpd	 
【答案】**C**

---

4、在搭建PXE+kickstart无人值守安装服务器时，以下_____服务不是必须的。
A.FTP/HTTP/NFS 
B.DNS 
C.TFTP 
D.DHCP 
【答案】**B**
【解析】**PXE网络装机，首先是DHCP服务分配IP地址，然后又TFTP服务提供引导文件及菜单文件，最后再由FTP/HTTP/NFS提供操作系统的众多安装包**

---

5、在/etc目录（含子目录）下查找文件名包含"passwd"的文件，可以执行_____操作。
A.ls -A /etc | grep '*passwd*' 
B.ls  /etc | grep 'passwd' 
C.find /etc -name "passwd*" 
D.find /etc -name "*passwd*" 
【答案】D
【解析】**find本身会对查找路径，进行递归查找。grep命令本身默认为模糊匹配，不能用通配符**

---

6、在Linux系统中，以下_____命令可用来查找文件所在路径。
A.whoami 
B.grep 
C.find 
D.where 
【答案】**C**
【解析】**whoami显示当前用户，grep在文本文件内容过滤指定字符串， where无此命令**

---

7、在Linux系统中，若要查询文件 /etc/dovecot.conf 是由哪个RPM软件包安装的，可以使用_____命令。
A.yum provides /etc/dovecot.conf 
B.rpm –q /etc/dovecot.conf 
C.rpm –ql /etc/dovecot.conf 
D.yum list /etc/dovecot.conf 
【答案】**A**

---

8、创建用户时使用选项_____可指定用户id值。
A.-d  
B.-G 
C.-u 
D.-s  
【答案】**C**
【解析】**-d指定家目录，-s指定登录系统的解释器，-G指定附加组**

---

9、Windows查看IP地址的命令为_____。
A.ifconfig 
B.ipconfig 
C.ifconf 
D.ipconf 
【答案】**B**

---

10、列出网上NFS共享资源的命令为_____。
A.mount -e 服务器地址 
B.showmount -e 服务器地址 
C.showmount 服务器地址 
D.mount 服务器地址 
【答案】**B**
【解析】**showmount  -e  服务器地址**

---

11、启动DNS服务的命令是_____。
A.systemctl  start  bind-chroot 
B.systemctl  start  bind 
C.systemctl  start  DNS 
D.systemctl   start  named 
【答案】**D**

---

12、在一台Linux服务器上，使用Apache作为Web服务程序，服务器名称是www.a.com，管理员把所有对外提供的文档放在/usr/local/source目录下面，希望远程用户在浏览器中使用http://www.a.com地址即能访问这些文档，他需要对Apache进行_____设置。
A.修改Apache配置文件httpd.conf中的Listen的值为8000 
B.修改Apache配置文件httpd.conf中的DocumentRoot项值为“/usr/local/source” 
C.安装Apache服务器在/usr/local/目录下即可 
D.修改Apache配置文件httpd.conf中的ServerRoot项值为“/usr/local/source” 
【答案】**B**
【解析】**A选项安装目录与网页文件根路径无关，B选项指定httpd服务 配置文件根路径与网页文件根路径无关，D选项指定端口与网页文件根路径无关**

---

13、在常见的Linux日志文件中，以下哪个文件_____的作用是记录与系统启动相关的消息。
A./var/log/secure 
B./var/log/maillog 
C./var/log/dmesg 
D./var/log/messages 
【答案】**C**
【解析】**/var/log/messages记录各种服务公共消息，/var/log/secure记录用户登录安全相关，/var/log/maillog邮件收发相关信息**

---

14、光盘的系统类型为_____。
A.iso9600 
B.defaults 
C.iso9660 
D.xfs 
【答案】**C**
【解析】**xfs是RHEL7分区与系统常用的文件系统，iso9600无此 文件系统**

---

15、在Linux系统中配置httpd服务器时，设置项_____用来指定该Web服务器的站点名。
A.ServerRoot 
B.ServerAdmin 
C.DocumentRoot 
D.ServerName 
【答案】**D**
【解析】**DocumentRoot指定网页文件根目录，ServerAdmin指定管理员的邮箱，ServerRoot指定httpd配置文件根路径**

---

16、在Linux系统中，使用lvextend命令为指定的逻辑卷动态扩容以后，
通过df命令查看时该分区显示的大小并未变化，还需要进行_____操作以便系统能够更新ext4文件系统大小。
A.mount 
B.partprobe 
C.resize2fs 
D.lvscan 
【答案】**C**
【解析】**partprobe为刷新分区表，lvscan为查看逻辑卷信息，mount为mount 挂载**

---

17、在Linux 系统中，执行 tail –n 5 /var/log/messages 后得到的其中一行信息如下：  
Oct 29 13:19:48 web5 dhclient: DHCPACK from 192.168.8.254 (xid=0x7c.. ..)，其中的dhclient指的是_____。
A.主机名 
B.时间标签 
C.消息内容 
D.程序名 
【答案】**D**
【解析】**本题考查日志记录的格式，按照时间、地点、人物、发生的事件进行记录，在计算机中人物会写具体用户名或服务名、程序名，所以dhclinet为程序名**

---

18、下面关于列出内核版本命令正确的是_____。
A.cat   /proc/meminfo 
B.cat    /etc/redhat-release 
C.lscpu  
D.uname     -r 
【答案】**D**
【解析】**lscpu查看CPU信息，cat /etc/redhat-release是查看系统 具体版本，cat /proc/meminfo是查看内存信息，查看内核版本为 uname -r**

---

19、MBR分区最大支持_____个主分区。
A.128个 
B.3个 
C.64个 
D.4个 
【答案】**D**
【解析】**MBR分区表在硬盘中占用64字节空间，而每个主分区需要占用16字节空间，所以至多有4个主分区**

---

20、在Linux系统中，若执行 scp dumb bilbo@www.foobar.com: 命令，
可以实现_____功能？
A.将远程服务器www.foobar.com 上用户“bilbo”主目录下的一个名为 “dumb”的文件拷贝到本地计算机当前目录下，并且登录远程服务器上的账号名为 “bilbo” 
B.将本地计算机当前目录下的一个名为“dumb”的文档拷贝到远程主机www.foobar.com中用户 “bilbo”的主目录下 
C.将本地计算机“dumb”目录下所有的文件拷贝到远程服务器www.fobar.com的根目录下，并且登录远程服务器上的密码为“bilbo” 
D.将本地计算机当前目录下的一个名为“dumb”的文件发送到邮件 bilbo@www.foobar.com 
【答案】**B**

---

21、在Linux系统中，MBR分区模式第四块SCSI硬盘中的第三个逻辑分区表示为_____。
A./dev/sdd3 
B./dev/hda3 
C./dev/sdd7 
D./dev/sdc7 
【答案】**C**
【解析】**在MBR分区模式中，分区方案为前三个为主分区，第四个为扩展分区，第一逻辑分区为第五个分区，依次类推第七个分区为第三个逻辑分区**

---

22、UNIX诞生日是_____。
A.1970年1月1号 
B.1969年年底 
C.1973年 
D.1991年10月 
【答案】**A**
【解析】**UNIX操作系统诞生为1970-1-1**

---

23、配置Postfix邮件服务时，以下_____参数表示外发邮件时的发件域地址。
A.inet_interfaces 
B.mydomain 
C.myorigin 
D.mydestination 
【答案】**C**
【解析】**inet_interfaces指定网络接口，mydomain指定本机域名，mydestination指定收件人域名为本域邮件**

---

24、在Linux系统中，用来记录用户账号的用户名、家目录、登录Shell等信息的文件是_____。
A./root/.bashrc 
B./etc/shadow 
C./etc/bashrc 
D./etc/passwd 
【答案】**D**
【解析】**/etc/passwd存放用户基本信息，/root/.bashrc定义root自定义初始化信息例如别名定义、变量定义等，/etc/shadow保存用户密码信息，/etc/bashrc为全局配置文件**

---

25、创建卷组是指定PE大小的命令是_____。
A.lvextend  -s PE大小 卷组名  空闲分区 
B.vgextend -s PE大小 卷组名  空闲分区 
C.lvcreate -s PE大小 卷组名  空闲分区 
D.vgcreate -s PE大小 卷组名  空闲分区 
【答案】**D**
【解析】**lvcreate为创建逻辑卷，lvextend为扩展逻辑卷，在创建及扩展 逻辑卷时，均不能指定PE大小，vgextend为扩展卷组，扩展卷组时也不能指定PE大小**

---

26、下面关于IP地址的组成正确的是_____。
A.IP地址由32个十进制数组成 
B.IP地址由40个十进制组成 
C.IP地址由48个二进制数组成 
D.IP地址由32个二进制数组成 
【答案】**D**

---

27、在Linux系统中，使用命令rpm -e卸载软件包时，返回错误提示：
“Failed dependencies”，这可能是由于_____。
A.该软件包已不存在 
B.该软件包已存在 
C.该软件包与其他软件包之间存在依赖关系 
D.该软件包已损坏 
【答案】**C**
【解析】**报错信息为错误的依赖关系**

---

28、在Linux系统中配置防火墙策略时，通过_____命令设置默认区域为trusted。
A.firewall-cmd --default --zone=trusted 
B.firewall-cmd --permanent  --zone=trusted 
C.firewall-cmd --set-default-zone=trusted 
D.firewall-cmd --get-default-zone=trusted 
【答案】**C**

---

29、关于硬RAID实现的方式，以下说法正确的是_____。
A.主板—>操作系统—>磁盘—>阵列卡—>数据 
B.主板—>磁盘—>操作系统—>阵列卡—>数据 
C.主板—>磁盘—>阵列卡—>操作系统—>数据 
D.主板—>阵列卡—>磁盘—>操作系统—>数据 
【答案】**D**
【解析】**服务器是同过阵列卡来识别磁盘，识别硬盘后才可以安装操作系统或读取操作系统数据**

---

30、使用grep过滤时选项_____可以忽略大小写。
A.$  
B.^ 
C.-i 
D.-v  
【答案】**C**
【解析】**-v为取反查找，^为匹配以字符串开头，$为匹配以字符串结尾**

---

31、在Linux系统中，执行_____命令可以把/dev/sdb6格式化成交换分区。
A.format /dev/sdb6 
B.mkfs  -t  ext3  /dev/sdb6 
C.fdisk /dev/sdb6 
D.mkswap /dev/sdb6 
【答案】**D**

---

32、在Linux系统中，执行_____操作可以将/mail文件夹的属组设置为postfix。
A.chmod :postfix /mail 
B.chmod postfix /mail 
C.chown :postfix /mail 
D.groupmod postfix /mail 
【答案】**C**
【解析】**chmod无法修改归属关系，groupmod修改组账号属性的命令**

---

33、对于IP地址的分类，C类IP地址的范围是_____。
A.191至223 
B.192至224 
C.192至223 
D.190至223  
【答案】**C**
【解析】**IP地址分类A类为1-127，B类为128-191，C类为192-223， D类为224-239，E类为240-254**

---

34、若要删除用户lily且把她的宿主目录一起删除，可以执行_____命令。
A.userdel -r lily 
B.userdel -R lily 
C.userkill -d lily 
D.userkill -D lily 
【答案】**A**
【解析】**userkill无此命令，userdel -r为将用户家目录一并删除**

---

35、在配置DNS服务的时候，正向解析记录的资源类型是_____。
A.PTR 
B.A 
C.CNAME 
D.SOA 
【答案】**B**
【解析】**PTR代表方向解析记录，CNAME代表解析记录别名，SOA代表授权记录**

---

36、在Linux系统中，若要实现开机自动挂载文件系统，需要修改_____配置文件。
A./etc/fstab 
B./etc/mount 
C./etc/startup 
D./etc/auto.master 
【答案】**A**
【解析】**/etc/auto.master为autofs触发挂载配置文件**

---

37、使用命令_____可以查看后台所有的进程，并且输出进程的PID。
A.jobs -l 
B.bg 
C.jobs 
D.fg 
【答案】**A**

---

38、在Linux系统中从源代码安装软件时，编译的过程由_____操作完成。
A../configure 
B.make 
C.make all 
D.make install 
【答案】**B**

---

39、格式化swap分区时使用_____命令。
A.mkfs.ext4 分区设备路径 
B.mkfs.xfs 分区设备路径 
C.swapon  分区路径 
D.mkswap分区路径 
【答案】**D**
【解析】**mkfs.ext4格式化ext4文件系统，mkfs.xfs格式化xfs文件系 统，swapon为启用swap交换分区**

---

40、配置Postfix邮件服务时，通常应修改主配置文件_____。
A./etc/postfix/master.conf 
B./etc/postfix/main.cf 
C./etc/postfix/main.conf 
D./etc/postfix/mail.conf 
【答案】**B**

---

# Multiple Choice

41、vim编辑器中调到首行的快捷键是_____。
A.1G 
B.1g 
C.gg 
D.GG 
【答案】**A,C**
【解析】**GG跳转到末行，1g无作用**

---

42、以下_____属于Linux发行版本。
A.Red Hat Enterprise Linux 
B.IBM AIX 
C.Windows Server 2008 
D.CentOS 
【答案】**A,D**

---

43、selinux切换运行模式的方法是_____。
A.临时切换：setenforce  1或0 
B.临时切换：getenforce  1或0 
C.固定配置：/etc/selinux/config 文件 
D.固定配置：/etc/selinux/selinux.cnf 
【答案】**A,C**
【解析】**修改SELinux模式，两个方面临时修改与固定修改，临时修改通过命令setenforce而getenforce为查看不能达到修改，固定修改 需要修改/etc/selinux/config 文件**

---

44、关于Linux系统的常见目录，以下描述正确的是_____。
A./tmp是临时目录 
B./root目录是所有用户的家目录 
C./boot目录用来存放启动相关文件 
D./dev目录用来存放配置文件 
【答案】**A,C**

---

45、常见的数据库软件有_____。
A.MySQL 
B.SQL Server 
C.DB2 
D.virtualbox 
【答案】**A,B,C**

---

46、Apache虚拟主机的类型包括_____。
A.基于路由的虚拟主机 
B.基于端口的虚拟主机 
C.基于域名的虚拟主机 
D.基于ip的虚拟主机 
【答案】**B,C,D**
【解析】**虚拟Web主机没有基于路由的类型**

---

47、selinux的运行模式有_____。
A.disabled 
B.enable 
C.enforcing 
D.permissive 
【答案】**A,C,D**
【解析】**SELinux无enable模式**

---

48、关于Linux命令行环境的通配符，以下描述正确的是_____。
A.* 匹配单个字符 
B.？匹配任意多个字符 
C.[a-z] 匹配连续多个字符a-z中的一个 
D.{a,min,xy} 分别匹配不连续的a,min,xy多组字符 
【答案】**C,D**
【解析】***匹配任意多个字符，？匹配单个字符**

---

49、把命令cp /ISO/1.txt /mnt无论状态如何，放入后台的命令是_____。
A.快捷键Ctrl+z 
B.cp /ISO/1.txt  /mnt& 
C.cp /ISO/1.txt  /mnt $ 
D.Ctrl+C 
【答案】**A,B**

---

50、(多选题)安装源码包时需要安装编译工具有_____。
A.make 
B.C++	 
C.g++ 
D.gcc 
【答案】**A,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Cluster & Security & Python Topic | Cloud computing )

---

# Single Choice

1、程序如下：

```shell
try:
    number = int(input("请输入数字："))
    print("number:",number)
    print("=======hello======")
except Exception as e:
    # 报错错误日志
    print("打印异常详情信息： ",e)
else:
    print("没有异常")
finally:#关闭资源
    print("finally")
print("end")
```

输入的是 1a 结果是_____。
A.

```shell
number: 1
打印异常详情信息：  invalid literal for int() with base 10:
finally
End 
```

B.

```shell
打印异常详情信息：  invalid literal for int() with base 10:
finally
End 
```

C.

```shell
========hello===========
打印异常详情信息：  invalid literal for int() with base 10:
finally
End 
```

D.以上都正确 
【答案】**B**

---

2、能够返回当前时间戳的方法是_____。
A.time.strftime() 
B.time.ctime() 
C.time.localtime() 
D.time.time() 
【答案】**D**

---

3、下列选项中_____是Zabbix_server服务默认监听的端口号。
A.10050 
B.10500 
C.10055 
D.10051 
【答案】**D**

---

4、在使用passwd命令时，下列_____选项可以查看账户的密码状态。
A.-U 
B.-S 
C.-L 
D.-M 
【答案】**B**

---

5、Zabbix监控获得的数据信息存放在了_____。
A.mysql 
B.excel 
C.zabbix.log 
D.zabbix.conf 
【答案】**A**

---

6、在使用passwd命令时，下列_____选项可以锁定账户。
A.-S 
B.-l 
C.-L 
D.-U 
【答案】**B**

---

7、下列_____语句在Python中是非法的。
A.x  +=  y 
B.x, y = y, x 
C.x = (y = z + 1) 
D.x = y = z = 1 
【答案】**C**

---

8、用户使用_____命令生成登录sshd服务的秘钥对。
A.gpg 
B.md5sum 
C.ssh-keygen 
D.openssl 
【答案】**C**

---

9、有关进程和线程说法错误的是_____。
A.线程的执行离不开进程的资源调度 
B.线程是程序执行的最小单位 
C.一个进程当中可以没有线程也可以包含一个或多个线程 
D.进程是争夺CPU资源的最小单位 
【答案】**C**

---

10、有如下列表：users = [('tom', 20), ('jerry', '19')] 使用_____选项可以取出jerry 。
A.users[1] 
B.users[1][0] 
C.users[0] 
D.users[-1][1] 
【答案】**B**

---

11、print()函数打印多项内容时，默认用空格分隔输出的各项。如果使用---替换空格，正确的参数是_____。
A.start='---' 
B.seq='---' 
C.sep='---' 
D.end='---' 
【答案】**C**

---

12、关于多线程编程，下面说法正确的是_____。
A.一个进程可以产生一到多个线程 
B.线程与进程完全一样，只是不同的称呼 
C.Python中主要使用Thread模块来实现多线程编程 
D.每个线程都有自己独立的运行空间 
【答案】**A**

---

13、在使用chage命令时，下列_____选项可以实现用户首次登陆系统
强制修改密码的功能。
A.-d 
B.-l 
C.-W 
D.-E 
【答案】**A**

---

14、关于模块导入，下面说法确的是_____。
A.模块不管导入（import）多少次，只会加载（load）一次 
B.为了防止循环导入，两个模块不能互相import 
C.多次导入模块，以最后一次导入为准 
D.只有管理员有权限导入模块 
【答案】**A**

---

15、使用字符串的_____方法，用于去除字符串左端的空白字符。
A.strip 
B.trim 
C.ltrim 
D.lstrip 
【答案】**D**

---

16、下列关于类的方法错误的是_____。
A.子类当中只能继承父类的普通方法，不能继承初始化方法 
B.对象是类的实例 
C.类是用来描述具有相同的属性和方法的对象的集合 
D.方法是类中定义的函数 
【答案】**A**
【解析】**从类中定义的方法必须和类或对象有关 改成 子类当中只能继承父类的普通方法，不能继承初始化方法**

---

17、使用nmap命令对目标主机做TCP SYN扫描半开式扫描，使用_____选项。
A.-sS 
B.-sT 
C.-sP 
D.-sU 
【答案】**A**
【解析】**nmap命令的选项中-sT是做tcp扫描，-sU是做udp扫描，-sS是 半开扫描（不执行完整的3次握手4次断开）**

---

18、有以下代码：

```shell
if -0.0:
    print('yes')
else:
    print('no')
```

程序的运行结果是_____。
A.no 
B.yes 
C.0 
D.报错 
【答案】**A**

---

19、关于函数的返回值，下面说法错误的是_____。
A.函数内部可以出现多个return语句 
B.函数可以通过return返回多个值 
C.函数没有明确的返回值，则返回None 
D.函数通过return进行返回 
【答案】B

---

20、list(range(0, 10, 2))产生的值是_____。
A.[2, 4, 6, 8] 
B.[0, 2, 4, 6, 8] 
C.[2, 4, 6, 8, 10] 
D.[0, 2, 4, 6, 8, 10] 
【答案】**B**

---

21、有关匿名函数，下面说法正确的是_____。
A.匿名函数没有返回值 
B.匿名函数的多行语句通过逗号分隔 
C.匿名函数不支持参数 
D.通过关键字lambda定义匿名函数 
【答案】**D**

---

22、程序执行期间，用户按下ctrl + c，将会触发_____异常。
A.KeyboardInterrupt 
B.ValueError 
C.NameError 
D.EOFError 
【答案】**A**

---

23、给文件添加_____属性后，仅可以使用追加的方式向文件内添加新内容。
A.a 
B.e 
C.i 
D.s 
【答案】**A**
【解析】**+i锁定文件，+a仅可追加**

---

24、创建两个集合s1 = set('abc'); s2 = set('bcd')，那么s1 | s2的结果是_____。
A.{'bc'} 
B.{'b', 'c'} 
C.{'a'} 
D.{'a', 'b', 'c', 'd'} 
【答案】**D**

---

25、下列选项中作为Zabbix_agentd服务监听的端口号是_____。
A.10051 
B.10500 
C.10055 
D.10050 
【答案】**D**
【解析】**zabbix_agent默认是10050，zabbix_server默认是 10051**

---

26、下列选项中_____是Zabbix_agentd服务的主配置文件。
A.zabbix.conf 
B.zabbix_server.conf 
C.zabbix_agent.conf 
D.zabbix_agentd.conf 
【答案】**D**

---

27、关于OOP中self的说法正确的是_____。
A.self代表实例本身 
B.class中所有方法的self都是可有可无的 
C.只有创建实例对象时，才会用到self 
D.self是关键字 
【答案】A

---

28、以下不能创建一个字典的语句是_____。
A.dict4 = {(1,2,3): "uestc"} 
B.dict1 = {} 
C.dict2 = { 3 : 5 } 
D.dict3 = {[1,2,3]: "uestc"} 
【答案】**D**

---

29、通过pickle模块将字典data写入文件fobj的方法是_____。
A.pickle.dump(fobj, data) 
B.pickle.dump(data, fobj) 
C.pickle.load(fobj, data) 
D.pickle.load(data, fobj) 
【答案】**B**

---

30、以下表达式可以正确的运行的有_____。
A.(123, 456) + 123 
B.[123, 456] + 123 
C.(123) + 123 
D.'abc' + 123 
【答案】**C**

---

31、以下表达式，正确定义了一个集合数据对象的是_____。
A.x = [ 200, ’flg’, 20.3 ] 
B.x = {‘flg’ : 20.3} 
C.x = ( 200, ’flg’, 20.3) 
D.x = { 200, ’flg’, 20.3} 
【答案】**D**

---

32、有如下函数声明：def fn(name, age): pass。下面方法使用正确的是_____。
A.fn('tom', 'jerry', 20) 
B.fn('tom') 
C.fn(name='tom', 20) 
D.fn('tom', age=20) 
【答案】**D**

---

33、关于循环语句说法正确的是_____。
A.循环如果执行了continue，它的else语句不会执行 
B.循环如果被break结束，它的else语句将会执行 
C.循环如果执行了continue，它的else语句将会执行 
D.循环如果被break结束，它的else语句不会执行 
【答案】**D**

---

34、下面有关hashlib模块计算md5值，说法错误的是_____。
A.只要原始数据有微小改动，md5值一定大不相同 
B.hashlib.md5()函数中的参数类型是字节串类型 
C.hashlib模块在使用前需要先下载，再导入 
D.md5值一般使用16进制数表示 
【答案】**C**

---

35、小王执行n = input("number: ")语句时，输入了10。运行结果为15的是_____。
A.n + 5 
B.n + str(5) 
C.int(n) + 5 
D.str(n) + 5 
【答案】**C**

---

36、'to' in 'python'的结果是_____。
A.True 
B.yes 
C.False 
D.no 
【答案】**C**

---

37、使用nmap暴力破解ssh密码的脚本是_____。
A.ssh-passwd.nse 
B.sshd-brute.nse 
C.sshd-passwd.nse 
D.ssh-brute.nse 
【答案】**D**

---

38、有以下代码：

```shell
if [5 > 10]:
    print('yes')
else:
    print('no')
```

程序的运行结果是_____。
A.True 
B.False 
C.yes 
D.no 
【答案】**C**

---

39、使用tcpdump命令抓包时，要求多个条件必须同时匹配使用_____选项。
A.and 
B.not 
C.or 
D.host 
【答案】**A**
【解析】**and代表逻辑与，or代表逻辑或**

---

40、以下叙述正确的是_____。
A.else只能和if连用，不能和循环语句连用 
B.在循环体内使用break语句或continue语句的作用相同 
C.只能在循环体内使用break语句 
D.continue语句的作用是结束整个循环的执行 
【答案】**C**

---

# Multiple Choice

41、以下字符串格式正确的有_____。
A.“abc”ab” 
B.“abc\nab” 
C.‘abc”ab’ 
D.‘abc”ab” 
【答案】**B,C**

---

42、下列软件能够提供监控服务有_____。
A.Cacti  
B.Nagios 
C.Zabbix 
D.nmap 
【答案】**A,B,C**
【解析】**常用监控软件有：cacti、nagios、zabbix**

---

43、以下可以生成192.168.1.1~192.168.1.254整个范围内的所有IP地址有_____。
A.['192.168.1.%s'  %  i  for  i  in  range(1, 254)] 
B.['192.168.1.%s'  %  i  for  i  in  range(1, 255)] 
C.['192.168.1.'  +  str(i)  for  i  in  range(1, 254)] 
D.['192.168.1.'  +  str(i)  for  i  in  range(1, 255)] 
【答案】**B,D**

---

44、zabbix监控服务，发送监控报警消息的方式有_____。
A.邮件 
B.短信 
C.只能使用邮件发送报警消息 
D.打电话 
【答案】**A,B**
【解析】**Zabbix支持短信和邮件发送报警信息**

---

45、有一个字典adict = {'name': 'bob', 'age': 23}，以下说法正确的有_____。
A.通过adict['name']可以取出bob 
B.字典长度为2 
C.通过adict[0]可取出字典中的第一个元素 
D.字典的长度为4 
【答案】**A,B**

---

46、有如下列表：users = ['tom', 'jerry', 'jack', 'rose']。可以取出rose的选项有_____。
A.users[4] 
B.users[-1] 
C.users[0] 
D.users[3] 
【答案】**B,D**

---

47、a = (10, 20, 30)，则a属于_____类型。
A.顺序 
B.不可变 
C.映射 
D.标量 
【答案】**A,B**

---

48、下列选项中是对称加密算法有_____。
A.AES 
B.RSA 
C.DES 
D.DSA 
【答案】**A,C**
【解析】**AES和DES是对称算法，RSA和DSA是非对称算法**

---

49、可以使用shutil的_____方法拷贝文件。
A.copy 
B.copyfileobj 
C.move 
D.copytree 
【答案】**A,B**

---

50、Prometheus有哪些组件？ 
A.PHP 
B.Node_exporter 
C.MySQL 
D.Prometheus server 
【答案】**B,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Cluster Topic | Cloud computing )

---

# Single Choice

1、ipvsadm命令使用_____选项添加真实服务器。
A.-a 
B.-A 
C.-r 
D.-g 
【答案】**A**

---

2、ipvsadm命令使用_____选项创建虚拟服务器。
A.-g 
B.-a 
C.-A 
D.-r 
【答案】**C**

---

3、ipvsadm命令使用_____选项设置NAT工作模式。
A.-i 
B.-n 
C.-m 
D.-g 
【答案】**C**

---

4、下面_____关键词用来描述集群后端的真实服务器IP地址。
A.RIP 
B.VIP 
C.DIP 
D.CIP 
【答案】**A**

---

5、ipvsadm命令使用_____选项设置DR工作模式。
A.-m 
B.-n 
C.-i 
D.-g 
【答案】**D**

---

6、CentOS7系统中ISCSI属于_____类型的存储。
A.块存储
B.文件系统存储
C.直连存储
D.对象存储
【答案】**A**

---

7、keepalived的配置文件中使用_____表示主服务器。
A.MAIN 
B.BACKUP 
C.SLAVE 
D.MASTER 
【答案】**D**

---

8、keepalived的配置文件中使用_____表示从服务器。
A.MASTER 
B.SLAVE 
C.BACKUP 
D.MAIN 
【答案】**C**

---

9、使用_____工具可以自动化部署ceph集群环境。
A.ceph-push 
B.ceph-install 
C.ceph-admin 
D.ceph-deploy 
【答案】**D**

---

# Multiple Choice

10、常见的集群分类有_____。
A.高可用集群 
B.负载均衡集群 
C.高配置集群 
D.高性能集群 
【答案】**A,B,D**

---

11、常见的存储类型有_____。
A.块存储
B.文件系统存储
C.无盘存储
D.对象存储
【答案】**A,B,D**

---

12、下面HTTP状态码_____表示连接被重定向。
A.301 
B.500 
C.302 
D.200 
【答案】A,C

---

13、keepalived支持的健康检查有_____。
A.对URL检查 
B.对TCP连接检查 
C.对mac地址检查 
D.对服务名称检查 
【答案】**A,B**

---

14、LVS有的工作模式有_____。
A.TUN模式 
B.DR模式 
C.PAT模式 
D.NAT模式 
【答案】**A,B,D**

---

15、LVS常见调度算法有_____。
A.加权轮询 
B.RSA算法 
C.最少连接 
D.轮询 
【答案】**A,C,D**

---

16、Ceph支持的存储类型有_____。
A.NFS存储 
B.文件系统存储 
C.对象存储 
D.块存储 
【答案】**B,C,D**

---

17、Ceph组件有_____。
A.OSDs 
B.Monitors 
C.MDs 
D.ntp 
【答案】**A,B,C**

---

18、HaProxy支持下面的调度有_____。
A.4层调度
B.2层调度
C.7层调度
D.3层调度
【答案】**A,C**

> 如有侵权，请联系作者删除



﻿@[TOC]( Network & Shell & Operation & Automation Topic | Cloud computing )

---

# Single Choice

1、在Shell脚本中，若要屏蔽终端的输出默认显示功能，可以执行_____命令。
A.set  tty   -echo 
B.stty -echo 
C.-echo 
D.stty echo 
【答案】**B**
【解析】**read -p默认读取的密码为明文，通过stty -echo可以防止密码输出**

---

2、使用test进行条件判断，测试两个数字的关系时，小于用_____表示。
A.-lt 
B.-gt 
C.-eq 
D.-ge 
【答案】**A**
【解析】**-lt是小于，-gt是大于，-ge是大于等于，-eq是等于**

---

3、如果abc=3 ，不能使循环任务执行3次的是_____。
A.for i in {1..\$abc} 
B.for i in seq \$ abc 
C.for i in echo \$ abc 
D.for i in \`seq \$abc\` 
【答案】**A**
【解析】**{1..\$abc}在for循环的值中只会被识别为1个整体，循环任务也只是1次**

---

4、关于变量，以下描述不正确的是_____。
A.变量名区分字母大小写 
B.变量名称可以使用字母、数字、下划线 
C.使用export可设置全局变量 
D.变量名不区分字母大小写 
【答案】**D**
【解析】**变量名可以是字母、数字、下划线（不能数字开始），变量名区 分大小写**

---

5、如果输入who命令后查看的结果为两行，执行[ \$(who | wc -l) -ge 3 ] && echo "ok" || echo "no" 会显示_____。
A.无显示 
B.3 
C.ok 
D.no 
【答案】**D**
【解析】**-ge在条件测试中表示大于等于，判断失败后不执行&&后的任务，结果为||前任务失败，会执行||后任务**

---

6、以下_____可以重新加载nginx配置文件。
A.reload 
B.restart 
C.stop 
D.start 
【答案】**A**
【解析】**nginx -s reload**

---

7、在正则表达式中，符号 *  [ ]  ? 分别代表的含义是_____。
A.匹配前面字符出现任意次，集合，匹配前面字符出现0~1次 
B.匹配前面字符出现任意次，组合为整体，匹配前面字符出现0~1次 
C.匹配任意，组合为整体，匹配前面字符出现1~多次 
D.匹配任意，集合，匹配前面字符出现0~1次 
【答案】**A**

---

8、_____关键词配置可以实现nginx地址重写。
A.reset 
B.remake 
C.rewrite 
D.release 
【答案】**C**

---

9、Shell脚本中，使用_____语句可以直接退出脚本。
A.q 
B.exit 
C.kill 
D.quit 
【答案】**B**
【解析】**break中断整个循环，continue中断当前一次循环，exit中断整个脚本**

---

10、在命令行中执行如下命令： 
#sed '2d' a.txt 
关于最后的执行结果，以下描述正确的是_____。
A.从文件的第2行开始删除至最后一行 
B.共删除1行 
C.删除文件中的第1~2行 
D.命令语法格式错误 
【答案】**B**
【解析】**2d代表删除第2行，也就是共删除1行**

---

11、启动nginx程序时，其命令选项_____可用于查看版本信息。
A.-c 
B.-t 
C.-V 
D.-s 
【答案】**C**
【解析】**-V选项用于查看版本信息以及编译选项的信息**

---

12、memcached服务的作用是_____。
A.可以解析域名 
B.可以搭建网站 
C.可以存储数据 
D.可以解析动态网站 
【答案】**C**
【解析】**memcached是个数据库服务，可以用内存存储数据**

---

13、awk命令使用_____变量存储行号。
A.NF 
B.NR 
C.NU 
D.NP 
【答案】**B**
【解析】**awk中NR代表当前行，NF代表当前行有几列**

---

14、Linux命令行中，对多个命令进行逻辑分隔时，仅前一个命令不成功才执行下一个命令，应该使用_____分隔符。
A.& 
B.%% 
C.&& 
D.|| 
【答案】**D**
【解析】**&&仅前一个命令成功才执行后一个命令 ||仅前一个命令失败才执行后一个命令**

---

15、在命令行中执行如下命令 
#sed  -i  '1~2d' a.txt  
关于最后的执行结果，以下描述正确的是_____。
A.删除文件中的前2行 
B.删除文件中的第2行 
C.删除文件中的奇数行 
D.删除文件中的第1行和第2行 
【答案】**C**
【解析】**sed使用行定位操作对象时，1~2表示1，3，5，7… 2是步长**

---

16、Shell脚本中可以进行小数运算的命令工具是_____。
A.gc 
B.bc 
C.ac 
D.tc 
【答案】**B**
【解析】**bc命令支持小数运算**

---

17、在awk指令中出现的BEGIN{ }任务会执行_____次。
A.3次 
B.1次 
C.2次 
D.4次 
【答案】**B**
【解析】**BEGIN{ }任务只会执行一次**

---

18、使用_____工具可以对Web服务器进行压力测试。
A.ab 
B.web 
C.test 
D.press 
【答案】**A**
【解析】**对web进行压力测试的软件很多，ab是其中之一**

---

19、对指awk 'BEGIN{x=100}{x++}END{print x}'令描述错误的是_____。
A.BEGIN中的任务只会执行1次 
B.如果BEGIN中的任务在执行完后无任何变化则不会执行END任务 
C.END中的任务只会执行1次 
D.中间的{ }任务执行次数与被处理文档的行数有关 
【答案】**B**
【解析】**BEGIN中的任务执行之后无论是否有变化不会影响END任务的执行**

---

20、使用stty –echo命令后，以下错误的是_____。
A.敲击任何按键将无任何输出 
B.仅输入命令时无输出，但执行命令后可以看到结果 
C.stty echo可以恢复正常 
D.不影响其他命令的执行结果 
【答案】A
【解析】输入命令后按回车键可以看到输出

---

21、有可能查看到单词good的搜索方式是_____。
A.grep –E "goo{0,2}d" 
B.grep "goo+d" 
C.grep "goooo*d" 
D.grep "go{2}d" 
【答案】**A**
【解析】**+与{}均属于扩展正则，grep需要使用-E支持**

---

22、使用sed修改test.txt可以实现永久效果的是_____。
A.sed -n 's/a/b/' test.txt 
B.sed -r 's/a/b/' test.txt 
C.sed -i 's/a/b/' test.txt 
D.sed -F 's/a/b/' test.txt 
【答案】**C**
【解析】**在sed中-i选项可以修改并保存入文件**

---

23、Shell脚本中使用_____命令可以对数据进行排序。
A.sort  
B.sed 
C.uniq 
D.more 
【答案】**A**
【解析】**Linux中sort命令可以将数据排序**

---

24、若执行如下命令 
#head  -5  /etc/passwd  |  awk -F: 'END{print NR,NF}'   
则最后输出的结果是_____。
A.1   7 
B.4   5 
C.3   6 
D.5   7 
【答案】**D**
【解析】**awk的END{}指令仅在读取完文件后才执行，所以NR当前行的 行号为5，NF为列共7列**

---

25、下面关于ansible描述错误的是_____。
A.ansible支持自定义模块 
B.ansible是基于ssh架构 
C.ansible不支持自定义模块 
D.ansible支持对windows进行自动化管理 
【答案】**C**
【解析】**ansible支持对windows的自动化管理；支持自定义模块；默认是基于ssh协议进行远程管理**

---

26、执行ls -l /opt/test.txt 命令后显示的结果是
---------- 1 root root 33139 12-11 10:43 /opt/test.txt
则以下_____命令会显示ok。
A.[root@svr5 ~]$ [ -r "/opt/test.txt" ] && echo "ok" 
B.[root@svr5 ~]# [ -x "/opt/test.txt" ] && echo "ok" 
C.[root@svr5 ~]# [ -r "/opt/test.txt" ] || echo "ok" 
D.[root@svr5 ~]# [ -r "/opt/test.txt" ] && echo "ok" 
【答案】**D**
【解析】**读写权限对root无限制**

---

27、关于命令 hostname=www.tarena.com; echo \${hostname\%\%.*} 的执行结果，以下描述正确的是_____。
A.tarena.com 
B.com 
C.www.tarena 
D.www 
【答案】**D**
【解析】**echo ${变量#}可以掐头；echo ${变量%}可以去尾**

---

28、sudo的配置文件是_____。
A./etc/visudoer 
B./etc/visudoers 
C./etc/sudoer 
D./etc/sudoers 
【答案】**D**
【解析】**主配置文件是/etc/sudoers**

---

29、使用export命令发布全局变量，错误的是_____。
A.执行export a=100后，在当前命令行输入bash指令后查看$a则显示100 
B.执行export a=100后，使用另一台计算机远程该服务器查看$a则无任何内容 
C.export –n a 可以取消变量a的全局效果，恢复为局部效果 
D.export –n a 可以取消变量a的定义 
【答案】**D**
【解析】**export –n 不可以取消变量的定义，只能恢复为局部效果**

---

30、若执行 head -5 /etc/passwd | awk '{i++}END{print i}'  操作，
输出的结果是_____。
A.1 
B.0 
C.没有值 
D.5 
【答案】**D**
【解析】**awk读取一行执行一次i++，读取5行后i的值为5**

---

31、Nginx配置文件中_____指令可以定义客户端浏览器缓存数据的时间。
A.ttl 
B.cached 
C.expires 
D.time 
【答案】**C**
【解析】**expires 30d可以设置缓存30天**

---

32、Linux操作系统对能够打开的最大文件数量进行了限制，默认为1024，通过_____命令可以调整这个限制。
A.ulimit 
B.limit 
C.glimit 
D.climit 
【答案】**A**
【解析】**ulimit -n可以修改最大文件数量**

---

33、Shell脚本中使用，_____命令可以取消一个已经定义的变量。
A.unset 变量名 
B.clear 变量名 
C.set 变量名 
D.delete 变量名 
【答案】**A**
【解析】**取消变量可以使用unset命令**

---

34、grep "[^0-9]"可以搜索到_____。
A.可以搜索含有数字之外内容的行 
B.不可以搜索到数字0和9 
C.可以搜索含有数字的行 
D.可以搜索到数字0和9 
【答案】**A**
【解析】**[ ] 在正则表达式中代表集合，内加^代表取反查找​​​​​​​**

---

35、命令行如下命令：
x=10;y=\${x:-30};echo \$y，其输出结果是_____。
A.0 
B.无值 
C.10 
D.30 
【答案】**C**
【解析】**\${x:-30}这个是看x有没有值，有值就返回x的值，没有就 返回30**

---

36、在memcached服务查看数据的指令是_____。
A.new 
B.write 
C.flush 
D.get 
【答案】**D**
【解析】**set写数据，get查数据。**

---

37、Linux命令行中，对多个命令进行逻辑分隔时，仅前一个命令成功才执行下一个命令，应该使用_____分隔符。
A.& 
B.% 
C.&& 
D.| 
【答案】**C**
【解析】**&&仅前一个命令成功才执行后一个命令 ||仅前一个命令失败才执行后一个命令**

---

38、使用什么（  　）指令可以清空memcached数据库中的所有数据。
A.flush 
B.delete_all 
C.flush_all 
D.delete 
【答案】**C**
【解析】**执行flush_all命令可以清空所有memcached数据**

---

39、若执行如下命令 
x=10;unset x;y=\${x:-30};echo \$y  
则最后的输出结果是_____
A.10 
B.0 
C.30 
D.无值 
【答案】**C**
【解析】**\${x:-30}这个是看x有没有值，有值就返回x的值，没有就返回30**

---

40、Tomcat中_____关键词表示一个虚拟主机。
A.server 
B.Host 
C.service 
D.Engine 
【答案】**B**
【解析】**Tomcat中每个Host就是一个虚拟主机**

---

# Multiple Choice

41、awk命令支持有条件地执行某些指令，仅当条件满足时才执行{}中的指令，awk支持_____判断条件。
A.字符判断 
B.文件大小判断 
C.正则判断 
D.数字判断 
【答案】**A,C,D**
【解析】**awk支持==,!=,>,>=等方式，但没有直接判断文件大小的条件**

---

42、awk命令中条件判断的”并且”和”或者”分别使用_____表示。
A.|| 
B.& 
C.&& 
D.| 
【答案】**A,C**
【解析】**&&代表并且，||代表或者**

---

43、持续集成包含_____流程。
A.Test 
B.Deploy 
C.Build 
D.Merge 
【答案】**A,C,D**

---

44、目前支持JAVA的Web服务器有_____。
A.Tomcat 
B.Jboss 
C.Websphere 
D.Weblogic 
【答案】**A,B,C,D**
【解析】**Tomcat（apache），JBoss（Redhat），Websphere（IBM），Weblogic（Oracle）**

---

45、下列关于Shell脚本中的if判断语句，说法正确的是_____。
A.支持多分支条件判断 
B.仅支持单分支条件判断 
C.支持单分支条件判断 
D.不支持多分支条件判断 
【答案】**A,C**
【解析】**shell的if判断支持单分支、双分支、多分支判断**

---

46、命令_____可以实现彩色字体的输出。
A.echo -e "\033[31mXYZ" 
B.echo -e "\033[31mXYZ\033[0m" 
C.echo -e \033[31mXYZ\033[0m 
D.echo  "\033[31mXYZ\033[0m" 
【答案】**A,B**
【解析】**使用echo处理特殊字符时需要加-e选项，之后内容需要用双引号包围**

---

47、Ansible支持_____类型的变量。
A.Host facts变量 
B.Playbook变量 
C.Inventory变量 
D.位置变量 
【答案】**A,B,C**

---

48、如下_____命令，可以对变量i进行自加2的操作。
A.let ++i 
B.let i=i+2 
C.let i+=2 
D.let i++  
【答案】**B,C**
【解析】**let i+=2是let i=i+2的简写，两者都支持自加2**

---

49、在ansible剧本中_____是与变量有关的键词定义。
A.vars 
B.vars_files 
C.par_prompt 
D.parameter 
【答案】**A,B**
【解析】**在剧本中可以通过vars定义变量；通过vars_prompt定义提示变量**

---

50、下面关于YAML文件描述正确的有_____。
A.数组使用-标识 
B.键值对使用:标识 
C.不能使用tab键缩进 
D.支持tab键缩进 
【答案】**A,B,C**


> 如有侵权，请联系作者删除



@[TOC]( Network & Shell Topic | Cloud computing )

---

# Single Choice

1、对shell脚本中使用函数描述错误的是_____。
A.将重复指令定义成公共语句块 
B.使脚本代码更加简洁，增强易读性 
C.函数的定义语句必须出现在调用之后 
D.提高Shell脚本的执行效率 
【答案】**C**

---

2、下列_____命令是跳出循环体，执行循环之后的任务。
A.break 
B.quit 
C.continue 
D.exit 
【答案】**A**

---

3、重定向输入的符号是_____。
A.<> 
B.> 
C.< 
D.>< 
【答案】**C**

---

4、取消变量的命令是_____。
A.set 
B.define 
C.unset 
D.undefine 
【答案】**C**

---

5、执行i=2;let i++;echo $i命令后，i的值是_____。
A.4 
B.1 
C.2 
D.3 
【答案】**D**

---

6、一个刚刚安装好的centos系统，在未做任何修改的情况下执行下列命令，结果为0的是_____。
A.[ -f /etc ] && echo $? 
B.[ -e /etc ] || echo $? 
C.[ -d /etc ] && echo $? 
D.[ -r /etc ] || echo $? 
【答案】**C**

---

7、如果要将正常输出与错误输出重定向同一个文件，可使用_____。
A.>> 
B.2> 
C.2>> 
D.&> 
【答案】**D**

---

8、在linux系统中使用ping命令，可以定义次数与间隔时间的选项是_____。
A.-c , -i 
B.-i , -c 
C.-c , -w 
D.-i , -W 
【答案】**A**

---

9、正则表达式中_____符号代表开始。
A.$ 
B.^ 
C.# 
D.u 
【答案】**B**

---

10、下列_____是字符串截取的语法格式。
A.\${变量名/起始位置/长度} 
B.\${变量名#起始位置#长度} 
C.\${变量名\%起始位置\%长度} 
D.\${变量名:起始位置:长度} 
【答案】**D**

---

11、如果要获取0~200以内的随机数，正确的命令行是_____。
A.echo \$[RANDMO\%200] 
B.echo \$[RANDOM\%200] 
C.echo \$[RANDOM\%0~200] 
D.echo \$[RANDOM\%201] 
【答案】**D**

--
12、正则表达式中_____符号代表对集合取反。
A.[^] 
B.[\$] 
C.[@] 
D.[&] 
【答案】**A**

---

13、使用\${变量:开始位置:长度}截取字符串时起始位置从_____开始。
A.2 
B.3 
C.1 
D.0 
【答案】**D**

---

14、grep命令在筛选信息后保持沉默的选项是_____。
A.-a 
B.-p 
C.-q 
D.-n 
【答案】**C**

---

15、如果变量a的值为空，那么可以输出123的命令行是_____。
A.echo \$a 
B.echo \${a:-123} 
C.echo \${a:123} 
D.\${a:-123} 
【答案】**B**

---

16、_____是合格的自定义变量。
A.123a=100 
B.abc#=100 
C.abc_123=100 
D.abc-123=100 
【答案】**C**

---

17、将标准输出重定向到文件的符号是_____。
A.> 
B.< 
C.<> 
D.>< 
【答案】**A**

---

18、可以将字符串abc替换成789的是_____。
A.${变量名#abc#789} 
B.${变量名%abc%789} 
C.${变量名:abc:789} 
D.${变量名/abc/789} 
【答案】**D**

---

19、从左向右，一直删除到最后一个x的是_____。
A.\${变量名#*x} 
B.\${变量名%%x*} 
C.\${变量名\%x*} 
D.\${变量名##*x} 
【答案】**D**

---

20、反引号（反撇号）中可以放_____。
A.任意字符 
B.数字 
C.文件 
D.命令 
【答案】**D**

---

# Multiple Choice

21、A && B || C,什么时候会执行C命令？ —— 出题人：王凯
A.A执行失败，B执行成功时 
B.B执行，但失败时 
C.A执行成功，B执行成功时 
D.A执行，但失败时 
【答案】**B,D**

---

22、sed可以通过操作指令对文件进行增、删、改、查的操作，下列_____指令是sed支持的。
A.a 
B.d 
C.s 
D.p 
【答案】**A,B,C,D**

---

23、sed可以通过操作指令对文件进行增、删、改、查的操作，下列_____指令是sed不支持的。
A.p 
B.a 
C.yy 
D.k 
【答案】**C,D**

---

24、下列正则表达式中_____代表a可能出现了3次及以上。
A.a\{3,\} 
B.a* 
C.aaaa* 
D.aa* 
【答案】**A,B,C,D**

---

25、常见的Shell解释器有_____。
A.bash 
B.cmd 
C.ksh 
D.csh 
【答案】**A,C,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( NoSQL Topic | Cloud computing )

---

# Single Choice

1、Redis RDB方式持久化的默认文件名是_____。
A.rdb.dump 
B.appendonly.aof 
C.dump.rdb 
D.aof.appendonly 
【答案】**C**

---

2、配置MHA时，可以指定主从同步连接用户名的选项是_____。
A.master_ip_failover_script 
B.repl_user 
C.manager_workdir 
D.ssh_user 
【答案】**B**

---

3、配置主从同步时，change master to 命令使用_____选项指定主库binlog文件偏移量。
A.master_log 
B.master_log_pos 
C.master_log_file 
D.master_log_nane 
【答案】**B**

---

4、配置mycat服务时，用于指定分片的表的配置文件是_____。
A.rule.xml 
B.server.xml 
C.schema.xml 
D.maxscale.conf 
【答案】**C**

---

5、mycat 支持_____种分片规则。
A.5 
B.8 
C.9 
D.10 
【答案】**D**

---

6、下列_____选项可以修改redis服务使用的ip地址。
A.cluster-config-file 
B.cluster-enabled 
C.daemonize 
D.bind 
【答案】**D**

---

7、Redis aof持久化的默认文件名是_____。
A.aof.appendonly 
B.rdb.dump 
C.appendonly.aof 
D.dump.rdb 
【答案】**C**

---

8、可以删除redis服务内存里的所有数据的命令是_____。
A.flushall 
B.flushdb 
C.bgsave 
D.save 
【答案】**A**

---

9、配置主从同步时，change master to 命令使用_____选项指定服务器ip地址。
A.master_password 
B.master_host 
C.master_user 
D.master_ip 
【答案】**B**

---

10、配置MHA时_____选项可以指定工作目录。
A.repl_user 
B.manager_workdir 
C.ssh_user 
D.master_ip_failover_script 
【答案】**B**

---

11、配置主从同步时，change master to 命令使用_____选项指定主服务器binlog文件名。
A.master_log 
B.master_log_pos 
C.master_log_file 
D.master_log_nane 
【答案】**C**

---

12、mycat服务运行后，默认监控的端口是_____。
A.127017 
B.3306 
C.6379 
D.8066 
【答案】**D**

---

13、启动MHA集群命令的选项是_____。
A.masterha_check_status 
B.masterha_manager 
C.masterha_check_ssh 
D.masterha_check_repl 
【答案】**B**

---

14、redis服务默认配置文件名的选项是_____。
A.redis_6379.conf 
B.redis.conf 
C.6379.conf 
D.redis.cnf 
【答案】**C**

---

15、配置mycat服务时，定义分片规则及使用的算法配置文件是_____。
A.maxscale.conf 
B.schema.xml 
C.rule.xml 
D.server.xml 
【答案】**C**

---

16、在使用redis-trib.rb脚本管理集群，用于创建集群的选项是_____。
A.create 
B.reshard 
C.add-node 
D.del-node 
【答案】**A**

---

17、设置mysql服务提交方式的选项是_____。
A.auto_commit 
B.commit 
C.commitauto 
D.autocommit 
【答案】**D**

---

18、配置MHA时，可以指定ssh连接用户名的选项是_____。
A.manager_workdir 
B.master_ip_failover_script 
C.repl_user 
D.ssh_user 
【答案】**D**

---

# Multiple Choice

19、MySQL事务操作命令的选项是_____。
A.set transaction 
B.release savepoint 
C.savepoint 
D.rollback to 
【答案】**A,B,C,D**

---

20、关于innodb存储引擎的表，下列正确的选项有_____。
A.有事务日志 
B.支持表级锁 
C.支持行级锁 
D.支持事务 
【答案】**A,C,D**

---

21、可以马上把内存里的数据存储到硬盘里的命令是_____。
A.flushall 
B.bgsave 
C.flushdb 
D.save 
【答案】**B,D**

---

22、mycat软件支持的分片规则有_____。
A.枚举法 
B.固定分片 
C.求模法 
D.范围约定 
【答案】**A,B,C,D**

---

23、redis服务支持的内存清除策略的选项是_____。
A.RANDOM 
B.LFU 
C.LRU 
D.VOLATILE-TTL 
【答案】**A,B,C,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Operation Topic | Cloud computing )

---

# Single Choice

1、nginx命令使用_____选项重新加载配置文件。
A.-s config 
B.-s reopen 
C.-s reload 
D.-s  stop 
【答案】**C**

---

2、nginx命令使用_____选项查看软件的版本信息。
A.-V 
B.-S 
C.-Ver 
D.-A 
【答案】**A**

---

3、Unit文件中描述在哪个服务之后启动的语句是_____。
A.after 
B.type 
C.before 
D.execstart 
【答案】**A**

---

4、查看Linux内核最大文件数量限制的命令是_____。
A.glimit 
B.kernellimit 
C.limit 
D.ulimit 
【答案】**D**

---

5、安装nginx时，加载四层代理（其他业务集群）模块的选项是_____。
A.--with-tcp_stream 
B.--with-stream 
C.--with-stream_module 
D.--with-tcp_module 
【答案】**B**

---

6、nginx配置文件中如何开启status状态页面？
A.status on 
B.stub on 
C.location 
D.stub_status on 
【答案】**D**

---

7、nginx配置文件使用_____语句定义账户认证的密码文件。
A.auth_file 
B.user_file 
C.auth_user_file 
D.auth_basic_user_file 
【答案】**D**

---

8、nginx使用_____语句定义web的调度器集群池。
A.upserver
B.upstream
C.pool
D.stream
【答案】**B**

---

9、下列_____是nginx的加密模块。
A.with-https_ssl_module 
B.with-https_module 
C.with-http_ssl_module 
D.with-ssl_module	 
【答案】**C**

---

10、memcached服务默认监听的端口是_____。
A.11211 
B.22122 
C.11212 
D.11311 
【答案】**A**

---

11、使用_____工具可以自定义制作RPM软件。
A.build-rpm 
B.rpm-build 
C.yum 
D.rpm 
【答案】**B**

---

12、启动Tomcat需要依赖_____软件。
A.nginx 
B.httpd 
C.cat 
D.JDK 
【答案】**D**

---

13、下列选项说法正确的是_____。
A.mariadb默认监听3260端口 
B.php-fpm默认监听9000端口 
C.memcached默认监听2211端口 
D.mariadb默认监听3308端口 
【答案】**B**

---

14、HTTP状态码中表示页面找不到的代码是_____。
A.301 
B.404 
C.302 
D.500 
【答案】**B**

---

15、nginx集群调度时，使用ip_hash的作用是_____。
A.相同客户端访问相同服务器 
B.相同客户端访问不同服务器 
C.不同客户端访问不同服务器 
D.不同客户端访问相同服务器 
【答案】**A**

---

# Multiple Choice

16、nginx支持的虚拟主机有_____。
A.基于IP地址 
B.基于端口 
C.基于域名 
D.基于MAC地址 
【答案】**A,B,C**

---

17、常见的VPN有_____。
A.mac VPN 
B.L2TP+IpSec VPN 
C.PPTP VPN 
D.GRE VPN 
【答案】**B,C,D**

---

18、对Maven描述正确的有_____。
A.可以提高开发效率 
B.是一种编程语言 
C.是一个项目管理工具 
D.是一个网站服务 
【答案】**A,C**

---

19、通过md5sum可以实现_____功能。
A.数据还原 
B.恢复数据 
C.判断数据是否被篡改 
D.校验数据的HASH值 
【答案】**C,D**

---

20、用于记录客户端与web服务器之间登录状态的临时文件可能是_____。
A.savedate 
B.sisseon 
C.cookie 
D.session 
【答案】**C,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Project & Rdbms Topic | Cloud computing )

---

# Single Choice

1、下列_____选项不是数据统计函数。
A.count() 
B.sum() 
C.curdate() 
D.avg() 
【答案】**C**

---

2、mysql服务错误日志存放的目录是_____。
A./data 
B./mysql 
C./var/lib/mysql 
D./var/log 
【答案】**D**

---

3、下列_____命令可以修改MySQL服务管理员的密码
A.mysqldumpslow 
B.mysqlbinlog 
C.mysqladmin 
D.mysqldump 
【答案】**C**

---

4、主键标记的选项是_____。
A.PRI 
B.key 
C.UNI 
D.MUL 
【答案】**A**

---

5、在mysql中表示空的选项是_____。
A.0 
B.null 
C."" 
D.none 
【答案】**B**

---

6、普通索引标记的选项是_____。
A.PRI 
B.key 
C.UNI 
D.MUL 
【答案】**D**

---

7、下列_____命令可以对MySQL数据库数据做完全备份
A.mysqldump 
B.mysqldumpslow 
C.mysqladmin 
D.mysqlbinlog 
【答案】**A**

---

8、SQL语句中，实现分组查询使用的关键字是_____。
A.group by 
B.order by 
C.having 
D.limit 
【答案】**A**

---

9、创建外键时_____选项可以实现数据的同步更新。
A.on cascade update 
B.on cascade delete 
C.on delete cascade 
D.on update cascade 
【答案】**D**

---

10、下列_____选项可以设置binlog日志文件的大小。
A.binlog_size 
B.max_size_binlog 
C.size_log 
D.max_binlog_size 
【答案】**D**

---

11、下列_____选项可以实现对新用户授予权限功能。
A.flush 
B.revoke 
C.grant 
D.insert 
【答案】**C**

---

12、下列_____选项，可以实现插入数据的功能。
A.INSERT 
B.DELETE 
C.UPDATE 
D.DROP 
【答案】**A**

---

13、不是mysql索引算法的是_____选项。
A.hash 
B.btree 
C.b+tree 
D.index 
【答案】**D**

---

14、下列_____命令可以查看MySQL binlog日志文件的内容。
A.mysqladmin 
B.mysqldump 
C.mysqlbinlog 
D.mysqldumpslow 
【答案】**C**

---

15、下列_____选项既可以修改字段名又可以修改字段类型。
A.alter 
B.set 
C.change 
D.modify 
【答案】**C**

---

16、Mysql服务的默认数据库目录的选项是_____。
A./var/lib/data 
B./var/lib/mysql 
C./var/lib/mysql-files 
D./var/log/ 
【答案】**B**

---

17、下列_____选项在select语句中可以匹配零个到多个字符。
A.% 
B._ 
C.* 
D.? 
【答案】**A**

---

18、下列_____选项在sql语句中可以匹配任意个字符。
A._ 
B.? 
C.* 
D.% 
【答案】**D**

---

19、删除索引使用的选项是_____。
A.drop user 
B.drop database 
C.drop  table 
D.drop index 
【答案】**D**

---

20、Mysql服务的默认端口是_____。
A.27017 
B.16379 
C.6379 
D.3306 
【答案】**D**

---

# Multiple Choice

21、以下是MySQL整型数值类型的选项有_____。
A.bigint 
B.smallint 
C.tinyint 
D.int 
【答案】**A,B,C,D**

---

22、MySQL日期时间类型的选项有_____。
A.date 
B.datetime 
C.timestamp 
D.time 
【答案】**A,B,C,D**

---

23、以下是MySQL数值类型的选项有_____。
A.int 
B.tinyint 
C.double 
D.float 
【答案】**A,B,C,D**

---

24、使用innobackupex对数据做增量备份时使用的选项是_____。
A.-p 
B.-u 
C.—incremental-basedir 
D.--incremental 
【答案】**A,B,C,D**

---

25、MySQL存储过程的循环结构有_____。
A.loop循环 
B.while循环 
C.for循环 
D.repeat循环 
【答案】**A,B,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Python Topic | Cloud computing )

---

# Single Choice

1、下列_____语句可以返回函数值。
A.return 
B.print 
C.break 
D.continue 
【答案】**A**

---

2、在shutil模块中，能在复制的同时将文件元数据也一同复制的命令是_____。
A.shutil.copyfile 
B.shutil.copy 
C.shutil.copy2 
D.shutil.copyfileobj 
【答案】**C**

---

3、下列对列表的定义中错误的是_____。
A.列表中可以包含任意类型的数据 
B.列表是有序的 
C.列表中的内容无法改变 
D.列表可以使用+拼接 
【答案】**C**

---

4、下列_____数据类型是可变的。
A.元组 
B.数字 
C.列表 
D.字符串 
【答案】**C**

---

5、下列有关判断语句说法错误的是_____。
A.可以有多个elif语句 
B.else语句可以省略 
C.多个elif，使用全部使用if替代也能达到一样的效果 
D.else语句中的代码块一定会执行 
【答案】**D**

---

6、下列_____数据类型不是python中的序列。
A.字符串 
B.字典 
C.列表 
D.元组 
【答案】**B**

---

7、现有变量n=0,下列变量表达式运行会报错的是_____。
A.n=n+1 
B.n+=1 
C.n++ 
D.n*=1 
【答案】**C**

---

8、下列关于字典说法正确的是_____。
A.字典是有序的 
B.字典的值可以是任意类型的数据 
C.字典的键可以使任意类型的数据 
D.字典的值无法改变 
【答案】**B**

---

9、下列代码的执行结果为_____。
[i**i for i in range(3)]"
A.[1,2,3] 
B.[0,1,2] 
C.[1,4,27] 
D.[1,1,4] 
【答案】**D**

---

10、有关python变量说法正确的是_____。
A.变量名不区分大小写 
B.变量的值可以为任意数据类型 
C.变量名可以为任意字符 
D.使用变量必须先指定变量的数据类型 
【答案】**B**

---

11、下列_____选项的内容不是数字类型。
A.1+1j 
B. '123' 
C.123 
D.3.14 
【答案】**B**

---

12、使用二进制模式打开文件需要在访问模式中添加_____模式选项。
A.w 
B.b 
C.a 
D.r 
【答案】**B**

---

13、下列代码运行会报错的是_____。
A.a,b = 10,20 
B.a = b =10 
C.a,b = 'ab' 
D.a = 10 = b 
【答案】**D**

---

14、下列有关python特点描述错误的是_____。
A.python关键字少、结构简单、语法清晰 
B.python只能在PC端操作系统运行 
C.没有其他语言通常用来访问变量的命令式符号 
D.有高级的数据结构，缩短开发时间与代码量 
【答案】**B**

---

15、下列_____语句可以向命令行输出指定的内容。
A.print 
B.len 
C.input 
D.help 
【答案】**A**

---

16、关于字符串的索引和切片说法错误的是_____。
A.可以对切片赋值修改字符串的内容 
B.切片可以得到字符串指定位置的子字符串 
C.最后一个字符的索引为-1 
D.第一个字符的索引为0 
【答案】**A**

---

17、下面有关集合，描述错误的是_____。
A.集合中的元素不能重复 
B.可以把列表存入集合 
C.集合是容器类型 
D.集合使用{}表示 
【答案】**B**

---

18、请判断(10)是下列_____类型的数据。
A.列表 
B.元组 
C.数字类型 
D.字典 
【答案】**C**

---

19、列有关模块说法错误的是_____。
A.模块之间可以互相导入 
B.为了不影响加载，模块中只能放函数 
C.模块加载时顶层的代码会自动执行 
D.在同一个程序中一个模块只能加载一次 
【答案】**B**

---

20、python中可以读取一整行文件内容的方法是_____。
A.read 
B.以上全部正确 
C.readlines 
D.readline 
【答案】**D**

---

# Multiple Choice

21、假设有一个元组atup=(1,2,[3]),下列_____语句能成功运行。
A.atup[2].sort() 
B.atup[2].append(4) 
C.atup.sort() 
D.atup.append(4) 
【答案】**A,B**

---

22、下列只能用于循环中的语句为_____。
A.quit 
B.break 
C.else 
D.continue 
【答案】**B,D**

---

23、假设有一个列表alist=[1,2,3],下列_____语句能成功运行。
A.alist.sort() 
B.alist+=[4] 
C.alist.append(4) 
D.alist.sorted() 
【答案】**A,B,C**

---

24、假设有一个字符串astr='abc',下列_____语句能成功运行。
A.astr.islower() 
B.astr.isupper() 
C.astr*=3 
D.astr[:100] 
【答案】**A,B,C,D**

---

25、下列说法中错误的是_____。
A.关键字是系统保留好的某些字符，我们可以直接拿来作为标识符使用 
B.python标识符字符串不能以数字开头 
C.在python中我们只能通过经验来判断某些字符是不是关键字 
D.python内建的内容可以在任何一级代码中使用 
【答案】**A,C**


> 如有侵权，请联系作者删除



﻿@[TOC]( Python Topic2 | Cloud computing )

---

# Single Choice

1、re模块中从头开始匹配的方法是_____。
A.re.search 
B.re.finditer 
C.re.findall 
D.re.match 
【答案】**D**

---

2、【单选题】
在程序中使用了一个没有声明过的变量会出现_____错误。
A.TypeError 
B.SyntaxError 
C.NameError 
D.IndexError 
【答案】**C**

---

3、下列关于类的方法错误的是_____。
A.方法是类中定义的函数 
B.对象是类的实例 
C.类是用来描述具有相同的属性和方法的对象的集合 
D.子类当中只能继承父类的普通方法，不能继承初始化方法 
【答案】**D**

---

4、假设现有一个函数foo需要接受a,b,c三个参数，下列传参方法错误的是_____。
A.foo(1, 2, c=3) 
B.foo(1,2,3) 
C.foo(a = 1, b= 2, 3) 
D.foo(a=2,b=1,c=3) 
【答案】**C**

---

5、下列关于函数的说法中错误的是_____。
A.使用一对圆括号()调用函数 
B.函数内部可以再放入另一个函数 
C.函数的参数必须放在圆括号中，如果没有参数可以不写圆括号 
D.函数不允许在函数未声明之前对其进行引用或者调用 
【答案】**C**

---

6、下列代码运行结果是_____。
list(map(lambda x:x**3,[1,2,3]))
A.[1,6,9] 
B.[1,12,27] 
C.[13,23,33] 
D.[1,8,27] 
【答案】**D**

---

7、有关模块搜索路径错误的说法是_____。
A.搜索路径的区域是固定的，必须将模块放到指定区域才能导入 
B.python在文件系统“预定义区域”中查找要调用的模块 
C.模块的导入需要一个叫做“路径搜索”的过程 
D.搜索路径在sys.path中定义 
【答案】**A**

---

8、下面代码的输出结果是？
d ={“大海”:“蓝色”, “天空”:“灰色”, “大地”:“黑色”}
print(d[“大地”], d.get(“大地”, “黄色”))   —— 出题人：牛枫翔
A.黑的 灰色 
B.黑色 黑色 
C.黑色 蓝色 
D.黑色 黄色 
【答案】**B**

---

9、关于匿名函数的说法错误的是_____。
A.需要用lambda关键字创造匿名函数 
B.匿名函数不需要使用def关键字 
C.lambda表达式的定义体必须和声明放在同一行 
D.一个lambda表达式可以同时声明多条语句 
【答案】**D**

---

10、将当前时间转换成指定格式的字符串需要使用time模块的_____方法。
A.time.localtime() 
B.time.strptime() 
C.time.strftime() 
D.time.ctime() 
【答案】**C**

---

11、下列方法描述错误的是_____。
A.match函数 从开头匹配符合正则表达式的对象 
B.search函数查找所有正则表达式匹配的对象 
C.使用match或search匹配成功后可以通过group方法获得匹配内容 
D.大量匹配的情况下可以先用compile函数对正则进行编译 
【答案】**B**

---

12、以下选项中，不是Python语言保留字的是_____。
A.while 
B.continue 
C.goto 
D.for 
【答案】**C**

---

13、有关类的继承说法错误的是_____。
A.每个子类只能继承一个父类 
B.继承不会影响系统中使用现存类的其它代码片段 
C.想要体现“相同的类 但有一些不同的功能”时用继承的方式更合适 
D.继承允许使用一个已经定义好的类的方法和属性 
【答案】**A**

---

14、有关字典说法正确的是_____。
A.字典的键可以为任意类型数据 
B.字典的值可以为任意类型的数据 
C.字典可以通过下标访问字典的值 
D.字典是一组有顺序的序列 
【答案】**B**

---

15、用户需要主动触发异常，并能够指定触发的异常名字，采用的关键字是_____。
A.else
B.except
C.raise
D.finally
【答案】**C**

---

16、面向对象编程OOP中，构造器方法是_____。
A.\__str__
B.\__init__
C.\__call__
D.\__name__
【答案】**B**

---

# Multiple Choice

17、对于os模块描述正确的是_____。
A.os模块是python访问操作系统功能的主要接口 
B.使用os模块可以复制和移动文件 
C.使用os模块之前需要先下载安装 
D.os模块可以修改文件权限 
【答案】**A,D**

---

18、下列可以用于集合的操作符有_____。
A.| 
B.+ 
C.- 
D.& 
【答案】**A,C,D**

---

19、下面关于集合的说法中正确的是_____。
A.集合是无序的 
B.集合是有序的 
C.集合的值都是可变的数据类型 
D.集合的值都是不可变的数据类型 
【答案】**A,D**

---

20、有关模块导入说法正确的是_____。
A.可以使用sys模块修改导入模块的搜索路径 
B.导入模块需要用import 
C.可以为模块取别名 
D.可以只导入模块的某些属性 
【答案】**A,B,C,D**


> 如有侵权，请联系作者删除



﻿@[TOC]( Security Topic | Cloud computing )

---

# Single Choice

1、iptables使用_____选项可以限制指定目标端口的访问规则。
A.--d 
B.--s 
C.--dport 
D.--sport 
【答案】**C**

---

2、iptables使用_____选项可以限制指定协议的访问规则。
A.-A 
B.-I 
C.-p 
D.-s 
【答案】**C**

---

3、node_exporter默认监听的端口是_____。
A.9090 
B.5100 
C.8080 
D.9100 
【答案】**D**

---

4、Linux开启路由转发功能需要修改_____文件。
A.forward 
B.ip forward 
C.ip 
D.ip_forward 
【答案】**D**

---

5、Grafana默认监听的端口是_____。
A.3000 
B.5001 
C.4000 
D.5000 
【答案】**A**

---

6、下列语法格式正确的是_____。
A.limit_req_zone $binary_remote_addr  zone=one:10m rate=1a/s 
B.limit_req_zone $binary_remote_addr  zone=one:10m rate=4r/s 
C.limit_req_zone $binary_remote_addr  zone=one:10m rate=2t/s 
D.limit_req_zone $binary_remote_addr  zone=one:10m rate=3h/s 
【答案】**B**

---

7、使用_____命令可以锁定账户密码。
A.chage 
B.id 
C.passwd 
D.usermod 
【答案】**C**

---

8、使用_____命令可以修改账户有效期。
A.passwd 
B.chage 
C.id 
D.usermod 
【答案】**B**

---

9、chattr使用_____选项可以锁定一个文件。
A.-a 
B.-c 
C.-d 
D.+i 
【答案】**D**

---

10、使用tcpdump抓取FTP账户和密码使用_____命令。
A.tcpdump  -A  -w  ftp.cap   tcp  port  22 
B.tcpdump  -A  -w  ftp.cap   udp  port  22 
C.tcpdump  -A  -w  ftp.cap   tcp  port  21 
D.tcpdump  -A  -w  ftp.cap   tcp  port  20 
【答案】**C**

---

11、nginx配置文件中，隐藏版本号信息使用_____命令。
A.server_version off 
B.server_tokens off 
C.tokens off 
D.version off 
【答案】**B**

---

12、Grafana实现数据可视化需要导入_____文件。
A.JSON文件 
B.YAML文件 
C.INI文件 
D.XML文件 
【答案】**A**

---

13、namp支持的扫描选项有_____。
A.nmap -sP 
B.nmap -sH 
C.nmap -sE 
D.nmap -sQ 
【答案】**A**

---

14、iptables有_____表。
A.nat 
B.POSTROUTING 
C.PREROUTING 
D.OUTPUT 
【答案】**A**

---

15、Prometheus服务器默认监听的端口是_____。
A.8080 
B.3306 
C.9000 
D.9090 
【答案】**D**

---

# Multiple Choice

16、zabbix支持的报警机制有_____。
A.电话 
B.短信 
C.wall消息 
D.邮件 
【答案】**B,D**

---

17、zabbix可以监控_____。
A.交换机、路由器 
B.http服务 
C.主机进程数量 
D.打印机 
【答案】**A,B,C,D**

---

18、常见的网络攻击有_____。
A.DDos攻击 
B.撞库攻击 
C.渗透测试 
D.暴力破解 
【答案】**A,B,C,D**

---

19、常见的HTTP请求方法有_____。
A.GET 
B.POST 
C.HEAD 
D.DELETE 
【答案】**A,B,C,D**

---

20、Zabbix的监控端和被监控端软件分别是_____。
A.zabbix_agentd 
B.zabbix_client 
C.zabbix 
D.zabbix_server 
【答案】**A,D**

---

21、nmap支持的扫描选项有_____。
A.nmap -sT 
B.nmap -sU 
C.nmap -sH 
D.nmap -sP 
【答案】**A,B,D**

---

22、下列是john命令有效的选项有_____。
A.--simple 
B.--word 
C.--wordlist 
D.--list 
【答案】**A,C**

---

23、下列_____是kali系统自带的nmap扫描脚本。
A.ftp-anon.nse 
B.root-brute.nse 
C.http-methods.nse 
D.ftp-brute.nse 
【答案】**A,C,D**

---

24、zabbix支持的监控方式有_____。
A.服务监控 
B.分布式监控 
C.被动监控 
D.主动监控 
【答案】**B,C,D**

---

25、Zabbix的监控端和被监控端软件分别是_____。
A.zabbix 
B.zabbix_client 
C.zabbix_server 
D.zabbix_agentd 
【答案】**C,D**


> 如有侵权，请联系作者删除

